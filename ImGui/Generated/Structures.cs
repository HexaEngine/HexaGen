// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace HexaEngine.ImGuiNET
{
	/// <summary>
	/// [Internal] For use by ImDrawListSplitter<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImDrawChannel
	{
		public ImVectorImDrawCmd CmdBuffer;
		public ImVectorImDrawIdx IdxBuffer;


	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImDrawChannelPtr : IEquatable<ImDrawChannelPtr>
	{
		public ImDrawChannelPtr(ImDrawChannel* handle) { Handle = handle; }

		public ImDrawChannel* Handle;

		public bool IsNull => Handle == null;

		public static ImDrawChannelPtr Null => new ImDrawChannelPtr(null);

		public static implicit operator ImDrawChannelPtr(ImDrawChannel* handle) => new ImDrawChannelPtr(handle);

		public static implicit operator ImDrawChannel*(ImDrawChannelPtr handle) => handle.Handle;

		public static bool operator ==(ImDrawChannelPtr left, ImDrawChannelPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImDrawChannelPtr left, ImDrawChannelPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImDrawChannelPtr left, ImDrawChannel* right) => left.Handle == right;

		public static bool operator !=(ImDrawChannelPtr left, ImDrawChannel* right) => left.Handle != right;

		public bool Equals(ImDrawChannelPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImDrawChannelPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImDrawChannelPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref ImVectorImDrawCmd CmdBuffer => ref Unsafe.AsRef<ImVectorImDrawCmd>(&Handle->CmdBuffer);
		public ref ImVectorImDrawIdx IdxBuffer => ref Unsafe.AsRef<ImVectorImDrawIdx>(&Handle->IdxBuffer);
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImDrawCmd
	{
		public int Size;
		public int Capacity;
		public unsafe ImDrawCmd* Data;


	}

	/// <summary>
	/// Typically, 1 command = 1 GPU draw call (unless command is a callback)<br/>
	/// - VtxOffset: When 'io.BackendFlags &amp; ImGuiBackendFlags_RendererHasVtxOffset' is enabled,<br/>
	/// this fields allow us to render meshes larger than 64K vertices while keeping 16-bit indices.<br/>
	/// Backends made for &lt;1.71. will typically ignore the VtxOffset fields.<br/>
	/// - The ClipRectTextureIdVtxOffset fields must be contiguous as we memcmp() them together (this is asserted for).<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImDrawCmd
	{
		/// <summary>
		/// 4*4   Clipping rectangle (x1, y1, x2, y2). Subtract ImDrawData-&gt;DisplayPos to get clipping rectangle in "viewport" coordinates<br/>
		/// </summary>
		public Vector4 ClipRect;

		/// <summary>
		/// 4-8   User-provided texture ID. Set by user in ImfontAtlas::SetTexID() for fonts or passed to Image*() functions. Ignore if never using images or multiple fonts atlas.<br/>
		/// </summary>
		public ImTextureID TextureId;

		/// <summary>
		/// 4     Start offset in vertex buffer. ImGuiBackendFlags_RendererHasVtxOffset: always 0, otherwise may be &gt;0 to support meshes larger than 64K vertices with 16-bit indices.<br/>
		/// </summary>
		public uint VtxOffset;

		/// <summary>
		/// 4     Start offset in index buffer.<br/>
		/// </summary>
		public uint IdxOffset;

		/// <summary>
		/// 4     Number of indices (multiple of 3) to be rendered as triangles. Vertices are stored in the callee ImDrawList's vtx_buffer[] array, indices in idx_buffer[].<br/>
		/// </summary>
		public uint ElemCount;

		/// <summary>
		/// 4-8   If != NULL, call the function instead of rendering the vertices. clip_rect and texture_id will be set normally.<br/>
		/// </summary>
		public unsafe void* UserCallback;
		/// <summary>
		/// 4-8   The draw callback code can access this.<br/>
		/// </summary>
		public unsafe void* UserCallbackData;





		public unsafe void Destroy()
		{
			fixed (ImDrawCmd* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe ImTextureID GetTexID()
		{
			fixed (ImDrawCmd* @this = &this)
			{
				ImTextureID ret = ImGui.GetTexIDNative(@this);
				return ret;
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImDrawCmdPtr : IEquatable<ImDrawCmdPtr>
	{
		public ImDrawCmdPtr(ImDrawCmd* handle) { Handle = handle; }

		public ImDrawCmd* Handle;

		public bool IsNull => Handle == null;

		public static ImDrawCmdPtr Null => new ImDrawCmdPtr(null);

		public static implicit operator ImDrawCmdPtr(ImDrawCmd* handle) => new ImDrawCmdPtr(handle);

		public static implicit operator ImDrawCmd*(ImDrawCmdPtr handle) => handle.Handle;

		public static bool operator ==(ImDrawCmdPtr left, ImDrawCmdPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImDrawCmdPtr left, ImDrawCmdPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImDrawCmdPtr left, ImDrawCmd* right) => left.Handle == right;

		public static bool operator !=(ImDrawCmdPtr left, ImDrawCmd* right) => left.Handle != right;

		public bool Equals(ImDrawCmdPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImDrawCmdPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImDrawCmdPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		/// <summary>
		/// 4*4   Clipping rectangle (x1, y1, x2, y2). Subtract ImDrawData-&gt;DisplayPos to get clipping rectangle in "viewport" coordinates<br/>
		/// </summary>
		public ref Vector4 ClipRect => ref Unsafe.AsRef<Vector4>(&Handle->ClipRect);
		/// <summary>
		/// 4-8   User-provided texture ID. Set by user in ImfontAtlas::SetTexID() for fonts or passed to Image*() functions. Ignore if never using images or multiple fonts atlas.<br/>
		/// </summary>
		public ref ImTextureID TextureId => ref Unsafe.AsRef<ImTextureID>(&Handle->TextureId);
		/// <summary>
		/// 4     Start offset in vertex buffer. ImGuiBackendFlags_RendererHasVtxOffset: always 0, otherwise may be &gt;0 to support meshes larger than 64K vertices with 16-bit indices.<br/>
		/// </summary>
		public ref uint VtxOffset => ref Unsafe.AsRef<uint>(&Handle->VtxOffset);
		/// <summary>
		/// 4     Start offset in index buffer.<br/>
		/// </summary>
		public ref uint IdxOffset => ref Unsafe.AsRef<uint>(&Handle->IdxOffset);
		/// <summary>
		/// 4     Number of indices (multiple of 3) to be rendered as triangles. Vertices are stored in the callee ImDrawList's vtx_buffer[] array, indices in idx_buffer[].<br/>
		/// </summary>
		public ref uint ElemCount => ref Unsafe.AsRef<uint>(&Handle->ElemCount);
		/// <summary>
		/// 4-8   If != NULL, call the function instead of rendering the vertices. clip_rect and texture_id will be set normally.<br/>
		/// </summary>
		public void* UserCallback { get => Handle->UserCallback; set => Handle->UserCallback = value; }
		/// <summary>
		/// 4-8   The draw callback code can access this.<br/>
		/// </summary>
		public void* UserCallbackData { get => Handle->UserCallbackData; set => Handle->UserCallbackData = value; }

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

		public unsafe ImTextureID GetTexID()
		{
			ImTextureID ret = ImGui.GetTexIDNative(Handle);
			return ret;
		}

	}

	/// <summary>
	/// Draw command list<br/>
	/// This is the low-level list of polygons that ImGui:: functions are filling. At the end of the frame,<br/>
	/// all command lists are passed to your ImGuiIO::RenderDrawListFn function for rendering.<br/>
	/// Each dear imgui window contains its own ImDrawList. You can use ImGui::GetWindowDrawList() to<br/>
	/// access the current window draw list and draw custom primitives.<br/>
	/// You can interleave normal ImGui:: calls and adding primitives to the current draw list.<br/>
	/// In single viewport mode, top-left is == GetMainViewport()-&gt;Pos (generally 0,0), bottom-right is == GetMainViewport()-&gt;Pos+Size (generally io.DisplaySize).<br/>
	/// You are totally free to apply whatever transformation matrix to want to the data (depending on the use of the transformation you may want to apply it to ClipRect as well!)<br/>
	/// Important: Primitives are always added to the list and not culled (culling is done at higher-level by ImGui:: functions), if you use this API a lot consider coarse culling your drawn objects.<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImDrawList
	{
		/// <summary>
		/// This is what you have to render Draw commands. Typically 1 command = 1 GPU draw call, unless the command is a callback.<br/>
		/// </summary>
		public ImVectorImDrawCmd CmdBuffer;

		/// <summary>
		/// Index buffer. Each command consume ImDrawCmd::ElemCount of those<br/>
		/// </summary>
		public ImVectorImDrawIdx IdxBuffer;

		/// <summary>
		/// Vertex buffer.<br/>
		/// </summary>
		public ImVectorImDrawVert VtxBuffer;

		/// <summary>
		/// Flags, you may poke into these to adjust anti-aliasing settings per-primitive.<br/>
		/// </summary>
		public ImDrawListFlags Flags;

		/// <summary>
		/// [Internal, used while building lists] [Internal] generally == VtxBuffer.Size unless we are past 64K vertices, in which case this gets reset to 0.<br/>
		/// </summary>
		public uint VtxCurrentIdx;

		/// <summary>
		/// Pointer to shared draw data (you can use ImGui::GetDrawListSharedData() to get the one from current ImGui context)<br/>
		/// </summary>
		public unsafe ImDrawListSharedData* Data;

		/// <summary>
		/// Pointer to owner window's name for debugging<br/>
		/// </summary>
		public unsafe byte* OwnerName;

		/// <summary>
		/// [Internal] point within VtxBuffer.Data after each add command (to avoid using the ImVector&lt;&gt; operators too much)<br/>
		/// </summary>
		public unsafe ImDrawVert* VtxWritePtr;

		/// <summary>
		/// [Internal] point within IdxBuffer.Data after each add command (to avoid using the ImVector&lt;&gt; operators too much)<br/>
		/// </summary>
		public unsafe ushort* IdxWritePtr;

		/// <summary>
		/// [Internal]<br/>
		/// </summary>
		public ImVectorImVec4 ClipRectStack;

		/// <summary>
		/// [Internal]<br/>
		/// </summary>
		public ImVectorImTextureID TextureIdStack;

		/// <summary>
		/// [Internal] current path building<br/>
		/// </summary>
		public ImVectorImVec2 Path;

		/// <summary>
		/// [Internal] template of active commands. Fields should match those of CmdBuffer.back().<br/>
		/// </summary>
		public ImDrawCmdHeader CmdHeader;

		/// <summary>
		/// [Internal] for channels api (note: prefer using your own persistent instance of ImDrawListSplitter!)<br/>
		/// </summary>
		public ImDrawListSplitter Splitter;

		/// <summary>
		/// [Internal] anti-alias fringe is scaled by this value, this helps to keep things sharp while zooming at vertex buffer content<br/>
		/// </summary>
		public float FringeScale;





		public unsafe int _CalcCircleAutoSegmentCount(float radius)
		{
			fixed (ImDrawList* @this = &this)
			{
				int ret = ImGui._CalcCircleAutoSegmentCountNative(@this, radius);
				return ret;
			}
		}

		public unsafe void _ClearFreeMemory()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui._ClearFreeMemoryNative(@this);
			}
		}

		public unsafe void _OnChangedClipRect()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui._OnChangedClipRectNative(@this);
			}
		}

		public unsafe void _OnChangedTextureID()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui._OnChangedTextureIDNative(@this);
			}
		}

		public unsafe void _OnChangedVtxOffset()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui._OnChangedVtxOffsetNative(@this);
			}
		}

		public unsafe void _PathArcToFastEx(Vector2 center, float radius, int aMinSample, int aMaxSample, int aStep)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui._PathArcToFastExNative(@this, center, radius, aMinSample, aMaxSample, aStep);
			}
		}

		public unsafe void _PathArcToN(Vector2 center, float radius, float aMin, float aMax, int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui._PathArcToNNative(@this, center, radius, aMin, aMax, numSegments);
			}
		}

		public unsafe void _PopUnusedDrawCmd()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui._PopUnusedDrawCmdNative(@this);
			}
		}

		public unsafe void _ResetForNewFrame()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui._ResetForNewFrameNative(@this);
			}
		}

		public unsafe void _TryMergeDrawCmds()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui._TryMergeDrawCmdsNative(@this);
			}
		}

		/// <summary>		/// Cubic Bezier (4 control points)		/// </summary>		public unsafe void AddBezierCubic(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col, float thickness, int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddBezierCubicNative(@this, p1, p2, p3, p4, col, thickness, numSegments);
			}
		}

		/// <summary>		/// Cubic Bezier (4 control points)		/// </summary>		public unsafe void AddBezierCubic(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col, float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddBezierCubicNative(@this, p1, p2, p3, p4, col, thickness, (int)(0));
			}
		}

		/// <summary>		/// Quadratic Bezier (3 control points)		/// </summary>		public unsafe void AddBezierQuadratic(Vector2 p1, Vector2 p2, Vector2 p3, uint col, float thickness, int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddBezierQuadraticNative(@this, p1, p2, p3, col, thickness, numSegments);
			}
		}

		/// <summary>		/// Quadratic Bezier (3 control points)		/// </summary>		public unsafe void AddBezierQuadratic(Vector2 p1, Vector2 p2, Vector2 p3, uint col, float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddBezierQuadraticNative(@this, p1, p2, p3, col, thickness, (int)(0));
			}
		}

		/// <summary>		/// Your rendering function must check for 'UserCallback' in ImDrawCmd and call the function instead of rendering triangles.		/// </summary>		public unsafe void AddCallback(ImDrawCallback callback, void* callbackData)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddCallbackNative(@this, callback, callbackData);
			}
		}

		public unsafe void AddCircle(Vector2 center, float radius, uint col, int numSegments, float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddCircleNative(@this, center, radius, col, numSegments, thickness);
			}
		}

		public unsafe void AddCircle(Vector2 center, float radius, uint col, int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddCircleNative(@this, center, radius, col, numSegments, (float)(1.0f));
			}
		}

		public unsafe void AddCircle(Vector2 center, float radius, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddCircleNative(@this, center, radius, col, (int)(0), (float)(1.0f));
			}
		}

		public unsafe void AddCircle(Vector2 center, float radius, uint col, float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddCircleNative(@this, center, radius, col, (int)(0), thickness);
			}
		}

		public unsafe void AddCircleFilled(Vector2 center, float radius, uint col, int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddCircleFilledNative(@this, center, radius, col, numSegments);
			}
		}

		public unsafe void AddCircleFilled(Vector2 center, float radius, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddCircleFilledNative(@this, center, radius, col, (int)(0));
			}
		}

		public unsafe void AddConvexPolyFilled(Vector2* points, int numPoints, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddConvexPolyFilledNative(@this, points, numPoints, col);
			}
		}

		public unsafe void AddConvexPolyFilled(ref Vector2 points, int numPoints, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (Vector2* ppoints = &points)
				{
					ImGui.AddConvexPolyFilledNative(@this, (Vector2*)ppoints, numPoints, col);
				}
			}
		}

		/// <summary>		/// This is useful if you need to forcefully create a new draw call (to allow for dependent rendering  blending). Otherwise primitives are merged into the same draw-call as much as possible		/// </summary>		public unsafe void AddDrawCmd()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddDrawCmdNative(@this);
			}
		}

		public unsafe void AddImage(ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, Vector2 uvMax, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageNative(@this, userTextureId, pMin, pMax, uvMin, uvMax, col);
			}
		}

		public unsafe void AddImage(ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, Vector2 uvMax)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageNative(@this, userTextureId, pMin, pMax, uvMin, uvMax, (uint)(4294967295));
			}
		}

		public unsafe void AddImage(ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageNative(@this, userTextureId, pMin, pMax, uvMin, (Vector2)(new Vector2(1,1)), (uint)(4294967295));
			}
		}

		public unsafe void AddImage(ImTextureID userTextureId, Vector2 pMin, Vector2 pMax)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageNative(@this, userTextureId, pMin, pMax, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,1)), (uint)(4294967295));
			}
		}

		public unsafe void AddImage(ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageNative(@this, userTextureId, pMin, pMax, uvMin, (Vector2)(new Vector2(1,1)), col);
			}
		}

		public unsafe void AddImage(ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageNative(@this, userTextureId, pMin, pMax, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,1)), col);
			}
		}

		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2, Vector2 uv3, Vector2 uv4, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageQuadNative(@this, userTextureId, p1, p2, p3, p4, uv1, uv2, uv3, uv4, col);
			}
		}

		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2, Vector2 uv3, Vector2 uv4)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageQuadNative(@this, userTextureId, p1, p2, p3, p4, uv1, uv2, uv3, uv4, (uint)(4294967295));
			}
		}

		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2, Vector2 uv3)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageQuadNative(@this, userTextureId, p1, p2, p3, p4, uv1, uv2, uv3, (Vector2)(new Vector2(0,1)), (uint)(4294967295));
			}
		}

		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageQuadNative(@this, userTextureId, p1, p2, p3, p4, uv1, uv2, (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), (uint)(4294967295));
			}
		}

		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageQuadNative(@this, userTextureId, p1, p2, p3, p4, uv1, (Vector2)(new Vector2(1,0)), (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), (uint)(4294967295));
			}
		}

		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageQuadNative(@this, userTextureId, p1, p2, p3, p4, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,0)), (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), (uint)(4294967295));
			}
		}

		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2, Vector2 uv3, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageQuadNative(@this, userTextureId, p1, p2, p3, p4, uv1, uv2, uv3, (Vector2)(new Vector2(0,1)), col);
			}
		}

		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageQuadNative(@this, userTextureId, p1, p2, p3, p4, uv1, uv2, (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), col);
			}
		}

		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageQuadNative(@this, userTextureId, p1, p2, p3, p4, uv1, (Vector2)(new Vector2(1,0)), (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), col);
			}
		}

		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageQuadNative(@this, userTextureId, p1, p2, p3, p4, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,0)), (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), col);
			}
		}

		public unsafe void AddImageRounded(ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, Vector2 uvMax, uint col, float rounding, ImDrawFlags flags)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageRoundedNative(@this, userTextureId, pMin, pMax, uvMin, uvMax, col, rounding, flags);
			}
		}

		public unsafe void AddImageRounded(ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, Vector2 uvMax, uint col, float rounding)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageRoundedNative(@this, userTextureId, pMin, pMax, uvMin, uvMax, col, rounding, (ImDrawFlags)(0));
			}
		}

		public unsafe void AddLine(Vector2 p1, Vector2 p2, uint col, float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddLineNative(@this, p1, p2, col, thickness);
			}
		}

		public unsafe void AddLine(Vector2 p1, Vector2 p2, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddLineNative(@this, p1, p2, col, (float)(1.0f));
			}
		}

		public unsafe void AddNgon(Vector2 center, float radius, uint col, int numSegments, float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddNgonNative(@this, center, radius, col, numSegments, thickness);
			}
		}

		public unsafe void AddNgon(Vector2 center, float radius, uint col, int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddNgonNative(@this, center, radius, col, numSegments, (float)(1.0f));
			}
		}

		public unsafe void AddNgonFilled(Vector2 center, float radius, uint col, int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddNgonFilledNative(@this, center, radius, col, numSegments);
			}
		}

		public unsafe void AddPolyline(Vector2* points, int numPoints, uint col, ImDrawFlags flags, float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddPolylineNative(@this, points, numPoints, col, flags, thickness);
			}
		}

		public unsafe void AddPolyline(ref Vector2 points, int numPoints, uint col, ImDrawFlags flags, float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (Vector2* ppoints = &points)
				{
					ImGui.AddPolylineNative(@this, (Vector2*)ppoints, numPoints, col, flags, thickness);
				}
			}
		}

		public unsafe void AddQuad(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col, float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddQuadNative(@this, p1, p2, p3, p4, col, thickness);
			}
		}

		public unsafe void AddQuad(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddQuadNative(@this, p1, p2, p3, p4, col, (float)(1.0f));
			}
		}

		public unsafe void AddQuadFilled(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddQuadFilledNative(@this, p1, p2, p3, p4, col);
			}
		}

		/// <summary>		/// a: upper-left, b: lower-right (== upper-left + size)		/// </summary>		public unsafe void AddRect(Vector2 pMin, Vector2 pMax, uint col, float rounding, ImDrawFlags flags, float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectNative(@this, pMin, pMax, col, rounding, flags, thickness);
			}
		}

		/// <summary>		/// a: upper-left, b: lower-right (== upper-left + size)		/// </summary>		public unsafe void AddRect(Vector2 pMin, Vector2 pMax, uint col, float rounding, ImDrawFlags flags)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectNative(@this, pMin, pMax, col, rounding, flags, (float)(1.0f));
			}
		}

		/// <summary>		/// a: upper-left, b: lower-right (== upper-left + size)		/// </summary>		public unsafe void AddRect(Vector2 pMin, Vector2 pMax, uint col, float rounding)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectNative(@this, pMin, pMax, col, rounding, (ImDrawFlags)(0), (float)(1.0f));
			}
		}

		/// <summary>		/// a: upper-left, b: lower-right (== upper-left + size)		/// </summary>		public unsafe void AddRect(Vector2 pMin, Vector2 pMax, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectNative(@this, pMin, pMax, col, (float)(0.0f), (ImDrawFlags)(0), (float)(1.0f));
			}
		}

		/// <summary>		/// a: upper-left, b: lower-right (== upper-left + size)		/// </summary>		public unsafe void AddRect(Vector2 pMin, Vector2 pMax, uint col, ImDrawFlags flags)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectNative(@this, pMin, pMax, col, (float)(0.0f), flags, (float)(1.0f));
			}
		}

		/// <summary>		/// a: upper-left, b: lower-right (== upper-left + size)		/// </summary>		public unsafe void AddRect(Vector2 pMin, Vector2 pMax, uint col, float rounding, float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectNative(@this, pMin, pMax, col, rounding, (ImDrawFlags)(0), thickness);
			}
		}

		/// <summary>		/// a: upper-left, b: lower-right (== upper-left + size)		/// </summary>		public unsafe void AddRect(Vector2 pMin, Vector2 pMax, uint col, ImDrawFlags flags, float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectNative(@this, pMin, pMax, col, (float)(0.0f), flags, thickness);
			}
		}

		/// <summary>		/// a: upper-left, b: lower-right (== upper-left + size)		/// </summary>		public unsafe void AddRectFilled(Vector2 pMin, Vector2 pMax, uint col, float rounding, ImDrawFlags flags)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectFilledNative(@this, pMin, pMax, col, rounding, flags);
			}
		}

		/// <summary>		/// a: upper-left, b: lower-right (== upper-left + size)		/// </summary>		public unsafe void AddRectFilled(Vector2 pMin, Vector2 pMax, uint col, float rounding)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectFilledNative(@this, pMin, pMax, col, rounding, (ImDrawFlags)(0));
			}
		}

		/// <summary>		/// a: upper-left, b: lower-right (== upper-left + size)		/// </summary>		public unsafe void AddRectFilled(Vector2 pMin, Vector2 pMax, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectFilledNative(@this, pMin, pMax, col, (float)(0.0f), (ImDrawFlags)(0));
			}
		}

		/// <summary>		/// a: upper-left, b: lower-right (== upper-left + size)		/// </summary>		public unsafe void AddRectFilled(Vector2 pMin, Vector2 pMax, uint col, ImDrawFlags flags)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectFilledNative(@this, pMin, pMax, col, (float)(0.0f), flags);
			}
		}

		public unsafe void AddRectFilledMultiColor(Vector2 pMin, Vector2 pMax, uint colUprLeft, uint colUprRight, uint colBotRight, uint colBotLeft)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectFilledMultiColorNative(@this, pMin, pMax, colUprLeft, colUprRight, colBotRight, colBotLeft);
			}
		}

		public unsafe void AddText(Vector2 pos, uint col, byte* textBegin, byte* textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTextNative(@this, pos, col, textBegin, textEnd);
			}
		}

		public unsafe void AddText(Vector2 pos, uint col, byte* textBegin)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTextNative(@this, pos, col, textBegin, (byte*)(default));
			}
		}

		public unsafe void AddText(Vector2 pos, uint col, ref byte textBegin, byte* textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(@this, pos, col, (byte*)ptextBegin, textEnd);
				}
			}
		}

		public unsafe void AddText(Vector2 pos, uint col, ref byte textBegin)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(@this, pos, col, (byte*)ptextBegin, (byte*)(default));
				}
			}
		}

		public unsafe void AddText(Vector2 pos, uint col, string textBegin, byte* textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, pos, col, pStr0, textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(Vector2 pos, uint col, string textBegin)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, pos, col, pStr0, (byte*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(Vector2 pos, uint col, byte* textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(@this, pos, col, textBegin, (byte*)ptextEnd);
				}
			}
		}

		public unsafe void AddText(Vector2 pos, uint col, byte* textBegin, string textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, pos, col, textBegin, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(Vector2 pos, uint col, ref byte textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, pos, col, (byte*)ptextBegin, (byte*)ptextEnd);
					}
				}
			}
		}

		public unsafe void AddText(Vector2 pos, uint col, string textBegin, string textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.AddTextNative(@this, pos, col, pStr0, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, textEnd, wrapWidth, cpuFineClipRect);
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, textEnd, wrapWidth, (Vector4*)(default));
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, textEnd, (float)(0.0f), (Vector4*)(default));
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)(default), (float)(0.0f), (Vector4*)(default));
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)(default), wrapWidth, (Vector4*)(default));
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, textEnd, (float)(0.0f), cpuFineClipRect);
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)(default), (float)(0.0f), cpuFineClipRect);
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)(default), wrapWidth, cpuFineClipRect);
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, wrapWidth, cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, wrapWidth, (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)(default), (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)(default), wrapWidth, (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, (float)(0.0f), cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)(default), (float)(0.0f), cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)(default), wrapWidth, cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, textEnd, wrapWidth, cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, textEnd, wrapWidth, (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, textEnd, (float)(0.0f), (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, (byte*)(default), (float)(0.0f), (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, (byte*)(default), wrapWidth, (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, textEnd, (float)(0.0f), cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, (byte*)(default), (float)(0.0f), cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, (byte*)(default), wrapWidth, cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, cpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)(default));
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), (Vector4*)(default));
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), (Vector4*)(default));
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, (Vector4*)(default));
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), cpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), cpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, cpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, wrapWidth, cpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, wrapWidth, (Vector4*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, (float)(0.0f), (Vector4*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)(default), (float)(0.0f), (Vector4*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)(default), wrapWidth, (Vector4*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, (float)(0.0f), cpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)(default), (float)(0.0f), cpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)(default), wrapWidth, cpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, pStr0, wrapWidth, cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, pStr0, wrapWidth, (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, pStr0, (float)(0.0f), (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, pStr0, (float)(0.0f), cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, wrapWidth, cpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, wrapWidth, (Vector4*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, (float)(0.0f), (Vector4*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, (float)(0.0f), cpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, pStr1, wrapWidth, cpuFineClipRect);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, pStr1, wrapWidth, (Vector4*)(default));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, pStr1, (float)(0.0f), (Vector4*)(default));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, pStr1, (float)(0.0f), cpuFineClipRect);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
						}
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
						}
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
						}
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
						}
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, wrapWidth, cpuFineClipRect);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, wrapWidth, (Vector4*)(default));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, (float)(0.0f), (Vector4*)(default));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, (float)(0.0f), cpuFineClipRect);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, textEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)(default), (float)(0.0f), (Vector4*)pcpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)(default), wrapWidth, (Vector4*)pcpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)(default), (float)(0.0f), (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)(default), wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, textEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, (byte*)(default), (float)(0.0f), (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, (byte*)(default), wrapWidth, (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)(default), (float)(0.0f), (Vector4*)pcpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)(default), wrapWidth, (Vector4*)pcpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, pStr0, wrapWidth, (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, pStr0, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, wrapWidth, (Vector4*)pcpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, (float)(0.0f), (Vector4*)pcpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, pStr1, wrapWidth, (Vector4*)pcpuFineClipRect);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, pStr1, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
							{
								ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
							}
						}
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
							{
								ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
							}
						}
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, wrapWidth, (Vector4*)pcpuFineClipRect);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr1);
						}
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, (float)(0.0f), (Vector4*)pcpuFineClipRect);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr1);
						}
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		public unsafe void AddTriangle(Vector2 p1, Vector2 p2, Vector2 p3, uint col, float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTriangleNative(@this, p1, p2, p3, col, thickness);
			}
		}

		public unsafe void AddTriangle(Vector2 p1, Vector2 p2, Vector2 p3, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTriangleNative(@this, p1, p2, p3, col, (float)(1.0f));
			}
		}

		public unsafe void AddTriangleFilled(Vector2 p1, Vector2 p2, Vector2 p3, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTriangleFilledNative(@this, p1, p2, p3, col);
			}
		}

		public unsafe void ChannelsMerge()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.ChannelsMergeNative(@this);
			}
		}

		public unsafe void ChannelsSetCurrent(int n)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.ChannelsSetCurrentNative(@this, n);
			}
		}

		public unsafe void ChannelsSplit(int count)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.ChannelsSplitNative(@this, count);
			}
		}

		/// <summary>		/// Create a clone of the CmdBufferIdxBufferVtxBuffer.		/// </summary>		public unsafe ImDrawList* CloneOutput()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImDrawList* ret = ImGui.CloneOutputNative(@this);
				return ret;
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe void PathArcTo(Vector2 center, float radius, float aMin, float aMax, int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathArcToNative(@this, center, radius, aMin, aMax, numSegments);
			}
		}

		public unsafe void PathArcTo(Vector2 center, float radius, float aMin, float aMax)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathArcToNative(@this, center, radius, aMin, aMax, (int)(0));
			}
		}

		/// <summary>		/// Use precomputed angles for a 12 steps circle		/// </summary>		public unsafe void PathArcToFast(Vector2 center, float radius, int aMinOf12, int aMaxOf12)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathArcToFastNative(@this, center, radius, aMinOf12, aMaxOf12);
			}
		}

		/// <summary>		/// Cubic Bezier (4 control points)		/// </summary>		public unsafe void PathBezierCubicCurveTo(Vector2 p2, Vector2 p3, Vector2 p4, int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathBezierCubicCurveToNative(@this, p2, p3, p4, numSegments);
			}
		}

		/// <summary>		/// Cubic Bezier (4 control points)		/// </summary>		public unsafe void PathBezierCubicCurveTo(Vector2 p2, Vector2 p3, Vector2 p4)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathBezierCubicCurveToNative(@this, p2, p3, p4, (int)(0));
			}
		}

		/// <summary>		/// Quadratic Bezier (3 control points)		/// </summary>		public unsafe void PathBezierQuadraticCurveTo(Vector2 p2, Vector2 p3, int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathBezierQuadraticCurveToNative(@this, p2, p3, numSegments);
			}
		}

		/// <summary>		/// Quadratic Bezier (3 control points)		/// </summary>		public unsafe void PathBezierQuadraticCurveTo(Vector2 p2, Vector2 p3)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathBezierQuadraticCurveToNative(@this, p2, p3, (int)(0));
			}
		}

		public unsafe void PathClear()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathClearNative(@this);
			}
		}

		public unsafe void PathFillConvex(uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathFillConvexNative(@this, col);
			}
		}

		public unsafe void PathLineTo(Vector2 pos)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathLineToNative(@this, pos);
			}
		}

		public unsafe void PathLineToMergeDuplicate(Vector2 pos)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathLineToMergeDuplicateNative(@this, pos);
			}
		}

		public unsafe void PathRect(Vector2 rectMin, Vector2 rectMax, float rounding, ImDrawFlags flags)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathRectNative(@this, rectMin, rectMax, rounding, flags);
			}
		}

		public unsafe void PathRect(Vector2 rectMin, Vector2 rectMax, float rounding)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathRectNative(@this, rectMin, rectMax, rounding, (ImDrawFlags)(0));
			}
		}

		public unsafe void PathRect(Vector2 rectMin, Vector2 rectMax)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathRectNative(@this, rectMin, rectMax, (float)(0.0f), (ImDrawFlags)(0));
			}
		}

		public unsafe void PathRect(Vector2 rectMin, Vector2 rectMax, ImDrawFlags flags)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathRectNative(@this, rectMin, rectMax, (float)(0.0f), flags);
			}
		}

		public unsafe void PathStroke(uint col, ImDrawFlags flags, float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathStrokeNative(@this, col, flags, thickness);
			}
		}

		public unsafe void PathStroke(uint col, ImDrawFlags flags)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathStrokeNative(@this, col, flags, (float)(1.0f));
			}
		}

		public unsafe void PathStroke(uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathStrokeNative(@this, col, (ImDrawFlags)(0), (float)(1.0f));
			}
		}

		public unsafe void PathStroke(uint col, float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathStrokeNative(@this, col, (ImDrawFlags)(0), thickness);
			}
		}

		public unsafe void PopClipRect()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PopClipRectNative(@this);
			}
		}

		public unsafe void PopTextureID()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PopTextureIDNative(@this);
			}
		}

		public unsafe void PrimQuadUV(Vector2 a, Vector2 b, Vector2 c, Vector2 d, Vector2 uvA, Vector2 uvB, Vector2 uvC, Vector2 uvD, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PrimQuadUVNative(@this, a, b, c, d, uvA, uvB, uvC, uvD, col);
			}
		}

		/// <summary>		/// Axis aligned rectangle (composed of two triangles)		/// </summary>		public unsafe void PrimRect(Vector2 a, Vector2 b, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PrimRectNative(@this, a, b, col);
			}
		}

		public unsafe void PrimRectUV(Vector2 a, Vector2 b, Vector2 uvA, Vector2 uvB, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PrimRectUVNative(@this, a, b, uvA, uvB, col);
			}
		}

		public unsafe void PrimReserve(int idxCount, int vtxCount)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PrimReserveNative(@this, idxCount, vtxCount);
			}
		}

		public unsafe void PrimUnreserve(int idxCount, int vtxCount)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PrimUnreserveNative(@this, idxCount, vtxCount);
			}
		}

		/// <summary>		/// Write vertex with unique index		/// </summary>		public unsafe void PrimVtx(Vector2 pos, Vector2 uv, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PrimVtxNative(@this, pos, uv, col);
			}
		}

		public unsafe void PrimWriteIdx(ushort idx)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PrimWriteIdxNative(@this, idx);
			}
		}

		public unsafe void PrimWriteVtx(Vector2 pos, Vector2 uv, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PrimWriteVtxNative(@this, pos, uv, col);
			}
		}

		/// <summary>		/// Render-level scissoring. This is passed down to your render function but not used for CPU-side coarse clipping. Prefer using higher-level ImGui::PushClipRect() to affect logic (hit-testing and widget culling)		/// </summary>		public unsafe void PushClipRect(Vector2 clipRectMin, Vector2 clipRectMax, bool intersectWithCurrentClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PushClipRectNative(@this, clipRectMin, clipRectMax, intersectWithCurrentClipRect ? (byte)1 : (byte)0);
			}
		}

		/// <summary>		/// Render-level scissoring. This is passed down to your render function but not used for CPU-side coarse clipping. Prefer using higher-level ImGui::PushClipRect() to affect logic (hit-testing and widget culling)		/// </summary>		public unsafe void PushClipRect(Vector2 clipRectMin, Vector2 clipRectMax)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PushClipRectNative(@this, clipRectMin, clipRectMax, (byte)(0));
			}
		}

		public unsafe void PushClipRectFullScreen()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PushClipRectFullScreenNative(@this);
			}
		}

		public unsafe void PushTextureID(ImTextureID textureId)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PushTextureIDNative(@this, textureId);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImDrawListPtr : IEquatable<ImDrawListPtr>
	{
		public ImDrawListPtr(ImDrawList* handle) { Handle = handle; }

		public ImDrawList* Handle;

		public bool IsNull => Handle == null;

		public static ImDrawListPtr Null => new ImDrawListPtr(null);

		public static implicit operator ImDrawListPtr(ImDrawList* handle) => new ImDrawListPtr(handle);

		public static implicit operator ImDrawList*(ImDrawListPtr handle) => handle.Handle;

		public static bool operator ==(ImDrawListPtr left, ImDrawListPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImDrawListPtr left, ImDrawListPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImDrawListPtr left, ImDrawList* right) => left.Handle == right;

		public static bool operator !=(ImDrawListPtr left, ImDrawList* right) => left.Handle != right;

		public bool Equals(ImDrawListPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImDrawListPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImDrawListPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		/// <summary>
		/// This is what you have to render Draw commands. Typically 1 command = 1 GPU draw call, unless the command is a callback.<br/>
		/// </summary>
		public ref ImVectorImDrawCmd CmdBuffer => ref Unsafe.AsRef<ImVectorImDrawCmd>(&Handle->CmdBuffer);
		/// <summary>
		/// Index buffer. Each command consume ImDrawCmd::ElemCount of those<br/>
		/// </summary>
		public ref ImVectorImDrawIdx IdxBuffer => ref Unsafe.AsRef<ImVectorImDrawIdx>(&Handle->IdxBuffer);
		/// <summary>
		/// Vertex buffer.<br/>
		/// </summary>
		public ref ImVectorImDrawVert VtxBuffer => ref Unsafe.AsRef<ImVectorImDrawVert>(&Handle->VtxBuffer);
		/// <summary>
		/// Flags, you may poke into these to adjust anti-aliasing settings per-primitive.<br/>
		/// </summary>
		public ref ImDrawListFlags Flags => ref Unsafe.AsRef<ImDrawListFlags>(&Handle->Flags);
		/// <summary>
		/// [Internal, used while building lists] [Internal] generally == VtxBuffer.Size unless we are past 64K vertices, in which case this gets reset to 0.<br/>
		/// </summary>
		public ref uint VtxCurrentIdx => ref Unsafe.AsRef<uint>(&Handle->VtxCurrentIdx);
		/// <summary>
		/// Pointer to shared draw data (you can use ImGui::GetDrawListSharedData() to get the one from current ImGui context)<br/>
		/// </summary>
		public ref ImDrawListSharedDataPtr Data => ref Unsafe.AsRef<ImDrawListSharedDataPtr>(&Handle->Data);
		/// <summary>
		/// Pointer to owner window's name for debugging<br/>
		/// </summary>
		public byte* OwnerName { get => Handle->OwnerName; set => Handle->OwnerName = value; }
		/// <summary>
		/// [Internal] point within VtxBuffer.Data after each add command (to avoid using the ImVector&lt;&gt; operators too much)<br/>
		/// </summary>
		public ref ImDrawVertPtr VtxWritePtr => ref Unsafe.AsRef<ImDrawVertPtr>(&Handle->VtxWritePtr);
		/// <summary>
		/// [Internal] point within IdxBuffer.Data after each add command (to avoid using the ImVector&lt;&gt; operators too much)<br/>
		/// </summary>
		public ushort* IdxWritePtr { get => Handle->IdxWritePtr; set => Handle->IdxWritePtr = value; }
		/// <summary>
		/// [Internal]<br/>
		/// </summary>
		public ref ImVectorImVec4 ClipRectStack => ref Unsafe.AsRef<ImVectorImVec4>(&Handle->ClipRectStack);
		/// <summary>
		/// [Internal]<br/>
		/// </summary>
		public ref ImVectorImTextureID TextureIdStack => ref Unsafe.AsRef<ImVectorImTextureID>(&Handle->TextureIdStack);
		/// <summary>
		/// [Internal] current path building<br/>
		/// </summary>
		public ref ImVectorImVec2 Path => ref Unsafe.AsRef<ImVectorImVec2>(&Handle->Path);
		/// <summary>
		/// [Internal] template of active commands. Fields should match those of CmdBuffer.back().<br/>
		/// </summary>
		public ref ImDrawCmdHeader CmdHeader => ref Unsafe.AsRef<ImDrawCmdHeader>(&Handle->CmdHeader);
		/// <summary>
		/// [Internal] for channels api (note: prefer using your own persistent instance of ImDrawListSplitter!)<br/>
		/// </summary>
		public ref ImDrawListSplitter Splitter => ref Unsafe.AsRef<ImDrawListSplitter>(&Handle->Splitter);
		/// <summary>
		/// [Internal] anti-alias fringe is scaled by this value, this helps to keep things sharp while zooming at vertex buffer content<br/>
		/// </summary>
		public ref float FringeScale => ref Unsafe.AsRef<float>(&Handle->FringeScale);

		public unsafe int _CalcCircleAutoSegmentCount(float radius)
		{
			int ret = ImGui._CalcCircleAutoSegmentCountNative(Handle, radius);
			return ret;
		}

		public unsafe void _ClearFreeMemory()
		{
			ImGui._ClearFreeMemoryNative(Handle);
		}

		public unsafe void _OnChangedClipRect()
		{
			ImGui._OnChangedClipRectNative(Handle);
		}

		public unsafe void _OnChangedTextureID()
		{
			ImGui._OnChangedTextureIDNative(Handle);
		}

		public unsafe void _OnChangedVtxOffset()
		{
			ImGui._OnChangedVtxOffsetNative(Handle);
		}

		public unsafe void _PathArcToFastEx(Vector2 center, float radius, int aMinSample, int aMaxSample, int aStep)
		{
			ImGui._PathArcToFastExNative(Handle, center, radius, aMinSample, aMaxSample, aStep);
		}

		public unsafe void _PathArcToN(Vector2 center, float radius, float aMin, float aMax, int numSegments)
		{
			ImGui._PathArcToNNative(Handle, center, radius, aMin, aMax, numSegments);
		}

		public unsafe void _PopUnusedDrawCmd()
		{
			ImGui._PopUnusedDrawCmdNative(Handle);
		}

		public unsafe void _ResetForNewFrame()
		{
			ImGui._ResetForNewFrameNative(Handle);
		}

		public unsafe void _TryMergeDrawCmds()
		{
			ImGui._TryMergeDrawCmdsNative(Handle);
		}

		/// <summary>		/// Cubic Bezier (4 control points)		/// </summary>		public unsafe void AddBezierCubic(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col, float thickness, int numSegments)
		{
			ImGui.AddBezierCubicNative(Handle, p1, p2, p3, p4, col, thickness, numSegments);
		}

		/// <summary>		/// Cubic Bezier (4 control points)		/// </summary>		public unsafe void AddBezierCubic(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col, float thickness)
		{
			ImGui.AddBezierCubicNative(Handle, p1, p2, p3, p4, col, thickness, (int)(0));
		}

		/// <summary>		/// Quadratic Bezier (3 control points)		/// </summary>		public unsafe void AddBezierQuadratic(Vector2 p1, Vector2 p2, Vector2 p3, uint col, float thickness, int numSegments)
		{
			ImGui.AddBezierQuadraticNative(Handle, p1, p2, p3, col, thickness, numSegments);
		}

		/// <summary>		/// Quadratic Bezier (3 control points)		/// </summary>		public unsafe void AddBezierQuadratic(Vector2 p1, Vector2 p2, Vector2 p3, uint col, float thickness)
		{
			ImGui.AddBezierQuadraticNative(Handle, p1, p2, p3, col, thickness, (int)(0));
		}

		/// <summary>		/// Your rendering function must check for 'UserCallback' in ImDrawCmd and call the function instead of rendering triangles.		/// </summary>		public unsafe void AddCallback(ImDrawCallback callback, void* callbackData)
		{
			ImGui.AddCallbackNative(Handle, callback, callbackData);
		}

		public unsafe void AddCircle(Vector2 center, float radius, uint col, int numSegments, float thickness)
		{
			ImGui.AddCircleNative(Handle, center, radius, col, numSegments, thickness);
		}

		public unsafe void AddCircle(Vector2 center, float radius, uint col, int numSegments)
		{
			ImGui.AddCircleNative(Handle, center, radius, col, numSegments, (float)(1.0f));
		}

		public unsafe void AddCircle(Vector2 center, float radius, uint col)
		{
			ImGui.AddCircleNative(Handle, center, radius, col, (int)(0), (float)(1.0f));
		}

		public unsafe void AddCircle(Vector2 center, float radius, uint col, float thickness)
		{
			ImGui.AddCircleNative(Handle, center, radius, col, (int)(0), thickness);
		}

		public unsafe void AddCircleFilled(Vector2 center, float radius, uint col, int numSegments)
		{
			ImGui.AddCircleFilledNative(Handle, center, radius, col, numSegments);
		}

		public unsafe void AddCircleFilled(Vector2 center, float radius, uint col)
		{
			ImGui.AddCircleFilledNative(Handle, center, radius, col, (int)(0));
		}

		public unsafe void AddConvexPolyFilled(Vector2* points, int numPoints, uint col)
		{
			ImGui.AddConvexPolyFilledNative(Handle, points, numPoints, col);
		}

		public unsafe void AddConvexPolyFilled(ref Vector2 points, int numPoints, uint col)
		{
			fixed (Vector2* ppoints = &points)
			{
				ImGui.AddConvexPolyFilledNative(Handle, (Vector2*)ppoints, numPoints, col);
			}
		}

		/// <summary>		/// This is useful if you need to forcefully create a new draw call (to allow for dependent rendering  blending). Otherwise primitives are merged into the same draw-call as much as possible		/// </summary>		public unsafe void AddDrawCmd()
		{
			ImGui.AddDrawCmdNative(Handle);
		}

		public unsafe void AddImage(ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, Vector2 uvMax, uint col)
		{
			ImGui.AddImageNative(Handle, userTextureId, pMin, pMax, uvMin, uvMax, col);
		}

		public unsafe void AddImage(ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, Vector2 uvMax)
		{
			ImGui.AddImageNative(Handle, userTextureId, pMin, pMax, uvMin, uvMax, (uint)(4294967295));
		}

		public unsafe void AddImage(ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin)
		{
			ImGui.AddImageNative(Handle, userTextureId, pMin, pMax, uvMin, (Vector2)(new Vector2(1,1)), (uint)(4294967295));
		}

		public unsafe void AddImage(ImTextureID userTextureId, Vector2 pMin, Vector2 pMax)
		{
			ImGui.AddImageNative(Handle, userTextureId, pMin, pMax, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,1)), (uint)(4294967295));
		}

		public unsafe void AddImage(ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, uint col)
		{
			ImGui.AddImageNative(Handle, userTextureId, pMin, pMax, uvMin, (Vector2)(new Vector2(1,1)), col);
		}

		public unsafe void AddImage(ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, uint col)
		{
			ImGui.AddImageNative(Handle, userTextureId, pMin, pMax, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,1)), col);
		}

		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2, Vector2 uv3, Vector2 uv4, uint col)
		{
			ImGui.AddImageQuadNative(Handle, userTextureId, p1, p2, p3, p4, uv1, uv2, uv3, uv4, col);
		}

		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2, Vector2 uv3, Vector2 uv4)
		{
			ImGui.AddImageQuadNative(Handle, userTextureId, p1, p2, p3, p4, uv1, uv2, uv3, uv4, (uint)(4294967295));
		}

		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2, Vector2 uv3)
		{
			ImGui.AddImageQuadNative(Handle, userTextureId, p1, p2, p3, p4, uv1, uv2, uv3, (Vector2)(new Vector2(0,1)), (uint)(4294967295));
		}

		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2)
		{
			ImGui.AddImageQuadNative(Handle, userTextureId, p1, p2, p3, p4, uv1, uv2, (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), (uint)(4294967295));
		}

		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1)
		{
			ImGui.AddImageQuadNative(Handle, userTextureId, p1, p2, p3, p4, uv1, (Vector2)(new Vector2(1,0)), (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), (uint)(4294967295));
		}

		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4)
		{
			ImGui.AddImageQuadNative(Handle, userTextureId, p1, p2, p3, p4, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,0)), (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), (uint)(4294967295));
		}

		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2, Vector2 uv3, uint col)
		{
			ImGui.AddImageQuadNative(Handle, userTextureId, p1, p2, p3, p4, uv1, uv2, uv3, (Vector2)(new Vector2(0,1)), col);
		}

		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2, uint col)
		{
			ImGui.AddImageQuadNative(Handle, userTextureId, p1, p2, p3, p4, uv1, uv2, (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), col);
		}

		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, uint col)
		{
			ImGui.AddImageQuadNative(Handle, userTextureId, p1, p2, p3, p4, uv1, (Vector2)(new Vector2(1,0)), (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), col);
		}

		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col)
		{
			ImGui.AddImageQuadNative(Handle, userTextureId, p1, p2, p3, p4, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,0)), (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), col);
		}

		public unsafe void AddImageRounded(ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, Vector2 uvMax, uint col, float rounding, ImDrawFlags flags)
		{
			ImGui.AddImageRoundedNative(Handle, userTextureId, pMin, pMax, uvMin, uvMax, col, rounding, flags);
		}

		public unsafe void AddImageRounded(ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, Vector2 uvMax, uint col, float rounding)
		{
			ImGui.AddImageRoundedNative(Handle, userTextureId, pMin, pMax, uvMin, uvMax, col, rounding, (ImDrawFlags)(0));
		}

		public unsafe void AddLine(Vector2 p1, Vector2 p2, uint col, float thickness)
		{
			ImGui.AddLineNative(Handle, p1, p2, col, thickness);
		}

		public unsafe void AddLine(Vector2 p1, Vector2 p2, uint col)
		{
			ImGui.AddLineNative(Handle, p1, p2, col, (float)(1.0f));
		}

		public unsafe void AddNgon(Vector2 center, float radius, uint col, int numSegments, float thickness)
		{
			ImGui.AddNgonNative(Handle, center, radius, col, numSegments, thickness);
		}

		public unsafe void AddNgon(Vector2 center, float radius, uint col, int numSegments)
		{
			ImGui.AddNgonNative(Handle, center, radius, col, numSegments, (float)(1.0f));
		}

		public unsafe void AddNgonFilled(Vector2 center, float radius, uint col, int numSegments)
		{
			ImGui.AddNgonFilledNative(Handle, center, radius, col, numSegments);
		}

		public unsafe void AddPolyline(Vector2* points, int numPoints, uint col, ImDrawFlags flags, float thickness)
		{
			ImGui.AddPolylineNative(Handle, points, numPoints, col, flags, thickness);
		}

		public unsafe void AddPolyline(ref Vector2 points, int numPoints, uint col, ImDrawFlags flags, float thickness)
		{
			fixed (Vector2* ppoints = &points)
			{
				ImGui.AddPolylineNative(Handle, (Vector2*)ppoints, numPoints, col, flags, thickness);
			}
		}

		public unsafe void AddQuad(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col, float thickness)
		{
			ImGui.AddQuadNative(Handle, p1, p2, p3, p4, col, thickness);
		}

		public unsafe void AddQuad(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col)
		{
			ImGui.AddQuadNative(Handle, p1, p2, p3, p4, col, (float)(1.0f));
		}

		public unsafe void AddQuadFilled(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col)
		{
			ImGui.AddQuadFilledNative(Handle, p1, p2, p3, p4, col);
		}

		/// <summary>		/// a: upper-left, b: lower-right (== upper-left + size)		/// </summary>		public unsafe void AddRect(Vector2 pMin, Vector2 pMax, uint col, float rounding, ImDrawFlags flags, float thickness)
		{
			ImGui.AddRectNative(Handle, pMin, pMax, col, rounding, flags, thickness);
		}

		/// <summary>		/// a: upper-left, b: lower-right (== upper-left + size)		/// </summary>		public unsafe void AddRect(Vector2 pMin, Vector2 pMax, uint col, float rounding, ImDrawFlags flags)
		{
			ImGui.AddRectNative(Handle, pMin, pMax, col, rounding, flags, (float)(1.0f));
		}

		/// <summary>		/// a: upper-left, b: lower-right (== upper-left + size)		/// </summary>		public unsafe void AddRect(Vector2 pMin, Vector2 pMax, uint col, float rounding)
		{
			ImGui.AddRectNative(Handle, pMin, pMax, col, rounding, (ImDrawFlags)(0), (float)(1.0f));
		}

		/// <summary>		/// a: upper-left, b: lower-right (== upper-left + size)		/// </summary>		public unsafe void AddRect(Vector2 pMin, Vector2 pMax, uint col)
		{
			ImGui.AddRectNative(Handle, pMin, pMax, col, (float)(0.0f), (ImDrawFlags)(0), (float)(1.0f));
		}

		/// <summary>		/// a: upper-left, b: lower-right (== upper-left + size)		/// </summary>		public unsafe void AddRect(Vector2 pMin, Vector2 pMax, uint col, ImDrawFlags flags)
		{
			ImGui.AddRectNative(Handle, pMin, pMax, col, (float)(0.0f), flags, (float)(1.0f));
		}

		/// <summary>		/// a: upper-left, b: lower-right (== upper-left + size)		/// </summary>		public unsafe void AddRect(Vector2 pMin, Vector2 pMax, uint col, float rounding, float thickness)
		{
			ImGui.AddRectNative(Handle, pMin, pMax, col, rounding, (ImDrawFlags)(0), thickness);
		}

		/// <summary>		/// a: upper-left, b: lower-right (== upper-left + size)		/// </summary>		public unsafe void AddRect(Vector2 pMin, Vector2 pMax, uint col, ImDrawFlags flags, float thickness)
		{
			ImGui.AddRectNative(Handle, pMin, pMax, col, (float)(0.0f), flags, thickness);
		}

		/// <summary>		/// a: upper-left, b: lower-right (== upper-left + size)		/// </summary>		public unsafe void AddRectFilled(Vector2 pMin, Vector2 pMax, uint col, float rounding, ImDrawFlags flags)
		{
			ImGui.AddRectFilledNative(Handle, pMin, pMax, col, rounding, flags);
		}

		/// <summary>		/// a: upper-left, b: lower-right (== upper-left + size)		/// </summary>		public unsafe void AddRectFilled(Vector2 pMin, Vector2 pMax, uint col, float rounding)
		{
			ImGui.AddRectFilledNative(Handle, pMin, pMax, col, rounding, (ImDrawFlags)(0));
		}

		/// <summary>		/// a: upper-left, b: lower-right (== upper-left + size)		/// </summary>		public unsafe void AddRectFilled(Vector2 pMin, Vector2 pMax, uint col)
		{
			ImGui.AddRectFilledNative(Handle, pMin, pMax, col, (float)(0.0f), (ImDrawFlags)(0));
		}

		/// <summary>		/// a: upper-left, b: lower-right (== upper-left + size)		/// </summary>		public unsafe void AddRectFilled(Vector2 pMin, Vector2 pMax, uint col, ImDrawFlags flags)
		{
			ImGui.AddRectFilledNative(Handle, pMin, pMax, col, (float)(0.0f), flags);
		}

		public unsafe void AddRectFilledMultiColor(Vector2 pMin, Vector2 pMax, uint colUprLeft, uint colUprRight, uint colBotRight, uint colBotLeft)
		{
			ImGui.AddRectFilledMultiColorNative(Handle, pMin, pMax, colUprLeft, colUprRight, colBotRight, colBotLeft);
		}

		public unsafe void AddText(Vector2 pos, uint col, byte* textBegin, byte* textEnd)
		{
			ImGui.AddTextNative(Handle, pos, col, textBegin, textEnd);
		}

		public unsafe void AddText(Vector2 pos, uint col, byte* textBegin)
		{
			ImGui.AddTextNative(Handle, pos, col, textBegin, (byte*)(default));
		}

		public unsafe void AddText(Vector2 pos, uint col, ref byte textBegin, byte* textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				ImGui.AddTextNative(Handle, pos, col, (byte*)ptextBegin, textEnd);
			}
		}

		public unsafe void AddText(Vector2 pos, uint col, ref byte textBegin)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				ImGui.AddTextNative(Handle, pos, col, (byte*)ptextBegin, (byte*)(default));
			}
		}

		public unsafe void AddText(Vector2 pos, uint col, string textBegin, byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.AddTextNative(Handle, pos, col, pStr0, textEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void AddText(Vector2 pos, uint col, string textBegin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.AddTextNative(Handle, pos, col, pStr0, (byte*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void AddText(Vector2 pos, uint col, byte* textBegin, ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				ImGui.AddTextNative(Handle, pos, col, textBegin, (byte*)ptextEnd);
			}
		}

		public unsafe void AddText(Vector2 pos, uint col, byte* textBegin, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.AddTextNative(Handle, pos, col, textBegin, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void AddText(Vector2 pos, uint col, ref byte textBegin, ref byte textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(Handle, pos, col, (byte*)ptextBegin, (byte*)ptextEnd);
				}
			}
		}

		public unsafe void AddText(Vector2 pos, uint col, string textBegin, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ImGui.AddTextNative(Handle, pos, col, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, textEnd, wrapWidth, cpuFineClipRect);
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth)
		{
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, textEnd, wrapWidth, (Vector4*)(default));
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd)
		{
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, textEnd, (float)(0.0f), (Vector4*)(default));
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin)
		{
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, (byte*)(default), (float)(0.0f), (Vector4*)(default));
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, float wrapWidth)
		{
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, (byte*)(default), wrapWidth, (Vector4*)(default));
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, Vector4* cpuFineClipRect)
		{
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, textEnd, (float)(0.0f), cpuFineClipRect);
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, Vector4* cpuFineClipRect)
		{
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, (byte*)(default), (float)(0.0f), cpuFineClipRect);
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, float wrapWidth, Vector4* cpuFineClipRect)
		{
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, (byte*)(default), wrapWidth, cpuFineClipRect);
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, wrapWidth, cpuFineClipRect);
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* pfont = &font)
			{
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, wrapWidth, (Vector4*)(default));
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd)
		{
			fixed (ImFont* pfont = &font)
			{
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, (float)(0.0f), (Vector4*)(default));
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin)
		{
			fixed (ImFont* pfont = &font)
			{
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)(default), (float)(0.0f), (Vector4*)(default));
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, float wrapWidth)
		{
			fixed (ImFont* pfont = &font)
			{
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)(default), wrapWidth, (Vector4*)(default));
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, (float)(0.0f), cpuFineClipRect);
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)(default), (float)(0.0f), cpuFineClipRect);
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)(default), wrapWidth, cpuFineClipRect);
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, cpuFineClipRect);
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)(default));
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), (Vector4*)(default));
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), (Vector4*)(default));
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, float wrapWidth)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, (Vector4*)(default));
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, Vector4* cpuFineClipRect)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), cpuFineClipRect);
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, Vector4* cpuFineClipRect)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), cpuFineClipRect);
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, cpuFineClipRect);
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, textEnd, wrapWidth, cpuFineClipRect);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, textEnd, wrapWidth, (Vector4*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, textEnd, (float)(0.0f), (Vector4*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, (byte*)(default), (float)(0.0f), (Vector4*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, (byte*)(default), wrapWidth, (Vector4*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, Vector4* cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, textEnd, (float)(0.0f), cpuFineClipRect);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, Vector4* cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, (byte*)(default), (float)(0.0f), cpuFineClipRect);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, float wrapWidth, Vector4* cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, (byte*)(default), wrapWidth, cpuFineClipRect);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, float wrapWidth)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, wrapWidth, cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, wrapWidth, (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, (float)(0.0f), (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)(default), (float)(0.0f), (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, float wrapWidth)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)(default), wrapWidth, (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, (float)(0.0f), cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)(default), (float)(0.0f), cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)(default), wrapWidth, cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, Vector4* cpuFineClipRect)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, pStr0, wrapWidth, cpuFineClipRect);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, pStr0, wrapWidth, (Vector4*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, pStr0, (float)(0.0f), (Vector4*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, Vector4* cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, pStr0, (float)(0.0f), cpuFineClipRect);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, wrapWidth, cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, wrapWidth, (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, (float)(0.0f), (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, (float)(0.0f), cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, Vector4* cpuFineClipRect)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, pStr1, wrapWidth, cpuFineClipRect);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, pStr1, wrapWidth, (Vector4*)(default));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, pStr1, (float)(0.0f), (Vector4*)(default));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, Vector4* cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, pStr1, (float)(0.0f), cpuFineClipRect);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, wrapWidth, cpuFineClipRect);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, wrapWidth, (Vector4*)(default));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, (float)(0.0f), (Vector4*)(default));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, (float)(0.0f), cpuFineClipRect);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, textEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref Vector4 cpuFineClipRect)
		{
			fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, (byte*)(default), (float)(0.0f), (Vector4*)pcpuFineClipRect);
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, (byte*)(default), wrapWidth, (Vector4*)pcpuFineClipRect);
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)(default), (float)(0.0f), (Vector4*)pcpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)(default), wrapWidth, (Vector4*)pcpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref Vector4 cpuFineClipRect)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), (Vector4*)pcpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, (Vector4*)pcpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, ref Vector4 cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, textEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, ref Vector4 cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, (byte*)(default), (float)(0.0f), (Vector4*)pcpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, (byte*)(default), wrapWidth, (Vector4*)pcpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)(default), (float)(0.0f), (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)(default), wrapWidth, (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, pStr0, wrapWidth, (Vector4*)pcpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, ref Vector4 cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, pStr0, (float)(0.0f), (Vector4*)pcpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, wrapWidth, (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, pStr1, wrapWidth, (Vector4*)pcpuFineClipRect);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, ref Vector4 cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, pStr1, (float)(0.0f), (Vector4*)pcpuFineClipRect);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, wrapWidth, (Vector4*)pcpuFineClipRect);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddTriangle(Vector2 p1, Vector2 p2, Vector2 p3, uint col, float thickness)
		{
			ImGui.AddTriangleNative(Handle, p1, p2, p3, col, thickness);
		}

		public unsafe void AddTriangle(Vector2 p1, Vector2 p2, Vector2 p3, uint col)
		{
			ImGui.AddTriangleNative(Handle, p1, p2, p3, col, (float)(1.0f));
		}

		public unsafe void AddTriangleFilled(Vector2 p1, Vector2 p2, Vector2 p3, uint col)
		{
			ImGui.AddTriangleFilledNative(Handle, p1, p2, p3, col);
		}

		public unsafe void ChannelsMerge()
		{
			ImGui.ChannelsMergeNative(Handle);
		}

		public unsafe void ChannelsSetCurrent(int n)
		{
			ImGui.ChannelsSetCurrentNative(Handle, n);
		}

		public unsafe void ChannelsSplit(int count)
		{
			ImGui.ChannelsSplitNative(Handle, count);
		}

		/// <summary>		/// Create a clone of the CmdBufferIdxBufferVtxBuffer.		/// </summary>		public unsafe ImDrawList* CloneOutput()
		{
			ImDrawList* ret = ImGui.CloneOutputNative(Handle);
			return ret;
		}

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

		public unsafe void PathArcTo(Vector2 center, float radius, float aMin, float aMax, int numSegments)
		{
			ImGui.PathArcToNative(Handle, center, radius, aMin, aMax, numSegments);
		}

		public unsafe void PathArcTo(Vector2 center, float radius, float aMin, float aMax)
		{
			ImGui.PathArcToNative(Handle, center, radius, aMin, aMax, (int)(0));
		}

		/// <summary>		/// Use precomputed angles for a 12 steps circle		/// </summary>		public unsafe void PathArcToFast(Vector2 center, float radius, int aMinOf12, int aMaxOf12)
		{
			ImGui.PathArcToFastNative(Handle, center, radius, aMinOf12, aMaxOf12);
		}

		/// <summary>		/// Cubic Bezier (4 control points)		/// </summary>		public unsafe void PathBezierCubicCurveTo(Vector2 p2, Vector2 p3, Vector2 p4, int numSegments)
		{
			ImGui.PathBezierCubicCurveToNative(Handle, p2, p3, p4, numSegments);
		}

		/// <summary>		/// Cubic Bezier (4 control points)		/// </summary>		public unsafe void PathBezierCubicCurveTo(Vector2 p2, Vector2 p3, Vector2 p4)
		{
			ImGui.PathBezierCubicCurveToNative(Handle, p2, p3, p4, (int)(0));
		}

		/// <summary>		/// Quadratic Bezier (3 control points)		/// </summary>		public unsafe void PathBezierQuadraticCurveTo(Vector2 p2, Vector2 p3, int numSegments)
		{
			ImGui.PathBezierQuadraticCurveToNative(Handle, p2, p3, numSegments);
		}

		/// <summary>		/// Quadratic Bezier (3 control points)		/// </summary>		public unsafe void PathBezierQuadraticCurveTo(Vector2 p2, Vector2 p3)
		{
			ImGui.PathBezierQuadraticCurveToNative(Handle, p2, p3, (int)(0));
		}

		public unsafe void PathClear()
		{
			ImGui.PathClearNative(Handle);
		}

		public unsafe void PathFillConvex(uint col)
		{
			ImGui.PathFillConvexNative(Handle, col);
		}

		public unsafe void PathLineTo(Vector2 pos)
		{
			ImGui.PathLineToNative(Handle, pos);
		}

		public unsafe void PathLineToMergeDuplicate(Vector2 pos)
		{
			ImGui.PathLineToMergeDuplicateNative(Handle, pos);
		}

		public unsafe void PathRect(Vector2 rectMin, Vector2 rectMax, float rounding, ImDrawFlags flags)
		{
			ImGui.PathRectNative(Handle, rectMin, rectMax, rounding, flags);
		}

		public unsafe void PathRect(Vector2 rectMin, Vector2 rectMax, float rounding)
		{
			ImGui.PathRectNative(Handle, rectMin, rectMax, rounding, (ImDrawFlags)(0));
		}

		public unsafe void PathRect(Vector2 rectMin, Vector2 rectMax)
		{
			ImGui.PathRectNative(Handle, rectMin, rectMax, (float)(0.0f), (ImDrawFlags)(0));
		}

		public unsafe void PathRect(Vector2 rectMin, Vector2 rectMax, ImDrawFlags flags)
		{
			ImGui.PathRectNative(Handle, rectMin, rectMax, (float)(0.0f), flags);
		}

		public unsafe void PathStroke(uint col, ImDrawFlags flags, float thickness)
		{
			ImGui.PathStrokeNative(Handle, col, flags, thickness);
		}

		public unsafe void PathStroke(uint col, ImDrawFlags flags)
		{
			ImGui.PathStrokeNative(Handle, col, flags, (float)(1.0f));
		}

		public unsafe void PathStroke(uint col)
		{
			ImGui.PathStrokeNative(Handle, col, (ImDrawFlags)(0), (float)(1.0f));
		}

		public unsafe void PathStroke(uint col, float thickness)
		{
			ImGui.PathStrokeNative(Handle, col, (ImDrawFlags)(0), thickness);
		}

		public unsafe void PopClipRect()
		{
			ImGui.PopClipRectNative(Handle);
		}

		public unsafe void PopTextureID()
		{
			ImGui.PopTextureIDNative(Handle);
		}

		public unsafe void PrimQuadUV(Vector2 a, Vector2 b, Vector2 c, Vector2 d, Vector2 uvA, Vector2 uvB, Vector2 uvC, Vector2 uvD, uint col)
		{
			ImGui.PrimQuadUVNative(Handle, a, b, c, d, uvA, uvB, uvC, uvD, col);
		}

		/// <summary>		/// Axis aligned rectangle (composed of two triangles)		/// </summary>		public unsafe void PrimRect(Vector2 a, Vector2 b, uint col)
		{
			ImGui.PrimRectNative(Handle, a, b, col);
		}

		public unsafe void PrimRectUV(Vector2 a, Vector2 b, Vector2 uvA, Vector2 uvB, uint col)
		{
			ImGui.PrimRectUVNative(Handle, a, b, uvA, uvB, col);
		}

		public unsafe void PrimReserve(int idxCount, int vtxCount)
		{
			ImGui.PrimReserveNative(Handle, idxCount, vtxCount);
		}

		public unsafe void PrimUnreserve(int idxCount, int vtxCount)
		{
			ImGui.PrimUnreserveNative(Handle, idxCount, vtxCount);
		}

		/// <summary>		/// Write vertex with unique index		/// </summary>		public unsafe void PrimVtx(Vector2 pos, Vector2 uv, uint col)
		{
			ImGui.PrimVtxNative(Handle, pos, uv, col);
		}

		public unsafe void PrimWriteIdx(ushort idx)
		{
			ImGui.PrimWriteIdxNative(Handle, idx);
		}

		public unsafe void PrimWriteVtx(Vector2 pos, Vector2 uv, uint col)
		{
			ImGui.PrimWriteVtxNative(Handle, pos, uv, col);
		}

		/// <summary>		/// Render-level scissoring. This is passed down to your render function but not used for CPU-side coarse clipping. Prefer using higher-level ImGui::PushClipRect() to affect logic (hit-testing and widget culling)		/// </summary>		public unsafe void PushClipRect(Vector2 clipRectMin, Vector2 clipRectMax, bool intersectWithCurrentClipRect)
		{
			ImGui.PushClipRectNative(Handle, clipRectMin, clipRectMax, intersectWithCurrentClipRect ? (byte)1 : (byte)0);
		}

		/// <summary>		/// Render-level scissoring. This is passed down to your render function but not used for CPU-side coarse clipping. Prefer using higher-level ImGui::PushClipRect() to affect logic (hit-testing and widget culling)		/// </summary>		public unsafe void PushClipRect(Vector2 clipRectMin, Vector2 clipRectMax)
		{
			ImGui.PushClipRectNative(Handle, clipRectMin, clipRectMax, (byte)(0));
		}

		public unsafe void PushClipRectFullScreen()
		{
			ImGui.PushClipRectFullScreenNative(Handle);
		}

		public unsafe void PushTextureID(ImTextureID textureId)
		{
			ImGui.PushTextureIDNative(Handle, textureId);
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImDrawListPtrPtr : IEquatable<ImDrawListPtrPtr>
	{
		public ImDrawListPtrPtr(ImDrawList** handle) { Handle = handle; }

		public ImDrawList** Handle;

		public bool IsNull => Handle == null;

		public static ImDrawListPtrPtr Null => new ImDrawListPtrPtr(null);

		public static implicit operator ImDrawListPtrPtr(ImDrawList** handle) => new ImDrawListPtrPtr(handle);

		public static implicit operator ImDrawList**(ImDrawListPtrPtr handle) => handle.Handle;

		public static bool operator ==(ImDrawListPtrPtr left, ImDrawListPtrPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImDrawListPtrPtr left, ImDrawListPtrPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImDrawListPtrPtr left, ImDrawList** right) => left.Handle == right;

		public static bool operator !=(ImDrawListPtrPtr left, ImDrawList** right) => left.Handle != right;

		public bool Equals(ImDrawListPtrPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImDrawListPtrPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImDrawListPtrPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ImDrawListPtr this[int index]
		{
			get => Handle[index]; set => Handle[index] = value;
		}
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImDrawIdx
	{
		public int Size;
		public int Capacity;
		public unsafe ushort* Data;


	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImDrawVert
	{
		public int Size;
		public int Capacity;
		public unsafe ImDrawVert* Data;


	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImDrawVert
	{
		public Vector2 Pos;
		public Vector2 Uv;
		public uint Col;


	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImDrawVertPtr : IEquatable<ImDrawVertPtr>
	{
		public ImDrawVertPtr(ImDrawVert* handle) { Handle = handle; }

		public ImDrawVert* Handle;

		public bool IsNull => Handle == null;

		public static ImDrawVertPtr Null => new ImDrawVertPtr(null);

		public static implicit operator ImDrawVertPtr(ImDrawVert* handle) => new ImDrawVertPtr(handle);

		public static implicit operator ImDrawVert*(ImDrawVertPtr handle) => handle.Handle;

		public static bool operator ==(ImDrawVertPtr left, ImDrawVertPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImDrawVertPtr left, ImDrawVertPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImDrawVertPtr left, ImDrawVert* right) => left.Handle == right;

		public static bool operator !=(ImDrawVertPtr left, ImDrawVert* right) => left.Handle != right;

		public bool Equals(ImDrawVertPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImDrawVertPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImDrawVertPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref Vector2 Pos => ref Unsafe.AsRef<Vector2>(&Handle->Pos);
		public ref Vector2 Uv => ref Unsafe.AsRef<Vector2>(&Handle->Uv);
		public ref uint Col => ref Unsafe.AsRef<uint>(&Handle->Col);
	}

	/// <summary>
	/// Data shared between all ImDrawList instances<br/>
	/// You may want to create your own instance of this if you want to use ImDrawList completely without ImGui. In that case, watch out for future changes to this structure.<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImDrawListSharedData
	{
		/// <summary>
		/// UV of white pixel in the atlas<br/>
		/// </summary>
		public Vector2 TexUvWhitePixel;

		/// <summary>
		/// Currentdefault font (optional, for simplified AddText overload)<br/>
		/// </summary>
		public unsafe ImFont* Font;

		/// <summary>
		/// Currentdefault font size (optional, for simplified AddText overload)<br/>
		/// </summary>
		public float FontSize;

		/// <summary>
		/// Tessellation tolerance when using PathBezierCurveTo()<br/>
		/// </summary>
		public float CurveTessellationTol;

		/// <summary>
		/// Number of circle segments to use per pixel of radius for AddCircle() etc<br/>
		/// </summary>
		public float CircleSegmentMaxError;

		/// <summary>
		/// Value for PushClipRectFullscreen()<br/>
		/// </summary>
		public Vector4 ClipRectFullscreen;

		/// <summary>
		/// Initial flags at the beginning of the frame (it is possible to alter flags on a per-drawlist basis afterwards)<br/>
		/// </summary>
		public ImDrawListFlags InitialFlags;

		public ImVectorImVec2 TempBuffer;
		/// <summary>
		/// [Internal] Lookup tables Sample points on the quarter of the circle.<br/>
		/// </summary>
		public Vector2 ArcFastVtx_0;
		public Vector2 ArcFastVtx_1;
		public Vector2 ArcFastVtx_2;
		public Vector2 ArcFastVtx_3;
		public Vector2 ArcFastVtx_4;
		public Vector2 ArcFastVtx_5;
		public Vector2 ArcFastVtx_6;
		public Vector2 ArcFastVtx_7;
		public Vector2 ArcFastVtx_8;
		public Vector2 ArcFastVtx_9;
		public Vector2 ArcFastVtx_10;
		public Vector2 ArcFastVtx_11;
		public Vector2 ArcFastVtx_12;
		public Vector2 ArcFastVtx_13;
		public Vector2 ArcFastVtx_14;
		public Vector2 ArcFastVtx_15;
		public Vector2 ArcFastVtx_16;
		public Vector2 ArcFastVtx_17;
		public Vector2 ArcFastVtx_18;
		public Vector2 ArcFastVtx_19;
		public Vector2 ArcFastVtx_20;
		public Vector2 ArcFastVtx_21;
		public Vector2 ArcFastVtx_22;
		public Vector2 ArcFastVtx_23;
		public Vector2 ArcFastVtx_24;
		public Vector2 ArcFastVtx_25;
		public Vector2 ArcFastVtx_26;
		public Vector2 ArcFastVtx_27;
		public Vector2 ArcFastVtx_28;
		public Vector2 ArcFastVtx_29;
		public Vector2 ArcFastVtx_30;
		public Vector2 ArcFastVtx_31;
		public Vector2 ArcFastVtx_32;
		public Vector2 ArcFastVtx_33;
		public Vector2 ArcFastVtx_34;
		public Vector2 ArcFastVtx_35;
		public Vector2 ArcFastVtx_36;
		public Vector2 ArcFastVtx_37;
		public Vector2 ArcFastVtx_38;
		public Vector2 ArcFastVtx_39;
		public Vector2 ArcFastVtx_40;
		public Vector2 ArcFastVtx_41;
		public Vector2 ArcFastVtx_42;
		public Vector2 ArcFastVtx_43;
		public Vector2 ArcFastVtx_44;
		public Vector2 ArcFastVtx_45;
		public Vector2 ArcFastVtx_46;
		public Vector2 ArcFastVtx_47;

		/// <summary>
		/// Cutoff radius after which arc drawing will fallback to slower PathArcTo()<br/>
		/// </summary>
		public float ArcFastRadiusCutoff;

		/// <summary>
		/// Precomputed segment count for given radius before we calculate it dynamically (to avoid calculation overhead)<br/>
		/// </summary>
		public byte CircleSegmentCounts_0;
		public byte CircleSegmentCounts_1;
		public byte CircleSegmentCounts_2;
		public byte CircleSegmentCounts_3;
		public byte CircleSegmentCounts_4;
		public byte CircleSegmentCounts_5;
		public byte CircleSegmentCounts_6;
		public byte CircleSegmentCounts_7;
		public byte CircleSegmentCounts_8;
		public byte CircleSegmentCounts_9;
		public byte CircleSegmentCounts_10;
		public byte CircleSegmentCounts_11;
		public byte CircleSegmentCounts_12;
		public byte CircleSegmentCounts_13;
		public byte CircleSegmentCounts_14;
		public byte CircleSegmentCounts_15;
		public byte CircleSegmentCounts_16;
		public byte CircleSegmentCounts_17;
		public byte CircleSegmentCounts_18;
		public byte CircleSegmentCounts_19;
		public byte CircleSegmentCounts_20;
		public byte CircleSegmentCounts_21;
		public byte CircleSegmentCounts_22;
		public byte CircleSegmentCounts_23;
		public byte CircleSegmentCounts_24;
		public byte CircleSegmentCounts_25;
		public byte CircleSegmentCounts_26;
		public byte CircleSegmentCounts_27;
		public byte CircleSegmentCounts_28;
		public byte CircleSegmentCounts_29;
		public byte CircleSegmentCounts_30;
		public byte CircleSegmentCounts_31;
		public byte CircleSegmentCounts_32;
		public byte CircleSegmentCounts_33;
		public byte CircleSegmentCounts_34;
		public byte CircleSegmentCounts_35;
		public byte CircleSegmentCounts_36;
		public byte CircleSegmentCounts_37;
		public byte CircleSegmentCounts_38;
		public byte CircleSegmentCounts_39;
		public byte CircleSegmentCounts_40;
		public byte CircleSegmentCounts_41;
		public byte CircleSegmentCounts_42;
		public byte CircleSegmentCounts_43;
		public byte CircleSegmentCounts_44;
		public byte CircleSegmentCounts_45;
		public byte CircleSegmentCounts_46;
		public byte CircleSegmentCounts_47;
		public byte CircleSegmentCounts_48;
		public byte CircleSegmentCounts_49;
		public byte CircleSegmentCounts_50;
		public byte CircleSegmentCounts_51;
		public byte CircleSegmentCounts_52;
		public byte CircleSegmentCounts_53;
		public byte CircleSegmentCounts_54;
		public byte CircleSegmentCounts_55;
		public byte CircleSegmentCounts_56;
		public byte CircleSegmentCounts_57;
		public byte CircleSegmentCounts_58;
		public byte CircleSegmentCounts_59;
		public byte CircleSegmentCounts_60;
		public byte CircleSegmentCounts_61;
		public byte CircleSegmentCounts_62;
		public byte CircleSegmentCounts_63;

		/// <summary>
		/// UV of anti-aliased lines in the atlas<br/>
		/// </summary>
		public unsafe Vector4* TexUvLines;




		public unsafe Span<Vector2> ArcFastVtx
		
		{
			get
			{
				fixed (Vector2* p = &this.ArcFastVtx_0)
				{
					return new Span<Vector2>(p, 48);
				}
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImDrawListSharedData* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe void SetCircleTessellationMaxError(float maxError)
		{
			fixed (ImDrawListSharedData* @this = &this)
			{
				ImGui.SetCircleTessellationMaxErrorNative(@this, maxError);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImDrawListSharedDataPtr : IEquatable<ImDrawListSharedDataPtr>
	{
		public ImDrawListSharedDataPtr(ImDrawListSharedData* handle) { Handle = handle; }

		public ImDrawListSharedData* Handle;

		public bool IsNull => Handle == null;

		public static ImDrawListSharedDataPtr Null => new ImDrawListSharedDataPtr(null);

		public static implicit operator ImDrawListSharedDataPtr(ImDrawListSharedData* handle) => new ImDrawListSharedDataPtr(handle);

		public static implicit operator ImDrawListSharedData*(ImDrawListSharedDataPtr handle) => handle.Handle;

		public static bool operator ==(ImDrawListSharedDataPtr left, ImDrawListSharedDataPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImDrawListSharedDataPtr left, ImDrawListSharedDataPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImDrawListSharedDataPtr left, ImDrawListSharedData* right) => left.Handle == right;

		public static bool operator !=(ImDrawListSharedDataPtr left, ImDrawListSharedData* right) => left.Handle != right;

		public bool Equals(ImDrawListSharedDataPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImDrawListSharedDataPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImDrawListSharedDataPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		/// <summary>
		/// UV of white pixel in the atlas<br/>
		/// </summary>
		public ref Vector2 TexUvWhitePixel => ref Unsafe.AsRef<Vector2>(&Handle->TexUvWhitePixel);
		/// <summary>
		/// Currentdefault font (optional, for simplified AddText overload)<br/>
		/// </summary>
		public ref ImFontPtr Font => ref Unsafe.AsRef<ImFontPtr>(&Handle->Font);
		/// <summary>
		/// Currentdefault font size (optional, for simplified AddText overload)<br/>
		/// </summary>
		public ref float FontSize => ref Unsafe.AsRef<float>(&Handle->FontSize);
		/// <summary>
		/// Tessellation tolerance when using PathBezierCurveTo()<br/>
		/// </summary>
		public ref float CurveTessellationTol => ref Unsafe.AsRef<float>(&Handle->CurveTessellationTol);
		/// <summary>
		/// Number of circle segments to use per pixel of radius for AddCircle() etc<br/>
		/// </summary>
		public ref float CircleSegmentMaxError => ref Unsafe.AsRef<float>(&Handle->CircleSegmentMaxError);
		/// <summary>
		/// Value for PushClipRectFullscreen()<br/>
		/// </summary>
		public ref Vector4 ClipRectFullscreen => ref Unsafe.AsRef<Vector4>(&Handle->ClipRectFullscreen);
		/// <summary>
		/// Initial flags at the beginning of the frame (it is possible to alter flags on a per-drawlist basis afterwards)<br/>
		/// </summary>
		public ref ImDrawListFlags InitialFlags => ref Unsafe.AsRef<ImDrawListFlags>(&Handle->InitialFlags);
		public ref ImVectorImVec2 TempBuffer => ref Unsafe.AsRef<ImVectorImVec2>(&Handle->TempBuffer);
		/// <summary>
		/// [Internal] Lookup tables Sample points on the quarter of the circle.<br/>
		/// </summary>
		public unsafe Span<Vector2> ArcFastVtx
		
		{
			get
			{
				return new Span<Vector2>(&Handle->ArcFastVtx_0, 48);
			}
		}
		/// <summary>
		/// Cutoff radius after which arc drawing will fallback to slower PathArcTo()<br/>
		/// </summary>
		public ref float ArcFastRadiusCutoff => ref Unsafe.AsRef<float>(&Handle->ArcFastRadiusCutoff);
		/// <summary>
		/// Precomputed segment count for given radius before we calculate it dynamically (to avoid calculation overhead)<br/>
		/// </summary>
		public unsafe Span<byte> CircleSegmentCounts
		
		{
			get
			{
				return new Span<byte>(&Handle->CircleSegmentCounts_0, 64);
			}
		}
		/// <summary>
		/// UV of anti-aliased lines in the atlas<br/>
		/// </summary>
		public Vector4* TexUvLines { get => Handle->TexUvLines; set => Handle->TexUvLines = value; }

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

		public unsafe void SetCircleTessellationMaxError(float maxError)
		{
			ImGui.SetCircleTessellationMaxErrorNative(Handle, maxError);
		}

	}

	/// <summary>
	/// Font runtime data and rendering<br/>
	/// ImFontAtlas automatically loads a default embedded font for you when you call GetTexDataAsAlpha8() or GetTexDataAsRGBA32().<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImFont
	{
		/// <summary>
		/// Members: Hot ~2024 bytes (for CalcTextSize) 12-16  out              Sparse. Glyphs-&gt;AdvanceX in a directly indexable way (cache-friendly for CalcTextSize functions which only this this info, and are often bottleneck in large UI).<br/>
		/// </summary>
		public ImVectorFloat IndexAdvanceX;

		/// <summary>
		/// 4      out  = FallbackGlyph-&gt;AdvanceX<br/>
		/// </summary>
		public float FallbackAdvanceX;

		/// <summary>
		/// 4      in               Height of charactersline, set during loading (don't change after loading)<br/>
		/// </summary>
		public float FontSize;

		/// <summary>
		/// Members: Hot ~2840 bytes (for CalcTextSize + render loop) 12-16  out              Sparse. Index glyphs by Unicode code-point.<br/>
		/// </summary>
		public ImVectorImWchar IndexLookup;

		/// <summary>
		/// 12-16  out              All glyphs.<br/>
		/// </summary>
		public ImVectorImFontGlyph Glyphs;

		/// <summary>
		/// 4-8    out  = FindGlyph(FontFallbackChar)<br/>
		/// </summary>
		public unsafe ImFontGlyph* FallbackGlyph;

		/// <summary>
		/// Members: Cold ~3240 bytes 4-8    out              What we has been loaded into<br/>
		/// </summary>
		public unsafe ImFontAtlas* ContainerAtlas;

		/// <summary>
		/// 4-8    in               Pointer within ContainerAtlas-&gt;ConfigData<br/>
		/// </summary>
		public unsafe ImFontConfig* ConfigData;

		/// <summary>
		/// 2      in   ~ 1         Number of ImFontConfig involved in creating this font. Bigger than 1 when merging multiple font sources into one ImFont.<br/>
		/// </summary>
		public short ConfigDataCount;

		/// <summary>
		/// 2      out  = FFFD'?'  Character used if a glyph isn't found.<br/>
		/// </summary>
		public char FallbackChar;

		/// <summary>
		/// 2      out  = '...''.' Character used for ellipsis rendering.<br/>
		/// </summary>
		public char EllipsisChar;

		/// <summary>
		/// 1      out  1 or 3<br/>
		/// </summary>
		public short EllipsisCharCount;

		/// <summary>
		/// 4      out                Width<br/>
		/// </summary>
		public float EllipsisWidth;

		/// <summary>
		/// 4      out                Step between characters when EllipsisCount &gt; 0<br/>
		/// </summary>
		public float EllipsisCharStep;

		/// <summary>
		/// 1      out<br/>
		/// </summary>
		public byte DirtyLookupTables;

		/// <summary>
		/// 4      in   = 1.f       Base font scale, multiplied by the per-window font scale which you can adjust with SetWindowFontScale()<br/>
		/// </summary>
		public float Scale;

		/// <summary>
		/// 4+4    out              Ascent: distance from top to bottom of e.g. 'A' [0..FontSize]<br/>
		/// </summary>
		public float Ascent;

		/// <summary>
		/// 4+4    out              Ascent: distance from top to bottom of e.g. 'A' [0..FontSize]<br/>
		/// </summary>
		public float Descent;

		/// <summary>
		/// 4      out              Total surface in pixels to get an idea of the font rasterizationtexture cost (not exact, we approximate the cost of padding between glyphs)<br/>
		/// </summary>
		public int MetricsTotalSurface;

		/// <summary>
		/// 2 bytes if ImWchar=ImWchar16, 34 bytes if ImWchar==ImWchar32. Store 1-bit for each block of 4K codepoints that has one active glyph. This is mainly used to facilitate iterations across all used codepoints.<br/>
		/// </summary>
		public byte Used4kPagesMap_0;
		public byte Used4kPagesMap_1;





		public unsafe void AddGlyph(ImFontConfig* srcCfg, char c, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advanceX)
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.AddGlyphNative(@this, srcCfg, c, x0, y0, x1, y1, u0, v0, u1, v1, advanceX);
			}
		}

		public unsafe void AddGlyph(ref ImFontConfig srcCfg, char c, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advanceX)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImFontConfig* psrcCfg = &srcCfg)
				{
					ImGui.AddGlyphNative(@this, (ImFontConfig*)psrcCfg, c, x0, y0, x1, y1, u0, v0, u1, v1, advanceX);
				}
			}
		}

		/// <summary>		/// Makes 'dst' characterglyph points to 'src' characterglyph. Currently needs to be called AFTER fonts have been built.		/// </summary>		public unsafe void AddRemapChar(char dst, char src, bool overwriteDst)
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.AddRemapCharNative(@this, dst, src, overwriteDst ? (byte)1 : (byte)0);
			}
		}

		/// <summary>		/// Makes 'dst' characterglyph points to 'src' characterglyph. Currently needs to be called AFTER fonts have been built.		/// </summary>		public unsafe void AddRemapChar(char dst, char src)
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.AddRemapCharNative(@this, dst, src, (byte)(1));
			}
		}

		public unsafe void BuildLookupTable()
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.BuildLookupTableNative(@this);
			}
		}

		public unsafe byte* CalcWordWrapPositionA(float scale, byte* text, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				byte* ret = ImGui.CalcWordWrapPositionANative(@this, scale, text, textEnd, wrapWidth);
				return ret;
			}
		}

		public unsafe string CalcWordWrapPositionAS(float scale, byte* text, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				string ret = Utils.DecodeStringUTF8(ImGui.CalcWordWrapPositionANative(@this, scale, text, textEnd, wrapWidth));
				return ret;
			}
		}

		public unsafe byte* CalcWordWrapPositionA(float scale, ref byte text, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					byte* ret = ImGui.CalcWordWrapPositionANative(@this, scale, (byte*)ptext, textEnd, wrapWidth);
					return ret;
				}
			}
		}

		public unsafe string CalcWordWrapPositionAS(float scale, ref byte text, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					string ret = Utils.DecodeStringUTF8(ImGui.CalcWordWrapPositionANative(@this, scale, (byte*)ptext, textEnd, wrapWidth));
					return ret;
				}
			}
		}

		public unsafe byte* CalcWordWrapPositionA(float scale, string text, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* ret = ImGui.CalcWordWrapPositionANative(@this, scale, pStr0, textEnd, wrapWidth);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe string CalcWordWrapPositionAS(float scale, string text, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImGui.CalcWordWrapPositionANative(@this, scale, pStr0, textEnd, wrapWidth));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe byte* CalcWordWrapPositionA(float scale, byte* text, ref byte textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					byte* ret = ImGui.CalcWordWrapPositionANative(@this, scale, text, (byte*)ptextEnd, wrapWidth);
					return ret;
				}
			}
		}

		public unsafe string CalcWordWrapPositionAS(float scale, byte* text, ref byte textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGui.CalcWordWrapPositionANative(@this, scale, text, (byte*)ptextEnd, wrapWidth));
					return ret;
				}
			}
		}

		public unsafe byte* CalcWordWrapPositionA(float scale, byte* text, string textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* ret = ImGui.CalcWordWrapPositionANative(@this, scale, text, pStr0, wrapWidth);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe string CalcWordWrapPositionAS(float scale, byte* text, string textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImGui.CalcWordWrapPositionANative(@this, scale, text, pStr0, wrapWidth));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe byte* CalcWordWrapPositionA(float scale, ref byte text, ref byte textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						byte* ret = ImGui.CalcWordWrapPositionANative(@this, scale, (byte*)ptext, (byte*)ptextEnd, wrapWidth);
						return ret;
					}
				}
			}
		}

		public unsafe string CalcWordWrapPositionAS(float scale, ref byte text, ref byte textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImGui.CalcWordWrapPositionANative(@this, scale, (byte*)ptext, (byte*)ptextEnd, wrapWidth));
						return ret;
					}
				}
			}
		}

		public unsafe byte* CalcWordWrapPositionA(float scale, string text, string textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte* ret = ImGui.CalcWordWrapPositionANative(@this, scale, pStr0, pStr1, wrapWidth);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe string CalcWordWrapPositionAS(float scale, string text, string textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImGui.CalcWordWrapPositionANative(@this, scale, pStr0, pStr1, wrapWidth));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe void ClearOutputData()
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.ClearOutputDataNative(@this);
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe ImFontGlyph* FindGlyph(char c)
		{
			fixed (ImFont* @this = &this)
			{
				ImFontGlyph* ret = ImGui.FindGlyphNative(@this, c);
				return ret;
			}
		}

		public unsafe ImFontGlyph* FindGlyphNoFallback(char c)
		{
			fixed (ImFont* @this = &this)
			{
				ImFontGlyph* ret = ImGui.FindGlyphNoFallbackNative(@this, c);
				return ret;
			}
		}

		public unsafe float GetCharAdvance(char c)
		{
			fixed (ImFont* @this = &this)
			{
				float ret = ImGui.GetCharAdvanceNative(@this, c);
				return ret;
			}
		}

		public unsafe byte* GetDebugName()
		{
			fixed (ImFont* @this = &this)
			{
				byte* ret = ImGui.GetDebugNameNative(@this);
				return ret;
			}
		}

		public unsafe string GetDebugNameS()
		{
			fixed (ImFont* @this = &this)
			{
				string ret = Utils.DecodeStringUTF8(ImGui.GetDebugNameNative(@this));
				return ret;
			}
		}

		public unsafe void GrowIndex(int newSize)
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.GrowIndexNative(@this, newSize);
			}
		}

		public unsafe bool IsGlyphRangeUnused(uint cBegin, uint cLast)
		{
			fixed (ImFont* @this = &this)
			{
				byte ret = ImGui.IsGlyphRangeUnusedNative(@this, cBegin, cLast);
				return ret != 0;
			}
		}

		public unsafe bool IsLoaded()
		{
			fixed (ImFont* @this = &this)
			{
				byte ret = ImGui.IsLoadedNative(@this);
				return ret != 0;
			}
		}

		public unsafe void RenderChar(ImDrawListPtr drawList, float size, Vector2 pos, uint col, char c)
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.RenderCharNative(@this, drawList, size, pos, col, c);
			}
		}

		public unsafe void RenderChar(ref ImDrawList drawList, float size, Vector2 pos, uint col, char c)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					ImGui.RenderCharNative(@this, (ImDrawList*)pdrawList, size, pos, col, c);
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, textBegin, textEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, textBegin, textEnd, wrapWidth, (byte)(0));
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, textBegin, textEnd, (float)(0.0f), (byte)(0));
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, textBegin, textEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, textEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, textEnd, wrapWidth, (byte)(0));
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, textEnd, (float)(0.0f), (byte)(0));
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, textEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, wrapWidth, (byte)(0));
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, (float)(0.0f), (byte)(0));
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, pStr0, textEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, pStr0, textEnd, wrapWidth, (byte)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, pStr0, textEnd, (float)(0.0f), (byte)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, pStr0, textEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
					}
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, wrapWidth, (byte)(0));
					}
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, (float)(0.0f), (byte)(0));
					}
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
					}
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, textEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, textEnd, wrapWidth, (byte)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, textEnd, (float)(0.0f), (byte)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, textEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, wrapWidth, (byte)(0));
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, (float)(0.0f), (byte)(0));
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, textBegin, pStr0, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, textBegin, pStr0, wrapWidth, (byte)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, textBegin, pStr0, (float)(0.0f), (byte)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, textBegin, pStr0, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
					}
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, wrapWidth, (byte)(0));
					}
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, (float)(0.0f), (byte)(0));
					}
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
					}
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, pStr0, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, pStr0, wrapWidth, (byte)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, pStr0, (float)(0.0f), (byte)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, pStr0, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
					}
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (byte)(0));
					}
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (byte)(0));
					}
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
					}
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, pStr0, pStr1, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, pStr0, pStr1, wrapWidth, (byte)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, pStr0, pStr1, (float)(0.0f), (byte)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, pStr0, pStr1, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
						}
					}
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (byte)(0));
						}
					}
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (byte)(0));
						}
					}
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
						}
					}
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, pStr1, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, pStr1, wrapWidth, (byte)(0));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, pStr1, (float)(0.0f), (byte)(0));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd, bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, pStr1, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void SetGlyphVisible(char c, bool visible)
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.SetGlyphVisibleNative(@this, c, visible ? (byte)1 : (byte)0);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImFontPtr : IEquatable<ImFontPtr>
	{
		public ImFontPtr(ImFont* handle) { Handle = handle; }

		public ImFont* Handle;

		public bool IsNull => Handle == null;

		public static ImFontPtr Null => new ImFontPtr(null);

		public static implicit operator ImFontPtr(ImFont* handle) => new ImFontPtr(handle);

		public static implicit operator ImFont*(ImFontPtr handle) => handle.Handle;

		public static bool operator ==(ImFontPtr left, ImFontPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImFontPtr left, ImFontPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImFontPtr left, ImFont* right) => left.Handle == right;

		public static bool operator !=(ImFontPtr left, ImFont* right) => left.Handle != right;

		public bool Equals(ImFontPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImFontPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImFontPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		/// <summary>
		/// Members: Hot ~2024 bytes (for CalcTextSize) 12-16  out              Sparse. Glyphs-&gt;AdvanceX in a directly indexable way (cache-friendly for CalcTextSize functions which only this this info, and are often bottleneck in large UI).<br/>
		/// </summary>
		public ref ImVectorFloat IndexAdvanceX => ref Unsafe.AsRef<ImVectorFloat>(&Handle->IndexAdvanceX);
		/// <summary>
		/// 4      out  = FallbackGlyph-&gt;AdvanceX<br/>
		/// </summary>
		public ref float FallbackAdvanceX => ref Unsafe.AsRef<float>(&Handle->FallbackAdvanceX);
		/// <summary>
		/// 4      in               Height of charactersline, set during loading (don't change after loading)<br/>
		/// </summary>
		public ref float FontSize => ref Unsafe.AsRef<float>(&Handle->FontSize);
		/// <summary>
		/// Members: Hot ~2840 bytes (for CalcTextSize + render loop) 12-16  out              Sparse. Index glyphs by Unicode code-point.<br/>
		/// </summary>
		public ref ImVectorImWchar IndexLookup => ref Unsafe.AsRef<ImVectorImWchar>(&Handle->IndexLookup);
		/// <summary>
		/// 12-16  out              All glyphs.<br/>
		/// </summary>
		public ref ImVectorImFontGlyph Glyphs => ref Unsafe.AsRef<ImVectorImFontGlyph>(&Handle->Glyphs);
		/// <summary>
		/// 4-8    out  = FindGlyph(FontFallbackChar)<br/>
		/// </summary>
		public ref ImFontGlyphPtr FallbackGlyph => ref Unsafe.AsRef<ImFontGlyphPtr>(&Handle->FallbackGlyph);
		/// <summary>
		/// Members: Cold ~3240 bytes 4-8    out              What we has been loaded into<br/>
		/// </summary>
		public ref ImFontAtlasPtr ContainerAtlas => ref Unsafe.AsRef<ImFontAtlasPtr>(&Handle->ContainerAtlas);
		/// <summary>
		/// 4-8    in               Pointer within ContainerAtlas-&gt;ConfigData<br/>
		/// </summary>
		public ref ImFontConfigPtr ConfigData => ref Unsafe.AsRef<ImFontConfigPtr>(&Handle->ConfigData);
		/// <summary>
		/// 2      in   ~ 1         Number of ImFontConfig involved in creating this font. Bigger than 1 when merging multiple font sources into one ImFont.<br/>
		/// </summary>
		public ref short ConfigDataCount => ref Unsafe.AsRef<short>(&Handle->ConfigDataCount);
		/// <summary>
		/// 2      out  = FFFD'?'  Character used if a glyph isn't found.<br/>
		/// </summary>
		public ref char FallbackChar => ref Unsafe.AsRef<char>(&Handle->FallbackChar);
		/// <summary>
		/// 2      out  = '...''.' Character used for ellipsis rendering.<br/>
		/// </summary>
		public ref char EllipsisChar => ref Unsafe.AsRef<char>(&Handle->EllipsisChar);
		/// <summary>
		/// 1      out  1 or 3<br/>
		/// </summary>
		public ref short EllipsisCharCount => ref Unsafe.AsRef<short>(&Handle->EllipsisCharCount);
		/// <summary>
		/// 4      out                Width<br/>
		/// </summary>
		public ref float EllipsisWidth => ref Unsafe.AsRef<float>(&Handle->EllipsisWidth);
		/// <summary>
		/// 4      out                Step between characters when EllipsisCount &gt; 0<br/>
		/// </summary>
		public ref float EllipsisCharStep => ref Unsafe.AsRef<float>(&Handle->EllipsisCharStep);
		/// <summary>
		/// 1      out<br/>
		/// </summary>
		public ref bool DirtyLookupTables => ref Unsafe.AsRef<bool>(&Handle->DirtyLookupTables);
		/// <summary>
		/// 4      in   = 1.f       Base font scale, multiplied by the per-window font scale which you can adjust with SetWindowFontScale()<br/>
		/// </summary>
		public ref float Scale => ref Unsafe.AsRef<float>(&Handle->Scale);
		/// <summary>
		/// 4+4    out              Ascent: distance from top to bottom of e.g. 'A' [0..FontSize]<br/>
		/// </summary>
		public ref float Ascent => ref Unsafe.AsRef<float>(&Handle->Ascent);
		/// <summary>
		/// 4+4    out              Ascent: distance from top to bottom of e.g. 'A' [0..FontSize]<br/>
		/// </summary>
		public ref float Descent => ref Unsafe.AsRef<float>(&Handle->Descent);
		/// <summary>
		/// 4      out              Total surface in pixels to get an idea of the font rasterizationtexture cost (not exact, we approximate the cost of padding between glyphs)<br/>
		/// </summary>
		public ref int MetricsTotalSurface => ref Unsafe.AsRef<int>(&Handle->MetricsTotalSurface);
		/// <summary>
		/// 2 bytes if ImWchar=ImWchar16, 34 bytes if ImWchar==ImWchar32. Store 1-bit for each block of 4K codepoints that has one active glyph. This is mainly used to facilitate iterations across all used codepoints.<br/>
		/// </summary>
		public unsafe Span<byte> Used4kPagesMap
		
		{
			get
			{
				return new Span<byte>(&Handle->Used4kPagesMap_0, 2);
			}
		}

		public unsafe void AddGlyph(ImFontConfig* srcCfg, char c, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advanceX)
		{
			ImGui.AddGlyphNative(Handle, srcCfg, c, x0, y0, x1, y1, u0, v0, u1, v1, advanceX);
		}

		public unsafe void AddGlyph(ref ImFontConfig srcCfg, char c, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advanceX)
		{
			fixed (ImFontConfig* psrcCfg = &srcCfg)
			{
				ImGui.AddGlyphNative(Handle, (ImFontConfig*)psrcCfg, c, x0, y0, x1, y1, u0, v0, u1, v1, advanceX);
			}
		}

		/// <summary>		/// Makes 'dst' characterglyph points to 'src' characterglyph. Currently needs to be called AFTER fonts have been built.		/// </summary>		public unsafe void AddRemapChar(char dst, char src, bool overwriteDst)
		{
			ImGui.AddRemapCharNative(Handle, dst, src, overwriteDst ? (byte)1 : (byte)0);
		}

		/// <summary>		/// Makes 'dst' characterglyph points to 'src' characterglyph. Currently needs to be called AFTER fonts have been built.		/// </summary>		public unsafe void AddRemapChar(char dst, char src)
		{
			ImGui.AddRemapCharNative(Handle, dst, src, (byte)(1));
		}

		public unsafe void BuildLookupTable()
		{
			ImGui.BuildLookupTableNative(Handle);
		}

		public unsafe byte* CalcWordWrapPositionA(float scale, byte* text, byte* textEnd, float wrapWidth)
		{
			byte* ret = ImGui.CalcWordWrapPositionANative(Handle, scale, text, textEnd, wrapWidth);
			return ret;
		}

		public unsafe string CalcWordWrapPositionAS(float scale, byte* text, byte* textEnd, float wrapWidth)
		{
			string ret = Utils.DecodeStringUTF8(ImGui.CalcWordWrapPositionANative(Handle, scale, text, textEnd, wrapWidth));
			return ret;
		}

		public unsafe byte* CalcWordWrapPositionA(float scale, ref byte text, byte* textEnd, float wrapWidth)
		{
			fixed (byte* ptext = &text)
			{
				byte* ret = ImGui.CalcWordWrapPositionANative(Handle, scale, (byte*)ptext, textEnd, wrapWidth);
				return ret;
			}
		}

		public unsafe string CalcWordWrapPositionAS(float scale, ref byte text, byte* textEnd, float wrapWidth)
		{
			fixed (byte* ptext = &text)
			{
				string ret = Utils.DecodeStringUTF8(ImGui.CalcWordWrapPositionANative(Handle, scale, (byte*)ptext, textEnd, wrapWidth));
				return ret;
			}
		}

		public unsafe byte* CalcWordWrapPositionA(float scale, string text, byte* textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImGui.CalcWordWrapPositionANative(Handle, scale, pStr0, textEnd, wrapWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public unsafe string CalcWordWrapPositionAS(float scale, string text, byte* textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImGui.CalcWordWrapPositionANative(Handle, scale, pStr0, textEnd, wrapWidth));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public unsafe byte* CalcWordWrapPositionA(float scale, byte* text, ref byte textEnd, float wrapWidth)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				byte* ret = ImGui.CalcWordWrapPositionANative(Handle, scale, text, (byte*)ptextEnd, wrapWidth);
				return ret;
			}
		}

		public unsafe string CalcWordWrapPositionAS(float scale, byte* text, ref byte textEnd, float wrapWidth)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				string ret = Utils.DecodeStringUTF8(ImGui.CalcWordWrapPositionANative(Handle, scale, text, (byte*)ptextEnd, wrapWidth));
				return ret;
			}
		}

		public unsafe byte* CalcWordWrapPositionA(float scale, byte* text, string textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImGui.CalcWordWrapPositionANative(Handle, scale, text, pStr0, wrapWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public unsafe string CalcWordWrapPositionAS(float scale, byte* text, string textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImGui.CalcWordWrapPositionANative(Handle, scale, text, pStr0, wrapWidth));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public unsafe byte* CalcWordWrapPositionA(float scale, ref byte text, ref byte textEnd, float wrapWidth)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					byte* ret = ImGui.CalcWordWrapPositionANative(Handle, scale, (byte*)ptext, (byte*)ptextEnd, wrapWidth);
					return ret;
				}
			}
		}

		public unsafe string CalcWordWrapPositionAS(float scale, ref byte text, ref byte textEnd, float wrapWidth)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGui.CalcWordWrapPositionANative(Handle, scale, (byte*)ptext, (byte*)ptextEnd, wrapWidth));
					return ret;
				}
			}
		}

		public unsafe byte* CalcWordWrapPositionA(float scale, string text, string textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = ImGui.CalcWordWrapPositionANative(Handle, scale, pStr0, pStr1, wrapWidth);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public unsafe string CalcWordWrapPositionAS(float scale, string text, string textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImGui.CalcWordWrapPositionANative(Handle, scale, pStr0, pStr1, wrapWidth));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public unsafe void ClearOutputData()
		{
			ImGui.ClearOutputDataNative(Handle);
		}

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

		public unsafe ImFontGlyph* FindGlyph(char c)
		{
			ImFontGlyph* ret = ImGui.FindGlyphNative(Handle, c);
			return ret;
		}

		public unsafe ImFontGlyph* FindGlyphNoFallback(char c)
		{
			ImFontGlyph* ret = ImGui.FindGlyphNoFallbackNative(Handle, c);
			return ret;
		}

		public unsafe float GetCharAdvance(char c)
		{
			float ret = ImGui.GetCharAdvanceNative(Handle, c);
			return ret;
		}

		public unsafe byte* GetDebugName()
		{
			byte* ret = ImGui.GetDebugNameNative(Handle);
			return ret;
		}

		public unsafe string GetDebugNameS()
		{
			string ret = Utils.DecodeStringUTF8(ImGui.GetDebugNameNative(Handle));
			return ret;
		}

		public unsafe void GrowIndex(int newSize)
		{
			ImGui.GrowIndexNative(Handle, newSize);
		}

		public unsafe bool IsGlyphRangeUnused(uint cBegin, uint cLast)
		{
			byte ret = ImGui.IsGlyphRangeUnusedNative(Handle, cBegin, cLast);
			return ret != 0;
		}

		public unsafe bool IsLoaded()
		{
			byte ret = ImGui.IsLoadedNative(Handle);
			return ret != 0;
		}

		public unsafe void RenderChar(ImDrawListPtr drawList, float size, Vector2 pos, uint col, char c)
		{
			ImGui.RenderCharNative(Handle, drawList, size, pos, col, c);
		}

		public unsafe void RenderChar(ref ImDrawList drawList, float size, Vector2 pos, uint col, char c)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				ImGui.RenderCharNative(Handle, (ImDrawList*)pdrawList, size, pos, col, c);
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd, float wrapWidth, bool cpuFineClip)
		{
			ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, textBegin, textEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd, float wrapWidth)
		{
			ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, textBegin, textEnd, wrapWidth, (byte)(0));
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd)
		{
			ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, textBegin, textEnd, (float)(0.0f), (byte)(0));
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd, bool cpuFineClip)
		{
			ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, textBegin, textEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, textEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, textEnd, wrapWidth, (byte)(0));
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, textEnd, (float)(0.0f), (byte)(0));
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd, bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, textEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, wrapWidth, (byte)(0));
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, (float)(0.0f), (byte)(0));
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd, bool cpuFineClip)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd, float wrapWidth, bool cpuFineClip)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, pStr0, textEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, pStr0, textEnd, wrapWidth, (byte)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, pStr0, textEnd, (float)(0.0f), (byte)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd, bool cpuFineClip)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, pStr0, textEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, wrapWidth, (byte)(0));
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, (float)(0.0f), (byte)(0));
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, byte* textEnd, bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, textEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, textEnd, wrapWidth, (byte)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, textEnd, (float)(0.0f), (byte)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, byte* textEnd, bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, textEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, wrapWidth, (byte)(0));
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, (float)(0.0f), (byte)(0));
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd, bool cpuFineClip)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd, float wrapWidth, bool cpuFineClip)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, textBegin, pStr0, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, textBegin, pStr0, wrapWidth, (byte)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, textBegin, pStr0, (float)(0.0f), (byte)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd, bool cpuFineClip)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, textBegin, pStr0, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, wrapWidth, (byte)(0));
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, (float)(0.0f), (byte)(0));
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, ref byte textEnd, bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, pStr0, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, pStr0, wrapWidth, (byte)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, pStr0, (float)(0.0f), (byte)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, string textEnd, bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, pStr0, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (byte)(0));
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (byte)(0));
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd, bool cpuFineClip)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
				}
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd, float wrapWidth, bool cpuFineClip)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, pStr0, pStr1, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, pStr0, pStr1, wrapWidth, (byte)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, pStr0, pStr1, (float)(0.0f), (byte)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void RenderText(ImDrawListPtr drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd, bool cpuFineClip)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ImGui.RenderTextNative(Handle, drawList, size, pos, col, clipRect, pStr0, pStr1, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
					}
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (byte)(0));
					}
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (byte)(0));
					}
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, ref byte textBegin, ref byte textEnd, bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
					}
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd, float wrapWidth, bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, pStr1, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, pStr1, wrapWidth, (byte)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, pStr1, (float)(0.0f), (byte)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText(ref ImDrawList drawList, float size, Vector2 pos, uint col, Vector4 clipRect, string textBegin, string textEnd, bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.RenderTextNative(Handle, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, pStr1, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void SetGlyphVisible(char c, bool visible)
		{
			ImGui.SetGlyphVisibleNative(Handle, c, visible ? (byte)1 : (byte)0);
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImFontPtrPtr : IEquatable<ImFontPtrPtr>
	{
		public ImFontPtrPtr(ImFont** handle) { Handle = handle; }

		public ImFont** Handle;

		public bool IsNull => Handle == null;

		public static ImFontPtrPtr Null => new ImFontPtrPtr(null);

		public static implicit operator ImFontPtrPtr(ImFont** handle) => new ImFontPtrPtr(handle);

		public static implicit operator ImFont**(ImFontPtrPtr handle) => handle.Handle;

		public static bool operator ==(ImFontPtrPtr left, ImFontPtrPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImFontPtrPtr left, ImFontPtrPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImFontPtrPtr left, ImFont** right) => left.Handle == right;

		public static bool operator !=(ImFontPtrPtr left, ImFont** right) => left.Handle != right;

		public bool Equals(ImFontPtrPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImFontPtrPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImFontPtrPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ImFontPtr this[int index]
		{
			get => Handle[index]; set => Handle[index] = value;
		}
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorFloat
	{
		public int Size;
		public int Capacity;
		public unsafe float* Data;


	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImWchar
	{
		public int Size;
		public int Capacity;
		public unsafe char* Data;


	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImVectorImWcharPtr : IEquatable<ImVectorImWcharPtr>
	{
		public ImVectorImWcharPtr(ImVectorImWchar* handle) { Handle = handle; }

		public ImVectorImWchar* Handle;

		public bool IsNull => Handle == null;

		public static ImVectorImWcharPtr Null => new ImVectorImWcharPtr(null);

		public static implicit operator ImVectorImWcharPtr(ImVectorImWchar* handle) => new ImVectorImWcharPtr(handle);

		public static implicit operator ImVectorImWchar*(ImVectorImWcharPtr handle) => handle.Handle;

		public static bool operator ==(ImVectorImWcharPtr left, ImVectorImWcharPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImVectorImWcharPtr left, ImVectorImWcharPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImVectorImWcharPtr left, ImVectorImWchar* right) => left.Handle == right;

		public static bool operator !=(ImVectorImWcharPtr left, ImVectorImWchar* right) => left.Handle != right;

		public bool Equals(ImVectorImWcharPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImVectorImWcharPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImVectorImWcharPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref int Size => ref Unsafe.AsRef<int>(&Handle->Size);
		public ref int Capacity => ref Unsafe.AsRef<int>(&Handle->Capacity);
		public char* Data { get => Handle->Data; set => Handle->Data = value; }
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImFontGlyph
	{
		public int Size;
		public int Capacity;
		public unsafe ImFontGlyph* Data;


	}

	/// <summary>
	/// Hold rendering data for one glyph.<br/>
	/// (Note: some language parsers may fail to convert the 31+1 bitfield members, in this case maybe drop store a single u32 or we can rework this)<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImFontGlyph
	{
		/// <summary>
		/// Flag to indicate glyph is colored and should generally ignore tinting (make it usable with no shift on little-endian as this is used in loops)<br/>
		/// </summary>
		public uint Colored;

		/// <summary>
		/// Flag to indicate glyph has no visible pixels (e.g. space). Allow early out when rendering.<br/>
		/// </summary>
		public uint Visible;

		/// <summary>
		/// 0x0000..0x10FFFF<br/>
		/// </summary>
		public uint Codepoint;

		/// <summary>
		/// Distance to next character (= data from font + ImFontConfig::GlyphExtraSpacing.x baked in)<br/>
		/// </summary>
		public float AdvanceX;

		/// <summary>
		/// Glyph corners<br/>
		/// </summary>
		public float X0;

		/// <summary>
		/// Glyph corners<br/>
		/// </summary>
		public float Y0;

		/// <summary>
		/// Glyph corners<br/>
		/// </summary>
		public float X1;

		/// <summary>
		/// Glyph corners<br/>
		/// </summary>
		public float Y1;

		/// <summary>
		/// Texture coordinates<br/>
		/// </summary>
		public float U0;

		/// <summary>
		/// Texture coordinates<br/>
		/// </summary>
		public float V0;

		/// <summary>
		/// Texture coordinates<br/>
		/// </summary>
		public float U1;

		/// <summary>
		/// Texture coordinates<br/>
		/// </summary>
		public float V1;



	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImFontGlyphPtr : IEquatable<ImFontGlyphPtr>
	{
		public ImFontGlyphPtr(ImFontGlyph* handle) { Handle = handle; }

		public ImFontGlyph* Handle;

		public bool IsNull => Handle == null;

		public static ImFontGlyphPtr Null => new ImFontGlyphPtr(null);

		public static implicit operator ImFontGlyphPtr(ImFontGlyph* handle) => new ImFontGlyphPtr(handle);

		public static implicit operator ImFontGlyph*(ImFontGlyphPtr handle) => handle.Handle;

		public static bool operator ==(ImFontGlyphPtr left, ImFontGlyphPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImFontGlyphPtr left, ImFontGlyphPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImFontGlyphPtr left, ImFontGlyph* right) => left.Handle == right;

		public static bool operator !=(ImFontGlyphPtr left, ImFontGlyph* right) => left.Handle != right;

		public bool Equals(ImFontGlyphPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImFontGlyphPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImFontGlyphPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		/// <summary>
		/// Flag to indicate glyph is colored and should generally ignore tinting (make it usable with no shift on little-endian as this is used in loops)<br/>
		/// </summary>
		public ref uint Colored => ref Unsafe.AsRef<uint>(&Handle->Colored);
		/// <summary>
		/// Flag to indicate glyph has no visible pixels (e.g. space). Allow early out when rendering.<br/>
		/// </summary>
		public ref uint Visible => ref Unsafe.AsRef<uint>(&Handle->Visible);
		/// <summary>
		/// 0x0000..0x10FFFF<br/>
		/// </summary>
		public ref uint Codepoint => ref Unsafe.AsRef<uint>(&Handle->Codepoint);
		/// <summary>
		/// Distance to next character (= data from font + ImFontConfig::GlyphExtraSpacing.x baked in)<br/>
		/// </summary>
		public ref float AdvanceX => ref Unsafe.AsRef<float>(&Handle->AdvanceX);
		/// <summary>
		/// Glyph corners<br/>
		/// </summary>
		public ref float X0 => ref Unsafe.AsRef<float>(&Handle->X0);
		/// <summary>
		/// Glyph corners<br/>
		/// </summary>
		public ref float Y0 => ref Unsafe.AsRef<float>(&Handle->Y0);
		/// <summary>
		/// Glyph corners<br/>
		/// </summary>
		public ref float X1 => ref Unsafe.AsRef<float>(&Handle->X1);
		/// <summary>
		/// Glyph corners<br/>
		/// </summary>
		public ref float Y1 => ref Unsafe.AsRef<float>(&Handle->Y1);
		/// <summary>
		/// Texture coordinates<br/>
		/// </summary>
		public ref float U0 => ref Unsafe.AsRef<float>(&Handle->U0);
		/// <summary>
		/// Texture coordinates<br/>
		/// </summary>
		public ref float V0 => ref Unsafe.AsRef<float>(&Handle->V0);
		/// <summary>
		/// Texture coordinates<br/>
		/// </summary>
		public ref float U1 => ref Unsafe.AsRef<float>(&Handle->U1);
		/// <summary>
		/// Texture coordinates<br/>
		/// </summary>
		public ref float V1 => ref Unsafe.AsRef<float>(&Handle->V1);
	}

	/// <summary>
	/// Load and rasterize multiple TTFOTF fonts into a same texture. The font atlas will build a single texture holding:<br/>
	/// - One or more fonts.<br/>
	/// - Custom graphics data needed to render the shapes needed by Dear ImGui.<br/>
	/// - Mouse cursor shapes for software cursor rendering (unless setting 'Flags |= ImFontAtlasFlags_NoMouseCursors' in the font atlas).<br/>
	/// It is the user-code responsibility to setupbuild the atlas, then upload the pixel data into a texture accessible by your graphics api.<br/>
	/// - Optionally, call any of the AddFont*** functions. If you don't call any, the default font embedded in the code will be loaded for you.<br/>
	/// - Call GetTexDataAsAlpha8() or GetTexDataAsRGBA32() to build and retrieve pixels data.<br/>
	/// - Upload the pixels data into a texture within your graphics system (see imgui_impl_xxxx.cpp examples)<br/>
	/// - Call SetTexID(my_tex_id); and pass the pointeridentifier to your texture in a format natural to your graphics API.<br/>
	/// This value will be passed back to you during rendering to identify the texture. Read FAQ entry about ImTextureID for more details.<br/>
	/// Common pitfalls:<br/>
	/// - If you pass a 'glyph_ranges' array to AddFont*** functions, you need to make sure that your array persist up until the<br/>
	/// atlas is build (when calling GetTexData*** or Build()). We only copy the pointer, not the data.<br/>
	/// - Important: By default, AddFontFromMemoryTTF() takes ownership of the data. Even though we are not writing to it, we will free the pointer on destruction.<br/>
	/// You can set font_cfg-&gt;FontDataOwnedByAtlas=false to keep ownership of your data and it won't be freed,<br/>
	/// - Even though many functions are suffixed with "TTF", OTF data is supported just as well.<br/>
	/// - This is an old API and it is currently awkward for those and various other reasons! We will address them in the future!<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImFontAtlas
	{
		/// <summary>
		/// Build flags (see ImFontAtlasFlags_)<br/>
		/// </summary>
		public ImFontAtlasFlags Flags;

		/// <summary>
		/// User data to refer to the texture once it has been uploaded to user's graphic systems. It is passed back to you during rendering via the ImDrawCmd structure.<br/>
		/// </summary>
		public ImTextureID TexID;

		/// <summary>
		/// Texture width desired by user before Build(). Must be a power-of-two. If have many glyphs your graphics API have texture size restrictions you may want to increase texture width to decrease height.<br/>
		/// </summary>
		public int TexDesiredWidth;

		/// <summary>
		/// Padding between glyphs within texture in pixels. Defaults to 1. If your rendering method doesn't rely on bilinear filtering you may set this to 0 (will also need to set AntiAliasedLinesUseTex = false).<br/>
		/// </summary>
		public int TexGlyphPadding;

		/// <summary>
		/// Marked as Locked by ImGui::NewFrame() so attempt to modify the atlas will assert.<br/>
		/// </summary>
		public byte Locked;

		/// <summary>
		/// Store your own atlas related user-data (if e.g. you have multiple font atlas).<br/>
		/// </summary>
		public unsafe void* UserData;

		/// <summary>
		/// [Internal]<br/>
		/// NB: Access texture data via GetTexData*() calls! Which will setup a default font for you. Set when texture was built matching current font input<br/>
		/// </summary>
		public byte TexReady;

		/// <summary>
		/// Tell whether our texture data is known to use colors (rather than just alpha channel), in order to help backend select a format.<br/>
		/// </summary>
		public byte TexPixelsUseColors;

		/// <summary>
		/// 1 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight<br/>
		/// </summary>
		public unsafe byte* TexPixelsAlpha8;

		/// <summary>
		/// 4 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight * 4<br/>
		/// </summary>
		public unsafe uint* TexPixelsRGBA32;

		/// <summary>
		/// Texture width calculated during Build().<br/>
		/// </summary>
		public int TexWidth;

		/// <summary>
		/// Texture height calculated during Build().<br/>
		/// </summary>
		public int TexHeight;

		/// <summary>
		/// = (1.0fTexWidth, 1.0fTexHeight)<br/>
		/// </summary>
		public Vector2 TexUvScale;

		/// <summary>
		/// Texture coordinates to a white pixel<br/>
		/// </summary>
		public Vector2 TexUvWhitePixel;

		/// <summary>
		/// Hold all the fonts returned by AddFont*. Fonts[0] is the default font upon calling ImGui::NewFrame(), use ImGui::PushFont()PopFont() to change the current font.<br/>
		/// </summary>
		public ImVectorImFontPtr Fonts;

		/// <summary>
		/// Rectangles for packing custom texture data into the atlas.<br/>
		/// </summary>
		public ImVectorImFontAtlasCustomRect CustomRects;

		/// <summary>
		/// Configuration data<br/>
		/// </summary>
		public ImVectorImFontConfig ConfigData;

		/// <summary>
		/// UVs for baked anti-aliased lines<br/>
		/// </summary>
		public Vector4 TexUvLines_0;
		public Vector4 TexUvLines_1;
		public Vector4 TexUvLines_2;
		public Vector4 TexUvLines_3;
		public Vector4 TexUvLines_4;
		public Vector4 TexUvLines_5;
		public Vector4 TexUvLines_6;
		public Vector4 TexUvLines_7;
		public Vector4 TexUvLines_8;
		public Vector4 TexUvLines_9;
		public Vector4 TexUvLines_10;
		public Vector4 TexUvLines_11;
		public Vector4 TexUvLines_12;
		public Vector4 TexUvLines_13;
		public Vector4 TexUvLines_14;
		public Vector4 TexUvLines_15;
		public Vector4 TexUvLines_16;
		public Vector4 TexUvLines_17;
		public Vector4 TexUvLines_18;
		public Vector4 TexUvLines_19;
		public Vector4 TexUvLines_20;
		public Vector4 TexUvLines_21;
		public Vector4 TexUvLines_22;
		public Vector4 TexUvLines_23;
		public Vector4 TexUvLines_24;
		public Vector4 TexUvLines_25;
		public Vector4 TexUvLines_26;
		public Vector4 TexUvLines_27;
		public Vector4 TexUvLines_28;
		public Vector4 TexUvLines_29;
		public Vector4 TexUvLines_30;
		public Vector4 TexUvLines_31;
		public Vector4 TexUvLines_32;
		public Vector4 TexUvLines_33;
		public Vector4 TexUvLines_34;
		public Vector4 TexUvLines_35;
		public Vector4 TexUvLines_36;
		public Vector4 TexUvLines_37;
		public Vector4 TexUvLines_38;
		public Vector4 TexUvLines_39;
		public Vector4 TexUvLines_40;
		public Vector4 TexUvLines_41;
		public Vector4 TexUvLines_42;
		public Vector4 TexUvLines_43;
		public Vector4 TexUvLines_44;
		public Vector4 TexUvLines_45;
		public Vector4 TexUvLines_46;
		public Vector4 TexUvLines_47;
		public Vector4 TexUvLines_48;
		public Vector4 TexUvLines_49;
		public Vector4 TexUvLines_50;
		public Vector4 TexUvLines_51;
		public Vector4 TexUvLines_52;
		public Vector4 TexUvLines_53;
		public Vector4 TexUvLines_54;
		public Vector4 TexUvLines_55;
		public Vector4 TexUvLines_56;
		public Vector4 TexUvLines_57;
		public Vector4 TexUvLines_58;
		public Vector4 TexUvLines_59;
		public Vector4 TexUvLines_60;
		public Vector4 TexUvLines_61;
		public Vector4 TexUvLines_62;
		public Vector4 TexUvLines_63;

		/// <summary>
		/// [Internal] Font builder Opaque interface to a font builder (default to stb_truetype, can be changed to use FreeType by defining IMGUI_ENABLE_FREETYPE).<br/>
		/// </summary>
		public unsafe ImFontBuilderIO* FontBuilderIO;

		/// <summary>
		/// Shared flags (for all fonts) for custom font builder. THIS IS BUILD IMPLEMENTATION DEPENDENT. Per-font override is also available in ImFontConfig.<br/>
		/// </summary>
		public uint FontBuilderFlags;

		/// <summary>
		/// [Internal] Packing data Custom texture rectangle ID for white pixel and mouse cursors<br/>
		/// </summary>
		public int PackIdMouseCursors;

		/// <summary>
		/// Custom texture rectangle ID for baked anti-aliased lines<br/>
		/// </summary>
		public int PackIdLines;




		public unsafe Span<Vector4> TexUvLines
		
		{
			get
			{
				fixed (Vector4* p = &this.TexUvLines_0)
				{
					return new Span<Vector4>(p, 64);
				}
			}
		}

		public unsafe int AddCustomRectFontGlyph(ImFontPtr font, char id, int width, int height, float advanceX, Vector2 offset)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				int ret = ImGui.AddCustomRectFontGlyphNative(@this, font, id, width, height, advanceX, offset);
				return ret;
			}
		}

		public unsafe int AddCustomRectFontGlyph(ImFontPtr font, char id, int width, int height, float advanceX)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				int ret = ImGui.AddCustomRectFontGlyphNative(@this, font, id, width, height, advanceX, (Vector2)(new Vector2(0,0)));
				return ret;
			}
		}

		public unsafe int AddCustomRectFontGlyph(ref ImFont font, char id, int width, int height, float advanceX, Vector2 offset)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					int ret = ImGui.AddCustomRectFontGlyphNative(@this, (ImFont*)pfont, id, width, height, advanceX, offset);
					return ret;
				}
			}
		}

		public unsafe int AddCustomRectFontGlyph(ref ImFont font, char id, int width, int height, float advanceX)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					int ret = ImGui.AddCustomRectFontGlyphNative(@this, (ImFont*)pfont, id, width, height, advanceX, (Vector2)(new Vector2(0,0)));
					return ret;
				}
			}
		}

		public unsafe int AddCustomRectRegular(int width, int height)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				int ret = ImGui.AddCustomRectRegularNative(@this, width, height);
				return ret;
			}
		}

		public unsafe ImFontPtr AddFont(ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFontPtr ret = ImGui.AddFontNative(@this, fontCfg);
				return ret;
			}
		}

		public unsafe ImFontPtr AddFont(ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = ImGui.AddFontNative(@this, (ImFontConfig*)pfontCfg);
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontDefault(ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFontPtr ret = ImGui.AddFontDefaultNative(@this, fontCfg);
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontDefault()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFontPtr ret = ImGui.AddFontDefaultNative(@this, (ImFontConfig*)(default));
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontDefault(ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = ImGui.AddFontDefaultNative(@this, (ImFontConfig*)pfontCfg);
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(byte* filename, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFontPtr ret = ImGui.AddFontFromFileTTFNative(@this, filename, sizePixels, fontCfg, glyphRanges);
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(byte* filename, float sizePixels, ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFontPtr ret = ImGui.AddFontFromFileTTFNative(@this, filename, sizePixels, fontCfg, (char*)(default));
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(byte* filename, float sizePixels)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFontPtr ret = ImGui.AddFontFromFileTTFNative(@this, filename, sizePixels, (ImFontConfig*)(default), (char*)(default));
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(byte* filename, float sizePixels, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFontPtr ret = ImGui.AddFontFromFileTTFNative(@this, filename, sizePixels, (ImFontConfig*)(default), glyphRanges);
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(ref byte filename, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pfilename = &filename)
				{
					ImFontPtr ret = ImGui.AddFontFromFileTTFNative(@this, (byte*)pfilename, sizePixels, fontCfg, glyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(ref byte filename, float sizePixels, ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pfilename = &filename)
				{
					ImFontPtr ret = ImGui.AddFontFromFileTTFNative(@this, (byte*)pfilename, sizePixels, fontCfg, (char*)(default));
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(ref byte filename, float sizePixels)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pfilename = &filename)
				{
					ImFontPtr ret = ImGui.AddFontFromFileTTFNative(@this, (byte*)pfilename, sizePixels, (ImFontConfig*)(default), (char*)(default));
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(ref byte filename, float sizePixels, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pfilename = &filename)
				{
					ImFontPtr ret = ImGui.AddFontFromFileTTFNative(@this, (byte*)pfilename, sizePixels, (ImFontConfig*)(default), glyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(string filename, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFontPtr ret = ImGui.AddFontFromFileTTFNative(@this, pStr0, sizePixels, fontCfg, glyphRanges);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(string filename, float sizePixels, ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFontPtr ret = ImGui.AddFontFromFileTTFNative(@this, pStr0, sizePixels, fontCfg, (char*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(string filename, float sizePixels)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFontPtr ret = ImGui.AddFontFromFileTTFNative(@this, pStr0, sizePixels, (ImFontConfig*)(default), (char*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(string filename, float sizePixels, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFontPtr ret = ImGui.AddFontFromFileTTFNative(@this, pStr0, sizePixels, (ImFontConfig*)(default), glyphRanges);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(byte* filename, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = ImGui.AddFontFromFileTTFNative(@this, filename, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(byte* filename, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = ImGui.AddFontFromFileTTFNative(@this, filename, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(ref byte filename, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pfilename = &filename)
				{
					fixed (ImFontConfig* pfontCfg = &fontCfg)
					{
						ImFontPtr ret = ImGui.AddFontFromFileTTFNative(@this, (byte*)pfilename, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
						return ret;
					}
				}
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(ref byte filename, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pfilename = &filename)
				{
					fixed (ImFontConfig* pfontCfg = &fontCfg)
					{
						ImFontPtr ret = ImGui.AddFontFromFileTTFNative(@this, (byte*)pfilename, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
						return ret;
					}
				}
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(string filename, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = ImGui.AddFontFromFileTTFNative(@this, pStr0, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(string filename, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = ImGui.AddFontFromFileTTFNative(@this, pStr0, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(byte* filename, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = ImGui.AddFontFromFileTTFNative(@this, filename, sizePixels, fontCfg, (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(byte* filename, float sizePixels, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = ImGui.AddFontFromFileTTFNative(@this, filename, sizePixels, (ImFontConfig*)(default), (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(ref byte filename, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pfilename = &filename)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFontPtr ret = ImGui.AddFontFromFileTTFNative(@this, (byte*)pfilename, sizePixels, fontCfg, (char*)pglyphRanges);
						return ret;
					}
				}
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(ref byte filename, float sizePixels, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pfilename = &filename)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFontPtr ret = ImGui.AddFontFromFileTTFNative(@this, (byte*)pfilename, sizePixels, (ImFontConfig*)(default), (char*)pglyphRanges);
						return ret;
					}
				}
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(string filename, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = ImGui.AddFontFromFileTTFNative(@this, pStr0, sizePixels, fontCfg, (char*)pglyphRanges);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(string filename, float sizePixels, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = ImGui.AddFontFromFileTTFNative(@this, pStr0, sizePixels, (ImFontConfig*)(default), (char*)pglyphRanges);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(byte* filename, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFontPtr ret = ImGui.AddFontFromFileTTFNative(@this, filename, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
						return ret;
					}
				}
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(ref byte filename, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pfilename = &filename)
				{
					fixed (ImFontConfig* pfontCfg = &fontCfg)
					{
						fixed (char* pglyphRanges = &glyphRanges)
						{
							ImFontPtr ret = ImGui.AddFontFromFileTTFNative(@this, (byte*)pfilename, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
							return ret;
						}
					}
				}
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(string filename, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFontPtr ret = ImGui.AddFontFromFileTTFNative(@this, pStr0, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}

		/// <summary>		/// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(byte* compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, compressedFontDataBase85, sizePixels, fontCfg, glyphRanges);
				return ret;
			}
		}

		/// <summary>		/// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(byte* compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, compressedFontDataBase85, sizePixels, fontCfg, (char*)(default));
				return ret;
			}
		}

		/// <summary>		/// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(byte* compressedFontDataBase85, float sizePixels)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, compressedFontDataBase85, sizePixels, (ImFontConfig*)(default), (char*)(default));
				return ret;
			}
		}

		/// <summary>		/// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(byte* compressedFontDataBase85, float sizePixels, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, compressedFontDataBase85, sizePixels, (ImFontConfig*)(default), glyphRanges);
				return ret;
			}
		}

		/// <summary>		/// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref byte compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, (byte*)pcompressedFontDataBase85, sizePixels, fontCfg, glyphRanges);
					return ret;
				}
			}
		}

		/// <summary>		/// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref byte compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, (byte*)pcompressedFontDataBase85, sizePixels, fontCfg, (char*)(default));
					return ret;
				}
			}
		}

		/// <summary>		/// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref byte compressedFontDataBase85, float sizePixels)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, (byte*)pcompressedFontDataBase85, sizePixels, (ImFontConfig*)(default), (char*)(default));
					return ret;
				}
			}
		}

		/// <summary>		/// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref byte compressedFontDataBase85, float sizePixels, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, (byte*)pcompressedFontDataBase85, sizePixels, (ImFontConfig*)(default), glyphRanges);
					return ret;
				}
			}
		}

		/// <summary>		/// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(string compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (compressedFontDataBase85 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, pStr0, sizePixels, fontCfg, glyphRanges);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>		/// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(string compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (compressedFontDataBase85 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, pStr0, sizePixels, fontCfg, (char*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>		/// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(string compressedFontDataBase85, float sizePixels)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (compressedFontDataBase85 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, pStr0, sizePixels, (ImFontConfig*)(default), (char*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>		/// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(string compressedFontDataBase85, float sizePixels, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (compressedFontDataBase85 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, pStr0, sizePixels, (ImFontConfig*)(default), glyphRanges);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>		/// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(byte* compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, compressedFontDataBase85, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
					return ret;
				}
			}
		}

		/// <summary>		/// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(byte* compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, compressedFontDataBase85, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
					return ret;
				}
			}
		}

		/// <summary>		/// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref byte compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
				{
					fixed (ImFontConfig* pfontCfg = &fontCfg)
					{
						ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, (byte*)pcompressedFontDataBase85, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref byte compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
				{
					fixed (ImFontConfig* pfontCfg = &fontCfg)
					{
						ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, (byte*)pcompressedFontDataBase85, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
						return ret;
					}
				}
			}
		}

		/// <summary>		/// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(string compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (compressedFontDataBase85 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, pStr0, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>		/// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(string compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (compressedFontDataBase85 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, pStr0, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>		/// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(byte* compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, compressedFontDataBase85, sizePixels, fontCfg, (char*)pglyphRanges);
					return ret;
				}
			}
		}

		/// <summary>		/// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(byte* compressedFontDataBase85, float sizePixels, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, compressedFontDataBase85, sizePixels, (ImFontConfig*)(default), (char*)pglyphRanges);
					return ret;
				}
			}
		}

		/// <summary>		/// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref byte compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, (byte*)pcompressedFontDataBase85, sizePixels, fontCfg, (char*)pglyphRanges);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref byte compressedFontDataBase85, float sizePixels, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, (byte*)pcompressedFontDataBase85, sizePixels, (ImFontConfig*)(default), (char*)pglyphRanges);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(string compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (compressedFontDataBase85 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, pStr0, sizePixels, fontCfg, (char*)pglyphRanges);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>		/// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(string compressedFontDataBase85, float sizePixels, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (compressedFontDataBase85 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, pStr0, sizePixels, (ImFontConfig*)(default), (char*)pglyphRanges);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>		/// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(byte* compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, compressedFontDataBase85, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref byte compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
				{
					fixed (ImFontConfig* pfontCfg = &fontCfg)
					{
						fixed (char* pglyphRanges = &glyphRanges)
						{
							ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, (byte*)pcompressedFontDataBase85, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(string compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (compressedFontDataBase85 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, pStr0, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}

		/// <summary>		/// 'compressed_font_data' still owned by caller. Compress with binary_to_compressed_c.cpp.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedTTF(void* compressedFontData, int compressedFontSize, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedTTFNative(@this, compressedFontData, compressedFontSize, sizePixels, fontCfg, glyphRanges);
				return ret;
			}
		}

		/// <summary>		/// 'compressed_font_data' still owned by caller. Compress with binary_to_compressed_c.cpp.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedTTF(void* compressedFontData, int compressedFontSize, float sizePixels, ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedTTFNative(@this, compressedFontData, compressedFontSize, sizePixels, fontCfg, (char*)(default));
				return ret;
			}
		}

		/// <summary>		/// 'compressed_font_data' still owned by caller. Compress with binary_to_compressed_c.cpp.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedTTF(void* compressedFontData, int compressedFontSize, float sizePixels)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedTTFNative(@this, compressedFontData, compressedFontSize, sizePixels, (ImFontConfig*)(default), (char*)(default));
				return ret;
			}
		}

		/// <summary>		/// 'compressed_font_data' still owned by caller. Compress with binary_to_compressed_c.cpp.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedTTF(void* compressedFontData, int compressedFontSize, float sizePixels, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedTTFNative(@this, compressedFontData, compressedFontSize, sizePixels, (ImFontConfig*)(default), glyphRanges);
				return ret;
			}
		}

		/// <summary>		/// 'compressed_font_data' still owned by caller. Compress with binary_to_compressed_c.cpp.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedTTF(void* compressedFontData, int compressedFontSize, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryCompressedTTFNative(@this, compressedFontData, compressedFontSize, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
					return ret;
				}
			}
		}

		/// <summary>		/// 'compressed_font_data' still owned by caller. Compress with binary_to_compressed_c.cpp.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedTTF(void* compressedFontData, int compressedFontSize, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryCompressedTTFNative(@this, compressedFontData, compressedFontSize, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
					return ret;
				}
			}
		}

		/// <summary>		/// 'compressed_font_data' still owned by caller. Compress with binary_to_compressed_c.cpp.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedTTF(void* compressedFontData, int compressedFontSize, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryCompressedTTFNative(@this, compressedFontData, compressedFontSize, sizePixels, fontCfg, (char*)pglyphRanges);
					return ret;
				}
			}
		}

		/// <summary>		/// 'compressed_font_data' still owned by caller. Compress with binary_to_compressed_c.cpp.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedTTF(void* compressedFontData, int compressedFontSize, float sizePixels, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryCompressedTTFNative(@this, compressedFontData, compressedFontSize, sizePixels, (ImFontConfig*)(default), (char*)pglyphRanges);
					return ret;
				}
			}
		}

		/// <summary>		/// 'compressed_font_data' still owned by caller. Compress with binary_to_compressed_c.cpp.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedTTF(void* compressedFontData, int compressedFontSize, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFontPtr ret = ImGui.AddFontFromMemoryCompressedTTFNative(@this, compressedFontData, compressedFontSize, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Note: Transfer ownership of 'ttf_data' to ImFontAtlas! Will be deleted after destruction of the atlas. Set font_cfg->FontDataOwnedByAtlas=false to keep ownership of your data and it won't be freed.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryTTF(void* fontData, int fontSize, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryTTFNative(@this, fontData, fontSize, sizePixels, fontCfg, glyphRanges);
				return ret;
			}
		}

		/// <summary>		/// Note: Transfer ownership of 'ttf_data' to ImFontAtlas! Will be deleted after destruction of the atlas. Set font_cfg->FontDataOwnedByAtlas=false to keep ownership of your data and it won't be freed.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryTTF(void* fontData, int fontSize, float sizePixels, ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryTTFNative(@this, fontData, fontSize, sizePixels, fontCfg, (char*)(default));
				return ret;
			}
		}

		/// <summary>		/// Note: Transfer ownership of 'ttf_data' to ImFontAtlas! Will be deleted after destruction of the atlas. Set font_cfg->FontDataOwnedByAtlas=false to keep ownership of your data and it won't be freed.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryTTF(void* fontData, int fontSize, float sizePixels)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryTTFNative(@this, fontData, fontSize, sizePixels, (ImFontConfig*)(default), (char*)(default));
				return ret;
			}
		}

		/// <summary>		/// Note: Transfer ownership of 'ttf_data' to ImFontAtlas! Will be deleted after destruction of the atlas. Set font_cfg->FontDataOwnedByAtlas=false to keep ownership of your data and it won't be freed.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryTTF(void* fontData, int fontSize, float sizePixels, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryTTFNative(@this, fontData, fontSize, sizePixels, (ImFontConfig*)(default), glyphRanges);
				return ret;
			}
		}

		/// <summary>		/// Note: Transfer ownership of 'ttf_data' to ImFontAtlas! Will be deleted after destruction of the atlas. Set font_cfg->FontDataOwnedByAtlas=false to keep ownership of your data and it won't be freed.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryTTF(void* fontData, int fontSize, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryTTFNative(@this, fontData, fontSize, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
					return ret;
				}
			}
		}

		/// <summary>		/// Note: Transfer ownership of 'ttf_data' to ImFontAtlas! Will be deleted after destruction of the atlas. Set font_cfg->FontDataOwnedByAtlas=false to keep ownership of your data and it won't be freed.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryTTF(void* fontData, int fontSize, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryTTFNative(@this, fontData, fontSize, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
					return ret;
				}
			}
		}

		/// <summary>		/// Note: Transfer ownership of 'ttf_data' to ImFontAtlas! Will be deleted after destruction of the atlas. Set font_cfg->FontDataOwnedByAtlas=false to keep ownership of your data and it won't be freed.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryTTF(void* fontData, int fontSize, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryTTFNative(@this, fontData, fontSize, sizePixels, fontCfg, (char*)pglyphRanges);
					return ret;
				}
			}
		}

		/// <summary>		/// Note: Transfer ownership of 'ttf_data' to ImFontAtlas! Will be deleted after destruction of the atlas. Set font_cfg->FontDataOwnedByAtlas=false to keep ownership of your data and it won't be freed.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryTTF(void* fontData, int fontSize, float sizePixels, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryTTFNative(@this, fontData, fontSize, sizePixels, (ImFontConfig*)(default), (char*)pglyphRanges);
					return ret;
				}
			}
		}

		/// <summary>		/// Note: Transfer ownership of 'ttf_data' to ImFontAtlas! Will be deleted after destruction of the atlas. Set font_cfg->FontDataOwnedByAtlas=false to keep ownership of your data and it won't be freed.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryTTF(void* fontData, int fontSize, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFontPtr ret = ImGui.AddFontFromMemoryTTFNative(@this, fontData, fontSize, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Build pixels data. This is called automatically for you by the GetTexData*** functions.		/// </summary>		public unsafe bool Build()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte ret = ImGui.BuildNative(@this);
				return ret != 0;
			}
		}

		public unsafe void CalcCustomRectUV(ImFontAtlasCustomRect* rect, Vector2* outUvMin, Vector2* outUvMax)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImGui.CalcCustomRectUVNative(@this, rect, outUvMin, outUvMax);
			}
		}

		public unsafe void CalcCustomRectUV(ref ImFontAtlasCustomRect rect, Vector2* outUvMin, Vector2* outUvMax)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontAtlasCustomRect* prect = &rect)
				{
					ImGui.CalcCustomRectUVNative(@this, (ImFontAtlasCustomRect*)prect, outUvMin, outUvMax);
				}
			}
		}

		public unsafe void CalcCustomRectUV(ImFontAtlasCustomRect* rect, ref Vector2 outUvMin, Vector2* outUvMax)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutUvMin = &outUvMin)
				{
					ImGui.CalcCustomRectUVNative(@this, rect, (Vector2*)poutUvMin, outUvMax);
				}
			}
		}

		public unsafe void CalcCustomRectUV(ref ImFontAtlasCustomRect rect, ref Vector2 outUvMin, Vector2* outUvMax)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontAtlasCustomRect* prect = &rect)
				{
					fixed (Vector2* poutUvMin = &outUvMin)
					{
						ImGui.CalcCustomRectUVNative(@this, (ImFontAtlasCustomRect*)prect, (Vector2*)poutUvMin, outUvMax);
					}
				}
			}
		}

		public unsafe void CalcCustomRectUV(ImFontAtlasCustomRect* rect, Vector2* outUvMin, ref Vector2 outUvMax)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutUvMax = &outUvMax)
				{
					ImGui.CalcCustomRectUVNative(@this, rect, outUvMin, (Vector2*)poutUvMax);
				}
			}
		}

		public unsafe void CalcCustomRectUV(ref ImFontAtlasCustomRect rect, Vector2* outUvMin, ref Vector2 outUvMax)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontAtlasCustomRect* prect = &rect)
				{
					fixed (Vector2* poutUvMax = &outUvMax)
					{
						ImGui.CalcCustomRectUVNative(@this, (ImFontAtlasCustomRect*)prect, outUvMin, (Vector2*)poutUvMax);
					}
				}
			}
		}

		public unsafe void CalcCustomRectUV(ImFontAtlasCustomRect* rect, ref Vector2 outUvMin, ref Vector2 outUvMax)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutUvMin = &outUvMin)
				{
					fixed (Vector2* poutUvMax = &outUvMax)
					{
						ImGui.CalcCustomRectUVNative(@this, rect, (Vector2*)poutUvMin, (Vector2*)poutUvMax);
					}
				}
			}
		}

		public unsafe void CalcCustomRectUV(ref ImFontAtlasCustomRect rect, ref Vector2 outUvMin, ref Vector2 outUvMax)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontAtlasCustomRect* prect = &rect)
				{
					fixed (Vector2* poutUvMin = &outUvMin)
					{
						fixed (Vector2* poutUvMax = &outUvMax)
						{
							ImGui.CalcCustomRectUVNative(@this, (ImFontAtlasCustomRect*)prect, (Vector2*)poutUvMin, (Vector2*)poutUvMax);
						}
					}
				}
			}
		}

		/// <summary>		/// Clear all input and output.		/// </summary>		public unsafe void Clear()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImGui.ClearNative(@this);
			}
		}

		/// <summary>		/// Clear output font data (glyphs storage, UV coordinates).		/// </summary>		public unsafe void ClearFonts()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImGui.ClearFontsNative(@this);
			}
		}

		/// <summary>		/// Clear input data (all ImFontConfig structures including sizes, TTF data, glyph ranges, etc.) = all the data used to build the texture and fonts.		/// </summary>		public unsafe void ClearInputData()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImGui.ClearInputDataNative(@this);
			}
		}

		/// <summary>		/// Clear output texture data (CPU side). Saves RAM once the texture has been copied to graphics memory.		/// </summary>		public unsafe void ClearTexData()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImGui.ClearTexDataNative(@this);
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe ImFontAtlasCustomRect* GetCustomRectByIndex(int index)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFontAtlasCustomRect* ret = ImGui.GetCustomRectByIndexNative(@this, index);
				return ret;
			}
		}

		/// <summary>		/// Default + Half-Width + Japanese HiraganaKatakana + full set of about 21000 CJK Unified Ideographs		/// </summary>		public unsafe char* GetGlyphRangesChineseFull()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				char* ret = ImGui.GetGlyphRangesChineseFullNative(@this);
				return ret;
			}
		}

		/// <summary>		/// Default + Half-Width + Japanese HiraganaKatakana + set of 2500 CJK Unified Ideographs for common simplified Chinese		/// </summary>		public unsafe char* GetGlyphRangesChineseSimplifiedCommon()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				char* ret = ImGui.GetGlyphRangesChineseSimplifiedCommonNative(@this);
				return ret;
			}
		}

		/// <summary>		/// Default + about 400 Cyrillic characters		/// </summary>		public unsafe char* GetGlyphRangesCyrillic()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				char* ret = ImGui.GetGlyphRangesCyrillicNative(@this);
				return ret;
			}
		}

		/// <summary>		/// Basic Latin, Extended Latin		/// </summary>		public unsafe char* GetGlyphRangesDefault()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				char* ret = ImGui.GetGlyphRangesDefaultNative(@this);
				return ret;
			}
		}

		/// <summary>		/// Default + Greek and Coptic		/// </summary>		public unsafe char* GetGlyphRangesGreek()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				char* ret = ImGui.GetGlyphRangesGreekNative(@this);
				return ret;
			}
		}

		/// <summary>		/// Default + Hiragana, Katakana, Half-Width, Selection of 2999 Ideographs		/// </summary>		public unsafe char* GetGlyphRangesJapanese()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				char* ret = ImGui.GetGlyphRangesJapaneseNative(@this);
				return ret;
			}
		}

		/// <summary>		/// Default + Korean characters		/// </summary>		public unsafe char* GetGlyphRangesKorean()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				char* ret = ImGui.GetGlyphRangesKoreanNative(@this);
				return ret;
			}
		}

		/// <summary>		/// Default + Thai characters		/// </summary>		public unsafe char* GetGlyphRangesThai()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				char* ret = ImGui.GetGlyphRangesThaiNative(@this);
				return ret;
			}
		}

		/// <summary>		/// Default + Vietnamese characters		/// </summary>		public unsafe char* GetGlyphRangesVietnamese()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				char* ret = ImGui.GetGlyphRangesVietnameseNative(@this);
				return ret;
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, Vector2* outUvBorder, Vector2* outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, outOffset, outSize, outUvBorder, outUvFill);
				return ret != 0;
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, Vector2* outUvBorder, Vector2* outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, (Vector2*)poutOffset, outSize, outUvBorder, outUvFill);
					return ret != 0;
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, Vector2* outUvBorder, Vector2* outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, outOffset, (Vector2*)poutSize, outUvBorder, outUvFill);
					return ret != 0;
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, Vector2* outUvBorder, Vector2* outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutSize = &outSize)
					{
						byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, outUvBorder, outUvFill);
						return ret != 0;
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, ref Vector2 outUvBorder, Vector2* outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutUvBorder = &outUvBorder)
				{
					byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, outOffset, outSize, (Vector2*)poutUvBorder, outUvFill);
					return ret != 0;
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, ref Vector2 outUvBorder, Vector2* outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutUvBorder = &outUvBorder)
					{
						byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, (Vector2*)poutOffset, outSize, (Vector2*)poutUvBorder, outUvFill);
						return ret != 0;
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, ref Vector2 outUvBorder, Vector2* outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvBorder = &outUvBorder)
					{
						byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, outOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, outUvFill);
						return ret != 0;
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, ref Vector2 outUvBorder, Vector2* outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutSize = &outSize)
					{
						fixed (Vector2* poutUvBorder = &outUvBorder)
						{
							byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, outUvFill);
							return ret != 0;
						}
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, Vector2* outUvBorder, ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutUvFill = &outUvFill)
				{
					byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, outOffset, outSize, outUvBorder, (Vector2*)poutUvFill);
					return ret != 0;
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, Vector2* outUvBorder, ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutUvFill = &outUvFill)
					{
						byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, (Vector2*)poutOffset, outSize, outUvBorder, (Vector2*)poutUvFill);
						return ret != 0;
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, Vector2* outUvBorder, ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvFill = &outUvFill)
					{
						byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, outOffset, (Vector2*)poutSize, outUvBorder, (Vector2*)poutUvFill);
						return ret != 0;
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, Vector2* outUvBorder, ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutSize = &outSize)
					{
						fixed (Vector2* poutUvFill = &outUvFill)
						{
							byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, outUvBorder, (Vector2*)poutUvFill);
							return ret != 0;
						}
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, ref Vector2 outUvBorder, ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutUvBorder = &outUvBorder)
				{
					fixed (Vector2* poutUvFill = &outUvFill)
					{
						byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, outOffset, outSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill);
						return ret != 0;
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, ref Vector2 outUvBorder, ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutUvBorder = &outUvBorder)
					{
						fixed (Vector2* poutUvFill = &outUvFill)
						{
							byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, (Vector2*)poutOffset, outSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill);
							return ret != 0;
						}
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, ref Vector2 outUvBorder, ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvBorder = &outUvBorder)
					{
						fixed (Vector2* poutUvFill = &outUvFill)
						{
							byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, outOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill);
							return ret != 0;
						}
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, ref Vector2 outUvBorder, ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutSize = &outSize)
					{
						fixed (Vector2* poutUvBorder = &outUvBorder)
						{
							fixed (Vector2* poutUvFill = &outUvFill)
							{
								byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>		/// 1 byte per-pixel		/// </summary>		public unsafe void GetTexDataAsAlpha8(byte** outPixels, int* outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImGui.GetTexDataAsAlpha8Native(@this, outPixels, outWidth, outHeight, outBytesPerPixel);
			}
		}

		/// <summary>		/// 1 byte per-pixel		/// </summary>		public unsafe void GetTexDataAsAlpha8(byte** outPixels, int* outWidth, int* outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImGui.GetTexDataAsAlpha8Native(@this, outPixels, outWidth, outHeight, (int*)(default));
			}
		}

		/// <summary>		/// 1 byte per-pixel		/// </summary>		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, int* outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					ImGui.GetTexDataAsAlpha8Native(@this, (byte**)poutPixels, outWidth, outHeight, outBytesPerPixel);
				}
			}
		}

		/// <summary>		/// 1 byte per-pixel		/// </summary>		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, int* outWidth, int* outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					ImGui.GetTexDataAsAlpha8Native(@this, (byte**)poutPixels, outWidth, outHeight, (int*)(default));
				}
			}
		}

		/// <summary>		/// 1 byte per-pixel		/// </summary>		public unsafe void GetTexDataAsAlpha8(byte** outPixels, ref int outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					ImGui.GetTexDataAsAlpha8Native(@this, outPixels, (int*)poutWidth, outHeight, outBytesPerPixel);
				}
			}
		}

		/// <summary>		/// 1 byte per-pixel		/// </summary>		public unsafe void GetTexDataAsAlpha8(byte** outPixels, ref int outWidth, int* outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					ImGui.GetTexDataAsAlpha8Native(@this, outPixels, (int*)poutWidth, outHeight, (int*)(default));
				}
			}
		}

		/// <summary>		/// 1 byte per-pixel		/// </summary>		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, ref int outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						ImGui.GetTexDataAsAlpha8Native(@this, (byte**)poutPixels, (int*)poutWidth, outHeight, outBytesPerPixel);
					}
				}
			}
		}

		/// <summary>		/// 1 byte per-pixel		/// </summary>		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, ref int outWidth, int* outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						ImGui.GetTexDataAsAlpha8Native(@this, (byte**)poutPixels, (int*)poutWidth, outHeight, (int*)(default));
					}
				}
			}
		}

		/// <summary>		/// 1 byte per-pixel		/// </summary>		public unsafe void GetTexDataAsAlpha8(byte** outPixels, int* outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutHeight = &outHeight)
				{
					ImGui.GetTexDataAsAlpha8Native(@this, outPixels, outWidth, (int*)poutHeight, outBytesPerPixel);
				}
			}
		}

		/// <summary>		/// 1 byte per-pixel		/// </summary>		public unsafe void GetTexDataAsAlpha8(byte** outPixels, int* outWidth, ref int outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutHeight = &outHeight)
				{
					ImGui.GetTexDataAsAlpha8Native(@this, outPixels, outWidth, (int*)poutHeight, (int*)(default));
				}
			}
		}

		/// <summary>		/// 1 byte per-pixel		/// </summary>		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, int* outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGui.GetTexDataAsAlpha8Native(@this, (byte**)poutPixels, outWidth, (int*)poutHeight, outBytesPerPixel);
					}
				}
			}
		}

		/// <summary>		/// 1 byte per-pixel		/// </summary>		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, int* outWidth, ref int outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGui.GetTexDataAsAlpha8Native(@this, (byte**)poutPixels, outWidth, (int*)poutHeight, (int*)(default));
					}
				}
			}
		}

		/// <summary>		/// 1 byte per-pixel		/// </summary>		public unsafe void GetTexDataAsAlpha8(byte** outPixels, ref int outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGui.GetTexDataAsAlpha8Native(@this, outPixels, (int*)poutWidth, (int*)poutHeight, outBytesPerPixel);
					}
				}
			}
		}

		/// <summary>		/// 1 byte per-pixel		/// </summary>		public unsafe void GetTexDataAsAlpha8(byte** outPixels, ref int outWidth, ref int outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGui.GetTexDataAsAlpha8Native(@this, outPixels, (int*)poutWidth, (int*)poutHeight, (int*)(default));
					}
				}
			}
		}

		/// <summary>		/// 1 byte per-pixel		/// </summary>		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, ref int outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutHeight = &outHeight)
						{
							ImGui.GetTexDataAsAlpha8Native(@this, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, outBytesPerPixel);
						}
					}
				}
			}
		}

		/// <summary>		/// 1 byte per-pixel		/// </summary>		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, ref int outWidth, ref int outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutHeight = &outHeight)
						{
							ImGui.GetTexDataAsAlpha8Native(@this, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, (int*)(default));
						}
					}
				}
			}
		}

		/// <summary>		/// 1 byte per-pixel		/// </summary>		public unsafe void GetTexDataAsAlpha8(byte** outPixels, int* outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutBytesPerPixel = &outBytesPerPixel)
				{
					ImGui.GetTexDataAsAlpha8Native(@this, outPixels, outWidth, outHeight, (int*)poutBytesPerPixel);
				}
			}
		}

		/// <summary>		/// 1 byte per-pixel		/// </summary>		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, int* outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						ImGui.GetTexDataAsAlpha8Native(@this, (byte**)poutPixels, outWidth, outHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		/// <summary>		/// 1 byte per-pixel		/// </summary>		public unsafe void GetTexDataAsAlpha8(byte** outPixels, ref int outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						ImGui.GetTexDataAsAlpha8Native(@this, outPixels, (int*)poutWidth, outHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		/// <summary>		/// 1 byte per-pixel		/// </summary>		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, ref int outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							ImGui.GetTexDataAsAlpha8Native(@this, (byte**)poutPixels, (int*)poutWidth, outHeight, (int*)poutBytesPerPixel);
						}
					}
				}
			}
		}

		/// <summary>		/// 1 byte per-pixel		/// </summary>		public unsafe void GetTexDataAsAlpha8(byte** outPixels, int* outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutHeight = &outHeight)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						ImGui.GetTexDataAsAlpha8Native(@this, outPixels, outWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		/// <summary>		/// 1 byte per-pixel		/// </summary>		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, int* outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutHeight = &outHeight)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							ImGui.GetTexDataAsAlpha8Native(@this, (byte**)poutPixels, outWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
						}
					}
				}
			}
		}

		/// <summary>		/// 1 byte per-pixel		/// </summary>		public unsafe void GetTexDataAsAlpha8(byte** outPixels, ref int outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							ImGui.GetTexDataAsAlpha8Native(@this, outPixels, (int*)poutWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
						}
					}
				}
			}
		}

		/// <summary>		/// 1 byte per-pixel		/// </summary>		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, ref int outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutHeight = &outHeight)
						{
							fixed (int* poutBytesPerPixel = &outBytesPerPixel)
							{
								ImGui.GetTexDataAsAlpha8Native(@this, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
							}
						}
					}
				}
			}
		}

		/// <summary>		/// 4 bytes-per-pixel		/// </summary>		public unsafe void GetTexDataAsRGBA32(byte** outPixels, int* outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImGui.GetTexDataAsRGBA32Native(@this, outPixels, outWidth, outHeight, outBytesPerPixel);
			}
		}

		/// <summary>		/// 4 bytes-per-pixel		/// </summary>		public unsafe void GetTexDataAsRGBA32(byte** outPixels, int* outWidth, int* outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImGui.GetTexDataAsRGBA32Native(@this, outPixels, outWidth, outHeight, (int*)(default));
			}
		}

		/// <summary>		/// 4 bytes-per-pixel		/// </summary>		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, int* outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					ImGui.GetTexDataAsRGBA32Native(@this, (byte**)poutPixels, outWidth, outHeight, outBytesPerPixel);
				}
			}
		}

		/// <summary>		/// 4 bytes-per-pixel		/// </summary>		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, int* outWidth, int* outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					ImGui.GetTexDataAsRGBA32Native(@this, (byte**)poutPixels, outWidth, outHeight, (int*)(default));
				}
			}
		}

		/// <summary>		/// 4 bytes-per-pixel		/// </summary>		public unsafe void GetTexDataAsRGBA32(byte** outPixels, ref int outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					ImGui.GetTexDataAsRGBA32Native(@this, outPixels, (int*)poutWidth, outHeight, outBytesPerPixel);
				}
			}
		}

		/// <summary>		/// 4 bytes-per-pixel		/// </summary>		public unsafe void GetTexDataAsRGBA32(byte** outPixels, ref int outWidth, int* outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					ImGui.GetTexDataAsRGBA32Native(@this, outPixels, (int*)poutWidth, outHeight, (int*)(default));
				}
			}
		}

		/// <summary>		/// 4 bytes-per-pixel		/// </summary>		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, ref int outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						ImGui.GetTexDataAsRGBA32Native(@this, (byte**)poutPixels, (int*)poutWidth, outHeight, outBytesPerPixel);
					}
				}
			}
		}

		/// <summary>		/// 4 bytes-per-pixel		/// </summary>		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, ref int outWidth, int* outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						ImGui.GetTexDataAsRGBA32Native(@this, (byte**)poutPixels, (int*)poutWidth, outHeight, (int*)(default));
					}
				}
			}
		}

		/// <summary>		/// 4 bytes-per-pixel		/// </summary>		public unsafe void GetTexDataAsRGBA32(byte** outPixels, int* outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutHeight = &outHeight)
				{
					ImGui.GetTexDataAsRGBA32Native(@this, outPixels, outWidth, (int*)poutHeight, outBytesPerPixel);
				}
			}
		}

		/// <summary>		/// 4 bytes-per-pixel		/// </summary>		public unsafe void GetTexDataAsRGBA32(byte** outPixels, int* outWidth, ref int outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutHeight = &outHeight)
				{
					ImGui.GetTexDataAsRGBA32Native(@this, outPixels, outWidth, (int*)poutHeight, (int*)(default));
				}
			}
		}

		/// <summary>		/// 4 bytes-per-pixel		/// </summary>		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, int* outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGui.GetTexDataAsRGBA32Native(@this, (byte**)poutPixels, outWidth, (int*)poutHeight, outBytesPerPixel);
					}
				}
			}
		}

		/// <summary>		/// 4 bytes-per-pixel		/// </summary>		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, int* outWidth, ref int outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGui.GetTexDataAsRGBA32Native(@this, (byte**)poutPixels, outWidth, (int*)poutHeight, (int*)(default));
					}
				}
			}
		}

		/// <summary>		/// 4 bytes-per-pixel		/// </summary>		public unsafe void GetTexDataAsRGBA32(byte** outPixels, ref int outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGui.GetTexDataAsRGBA32Native(@this, outPixels, (int*)poutWidth, (int*)poutHeight, outBytesPerPixel);
					}
				}
			}
		}

		/// <summary>		/// 4 bytes-per-pixel		/// </summary>		public unsafe void GetTexDataAsRGBA32(byte** outPixels, ref int outWidth, ref int outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGui.GetTexDataAsRGBA32Native(@this, outPixels, (int*)poutWidth, (int*)poutHeight, (int*)(default));
					}
				}
			}
		}

		/// <summary>		/// 4 bytes-per-pixel		/// </summary>		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, ref int outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutHeight = &outHeight)
						{
							ImGui.GetTexDataAsRGBA32Native(@this, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, outBytesPerPixel);
						}
					}
				}
			}
		}

		/// <summary>		/// 4 bytes-per-pixel		/// </summary>		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, ref int outWidth, ref int outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutHeight = &outHeight)
						{
							ImGui.GetTexDataAsRGBA32Native(@this, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, (int*)(default));
						}
					}
				}
			}
		}

		/// <summary>		/// 4 bytes-per-pixel		/// </summary>		public unsafe void GetTexDataAsRGBA32(byte** outPixels, int* outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutBytesPerPixel = &outBytesPerPixel)
				{
					ImGui.GetTexDataAsRGBA32Native(@this, outPixels, outWidth, outHeight, (int*)poutBytesPerPixel);
				}
			}
		}

		/// <summary>		/// 4 bytes-per-pixel		/// </summary>		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, int* outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						ImGui.GetTexDataAsRGBA32Native(@this, (byte**)poutPixels, outWidth, outHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		/// <summary>		/// 4 bytes-per-pixel		/// </summary>		public unsafe void GetTexDataAsRGBA32(byte** outPixels, ref int outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						ImGui.GetTexDataAsRGBA32Native(@this, outPixels, (int*)poutWidth, outHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		/// <summary>		/// 4 bytes-per-pixel		/// </summary>		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, ref int outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							ImGui.GetTexDataAsRGBA32Native(@this, (byte**)poutPixels, (int*)poutWidth, outHeight, (int*)poutBytesPerPixel);
						}
					}
				}
			}
		}

		/// <summary>		/// 4 bytes-per-pixel		/// </summary>		public unsafe void GetTexDataAsRGBA32(byte** outPixels, int* outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutHeight = &outHeight)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						ImGui.GetTexDataAsRGBA32Native(@this, outPixels, outWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		/// <summary>		/// 4 bytes-per-pixel		/// </summary>		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, int* outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutHeight = &outHeight)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							ImGui.GetTexDataAsRGBA32Native(@this, (byte**)poutPixels, outWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
						}
					}
				}
			}
		}

		/// <summary>		/// 4 bytes-per-pixel		/// </summary>		public unsafe void GetTexDataAsRGBA32(byte** outPixels, ref int outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							ImGui.GetTexDataAsRGBA32Native(@this, outPixels, (int*)poutWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
						}
					}
				}
			}
		}

		/// <summary>		/// 4 bytes-per-pixel		/// </summary>		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, ref int outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutHeight = &outHeight)
						{
							fixed (int* poutBytesPerPixel = &outBytesPerPixel)
							{
								ImGui.GetTexDataAsRGBA32Native(@this, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
							}
						}
					}
				}
			}
		}

		/// <summary>		/// Bit ambiguous: used to detect when user didn't build texture but effectively we should check TexID != 0 except that would be backend dependent...		/// </summary>		public unsafe bool IsBuilt()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte ret = ImGui.IsBuiltNative(@this);
				return ret != 0;
			}
		}

		public unsafe void SetTexID(ImTextureID id)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImGui.SetTexIDNative(@this, id);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImFontAtlasPtr : IEquatable<ImFontAtlasPtr>
	{
		public ImFontAtlasPtr(ImFontAtlas* handle) { Handle = handle; }

		public ImFontAtlas* Handle;

		public bool IsNull => Handle == null;

		public static ImFontAtlasPtr Null => new ImFontAtlasPtr(null);

		public static implicit operator ImFontAtlasPtr(ImFontAtlas* handle) => new ImFontAtlasPtr(handle);

		public static implicit operator ImFontAtlas*(ImFontAtlasPtr handle) => handle.Handle;

		public static bool operator ==(ImFontAtlasPtr left, ImFontAtlasPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImFontAtlasPtr left, ImFontAtlasPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImFontAtlasPtr left, ImFontAtlas* right) => left.Handle == right;

		public static bool operator !=(ImFontAtlasPtr left, ImFontAtlas* right) => left.Handle != right;

		public bool Equals(ImFontAtlasPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImFontAtlasPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImFontAtlasPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		/// <summary>
		/// Build flags (see ImFontAtlasFlags_)<br/>
		/// </summary>
		public ref ImFontAtlasFlags Flags => ref Unsafe.AsRef<ImFontAtlasFlags>(&Handle->Flags);
		/// <summary>
		/// User data to refer to the texture once it has been uploaded to user's graphic systems. It is passed back to you during rendering via the ImDrawCmd structure.<br/>
		/// </summary>
		public ref ImTextureID TexID => ref Unsafe.AsRef<ImTextureID>(&Handle->TexID);
		/// <summary>
		/// Texture width desired by user before Build(). Must be a power-of-two. If have many glyphs your graphics API have texture size restrictions you may want to increase texture width to decrease height.<br/>
		/// </summary>
		public ref int TexDesiredWidth => ref Unsafe.AsRef<int>(&Handle->TexDesiredWidth);
		/// <summary>
		/// Padding between glyphs within texture in pixels. Defaults to 1. If your rendering method doesn't rely on bilinear filtering you may set this to 0 (will also need to set AntiAliasedLinesUseTex = false).<br/>
		/// </summary>
		public ref int TexGlyphPadding => ref Unsafe.AsRef<int>(&Handle->TexGlyphPadding);
		/// <summary>
		/// Marked as Locked by ImGui::NewFrame() so attempt to modify the atlas will assert.<br/>
		/// </summary>
		public ref bool Locked => ref Unsafe.AsRef<bool>(&Handle->Locked);
		/// <summary>
		/// Store your own atlas related user-data (if e.g. you have multiple font atlas).<br/>
		/// </summary>
		public void* UserData { get => Handle->UserData; set => Handle->UserData = value; }
		/// <summary>
		/// [Internal]<br/>
		/// NB: Access texture data via GetTexData*() calls! Which will setup a default font for you. Set when texture was built matching current font input<br/>
		/// </summary>
		public ref bool TexReady => ref Unsafe.AsRef<bool>(&Handle->TexReady);
		/// <summary>
		/// Tell whether our texture data is known to use colors (rather than just alpha channel), in order to help backend select a format.<br/>
		/// </summary>
		public ref bool TexPixelsUseColors => ref Unsafe.AsRef<bool>(&Handle->TexPixelsUseColors);
		/// <summary>
		/// 1 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight<br/>
		/// </summary>
		public byte* TexPixelsAlpha8 { get => Handle->TexPixelsAlpha8; set => Handle->TexPixelsAlpha8 = value; }
		/// <summary>
		/// 4 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight * 4<br/>
		/// </summary>
		public uint* TexPixelsRGBA32 { get => Handle->TexPixelsRGBA32; set => Handle->TexPixelsRGBA32 = value; }
		/// <summary>
		/// Texture width calculated during Build().<br/>
		/// </summary>
		public ref int TexWidth => ref Unsafe.AsRef<int>(&Handle->TexWidth);
		/// <summary>
		/// Texture height calculated during Build().<br/>
		/// </summary>
		public ref int TexHeight => ref Unsafe.AsRef<int>(&Handle->TexHeight);
		/// <summary>
		/// = (1.0fTexWidth, 1.0fTexHeight)<br/>
		/// </summary>
		public ref Vector2 TexUvScale => ref Unsafe.AsRef<Vector2>(&Handle->TexUvScale);
		/// <summary>
		/// Texture coordinates to a white pixel<br/>
		/// </summary>
		public ref Vector2 TexUvWhitePixel => ref Unsafe.AsRef<Vector2>(&Handle->TexUvWhitePixel);
		/// <summary>
		/// Hold all the fonts returned by AddFont*. Fonts[0] is the default font upon calling ImGui::NewFrame(), use ImGui::PushFont()PopFont() to change the current font.<br/>
		/// </summary>
		public ref ImVectorImFontPtr Fonts => ref Unsafe.AsRef<ImVectorImFontPtr>(&Handle->Fonts);
		/// <summary>
		/// Rectangles for packing custom texture data into the atlas.<br/>
		/// </summary>
		public ref ImVectorImFontAtlasCustomRect CustomRects => ref Unsafe.AsRef<ImVectorImFontAtlasCustomRect>(&Handle->CustomRects);
		/// <summary>
		/// Configuration data<br/>
		/// </summary>
		public ref ImVectorImFontConfig ConfigData => ref Unsafe.AsRef<ImVectorImFontConfig>(&Handle->ConfigData);
		/// <summary>
		/// UVs for baked anti-aliased lines<br/>
		/// </summary>
		public unsafe Span<Vector4> TexUvLines
		
		{
			get
			{
				return new Span<Vector4>(&Handle->TexUvLines_0, 64);
			}
		}
		/// <summary>
		/// [Internal] Font builder Opaque interface to a font builder (default to stb_truetype, can be changed to use FreeType by defining IMGUI_ENABLE_FREETYPE).<br/>
		/// </summary>
		public ref ImFontBuilderIOPtr FontBuilderIO => ref Unsafe.AsRef<ImFontBuilderIOPtr>(&Handle->FontBuilderIO);
		/// <summary>
		/// Shared flags (for all fonts) for custom font builder. THIS IS BUILD IMPLEMENTATION DEPENDENT. Per-font override is also available in ImFontConfig.<br/>
		/// </summary>
		public ref uint FontBuilderFlags => ref Unsafe.AsRef<uint>(&Handle->FontBuilderFlags);
		/// <summary>
		/// [Internal] Packing data Custom texture rectangle ID for white pixel and mouse cursors<br/>
		/// </summary>
		public ref int PackIdMouseCursors => ref Unsafe.AsRef<int>(&Handle->PackIdMouseCursors);
		/// <summary>
		/// Custom texture rectangle ID for baked anti-aliased lines<br/>
		/// </summary>
		public ref int PackIdLines => ref Unsafe.AsRef<int>(&Handle->PackIdLines);

		public unsafe int AddCustomRectFontGlyph(ImFontPtr font, char id, int width, int height, float advanceX, Vector2 offset)
		{
			int ret = ImGui.AddCustomRectFontGlyphNative(Handle, font, id, width, height, advanceX, offset);
			return ret;
		}

		public unsafe int AddCustomRectFontGlyph(ImFontPtr font, char id, int width, int height, float advanceX)
		{
			int ret = ImGui.AddCustomRectFontGlyphNative(Handle, font, id, width, height, advanceX, (Vector2)(new Vector2(0,0)));
			return ret;
		}

		public unsafe int AddCustomRectFontGlyph(ref ImFont font, char id, int width, int height, float advanceX, Vector2 offset)
		{
			fixed (ImFont* pfont = &font)
			{
				int ret = ImGui.AddCustomRectFontGlyphNative(Handle, (ImFont*)pfont, id, width, height, advanceX, offset);
				return ret;
			}
		}

		public unsafe int AddCustomRectFontGlyph(ref ImFont font, char id, int width, int height, float advanceX)
		{
			fixed (ImFont* pfont = &font)
			{
				int ret = ImGui.AddCustomRectFontGlyphNative(Handle, (ImFont*)pfont, id, width, height, advanceX, (Vector2)(new Vector2(0,0)));
				return ret;
			}
		}

		public unsafe int AddCustomRectRegular(int width, int height)
		{
			int ret = ImGui.AddCustomRectRegularNative(Handle, width, height);
			return ret;
		}

		public unsafe ImFontPtr AddFont(ImFontConfig* fontCfg)
		{
			ImFontPtr ret = ImGui.AddFontNative(Handle, fontCfg);
			return ret;
		}

		public unsafe ImFontPtr AddFont(ref ImFontConfig fontCfg)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFontPtr ret = ImGui.AddFontNative(Handle, (ImFontConfig*)pfontCfg);
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontDefault(ImFontConfig* fontCfg)
		{
			ImFontPtr ret = ImGui.AddFontDefaultNative(Handle, fontCfg);
			return ret;
		}

		public unsafe ImFontPtr AddFontDefault()
		{
			ImFontPtr ret = ImGui.AddFontDefaultNative(Handle, (ImFontConfig*)(default));
			return ret;
		}

		public unsafe ImFontPtr AddFontDefault(ref ImFontConfig fontCfg)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFontPtr ret = ImGui.AddFontDefaultNative(Handle, (ImFontConfig*)pfontCfg);
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(byte* filename, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			ImFontPtr ret = ImGui.AddFontFromFileTTFNative(Handle, filename, sizePixels, fontCfg, glyphRanges);
			return ret;
		}

		public unsafe ImFontPtr AddFontFromFileTTF(byte* filename, float sizePixels, ImFontConfig* fontCfg)
		{
			ImFontPtr ret = ImGui.AddFontFromFileTTFNative(Handle, filename, sizePixels, fontCfg, (char*)(default));
			return ret;
		}

		public unsafe ImFontPtr AddFontFromFileTTF(byte* filename, float sizePixels)
		{
			ImFontPtr ret = ImGui.AddFontFromFileTTFNative(Handle, filename, sizePixels, (ImFontConfig*)(default), (char*)(default));
			return ret;
		}

		public unsafe ImFontPtr AddFontFromFileTTF(byte* filename, float sizePixels, char* glyphRanges)
		{
			ImFontPtr ret = ImGui.AddFontFromFileTTFNative(Handle, filename, sizePixels, (ImFontConfig*)(default), glyphRanges);
			return ret;
		}

		public unsafe ImFontPtr AddFontFromFileTTF(ref byte filename, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			fixed (byte* pfilename = &filename)
			{
				ImFontPtr ret = ImGui.AddFontFromFileTTFNative(Handle, (byte*)pfilename, sizePixels, fontCfg, glyphRanges);
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(ref byte filename, float sizePixels, ImFontConfig* fontCfg)
		{
			fixed (byte* pfilename = &filename)
			{
				ImFontPtr ret = ImGui.AddFontFromFileTTFNative(Handle, (byte*)pfilename, sizePixels, fontCfg, (char*)(default));
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(ref byte filename, float sizePixels)
		{
			fixed (byte* pfilename = &filename)
			{
				ImFontPtr ret = ImGui.AddFontFromFileTTFNative(Handle, (byte*)pfilename, sizePixels, (ImFontConfig*)(default), (char*)(default));
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(ref byte filename, float sizePixels, char* glyphRanges)
		{
			fixed (byte* pfilename = &filename)
			{
				ImFontPtr ret = ImGui.AddFontFromFileTTFNative(Handle, (byte*)pfilename, sizePixels, (ImFontConfig*)(default), glyphRanges);
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(string filename, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImFontPtr ret = ImGui.AddFontFromFileTTFNative(Handle, pStr0, sizePixels, fontCfg, glyphRanges);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public unsafe ImFontPtr AddFontFromFileTTF(string filename, float sizePixels, ImFontConfig* fontCfg)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImFontPtr ret = ImGui.AddFontFromFileTTFNative(Handle, pStr0, sizePixels, fontCfg, (char*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public unsafe ImFontPtr AddFontFromFileTTF(string filename, float sizePixels)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImFontPtr ret = ImGui.AddFontFromFileTTFNative(Handle, pStr0, sizePixels, (ImFontConfig*)(default), (char*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public unsafe ImFontPtr AddFontFromFileTTF(string filename, float sizePixels, char* glyphRanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImFontPtr ret = ImGui.AddFontFromFileTTFNative(Handle, pStr0, sizePixels, (ImFontConfig*)(default), glyphRanges);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public unsafe ImFontPtr AddFontFromFileTTF(byte* filename, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFontPtr ret = ImGui.AddFontFromFileTTFNative(Handle, filename, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(byte* filename, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFontPtr ret = ImGui.AddFontFromFileTTFNative(Handle, filename, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(ref byte filename, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (byte* pfilename = &filename)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = ImGui.AddFontFromFileTTFNative(Handle, (byte*)pfilename, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(ref byte filename, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (byte* pfilename = &filename)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = ImGui.AddFontFromFileTTFNative(Handle, (byte*)pfilename, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(string filename, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFontPtr ret = ImGui.AddFontFromFileTTFNative(Handle, pStr0, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(string filename, float sizePixels, ref ImFontConfig fontCfg)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFontPtr ret = ImGui.AddFontFromFileTTFNative(Handle, pStr0, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(byte* filename, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (char* pglyphRanges = &glyphRanges)
			{
				ImFontPtr ret = ImGui.AddFontFromFileTTFNative(Handle, filename, sizePixels, fontCfg, (char*)pglyphRanges);
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(byte* filename, float sizePixels, ref char glyphRanges)
		{
			fixed (char* pglyphRanges = &glyphRanges)
			{
				ImFontPtr ret = ImGui.AddFontFromFileTTFNative(Handle, filename, sizePixels, (ImFontConfig*)(default), (char*)pglyphRanges);
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(ref byte filename, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (byte* pfilename = &filename)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = ImGui.AddFontFromFileTTFNative(Handle, (byte*)pfilename, sizePixels, fontCfg, (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(ref byte filename, float sizePixels, ref char glyphRanges)
		{
			fixed (byte* pfilename = &filename)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = ImGui.AddFontFromFileTTFNative(Handle, (byte*)pfilename, sizePixels, (ImFontConfig*)(default), (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(string filename, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (char* pglyphRanges = &glyphRanges)
			{
				ImFontPtr ret = ImGui.AddFontFromFileTTFNative(Handle, pStr0, sizePixels, fontCfg, (char*)pglyphRanges);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(string filename, float sizePixels, ref char glyphRanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (char* pglyphRanges = &glyphRanges)
			{
				ImFontPtr ret = ImGui.AddFontFromFileTTFNative(Handle, pStr0, sizePixels, (ImFontConfig*)(default), (char*)pglyphRanges);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(byte* filename, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = ImGui.AddFontFromFileTTFNative(Handle, filename, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(ref byte filename, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (byte* pfilename = &filename)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFontPtr ret = ImGui.AddFontFromFileTTFNative(Handle, (byte*)pfilename, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
						return ret;
					}
				}
			}
		}

		public unsafe ImFontPtr AddFontFromFileTTF(string filename, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = ImGui.AddFontFromFileTTFNative(Handle, pStr0, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>		/// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(byte* compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(Handle, compressedFontDataBase85, sizePixels, fontCfg, glyphRanges);
			return ret;
		}

		/// <summary>		/// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(byte* compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg)
		{
			ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(Handle, compressedFontDataBase85, sizePixels, fontCfg, (char*)(default));
			return ret;
		}

		/// <summary>		/// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(byte* compressedFontDataBase85, float sizePixels)
		{
			ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(Handle, compressedFontDataBase85, sizePixels, (ImFontConfig*)(default), (char*)(default));
			return ret;
		}

		/// <summary>		/// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(byte* compressedFontDataBase85, float sizePixels, char* glyphRanges)
		{
			ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(Handle, compressedFontDataBase85, sizePixels, (ImFontConfig*)(default), glyphRanges);
			return ret;
		}

		/// <summary>		/// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref byte compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(Handle, (byte*)pcompressedFontDataBase85, sizePixels, fontCfg, glyphRanges);
				return ret;
			}
		}

		/// <summary>		/// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref byte compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg)
		{
			fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(Handle, (byte*)pcompressedFontDataBase85, sizePixels, fontCfg, (char*)(default));
				return ret;
			}
		}

		/// <summary>		/// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref byte compressedFontDataBase85, float sizePixels)
		{
			fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(Handle, (byte*)pcompressedFontDataBase85, sizePixels, (ImFontConfig*)(default), (char*)(default));
				return ret;
			}
		}

		/// <summary>		/// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref byte compressedFontDataBase85, float sizePixels, char* glyphRanges)
		{
			fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(Handle, (byte*)pcompressedFontDataBase85, sizePixels, (ImFontConfig*)(default), glyphRanges);
				return ret;
			}
		}

		/// <summary>		/// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(string compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (compressedFontDataBase85 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(Handle, pStr0, sizePixels, fontCfg, glyphRanges);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>		/// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(string compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (compressedFontDataBase85 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(Handle, pStr0, sizePixels, fontCfg, (char*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>		/// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(string compressedFontDataBase85, float sizePixels)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (compressedFontDataBase85 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(Handle, pStr0, sizePixels, (ImFontConfig*)(default), (char*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>		/// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(string compressedFontDataBase85, float sizePixels, char* glyphRanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (compressedFontDataBase85 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(Handle, pStr0, sizePixels, (ImFontConfig*)(default), glyphRanges);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>		/// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(byte* compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(Handle, compressedFontDataBase85, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
				return ret;
			}
		}

		/// <summary>		/// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(byte* compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(Handle, compressedFontDataBase85, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
				return ret;
			}
		}

		/// <summary>		/// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref byte compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(Handle, (byte*)pcompressedFontDataBase85, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
					return ret;
				}
			}
		}

		/// <summary>		/// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref byte compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(Handle, (byte*)pcompressedFontDataBase85, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
					return ret;
				}
			}
		}

		/// <summary>		/// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(string compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (compressedFontDataBase85 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(Handle, pStr0, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>		/// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(string compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (compressedFontDataBase85 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(Handle, pStr0, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>		/// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(byte* compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (char* pglyphRanges = &glyphRanges)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(Handle, compressedFontDataBase85, sizePixels, fontCfg, (char*)pglyphRanges);
				return ret;
			}
		}

		/// <summary>		/// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(byte* compressedFontDataBase85, float sizePixels, ref char glyphRanges)
		{
			fixed (char* pglyphRanges = &glyphRanges)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(Handle, compressedFontDataBase85, sizePixels, (ImFontConfig*)(default), (char*)pglyphRanges);
				return ret;
			}
		}

		/// <summary>		/// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref byte compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(Handle, (byte*)pcompressedFontDataBase85, sizePixels, fontCfg, (char*)pglyphRanges);
					return ret;
				}
			}
		}

		/// <summary>		/// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref byte compressedFontDataBase85, float sizePixels, ref char glyphRanges)
		{
			fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(Handle, (byte*)pcompressedFontDataBase85, sizePixels, (ImFontConfig*)(default), (char*)pglyphRanges);
					return ret;
				}
			}
		}

		/// <summary>		/// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(string compressedFontDataBase85, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (compressedFontDataBase85 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (char* pglyphRanges = &glyphRanges)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(Handle, pStr0, sizePixels, fontCfg, (char*)pglyphRanges);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>		/// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(string compressedFontDataBase85, float sizePixels, ref char glyphRanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (compressedFontDataBase85 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (char* pglyphRanges = &glyphRanges)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(Handle, pStr0, sizePixels, (ImFontConfig*)(default), (char*)pglyphRanges);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>		/// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(byte* compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(Handle, compressedFontDataBase85, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
					return ret;
				}
			}
		}

		/// <summary>		/// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(ref byte compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (byte* pcompressedFontDataBase85 = &compressedFontDataBase85)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(Handle, (byte*)pcompressedFontDataBase85, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedBase85TTF(string compressedFontDataBase85, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (compressedFontDataBase85 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(compressedFontDataBase85);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDataBase85, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(Handle, pStr0, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>		/// 'compressed_font_data' still owned by caller. Compress with binary_to_compressed_c.cpp.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedTTF(void* compressedFontData, int compressedFontSize, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			ImFontPtr ret = ImGui.AddFontFromMemoryCompressedTTFNative(Handle, compressedFontData, compressedFontSize, sizePixels, fontCfg, glyphRanges);
			return ret;
		}

		/// <summary>		/// 'compressed_font_data' still owned by caller. Compress with binary_to_compressed_c.cpp.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedTTF(void* compressedFontData, int compressedFontSize, float sizePixels, ImFontConfig* fontCfg)
		{
			ImFontPtr ret = ImGui.AddFontFromMemoryCompressedTTFNative(Handle, compressedFontData, compressedFontSize, sizePixels, fontCfg, (char*)(default));
			return ret;
		}

		/// <summary>		/// 'compressed_font_data' still owned by caller. Compress with binary_to_compressed_c.cpp.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedTTF(void* compressedFontData, int compressedFontSize, float sizePixels)
		{
			ImFontPtr ret = ImGui.AddFontFromMemoryCompressedTTFNative(Handle, compressedFontData, compressedFontSize, sizePixels, (ImFontConfig*)(default), (char*)(default));
			return ret;
		}

		/// <summary>		/// 'compressed_font_data' still owned by caller. Compress with binary_to_compressed_c.cpp.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedTTF(void* compressedFontData, int compressedFontSize, float sizePixels, char* glyphRanges)
		{
			ImFontPtr ret = ImGui.AddFontFromMemoryCompressedTTFNative(Handle, compressedFontData, compressedFontSize, sizePixels, (ImFontConfig*)(default), glyphRanges);
			return ret;
		}

		/// <summary>		/// 'compressed_font_data' still owned by caller. Compress with binary_to_compressed_c.cpp.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedTTF(void* compressedFontData, int compressedFontSize, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedTTFNative(Handle, compressedFontData, compressedFontSize, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
				return ret;
			}
		}

		/// <summary>		/// 'compressed_font_data' still owned by caller. Compress with binary_to_compressed_c.cpp.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedTTF(void* compressedFontData, int compressedFontSize, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedTTFNative(Handle, compressedFontData, compressedFontSize, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
				return ret;
			}
		}

		/// <summary>		/// 'compressed_font_data' still owned by caller. Compress with binary_to_compressed_c.cpp.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedTTF(void* compressedFontData, int compressedFontSize, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (char* pglyphRanges = &glyphRanges)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedTTFNative(Handle, compressedFontData, compressedFontSize, sizePixels, fontCfg, (char*)pglyphRanges);
				return ret;
			}
		}

		/// <summary>		/// 'compressed_font_data' still owned by caller. Compress with binary_to_compressed_c.cpp.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedTTF(void* compressedFontData, int compressedFontSize, float sizePixels, ref char glyphRanges)
		{
			fixed (char* pglyphRanges = &glyphRanges)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryCompressedTTFNative(Handle, compressedFontData, compressedFontSize, sizePixels, (ImFontConfig*)(default), (char*)pglyphRanges);
				return ret;
			}
		}

		/// <summary>		/// 'compressed_font_data' still owned by caller. Compress with binary_to_compressed_c.cpp.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryCompressedTTF(void* compressedFontData, int compressedFontSize, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryCompressedTTFNative(Handle, compressedFontData, compressedFontSize, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
					return ret;
				}
			}
		}

		/// <summary>		/// Note: Transfer ownership of 'ttf_data' to ImFontAtlas! Will be deleted after destruction of the atlas. Set font_cfg->FontDataOwnedByAtlas=false to keep ownership of your data and it won't be freed.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryTTF(void* fontData, int fontSize, float sizePixels, ImFontConfig* fontCfg, char* glyphRanges)
		{
			ImFontPtr ret = ImGui.AddFontFromMemoryTTFNative(Handle, fontData, fontSize, sizePixels, fontCfg, glyphRanges);
			return ret;
		}

		/// <summary>		/// Note: Transfer ownership of 'ttf_data' to ImFontAtlas! Will be deleted after destruction of the atlas. Set font_cfg->FontDataOwnedByAtlas=false to keep ownership of your data and it won't be freed.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryTTF(void* fontData, int fontSize, float sizePixels, ImFontConfig* fontCfg)
		{
			ImFontPtr ret = ImGui.AddFontFromMemoryTTFNative(Handle, fontData, fontSize, sizePixels, fontCfg, (char*)(default));
			return ret;
		}

		/// <summary>		/// Note: Transfer ownership of 'ttf_data' to ImFontAtlas! Will be deleted after destruction of the atlas. Set font_cfg->FontDataOwnedByAtlas=false to keep ownership of your data and it won't be freed.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryTTF(void* fontData, int fontSize, float sizePixels)
		{
			ImFontPtr ret = ImGui.AddFontFromMemoryTTFNative(Handle, fontData, fontSize, sizePixels, (ImFontConfig*)(default), (char*)(default));
			return ret;
		}

		/// <summary>		/// Note: Transfer ownership of 'ttf_data' to ImFontAtlas! Will be deleted after destruction of the atlas. Set font_cfg->FontDataOwnedByAtlas=false to keep ownership of your data and it won't be freed.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryTTF(void* fontData, int fontSize, float sizePixels, char* glyphRanges)
		{
			ImFontPtr ret = ImGui.AddFontFromMemoryTTFNative(Handle, fontData, fontSize, sizePixels, (ImFontConfig*)(default), glyphRanges);
			return ret;
		}

		/// <summary>		/// Note: Transfer ownership of 'ttf_data' to ImFontAtlas! Will be deleted after destruction of the atlas. Set font_cfg->FontDataOwnedByAtlas=false to keep ownership of your data and it won't be freed.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryTTF(void* fontData, int fontSize, float sizePixels, ref ImFontConfig fontCfg, char* glyphRanges)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryTTFNative(Handle, fontData, fontSize, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
				return ret;
			}
		}

		/// <summary>		/// Note: Transfer ownership of 'ttf_data' to ImFontAtlas! Will be deleted after destruction of the atlas. Set font_cfg->FontDataOwnedByAtlas=false to keep ownership of your data and it won't be freed.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryTTF(void* fontData, int fontSize, float sizePixels, ref ImFontConfig fontCfg)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryTTFNative(Handle, fontData, fontSize, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
				return ret;
			}
		}

		/// <summary>		/// Note: Transfer ownership of 'ttf_data' to ImFontAtlas! Will be deleted after destruction of the atlas. Set font_cfg->FontDataOwnedByAtlas=false to keep ownership of your data and it won't be freed.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryTTF(void* fontData, int fontSize, float sizePixels, ImFontConfig* fontCfg, ref char glyphRanges)
		{
			fixed (char* pglyphRanges = &glyphRanges)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryTTFNative(Handle, fontData, fontSize, sizePixels, fontCfg, (char*)pglyphRanges);
				return ret;
			}
		}

		/// <summary>		/// Note: Transfer ownership of 'ttf_data' to ImFontAtlas! Will be deleted after destruction of the atlas. Set font_cfg->FontDataOwnedByAtlas=false to keep ownership of your data and it won't be freed.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryTTF(void* fontData, int fontSize, float sizePixels, ref char glyphRanges)
		{
			fixed (char* pglyphRanges = &glyphRanges)
			{
				ImFontPtr ret = ImGui.AddFontFromMemoryTTFNative(Handle, fontData, fontSize, sizePixels, (ImFontConfig*)(default), (char*)pglyphRanges);
				return ret;
			}
		}

		/// <summary>		/// Note: Transfer ownership of 'ttf_data' to ImFontAtlas! Will be deleted after destruction of the atlas. Set font_cfg->FontDataOwnedByAtlas=false to keep ownership of your data and it won't be freed.		/// </summary>		public unsafe ImFontPtr AddFontFromMemoryTTF(void* fontData, int fontSize, float sizePixels, ref ImFontConfig fontCfg, ref char glyphRanges)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFontPtr ret = ImGui.AddFontFromMemoryTTFNative(Handle, fontData, fontSize, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
					return ret;
				}
			}
		}

		/// <summary>		/// Build pixels data. This is called automatically for you by the GetTexData*** functions.		/// </summary>		public unsafe bool Build()
		{
			byte ret = ImGui.BuildNative(Handle);
			return ret != 0;
		}

		public unsafe void CalcCustomRectUV(ImFontAtlasCustomRect* rect, Vector2* outUvMin, Vector2* outUvMax)
		{
			ImGui.CalcCustomRectUVNative(Handle, rect, outUvMin, outUvMax);
		}

		public unsafe void CalcCustomRectUV(ref ImFontAtlasCustomRect rect, Vector2* outUvMin, Vector2* outUvMax)
		{
			fixed (ImFontAtlasCustomRect* prect = &rect)
			{
				ImGui.CalcCustomRectUVNative(Handle, (ImFontAtlasCustomRect*)prect, outUvMin, outUvMax);
			}
		}

		public unsafe void CalcCustomRectUV(ImFontAtlasCustomRect* rect, ref Vector2 outUvMin, Vector2* outUvMax)
		{
			fixed (Vector2* poutUvMin = &outUvMin)
			{
				ImGui.CalcCustomRectUVNative(Handle, rect, (Vector2*)poutUvMin, outUvMax);
			}
		}

		public unsafe void CalcCustomRectUV(ref ImFontAtlasCustomRect rect, ref Vector2 outUvMin, Vector2* outUvMax)
		{
			fixed (ImFontAtlasCustomRect* prect = &rect)
			{
				fixed (Vector2* poutUvMin = &outUvMin)
				{
					ImGui.CalcCustomRectUVNative(Handle, (ImFontAtlasCustomRect*)prect, (Vector2*)poutUvMin, outUvMax);
				}
			}
		}

		public unsafe void CalcCustomRectUV(ImFontAtlasCustomRect* rect, Vector2* outUvMin, ref Vector2 outUvMax)
		{
			fixed (Vector2* poutUvMax = &outUvMax)
			{
				ImGui.CalcCustomRectUVNative(Handle, rect, outUvMin, (Vector2*)poutUvMax);
			}
		}

		public unsafe void CalcCustomRectUV(ref ImFontAtlasCustomRect rect, Vector2* outUvMin, ref Vector2 outUvMax)
		{
			fixed (ImFontAtlasCustomRect* prect = &rect)
			{
				fixed (Vector2* poutUvMax = &outUvMax)
				{
					ImGui.CalcCustomRectUVNative(Handle, (ImFontAtlasCustomRect*)prect, outUvMin, (Vector2*)poutUvMax);
				}
			}
		}

		public unsafe void CalcCustomRectUV(ImFontAtlasCustomRect* rect, ref Vector2 outUvMin, ref Vector2 outUvMax)
		{
			fixed (Vector2* poutUvMin = &outUvMin)
			{
				fixed (Vector2* poutUvMax = &outUvMax)
				{
					ImGui.CalcCustomRectUVNative(Handle, rect, (Vector2*)poutUvMin, (Vector2*)poutUvMax);
				}
			}
		}

		public unsafe void CalcCustomRectUV(ref ImFontAtlasCustomRect rect, ref Vector2 outUvMin, ref Vector2 outUvMax)
		{
			fixed (ImFontAtlasCustomRect* prect = &rect)
			{
				fixed (Vector2* poutUvMin = &outUvMin)
				{
					fixed (Vector2* poutUvMax = &outUvMax)
					{
						ImGui.CalcCustomRectUVNative(Handle, (ImFontAtlasCustomRect*)prect, (Vector2*)poutUvMin, (Vector2*)poutUvMax);
					}
				}
			}
		}

		/// <summary>		/// Clear all input and output.		/// </summary>		public unsafe void Clear()
		{
			ImGui.ClearNative(Handle);
		}

		/// <summary>		/// Clear output font data (glyphs storage, UV coordinates).		/// </summary>		public unsafe void ClearFonts()
		{
			ImGui.ClearFontsNative(Handle);
		}

		/// <summary>		/// Clear input data (all ImFontConfig structures including sizes, TTF data, glyph ranges, etc.) = all the data used to build the texture and fonts.		/// </summary>		public unsafe void ClearInputData()
		{
			ImGui.ClearInputDataNative(Handle);
		}

		/// <summary>		/// Clear output texture data (CPU side). Saves RAM once the texture has been copied to graphics memory.		/// </summary>		public unsafe void ClearTexData()
		{
			ImGui.ClearTexDataNative(Handle);
		}

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

		public unsafe ImFontAtlasCustomRect* GetCustomRectByIndex(int index)
		{
			ImFontAtlasCustomRect* ret = ImGui.GetCustomRectByIndexNative(Handle, index);
			return ret;
		}

		/// <summary>		/// Default + Half-Width + Japanese HiraganaKatakana + full set of about 21000 CJK Unified Ideographs		/// </summary>		public unsafe char* GetGlyphRangesChineseFull()
		{
			char* ret = ImGui.GetGlyphRangesChineseFullNative(Handle);
			return ret;
		}

		/// <summary>		/// Default + Half-Width + Japanese HiraganaKatakana + set of 2500 CJK Unified Ideographs for common simplified Chinese		/// </summary>		public unsafe char* GetGlyphRangesChineseSimplifiedCommon()
		{
			char* ret = ImGui.GetGlyphRangesChineseSimplifiedCommonNative(Handle);
			return ret;
		}

		/// <summary>		/// Default + about 400 Cyrillic characters		/// </summary>		public unsafe char* GetGlyphRangesCyrillic()
		{
			char* ret = ImGui.GetGlyphRangesCyrillicNative(Handle);
			return ret;
		}

		/// <summary>		/// Basic Latin, Extended Latin		/// </summary>		public unsafe char* GetGlyphRangesDefault()
		{
			char* ret = ImGui.GetGlyphRangesDefaultNative(Handle);
			return ret;
		}

		/// <summary>		/// Default + Greek and Coptic		/// </summary>		public unsafe char* GetGlyphRangesGreek()
		{
			char* ret = ImGui.GetGlyphRangesGreekNative(Handle);
			return ret;
		}

		/// <summary>		/// Default + Hiragana, Katakana, Half-Width, Selection of 2999 Ideographs		/// </summary>		public unsafe char* GetGlyphRangesJapanese()
		{
			char* ret = ImGui.GetGlyphRangesJapaneseNative(Handle);
			return ret;
		}

		/// <summary>		/// Default + Korean characters		/// </summary>		public unsafe char* GetGlyphRangesKorean()
		{
			char* ret = ImGui.GetGlyphRangesKoreanNative(Handle);
			return ret;
		}

		/// <summary>		/// Default + Thai characters		/// </summary>		public unsafe char* GetGlyphRangesThai()
		{
			char* ret = ImGui.GetGlyphRangesThaiNative(Handle);
			return ret;
		}

		/// <summary>		/// Default + Vietnamese characters		/// </summary>		public unsafe char* GetGlyphRangesVietnamese()
		{
			char* ret = ImGui.GetGlyphRangesVietnameseNative(Handle);
			return ret;
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, Vector2* outUvBorder, Vector2* outUvFill)
		{
			byte ret = ImGui.GetMouseCursorTexDataNative(Handle, cursor, outOffset, outSize, outUvBorder, outUvFill);
			return ret != 0;
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, Vector2* outUvBorder, Vector2* outUvFill)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				byte ret = ImGui.GetMouseCursorTexDataNative(Handle, cursor, (Vector2*)poutOffset, outSize, outUvBorder, outUvFill);
				return ret != 0;
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, Vector2* outUvBorder, Vector2* outUvFill)
		{
			fixed (Vector2* poutSize = &outSize)
			{
				byte ret = ImGui.GetMouseCursorTexDataNative(Handle, cursor, outOffset, (Vector2*)poutSize, outUvBorder, outUvFill);
				return ret != 0;
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, Vector2* outUvBorder, Vector2* outUvFill)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					byte ret = ImGui.GetMouseCursorTexDataNative(Handle, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, outUvBorder, outUvFill);
					return ret != 0;
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, ref Vector2 outUvBorder, Vector2* outUvFill)
		{
			fixed (Vector2* poutUvBorder = &outUvBorder)
			{
				byte ret = ImGui.GetMouseCursorTexDataNative(Handle, cursor, outOffset, outSize, (Vector2*)poutUvBorder, outUvFill);
				return ret != 0;
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, ref Vector2 outUvBorder, Vector2* outUvFill)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutUvBorder = &outUvBorder)
				{
					byte ret = ImGui.GetMouseCursorTexDataNative(Handle, cursor, (Vector2*)poutOffset, outSize, (Vector2*)poutUvBorder, outUvFill);
					return ret != 0;
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, ref Vector2 outUvBorder, Vector2* outUvFill)
		{
			fixed (Vector2* poutSize = &outSize)
			{
				fixed (Vector2* poutUvBorder = &outUvBorder)
				{
					byte ret = ImGui.GetMouseCursorTexDataNative(Handle, cursor, outOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, outUvFill);
					return ret != 0;
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, ref Vector2 outUvBorder, Vector2* outUvFill)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvBorder = &outUvBorder)
					{
						byte ret = ImGui.GetMouseCursorTexDataNative(Handle, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, outUvFill);
						return ret != 0;
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, Vector2* outUvBorder, ref Vector2 outUvFill)
		{
			fixed (Vector2* poutUvFill = &outUvFill)
			{
				byte ret = ImGui.GetMouseCursorTexDataNative(Handle, cursor, outOffset, outSize, outUvBorder, (Vector2*)poutUvFill);
				return ret != 0;
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, Vector2* outUvBorder, ref Vector2 outUvFill)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutUvFill = &outUvFill)
				{
					byte ret = ImGui.GetMouseCursorTexDataNative(Handle, cursor, (Vector2*)poutOffset, outSize, outUvBorder, (Vector2*)poutUvFill);
					return ret != 0;
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, Vector2* outUvBorder, ref Vector2 outUvFill)
		{
			fixed (Vector2* poutSize = &outSize)
			{
				fixed (Vector2* poutUvFill = &outUvFill)
				{
					byte ret = ImGui.GetMouseCursorTexDataNative(Handle, cursor, outOffset, (Vector2*)poutSize, outUvBorder, (Vector2*)poutUvFill);
					return ret != 0;
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, Vector2* outUvBorder, ref Vector2 outUvFill)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvFill = &outUvFill)
					{
						byte ret = ImGui.GetMouseCursorTexDataNative(Handle, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, outUvBorder, (Vector2*)poutUvFill);
						return ret != 0;
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, ref Vector2 outUvBorder, ref Vector2 outUvFill)
		{
			fixed (Vector2* poutUvBorder = &outUvBorder)
			{
				fixed (Vector2* poutUvFill = &outUvFill)
				{
					byte ret = ImGui.GetMouseCursorTexDataNative(Handle, cursor, outOffset, outSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill);
					return ret != 0;
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, ref Vector2 outUvBorder, ref Vector2 outUvFill)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutUvBorder = &outUvBorder)
				{
					fixed (Vector2* poutUvFill = &outUvFill)
					{
						byte ret = ImGui.GetMouseCursorTexDataNative(Handle, cursor, (Vector2*)poutOffset, outSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill);
						return ret != 0;
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, ref Vector2 outUvBorder, ref Vector2 outUvFill)
		{
			fixed (Vector2* poutSize = &outSize)
			{
				fixed (Vector2* poutUvBorder = &outUvBorder)
				{
					fixed (Vector2* poutUvFill = &outUvFill)
					{
						byte ret = ImGui.GetMouseCursorTexDataNative(Handle, cursor, outOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill);
						return ret != 0;
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData(ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, ref Vector2 outUvBorder, ref Vector2 outUvFill)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvBorder = &outUvBorder)
					{
						fixed (Vector2* poutUvFill = &outUvFill)
						{
							byte ret = ImGui.GetMouseCursorTexDataNative(Handle, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>		/// 1 byte per-pixel		/// </summary>		public unsafe void GetTexDataAsAlpha8(byte** outPixels, int* outWidth, int* outHeight, int* outBytesPerPixel)
		{
			ImGui.GetTexDataAsAlpha8Native(Handle, outPixels, outWidth, outHeight, outBytesPerPixel);
		}

		/// <summary>		/// 1 byte per-pixel		/// </summary>		public unsafe void GetTexDataAsAlpha8(byte** outPixels, int* outWidth, int* outHeight)
		{
			ImGui.GetTexDataAsAlpha8Native(Handle, outPixels, outWidth, outHeight, (int*)(default));
		}

		/// <summary>		/// 1 byte per-pixel		/// </summary>		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, int* outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				ImGui.GetTexDataAsAlpha8Native(Handle, (byte**)poutPixels, outWidth, outHeight, outBytesPerPixel);
			}
		}

		/// <summary>		/// 1 byte per-pixel		/// </summary>		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, int* outWidth, int* outHeight)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				ImGui.GetTexDataAsAlpha8Native(Handle, (byte**)poutPixels, outWidth, outHeight, (int*)(default));
			}
		}

		/// <summary>		/// 1 byte per-pixel		/// </summary>		public unsafe void GetTexDataAsAlpha8(byte** outPixels, ref int outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (int* poutWidth = &outWidth)
			{
				ImGui.GetTexDataAsAlpha8Native(Handle, outPixels, (int*)poutWidth, outHeight, outBytesPerPixel);
			}
		}

		/// <summary>		/// 1 byte per-pixel		/// </summary>		public unsafe void GetTexDataAsAlpha8(byte** outPixels, ref int outWidth, int* outHeight)
		{
			fixed (int* poutWidth = &outWidth)
			{
				ImGui.GetTexDataAsAlpha8Native(Handle, outPixels, (int*)poutWidth, outHeight, (int*)(default));
			}
		}

		/// <summary>		/// 1 byte per-pixel		/// </summary>		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, ref int outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					ImGui.GetTexDataAsAlpha8Native(Handle, (byte**)poutPixels, (int*)poutWidth, outHeight, outBytesPerPixel);
				}
			}
		}

		/// <summary>		/// 1 byte per-pixel		/// </summary>		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, ref int outWidth, int* outHeight)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					ImGui.GetTexDataAsAlpha8Native(Handle, (byte**)poutPixels, (int*)poutWidth, outHeight, (int*)(default));
				}
			}
		}

		/// <summary>		/// 1 byte per-pixel		/// </summary>		public unsafe void GetTexDataAsAlpha8(byte** outPixels, int* outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (int* poutHeight = &outHeight)
			{
				ImGui.GetTexDataAsAlpha8Native(Handle, outPixels, outWidth, (int*)poutHeight, outBytesPerPixel);
			}
		}

		/// <summary>		/// 1 byte per-pixel		/// </summary>		public unsafe void GetTexDataAsAlpha8(byte** outPixels, int* outWidth, ref int outHeight)
		{
			fixed (int* poutHeight = &outHeight)
			{
				ImGui.GetTexDataAsAlpha8Native(Handle, outPixels, outWidth, (int*)poutHeight, (int*)(default));
			}
		}

		/// <summary>		/// 1 byte per-pixel		/// </summary>		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, int* outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutHeight = &outHeight)
				{
					ImGui.GetTexDataAsAlpha8Native(Handle, (byte**)poutPixels, outWidth, (int*)poutHeight, outBytesPerPixel);
				}
			}
		}

		/// <summary>		/// 1 byte per-pixel		/// </summary>		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, int* outWidth, ref int outHeight)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutHeight = &outHeight)
				{
					ImGui.GetTexDataAsAlpha8Native(Handle, (byte**)poutPixels, outWidth, (int*)poutHeight, (int*)(default));
				}
			}
		}

		/// <summary>		/// 1 byte per-pixel		/// </summary>		public unsafe void GetTexDataAsAlpha8(byte** outPixels, ref int outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (int* poutWidth = &outWidth)
			{
				fixed (int* poutHeight = &outHeight)
				{
					ImGui.GetTexDataAsAlpha8Native(Handle, outPixels, (int*)poutWidth, (int*)poutHeight, outBytesPerPixel);
				}
			}
		}

		/// <summary>		/// 1 byte per-pixel		/// </summary>		public unsafe void GetTexDataAsAlpha8(byte** outPixels, ref int outWidth, ref int outHeight)
		{
			fixed (int* poutWidth = &outWidth)
			{
				fixed (int* poutHeight = &outHeight)
				{
					ImGui.GetTexDataAsAlpha8Native(Handle, outPixels, (int*)poutWidth, (int*)poutHeight, (int*)(default));
				}
			}
		}

		/// <summary>		/// 1 byte per-pixel		/// </summary>		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, ref int outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGui.GetTexDataAsAlpha8Native(Handle, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, outBytesPerPixel);
					}
				}
			}
		}

		/// <summary>		/// 1 byte per-pixel		/// </summary>		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, ref int outWidth, ref int outHeight)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGui.GetTexDataAsAlpha8Native(Handle, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, (int*)(default));
					}
				}
			}
		}

		/// <summary>		/// 1 byte per-pixel		/// </summary>		public unsafe void GetTexDataAsAlpha8(byte** outPixels, int* outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (int* poutBytesPerPixel = &outBytesPerPixel)
			{
				ImGui.GetTexDataAsAlpha8Native(Handle, outPixels, outWidth, outHeight, (int*)poutBytesPerPixel);
			}
		}

		/// <summary>		/// 1 byte per-pixel		/// </summary>		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, int* outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutBytesPerPixel = &outBytesPerPixel)
				{
					ImGui.GetTexDataAsAlpha8Native(Handle, (byte**)poutPixels, outWidth, outHeight, (int*)poutBytesPerPixel);
				}
			}
		}

		/// <summary>		/// 1 byte per-pixel		/// </summary>		public unsafe void GetTexDataAsAlpha8(byte** outPixels, ref int outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (int* poutWidth = &outWidth)
			{
				fixed (int* poutBytesPerPixel = &outBytesPerPixel)
				{
					ImGui.GetTexDataAsAlpha8Native(Handle, outPixels, (int*)poutWidth, outHeight, (int*)poutBytesPerPixel);
				}
			}
		}

		/// <summary>		/// 1 byte per-pixel		/// </summary>		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, ref int outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						ImGui.GetTexDataAsAlpha8Native(Handle, (byte**)poutPixels, (int*)poutWidth, outHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		/// <summary>		/// 1 byte per-pixel		/// </summary>		public unsafe void GetTexDataAsAlpha8(byte** outPixels, int* outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (int* poutHeight = &outHeight)
			{
				fixed (int* poutBytesPerPixel = &outBytesPerPixel)
				{
					ImGui.GetTexDataAsAlpha8Native(Handle, outPixels, outWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
				}
			}
		}

		/// <summary>		/// 1 byte per-pixel		/// </summary>		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, int* outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutHeight = &outHeight)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						ImGui.GetTexDataAsAlpha8Native(Handle, (byte**)poutPixels, outWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		/// <summary>		/// 1 byte per-pixel		/// </summary>		public unsafe void GetTexDataAsAlpha8(byte** outPixels, ref int outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (int* poutWidth = &outWidth)
			{
				fixed (int* poutHeight = &outHeight)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						ImGui.GetTexDataAsAlpha8Native(Handle, outPixels, (int*)poutWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		/// <summary>		/// 1 byte per-pixel		/// </summary>		public unsafe void GetTexDataAsAlpha8(ref byte* outPixels, ref int outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							ImGui.GetTexDataAsAlpha8Native(Handle, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
						}
					}
				}
			}
		}

		/// <summary>		/// 4 bytes-per-pixel		/// </summary>		public unsafe void GetTexDataAsRGBA32(byte** outPixels, int* outWidth, int* outHeight, int* outBytesPerPixel)
		{
			ImGui.GetTexDataAsRGBA32Native(Handle, outPixels, outWidth, outHeight, outBytesPerPixel);
		}

		/// <summary>		/// 4 bytes-per-pixel		/// </summary>		public unsafe void GetTexDataAsRGBA32(byte** outPixels, int* outWidth, int* outHeight)
		{
			ImGui.GetTexDataAsRGBA32Native(Handle, outPixels, outWidth, outHeight, (int*)(default));
		}

		/// <summary>		/// 4 bytes-per-pixel		/// </summary>		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, int* outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				ImGui.GetTexDataAsRGBA32Native(Handle, (byte**)poutPixels, outWidth, outHeight, outBytesPerPixel);
			}
		}

		/// <summary>		/// 4 bytes-per-pixel		/// </summary>		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, int* outWidth, int* outHeight)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				ImGui.GetTexDataAsRGBA32Native(Handle, (byte**)poutPixels, outWidth, outHeight, (int*)(default));
			}
		}

		/// <summary>		/// 4 bytes-per-pixel		/// </summary>		public unsafe void GetTexDataAsRGBA32(byte** outPixels, ref int outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (int* poutWidth = &outWidth)
			{
				ImGui.GetTexDataAsRGBA32Native(Handle, outPixels, (int*)poutWidth, outHeight, outBytesPerPixel);
			}
		}

		/// <summary>		/// 4 bytes-per-pixel		/// </summary>		public unsafe void GetTexDataAsRGBA32(byte** outPixels, ref int outWidth, int* outHeight)
		{
			fixed (int* poutWidth = &outWidth)
			{
				ImGui.GetTexDataAsRGBA32Native(Handle, outPixels, (int*)poutWidth, outHeight, (int*)(default));
			}
		}

		/// <summary>		/// 4 bytes-per-pixel		/// </summary>		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, ref int outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					ImGui.GetTexDataAsRGBA32Native(Handle, (byte**)poutPixels, (int*)poutWidth, outHeight, outBytesPerPixel);
				}
			}
		}

		/// <summary>		/// 4 bytes-per-pixel		/// </summary>		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, ref int outWidth, int* outHeight)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					ImGui.GetTexDataAsRGBA32Native(Handle, (byte**)poutPixels, (int*)poutWidth, outHeight, (int*)(default));
				}
			}
		}

		/// <summary>		/// 4 bytes-per-pixel		/// </summary>		public unsafe void GetTexDataAsRGBA32(byte** outPixels, int* outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (int* poutHeight = &outHeight)
			{
				ImGui.GetTexDataAsRGBA32Native(Handle, outPixels, outWidth, (int*)poutHeight, outBytesPerPixel);
			}
		}

		/// <summary>		/// 4 bytes-per-pixel		/// </summary>		public unsafe void GetTexDataAsRGBA32(byte** outPixels, int* outWidth, ref int outHeight)
		{
			fixed (int* poutHeight = &outHeight)
			{
				ImGui.GetTexDataAsRGBA32Native(Handle, outPixels, outWidth, (int*)poutHeight, (int*)(default));
			}
		}

		/// <summary>		/// 4 bytes-per-pixel		/// </summary>		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, int* outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutHeight = &outHeight)
				{
					ImGui.GetTexDataAsRGBA32Native(Handle, (byte**)poutPixels, outWidth, (int*)poutHeight, outBytesPerPixel);
				}
			}
		}

		/// <summary>		/// 4 bytes-per-pixel		/// </summary>		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, int* outWidth, ref int outHeight)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutHeight = &outHeight)
				{
					ImGui.GetTexDataAsRGBA32Native(Handle, (byte**)poutPixels, outWidth, (int*)poutHeight, (int*)(default));
				}
			}
		}

		/// <summary>		/// 4 bytes-per-pixel		/// </summary>		public unsafe void GetTexDataAsRGBA32(byte** outPixels, ref int outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (int* poutWidth = &outWidth)
			{
				fixed (int* poutHeight = &outHeight)
				{
					ImGui.GetTexDataAsRGBA32Native(Handle, outPixels, (int*)poutWidth, (int*)poutHeight, outBytesPerPixel);
				}
			}
		}

		/// <summary>		/// 4 bytes-per-pixel		/// </summary>		public unsafe void GetTexDataAsRGBA32(byte** outPixels, ref int outWidth, ref int outHeight)
		{
			fixed (int* poutWidth = &outWidth)
			{
				fixed (int* poutHeight = &outHeight)
				{
					ImGui.GetTexDataAsRGBA32Native(Handle, outPixels, (int*)poutWidth, (int*)poutHeight, (int*)(default));
				}
			}
		}

		/// <summary>		/// 4 bytes-per-pixel		/// </summary>		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, ref int outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGui.GetTexDataAsRGBA32Native(Handle, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, outBytesPerPixel);
					}
				}
			}
		}

		/// <summary>		/// 4 bytes-per-pixel		/// </summary>		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, ref int outWidth, ref int outHeight)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGui.GetTexDataAsRGBA32Native(Handle, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, (int*)(default));
					}
				}
			}
		}

		/// <summary>		/// 4 bytes-per-pixel		/// </summary>		public unsafe void GetTexDataAsRGBA32(byte** outPixels, int* outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (int* poutBytesPerPixel = &outBytesPerPixel)
			{
				ImGui.GetTexDataAsRGBA32Native(Handle, outPixels, outWidth, outHeight, (int*)poutBytesPerPixel);
			}
		}

		/// <summary>		/// 4 bytes-per-pixel		/// </summary>		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, int* outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutBytesPerPixel = &outBytesPerPixel)
				{
					ImGui.GetTexDataAsRGBA32Native(Handle, (byte**)poutPixels, outWidth, outHeight, (int*)poutBytesPerPixel);
				}
			}
		}

		/// <summary>		/// 4 bytes-per-pixel		/// </summary>		public unsafe void GetTexDataAsRGBA32(byte** outPixels, ref int outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (int* poutWidth = &outWidth)
			{
				fixed (int* poutBytesPerPixel = &outBytesPerPixel)
				{
					ImGui.GetTexDataAsRGBA32Native(Handle, outPixels, (int*)poutWidth, outHeight, (int*)poutBytesPerPixel);
				}
			}
		}

		/// <summary>		/// 4 bytes-per-pixel		/// </summary>		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, ref int outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						ImGui.GetTexDataAsRGBA32Native(Handle, (byte**)poutPixels, (int*)poutWidth, outHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		/// <summary>		/// 4 bytes-per-pixel		/// </summary>		public unsafe void GetTexDataAsRGBA32(byte** outPixels, int* outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (int* poutHeight = &outHeight)
			{
				fixed (int* poutBytesPerPixel = &outBytesPerPixel)
				{
					ImGui.GetTexDataAsRGBA32Native(Handle, outPixels, outWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
				}
			}
		}

		/// <summary>		/// 4 bytes-per-pixel		/// </summary>		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, int* outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutHeight = &outHeight)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						ImGui.GetTexDataAsRGBA32Native(Handle, (byte**)poutPixels, outWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		/// <summary>		/// 4 bytes-per-pixel		/// </summary>		public unsafe void GetTexDataAsRGBA32(byte** outPixels, ref int outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (int* poutWidth = &outWidth)
			{
				fixed (int* poutHeight = &outHeight)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						ImGui.GetTexDataAsRGBA32Native(Handle, outPixels, (int*)poutWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		/// <summary>		/// 4 bytes-per-pixel		/// </summary>		public unsafe void GetTexDataAsRGBA32(ref byte* outPixels, ref int outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							ImGui.GetTexDataAsRGBA32Native(Handle, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
						}
					}
				}
			}
		}

		/// <summary>		/// Bit ambiguous: used to detect when user didn't build texture but effectively we should check TexID != 0 except that would be backend dependent...		/// </summary>		public unsafe bool IsBuilt()
		{
			byte ret = ImGui.IsBuiltNative(Handle);
			return ret != 0;
		}

		public unsafe void SetTexID(ImTextureID id)
		{
			ImGui.SetTexIDNative(Handle, id);
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImFontPtr
	{
		public int Size;
		public int Capacity;
		public unsafe ImFont** Data;


	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImFontAtlasCustomRect
	{
		public int Size;
		public int Capacity;
		public unsafe ImFontAtlasCustomRect* Data;


	}

	/// <summary>
	/// See ImFontAtlas::AddCustomRectXXX functions.<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImFontAtlasCustomRect
	{
		/// <summary>
		/// Input     Desired rectangle dimension<br/>
		/// </summary>
		public ushort Width;

		/// <summary>
		/// Input     Desired rectangle dimension<br/>
		/// </summary>
		public ushort Height;

		/// <summary>
		/// Output    Packed position in Atlas<br/>
		/// </summary>
		public ushort X;

		/// <summary>
		/// Output    Packed position in Atlas<br/>
		/// </summary>
		public ushort Y;

		/// <summary>
		/// Input     For custom font glyphs only (ID &lt; 0x110000)<br/>
		/// </summary>
		public uint GlyphID;

		/// <summary>
		/// Input     For custom font glyphs only: glyph xadvance<br/>
		/// </summary>
		public float GlyphAdvanceX;

		/// <summary>
		/// Input     For custom font glyphs only: glyph display offset<br/>
		/// </summary>
		public Vector2 GlyphOffset;

		/// <summary>
		/// Input     For custom font glyphs only: target font<br/>
		/// </summary>
		public unsafe ImFont* Font;





		public unsafe void Destroy()
		{
			fixed (ImFontAtlasCustomRect* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe bool IsPacked()
		{
			fixed (ImFontAtlasCustomRect* @this = &this)
			{
				byte ret = ImGui.IsPackedNative(@this);
				return ret != 0;
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImFontAtlasCustomRectPtr : IEquatable<ImFontAtlasCustomRectPtr>
	{
		public ImFontAtlasCustomRectPtr(ImFontAtlasCustomRect* handle) { Handle = handle; }

		public ImFontAtlasCustomRect* Handle;

		public bool IsNull => Handle == null;

		public static ImFontAtlasCustomRectPtr Null => new ImFontAtlasCustomRectPtr(null);

		public static implicit operator ImFontAtlasCustomRectPtr(ImFontAtlasCustomRect* handle) => new ImFontAtlasCustomRectPtr(handle);

		public static implicit operator ImFontAtlasCustomRect*(ImFontAtlasCustomRectPtr handle) => handle.Handle;

		public static bool operator ==(ImFontAtlasCustomRectPtr left, ImFontAtlasCustomRectPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImFontAtlasCustomRectPtr left, ImFontAtlasCustomRectPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImFontAtlasCustomRectPtr left, ImFontAtlasCustomRect* right) => left.Handle == right;

		public static bool operator !=(ImFontAtlasCustomRectPtr left, ImFontAtlasCustomRect* right) => left.Handle != right;

		public bool Equals(ImFontAtlasCustomRectPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImFontAtlasCustomRectPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImFontAtlasCustomRectPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		/// <summary>
		/// Input     Desired rectangle dimension<br/>
		/// </summary>
		public ref ushort Width => ref Unsafe.AsRef<ushort>(&Handle->Width);
		/// <summary>
		/// Input     Desired rectangle dimension<br/>
		/// </summary>
		public ref ushort Height => ref Unsafe.AsRef<ushort>(&Handle->Height);
		/// <summary>
		/// Output    Packed position in Atlas<br/>
		/// </summary>
		public ref ushort X => ref Unsafe.AsRef<ushort>(&Handle->X);
		/// <summary>
		/// Output    Packed position in Atlas<br/>
		/// </summary>
		public ref ushort Y => ref Unsafe.AsRef<ushort>(&Handle->Y);
		/// <summary>
		/// Input     For custom font glyphs only (ID &lt; 0x110000)<br/>
		/// </summary>
		public ref uint GlyphID => ref Unsafe.AsRef<uint>(&Handle->GlyphID);
		/// <summary>
		/// Input     For custom font glyphs only: glyph xadvance<br/>
		/// </summary>
		public ref float GlyphAdvanceX => ref Unsafe.AsRef<float>(&Handle->GlyphAdvanceX);
		/// <summary>
		/// Input     For custom font glyphs only: glyph display offset<br/>
		/// </summary>
		public ref Vector2 GlyphOffset => ref Unsafe.AsRef<Vector2>(&Handle->GlyphOffset);
		/// <summary>
		/// Input     For custom font glyphs only: target font<br/>
		/// </summary>
		public ref ImFontPtr Font => ref Unsafe.AsRef<ImFontPtr>(&Handle->Font);

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

		public unsafe bool IsPacked()
		{
			byte ret = ImGui.IsPackedNative(Handle);
			return ret != 0;
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImFontConfig
	{
		public int Size;
		public int Capacity;
		public unsafe ImFontConfig* Data;


	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImFontConfig
	{
		/// <summary>
		/// TTFOTF data<br/>
		/// </summary>
		public unsafe void* FontData;

		/// <summary>
		/// TTFOTF data size<br/>
		/// </summary>
		public int FontDataSize;

		/// <summary>
		/// true      TTFOTF data ownership taken by the container ImFontAtlas (will delete memory itself).<br/>
		/// </summary>
		public byte FontDataOwnedByAtlas;

		/// <summary>
		/// 0         Index of font within TTFOTF file<br/>
		/// </summary>
		public int FontNo;

		/// <summary>
		/// Size in pixels for rasterizer (more or less maps to the resulting font height).<br/>
		/// </summary>
		public float SizePixels;

		/// <summary>
		/// 3         Rasterize at higher quality for sub-pixel positioning. Note the difference between 2 and 3 is minimal so you can reduce this to 2 to save memory. Read https:github.comnothingsstbblobmastertestsoversampleREADME.md for details.<br/>
		/// </summary>
		public int OversampleH;

		/// <summary>
		/// 1         Rasterize at higher quality for sub-pixel positioning. This is not really useful as we don't use sub-pixel positions on the Y axis.<br/>
		/// </summary>
		public int OversampleV;

		/// <summary>
		/// false     Align every glyph to pixel boundary. Useful e.g. if you are merging a non-pixel aligned font with the default font. If enabled, you can set OversampleHV to 1.<br/>
		/// </summary>
		public byte PixelSnapH;

		/// <summary>
		/// 0, 0      Extra spacing (in pixels) between glyphs. Only X axis is supported for now.<br/>
		/// </summary>
		public Vector2 GlyphExtraSpacing;

		/// <summary>
		/// 0, 0      Offset all glyphs from this font input.<br/>
		/// </summary>
		public Vector2 GlyphOffset;

		/// <summary>
		/// NULL      THE ARRAY DATA NEEDS TO PERSIST AS LONG AS THE FONT IS ALIVE. Pointer to a user-provided list of Unicode range (2 value per range, values are inclusive, zero-terminated list).<br/>
		/// </summary>
		public unsafe char* GlyphRanges;

		/// <summary>
		/// 0         Minimum AdvanceX for glyphs, set Min to align font icons, set both MinMax to enforce mono-space font<br/>
		/// </summary>
		public float GlyphMinAdvanceX;

		/// <summary>
		/// FLT_MAX   Maximum AdvanceX for glyphs<br/>
		/// </summary>
		public float GlyphMaxAdvanceX;

		/// <summary>
		/// false     Merge into previous ImFont, so you can combine multiple inputs font into one ImFont (e.g. ASCII font + icons + Japanese glyphs). You may want to use GlyphOffset.y when merge font of different heights.<br/>
		/// </summary>
		public byte MergeMode;

		/// <summary>
		/// 0         Settings for custom font builder. THIS IS BUILDER IMPLEMENTATION DEPENDENT. Leave as zero if unsure.<br/>
		/// </summary>
		public uint FontBuilderFlags;

		/// <summary>
		/// 1.0f      Brighten (&gt;1.0f) or darken (&lt;1.0f) font output. Brightening small fonts may be a good workaround to make them more readable.<br/>
		/// </summary>
		public float RasterizerMultiply;

		/// <summary>
		/// -1        Explicitly specify unicode codepoint of ellipsis character. When fonts are being merged first specified ellipsis will be used.<br/>
		/// </summary>
		public char EllipsisChar;

		/// <summary>
		/// [Internal] Name (strictly to ease debugging)<br/>
		/// </summary>
		public byte Name_0;
		public byte Name_1;
		public byte Name_2;
		public byte Name_3;
		public byte Name_4;
		public byte Name_5;
		public byte Name_6;
		public byte Name_7;
		public byte Name_8;
		public byte Name_9;
		public byte Name_10;
		public byte Name_11;
		public byte Name_12;
		public byte Name_13;
		public byte Name_14;
		public byte Name_15;
		public byte Name_16;
		public byte Name_17;
		public byte Name_18;
		public byte Name_19;
		public byte Name_20;
		public byte Name_21;
		public byte Name_22;
		public byte Name_23;
		public byte Name_24;
		public byte Name_25;
		public byte Name_26;
		public byte Name_27;
		public byte Name_28;
		public byte Name_29;
		public byte Name_30;
		public byte Name_31;
		public byte Name_32;
		public byte Name_33;
		public byte Name_34;
		public byte Name_35;
		public byte Name_36;
		public byte Name_37;
		public byte Name_38;
		public byte Name_39;

		public unsafe ImFont* DstFont;




		public unsafe void Destroy()
		{
			fixed (ImFontConfig* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImFontConfigPtr : IEquatable<ImFontConfigPtr>
	{
		public ImFontConfigPtr(ImFontConfig* handle) { Handle = handle; }

		public ImFontConfig* Handle;

		public bool IsNull => Handle == null;

		public static ImFontConfigPtr Null => new ImFontConfigPtr(null);

		public static implicit operator ImFontConfigPtr(ImFontConfig* handle) => new ImFontConfigPtr(handle);

		public static implicit operator ImFontConfig*(ImFontConfigPtr handle) => handle.Handle;

		public static bool operator ==(ImFontConfigPtr left, ImFontConfigPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImFontConfigPtr left, ImFontConfigPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImFontConfigPtr left, ImFontConfig* right) => left.Handle == right;

		public static bool operator !=(ImFontConfigPtr left, ImFontConfig* right) => left.Handle != right;

		public bool Equals(ImFontConfigPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImFontConfigPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImFontConfigPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		/// <summary>
		/// TTFOTF data<br/>
		/// </summary>
		public void* FontData { get => Handle->FontData; set => Handle->FontData = value; }
		/// <summary>
		/// TTFOTF data size<br/>
		/// </summary>
		public ref int FontDataSize => ref Unsafe.AsRef<int>(&Handle->FontDataSize);
		/// <summary>
		/// true      TTFOTF data ownership taken by the container ImFontAtlas (will delete memory itself).<br/>
		/// </summary>
		public ref bool FontDataOwnedByAtlas => ref Unsafe.AsRef<bool>(&Handle->FontDataOwnedByAtlas);
		/// <summary>
		/// 0         Index of font within TTFOTF file<br/>
		/// </summary>
		public ref int FontNo => ref Unsafe.AsRef<int>(&Handle->FontNo);
		/// <summary>
		/// Size in pixels for rasterizer (more or less maps to the resulting font height).<br/>
		/// </summary>
		public ref float SizePixels => ref Unsafe.AsRef<float>(&Handle->SizePixels);
		/// <summary>
		/// 3         Rasterize at higher quality for sub-pixel positioning. Note the difference between 2 and 3 is minimal so you can reduce this to 2 to save memory. Read https:github.comnothingsstbblobmastertestsoversampleREADME.md for details.<br/>
		/// </summary>
		public ref int OversampleH => ref Unsafe.AsRef<int>(&Handle->OversampleH);
		/// <summary>
		/// 1         Rasterize at higher quality for sub-pixel positioning. This is not really useful as we don't use sub-pixel positions on the Y axis.<br/>
		/// </summary>
		public ref int OversampleV => ref Unsafe.AsRef<int>(&Handle->OversampleV);
		/// <summary>
		/// false     Align every glyph to pixel boundary. Useful e.g. if you are merging a non-pixel aligned font with the default font. If enabled, you can set OversampleHV to 1.<br/>
		/// </summary>
		public ref bool PixelSnapH => ref Unsafe.AsRef<bool>(&Handle->PixelSnapH);
		/// <summary>
		/// 0, 0      Extra spacing (in pixels) between glyphs. Only X axis is supported for now.<br/>
		/// </summary>
		public ref Vector2 GlyphExtraSpacing => ref Unsafe.AsRef<Vector2>(&Handle->GlyphExtraSpacing);
		/// <summary>
		/// 0, 0      Offset all glyphs from this font input.<br/>
		/// </summary>
		public ref Vector2 GlyphOffset => ref Unsafe.AsRef<Vector2>(&Handle->GlyphOffset);
		/// <summary>
		/// NULL      THE ARRAY DATA NEEDS TO PERSIST AS LONG AS THE FONT IS ALIVE. Pointer to a user-provided list of Unicode range (2 value per range, values are inclusive, zero-terminated list).<br/>
		/// </summary>
		public char* GlyphRanges { get => Handle->GlyphRanges; set => Handle->GlyphRanges = value; }
		/// <summary>
		/// 0         Minimum AdvanceX for glyphs, set Min to align font icons, set both MinMax to enforce mono-space font<br/>
		/// </summary>
		public ref float GlyphMinAdvanceX => ref Unsafe.AsRef<float>(&Handle->GlyphMinAdvanceX);
		/// <summary>
		/// FLT_MAX   Maximum AdvanceX for glyphs<br/>
		/// </summary>
		public ref float GlyphMaxAdvanceX => ref Unsafe.AsRef<float>(&Handle->GlyphMaxAdvanceX);
		/// <summary>
		/// false     Merge into previous ImFont, so you can combine multiple inputs font into one ImFont (e.g. ASCII font + icons + Japanese glyphs). You may want to use GlyphOffset.y when merge font of different heights.<br/>
		/// </summary>
		public ref bool MergeMode => ref Unsafe.AsRef<bool>(&Handle->MergeMode);
		/// <summary>
		/// 0         Settings for custom font builder. THIS IS BUILDER IMPLEMENTATION DEPENDENT. Leave as zero if unsure.<br/>
		/// </summary>
		public ref uint FontBuilderFlags => ref Unsafe.AsRef<uint>(&Handle->FontBuilderFlags);
		/// <summary>
		/// 1.0f      Brighten (&gt;1.0f) or darken (&lt;1.0f) font output. Brightening small fonts may be a good workaround to make them more readable.<br/>
		/// </summary>
		public ref float RasterizerMultiply => ref Unsafe.AsRef<float>(&Handle->RasterizerMultiply);
		/// <summary>
		/// -1        Explicitly specify unicode codepoint of ellipsis character. When fonts are being merged first specified ellipsis will be used.<br/>
		/// </summary>
		public ref char EllipsisChar => ref Unsafe.AsRef<char>(&Handle->EllipsisChar);
		/// <summary>
		/// [Internal] Name (strictly to ease debugging)<br/>
		/// </summary>
		public unsafe Span<byte> Name
		
		{
			get
			{
				return new Span<byte>(&Handle->Name_0, 40);
			}
		}
		public ref ImFontPtr DstFont => ref Unsafe.AsRef<ImFontPtr>(&Handle->DstFont);

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

	}

	/// <summary>
	/// This structure is likely to evolve as we add support for incremental atlas updates<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImFontBuilderIO
	{
		public unsafe void* FontBuilderBuild;


	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImFontBuilderIOPtr : IEquatable<ImFontBuilderIOPtr>
	{
		public ImFontBuilderIOPtr(ImFontBuilderIO* handle) { Handle = handle; }

		public ImFontBuilderIO* Handle;

		public bool IsNull => Handle == null;

		public static ImFontBuilderIOPtr Null => new ImFontBuilderIOPtr(null);

		public static implicit operator ImFontBuilderIOPtr(ImFontBuilderIO* handle) => new ImFontBuilderIOPtr(handle);

		public static implicit operator ImFontBuilderIO*(ImFontBuilderIOPtr handle) => handle.Handle;

		public static bool operator ==(ImFontBuilderIOPtr left, ImFontBuilderIOPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImFontBuilderIOPtr left, ImFontBuilderIOPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImFontBuilderIOPtr left, ImFontBuilderIO* right) => left.Handle == right;

		public static bool operator !=(ImFontBuilderIOPtr left, ImFontBuilderIO* right) => left.Handle != right;

		public bool Equals(ImFontBuilderIOPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImFontBuilderIOPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImFontBuilderIOPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public void* FontBuilderBuild { get => Handle->FontBuilderBuild; set => Handle->FontBuilderBuild = value; }
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImVec2
	{
		public int Size;
		public int Capacity;
		public unsafe Vector2* Data;


	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImVec4
	{
		public int Size;
		public int Capacity;
		public unsafe Vector4* Data;


	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImTextureID
	{
		public int Size;
		public int Capacity;
		public unsafe ImTextureID* Data;


	}

	/// <summary>
	/// [Internal] For use by ImDrawList<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImDrawCmdHeader
	{
		public Vector4 ClipRect;
		public ImTextureID TextureId;
		public uint VtxOffset;


	}

	/// <summary>
	/// SplitMerge functions are used to split the draw list into different layers which can be drawn into out of order.<br/>
	/// This is used by the ColumnsTables API, so items of each column can be batched together in a same draw call.<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImDrawListSplitter
	{
		/// <summary>
		/// Current channel number (0)<br/>
		/// </summary>
		public int Current;

		/// <summary>
		/// Number of active channels (1+)<br/>
		/// </summary>
		public int Count;

		/// <summary>
		/// Draw channels (not resized down so _Count might be &lt; Channels.Size)<br/>
		/// </summary>
		public ImVectorImDrawChannel Channels;





		/// <summary>		/// Do not clear Channels[] so our allocations are reused next frame		/// </summary>		public unsafe void Clear()
		{
			fixed (ImDrawListSplitter* @this = &this)
			{
				ImGui.ClearNative(@this);
			}
		}

		public unsafe void ClearFreeMemory()
		{
			fixed (ImDrawListSplitter* @this = &this)
			{
				ImGui.ClearFreeMemoryNative(@this);
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImDrawListSplitter* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe void Merge(ImDrawListPtr drawList)
		{
			fixed (ImDrawListSplitter* @this = &this)
			{
				ImGui.MergeNative(@this, drawList);
			}
		}

		public unsafe void Merge(ref ImDrawList drawList)
		{
			fixed (ImDrawListSplitter* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					ImGui.MergeNative(@this, (ImDrawList*)pdrawList);
				}
			}
		}

		public unsafe void SetCurrentChannel(ImDrawListPtr drawList, int channelIdx)
		{
			fixed (ImDrawListSplitter* @this = &this)
			{
				ImGui.SetCurrentChannelNative(@this, drawList, channelIdx);
			}
		}

		public unsafe void SetCurrentChannel(ref ImDrawList drawList, int channelIdx)
		{
			fixed (ImDrawListSplitter* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					ImGui.SetCurrentChannelNative(@this, (ImDrawList*)pdrawList, channelIdx);
				}
			}
		}

		public unsafe void Split(ImDrawListPtr drawList, int count)
		{
			fixed (ImDrawListSplitter* @this = &this)
			{
				ImGui.SplitNative(@this, drawList, count);
			}
		}

		public unsafe void Split(ref ImDrawList drawList, int count)
		{
			fixed (ImDrawListSplitter* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					ImGui.SplitNative(@this, (ImDrawList*)pdrawList, count);
				}
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImDrawListSplitterPtr : IEquatable<ImDrawListSplitterPtr>
	{
		public ImDrawListSplitterPtr(ImDrawListSplitter* handle) { Handle = handle; }

		public ImDrawListSplitter* Handle;

		public bool IsNull => Handle == null;

		public static ImDrawListSplitterPtr Null => new ImDrawListSplitterPtr(null);

		public static implicit operator ImDrawListSplitterPtr(ImDrawListSplitter* handle) => new ImDrawListSplitterPtr(handle);

		public static implicit operator ImDrawListSplitter*(ImDrawListSplitterPtr handle) => handle.Handle;

		public static bool operator ==(ImDrawListSplitterPtr left, ImDrawListSplitterPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImDrawListSplitterPtr left, ImDrawListSplitterPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImDrawListSplitterPtr left, ImDrawListSplitter* right) => left.Handle == right;

		public static bool operator !=(ImDrawListSplitterPtr left, ImDrawListSplitter* right) => left.Handle != right;

		public bool Equals(ImDrawListSplitterPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImDrawListSplitterPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImDrawListSplitterPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		/// <summary>
		/// Current channel number (0)<br/>
		/// </summary>
		public ref int Current => ref Unsafe.AsRef<int>(&Handle->Current);
		/// <summary>
		/// Number of active channels (1+)<br/>
		/// </summary>
		public ref int Count => ref Unsafe.AsRef<int>(&Handle->Count);
		/// <summary>
		/// Draw channels (not resized down so _Count might be &lt; Channels.Size)<br/>
		/// </summary>
		public ref ImVectorImDrawChannel Channels => ref Unsafe.AsRef<ImVectorImDrawChannel>(&Handle->Channels);

		/// <summary>		/// Do not clear Channels[] so our allocations are reused next frame		/// </summary>		public unsafe void Clear()
		{
			ImGui.ClearNative(Handle);
		}

		public unsafe void ClearFreeMemory()
		{
			ImGui.ClearFreeMemoryNative(Handle);
		}

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

		public unsafe void Merge(ImDrawListPtr drawList)
		{
			ImGui.MergeNative(Handle, drawList);
		}

		public unsafe void Merge(ref ImDrawList drawList)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				ImGui.MergeNative(Handle, (ImDrawList*)pdrawList);
			}
		}

		public unsafe void SetCurrentChannel(ImDrawListPtr drawList, int channelIdx)
		{
			ImGui.SetCurrentChannelNative(Handle, drawList, channelIdx);
		}

		public unsafe void SetCurrentChannel(ref ImDrawList drawList, int channelIdx)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				ImGui.SetCurrentChannelNative(Handle, (ImDrawList*)pdrawList, channelIdx);
			}
		}

		public unsafe void Split(ImDrawListPtr drawList, int count)
		{
			ImGui.SplitNative(Handle, drawList, count);
		}

		public unsafe void Split(ref ImDrawList drawList, int count)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				ImGui.SplitNative(Handle, (ImDrawList*)pdrawList, count);
			}
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImDrawChannel
	{
		public int Size;
		public int Capacity;
		public unsafe ImDrawChannel* Data;


	}

	/// <summary>
	/// All draw data to render a Dear ImGui frame<br/>
	/// (NB: the style and the naming convention here is a little inconsistent, we currently preserve them for backward compatibility purpose,<br/>
	/// as this is one of the oldest structure exposed by the library! Basically, ImDrawList == CmdList)<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImDrawData
	{
		/// <summary>
		/// Only valid after Render() is called and before the next NewFrame() is called.<br/>
		/// </summary>
		public byte Valid;

		/// <summary>
		/// Number of ImDrawList* to render<br/>
		/// </summary>
		public int CmdListsCount;

		/// <summary>
		/// For convenience, sum of all ImDrawList's IdxBuffer.Size<br/>
		/// </summary>
		public int TotalIdxCount;

		/// <summary>
		/// For convenience, sum of all ImDrawList's VtxBuffer.Size<br/>
		/// </summary>
		public int TotalVtxCount;

		/// <summary>
		/// Array of ImDrawList* to render. The ImDrawList are owned by ImGuiContext and only pointed to from here.<br/>
		/// </summary>
		public unsafe ImDrawList** CmdLists;

		/// <summary>
		/// Top-left position of the viewport to render (== top-left of the orthogonal projection matrix to use) (== GetMainViewport()-&gt;Pos for the main viewport, == (0.0) in most single-viewport applications)<br/>
		/// </summary>
		public Vector2 DisplayPos;

		/// <summary>
		/// Size of the viewport to render (== GetMainViewport()-&gt;Size for the main viewport, == io.DisplaySize in most single-viewport applications)<br/>
		/// </summary>
		public Vector2 DisplaySize;

		/// <summary>
		/// Amount of pixels for each unit of DisplaySize. Based on io.DisplayFramebufferScale. Generally (1,1) on normal display, (2,2) on OSX with Retina display.<br/>
		/// </summary>
		public Vector2 FramebufferScale;

		/// <summary>
		/// Viewport carrying the ImDrawData instance, might be of use to the renderer (generally not).<br/>
		/// </summary>
		public unsafe ImGuiViewport* OwnerViewport;





		/// <summary>		/// The ImDrawList are owned by ImGuiContext!		/// </summary>		public unsafe void Clear()
		{
			fixed (ImDrawData* @this = &this)
			{
				ImGui.ClearNative(@this);
			}
		}

		/// <summary>		/// Helper to convert all buffers from indexed to non-indexed, in case you cannot render indexed. Note: this is slow and most likely a waste of resources. Always prefer indexed rendering!		/// </summary>		public unsafe void DeIndexAllBuffers()
		{
			fixed (ImDrawData* @this = &this)
			{
				ImGui.DeIndexAllBuffersNative(@this);
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImDrawData* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		/// <summary>		/// Helper to scale the ClipRect field of each ImDrawCmd. Use if your final output buffer is at a different scale than Dear ImGui expects, or if there is a difference between your window resolution and framebuffer resolution.		/// </summary>		public unsafe void ScaleClipRects(Vector2 fbScale)
		{
			fixed (ImDrawData* @this = &this)
			{
				ImGui.ScaleClipRectsNative(@this, fbScale);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImDrawDataPtr : IEquatable<ImDrawDataPtr>
	{
		public ImDrawDataPtr(ImDrawData* handle) { Handle = handle; }

		public ImDrawData* Handle;

		public bool IsNull => Handle == null;

		public static ImDrawDataPtr Null => new ImDrawDataPtr(null);

		public static implicit operator ImDrawDataPtr(ImDrawData* handle) => new ImDrawDataPtr(handle);

		public static implicit operator ImDrawData*(ImDrawDataPtr handle) => handle.Handle;

		public static bool operator ==(ImDrawDataPtr left, ImDrawDataPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImDrawDataPtr left, ImDrawDataPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImDrawDataPtr left, ImDrawData* right) => left.Handle == right;

		public static bool operator !=(ImDrawDataPtr left, ImDrawData* right) => left.Handle != right;

		public bool Equals(ImDrawDataPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImDrawDataPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImDrawDataPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		/// <summary>
		/// Only valid after Render() is called and before the next NewFrame() is called.<br/>
		/// </summary>
		public ref bool Valid => ref Unsafe.AsRef<bool>(&Handle->Valid);
		/// <summary>
		/// Number of ImDrawList* to render<br/>
		/// </summary>
		public ref int CmdListsCount => ref Unsafe.AsRef<int>(&Handle->CmdListsCount);
		/// <summary>
		/// For convenience, sum of all ImDrawList's IdxBuffer.Size<br/>
		/// </summary>
		public ref int TotalIdxCount => ref Unsafe.AsRef<int>(&Handle->TotalIdxCount);
		/// <summary>
		/// For convenience, sum of all ImDrawList's VtxBuffer.Size<br/>
		/// </summary>
		public ref int TotalVtxCount => ref Unsafe.AsRef<int>(&Handle->TotalVtxCount);
		/// <summary>
		/// Array of ImDrawList* to render. The ImDrawList are owned by ImGuiContext and only pointed to from here.<br/>
		/// </summary>
		public ref ImDrawListPtrPtr CmdLists => ref Unsafe.AsRef<ImDrawListPtrPtr>(&Handle->CmdLists);
		/// <summary>
		/// Top-left position of the viewport to render (== top-left of the orthogonal projection matrix to use) (== GetMainViewport()-&gt;Pos for the main viewport, == (0.0) in most single-viewport applications)<br/>
		/// </summary>
		public ref Vector2 DisplayPos => ref Unsafe.AsRef<Vector2>(&Handle->DisplayPos);
		/// <summary>
		/// Size of the viewport to render (== GetMainViewport()-&gt;Size for the main viewport, == io.DisplaySize in most single-viewport applications)<br/>
		/// </summary>
		public ref Vector2 DisplaySize => ref Unsafe.AsRef<Vector2>(&Handle->DisplaySize);
		/// <summary>
		/// Amount of pixels for each unit of DisplaySize. Based on io.DisplayFramebufferScale. Generally (1,1) on normal display, (2,2) on OSX with Retina display.<br/>
		/// </summary>
		public ref Vector2 FramebufferScale => ref Unsafe.AsRef<Vector2>(&Handle->FramebufferScale);
		/// <summary>
		/// Viewport carrying the ImDrawData instance, might be of use to the renderer (generally not).<br/>
		/// </summary>
		public ref ImGuiViewportPtr OwnerViewport => ref Unsafe.AsRef<ImGuiViewportPtr>(&Handle->OwnerViewport);

		/// <summary>		/// The ImDrawList are owned by ImGuiContext!		/// </summary>		public unsafe void Clear()
		{
			ImGui.ClearNative(Handle);
		}

		/// <summary>		/// Helper to convert all buffers from indexed to non-indexed, in case you cannot render indexed. Note: this is slow and most likely a waste of resources. Always prefer indexed rendering!		/// </summary>		public unsafe void DeIndexAllBuffers()
		{
			ImGui.DeIndexAllBuffersNative(Handle);
		}

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

		/// <summary>		/// Helper to scale the ClipRect field of each ImDrawCmd. Use if your final output buffer is at a different scale than Dear ImGui expects, or if there is a difference between your window resolution and framebuffer resolution.		/// </summary>		public unsafe void ScaleClipRects(Vector2 fbScale)
		{
			ImGui.ScaleClipRectsNative(Handle, fbScale);
		}

	}

	/// <summary>
	/// - Currently represents the Platform Window created by the application which is hosting our Dear ImGui windows.<br/>
	/// - With multi-viewport enabled, we extend this concept to have multiple active viewports.<br/>
	/// - In the future we will extend this concept further to also represent Platform Monitor and support a "no main platform window" operation mode.<br/>
	/// - About Main Area vs Work Area:<br/>
	/// - Main Area = entire viewport.<br/>
	/// - Work Area = entire viewport minus sections used by main menu bars (for platform windows), or by task bar (for platform monitor).<br/>
	/// - Windows are generally trying to stay within the Work Area of their host viewport.<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiViewport
	{
		/// <summary>
		/// Unique identifier for the viewport<br/>
		/// </summary>
		public int ID;

		/// <summary>
		/// See ImGuiViewportFlags_<br/>
		/// </summary>
		public ImGuiViewportFlags Flags;

		/// <summary>
		/// Main Area: Position of the viewport (Dear ImGui coordinates are the same as OS desktopnative coordinates)<br/>
		/// </summary>
		public Vector2 Pos;

		/// <summary>
		/// Main Area: Size of the viewport.<br/>
		/// </summary>
		public Vector2 Size;

		/// <summary>
		/// Work Area: Position of the viewport minus task bars, menus bars, status bars (&gt;= Pos)<br/>
		/// </summary>
		public Vector2 WorkPos;

		/// <summary>
		/// Work Area: Size of the viewport minus task bars, menu bars, status bars (&lt;= Size)<br/>
		/// </summary>
		public Vector2 WorkSize;

		/// <summary>
		/// 1.0f = 96 DPI = No extra scale.<br/>
		/// </summary>
		public float DpiScale;

		/// <summary>
		/// (Advanced) 0: no parent. Instruct the platform backend to setup a parentchild relationship between platform windows.<br/>
		/// </summary>
		public int ParentViewportId;

		/// <summary>
		/// The ImDrawData corresponding to this viewport. Valid after Render() and until the next call to NewFrame().<br/>
		/// </summary>
		public unsafe ImDrawData* DrawData;

		/// <summary>
		/// PlatformBackend Dependent Data<br/>
		/// Our design separate the Renderer and Platform backends to facilitate combining default backends with each others.<br/>
		/// When our create your own backend for a custom engine, it is possible that both Renderer and Platform will be handled<br/>
		/// by the same system and you may not need to use all the UserDataHandle fields.<br/>
		/// The library never uses those fields, they are merely storage to facilitate backend implementation. void* to hold custom data structure for the renderer (e.g. swap chain, framebuffers etc.). generally set by your Renderer_CreateWindow function.<br/>
		/// </summary>
		public unsafe void* RendererUserData;

		/// <summary>
		/// void* to hold custom data structure for the OS  platform (e.g. windowing info, render context). generally set by your Platform_CreateWindow function.<br/>
		/// </summary>
		public unsafe void* PlatformUserData;

		/// <summary>
		/// void* for FindViewportByPlatformHandle(). (e.g. suggested to use natural platform handle such as HWND, GLFWWindow*, SDL_Window*)<br/>
		/// </summary>
		public unsafe void* PlatformHandle;

		/// <summary>
		/// void* to hold lower-level, platform-native window handle (under Win32 this is expected to be a HWND, unused for other platforms), when using an abstraction layer like GLFW or SDL (where PlatformHandle would be a SDL_Window*)<br/>
		/// </summary>
		public unsafe void* PlatformHandleRaw;

		/// <summary>
		/// Platform window has been created (Platform_CreateWindow() has been called). This is false during the first frame where a viewport is being created.<br/>
		/// </summary>
		public byte PlatformWindowCreated;

		/// <summary>
		/// Platform window requested move (e.g. window was moved by the OS  host window manager, authoritative position will be OS window position)<br/>
		/// </summary>
		public byte PlatformRequestMove;

		/// <summary>
		/// Platform window requested resize (e.g. window was resized by the OS  host window manager, authoritative size will be OS window size)<br/>
		/// </summary>
		public byte PlatformRequestResize;

		/// <summary>
		/// Platform window requested closure (e.g. window was moved by the OS  host window manager, e.g. pressing ALT-F4)<br/>
		/// </summary>
		public byte PlatformRequestClose;





		public unsafe void Destroy()
		{
			fixed (ImGuiViewport* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiViewportPtr : IEquatable<ImGuiViewportPtr>
	{
		public ImGuiViewportPtr(ImGuiViewport* handle) { Handle = handle; }

		public ImGuiViewport* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiViewportPtr Null => new ImGuiViewportPtr(null);

		public static implicit operator ImGuiViewportPtr(ImGuiViewport* handle) => new ImGuiViewportPtr(handle);

		public static implicit operator ImGuiViewport*(ImGuiViewportPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiViewportPtr left, ImGuiViewportPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiViewportPtr left, ImGuiViewportPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiViewportPtr left, ImGuiViewport* right) => left.Handle == right;

		public static bool operator !=(ImGuiViewportPtr left, ImGuiViewport* right) => left.Handle != right;

		public bool Equals(ImGuiViewportPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiViewportPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiViewportPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		/// <summary>
		/// Unique identifier for the viewport<br/>
		/// </summary>
		public ref int ID => ref Unsafe.AsRef<int>(&Handle->ID);
		/// <summary>
		/// See ImGuiViewportFlags_<br/>
		/// </summary>
		public ref ImGuiViewportFlags Flags => ref Unsafe.AsRef<ImGuiViewportFlags>(&Handle->Flags);
		/// <summary>
		/// Main Area: Position of the viewport (Dear ImGui coordinates are the same as OS desktopnative coordinates)<br/>
		/// </summary>
		public ref Vector2 Pos => ref Unsafe.AsRef<Vector2>(&Handle->Pos);
		/// <summary>
		/// Main Area: Size of the viewport.<br/>
		/// </summary>
		public ref Vector2 Size => ref Unsafe.AsRef<Vector2>(&Handle->Size);
		/// <summary>
		/// Work Area: Position of the viewport minus task bars, menus bars, status bars (&gt;= Pos)<br/>
		/// </summary>
		public ref Vector2 WorkPos => ref Unsafe.AsRef<Vector2>(&Handle->WorkPos);
		/// <summary>
		/// Work Area: Size of the viewport minus task bars, menu bars, status bars (&lt;= Size)<br/>
		/// </summary>
		public ref Vector2 WorkSize => ref Unsafe.AsRef<Vector2>(&Handle->WorkSize);
		/// <summary>
		/// 1.0f = 96 DPI = No extra scale.<br/>
		/// </summary>
		public ref float DpiScale => ref Unsafe.AsRef<float>(&Handle->DpiScale);
		/// <summary>
		/// (Advanced) 0: no parent. Instruct the platform backend to setup a parentchild relationship between platform windows.<br/>
		/// </summary>
		public ref int ParentViewportId => ref Unsafe.AsRef<int>(&Handle->ParentViewportId);
		/// <summary>
		/// The ImDrawData corresponding to this viewport. Valid after Render() and until the next call to NewFrame().<br/>
		/// </summary>
		public ref ImDrawDataPtr DrawData => ref Unsafe.AsRef<ImDrawDataPtr>(&Handle->DrawData);
		/// <summary>
		/// PlatformBackend Dependent Data<br/>
		/// Our design separate the Renderer and Platform backends to facilitate combining default backends with each others.<br/>
		/// When our create your own backend for a custom engine, it is possible that both Renderer and Platform will be handled<br/>
		/// by the same system and you may not need to use all the UserDataHandle fields.<br/>
		/// The library never uses those fields, they are merely storage to facilitate backend implementation. void* to hold custom data structure for the renderer (e.g. swap chain, framebuffers etc.). generally set by your Renderer_CreateWindow function.<br/>
		/// </summary>
		public void* RendererUserData { get => Handle->RendererUserData; set => Handle->RendererUserData = value; }
		/// <summary>
		/// void* to hold custom data structure for the OS  platform (e.g. windowing info, render context). generally set by your Platform_CreateWindow function.<br/>
		/// </summary>
		public void* PlatformUserData { get => Handle->PlatformUserData; set => Handle->PlatformUserData = value; }
		/// <summary>
		/// void* for FindViewportByPlatformHandle(). (e.g. suggested to use natural platform handle such as HWND, GLFWWindow*, SDL_Window*)<br/>
		/// </summary>
		public void* PlatformHandle { get => Handle->PlatformHandle; set => Handle->PlatformHandle = value; }
		/// <summary>
		/// void* to hold lower-level, platform-native window handle (under Win32 this is expected to be a HWND, unused for other platforms), when using an abstraction layer like GLFW or SDL (where PlatformHandle would be a SDL_Window*)<br/>
		/// </summary>
		public void* PlatformHandleRaw { get => Handle->PlatformHandleRaw; set => Handle->PlatformHandleRaw = value; }
		/// <summary>
		/// Platform window has been created (Platform_CreateWindow() has been called). This is false during the first frame where a viewport is being created.<br/>
		/// </summary>
		public ref bool PlatformWindowCreated => ref Unsafe.AsRef<bool>(&Handle->PlatformWindowCreated);
		/// <summary>
		/// Platform window requested move (e.g. window was moved by the OS  host window manager, authoritative position will be OS window position)<br/>
		/// </summary>
		public ref bool PlatformRequestMove => ref Unsafe.AsRef<bool>(&Handle->PlatformRequestMove);
		/// <summary>
		/// Platform window requested resize (e.g. window was resized by the OS  host window manager, authoritative size will be OS window size)<br/>
		/// </summary>
		public ref bool PlatformRequestResize => ref Unsafe.AsRef<bool>(&Handle->PlatformRequestResize);
		/// <summary>
		/// Platform window requested closure (e.g. window was moved by the OS  host window manager, e.g. pressing ALT-F4)<br/>
		/// </summary>
		public ref bool PlatformRequestClose => ref Unsafe.AsRef<bool>(&Handle->PlatformRequestClose);

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiViewportPtrPtr : IEquatable<ImGuiViewportPtrPtr>
	{
		public ImGuiViewportPtrPtr(ImGuiViewport** handle) { Handle = handle; }

		public ImGuiViewport** Handle;

		public bool IsNull => Handle == null;

		public static ImGuiViewportPtrPtr Null => new ImGuiViewportPtrPtr(null);

		public static implicit operator ImGuiViewportPtrPtr(ImGuiViewport** handle) => new ImGuiViewportPtrPtr(handle);

		public static implicit operator ImGuiViewport**(ImGuiViewportPtrPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiViewportPtrPtr left, ImGuiViewportPtrPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiViewportPtrPtr left, ImGuiViewportPtrPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiViewportPtrPtr left, ImGuiViewport** right) => left.Handle == right;

		public static bool operator !=(ImGuiViewportPtrPtr left, ImGuiViewport** right) => left.Handle != right;

		public bool Equals(ImGuiViewportPtrPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiViewportPtrPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiViewportPtrPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ImGuiViewportPtr this[int index]
		{
			get => Handle[index]; set => Handle[index] = value;
		}
	}

	/// <summary>
	/// Helper to build glyph ranges from textstring data. Feed your application stringscharacters to it then call BuildRanges().<br/>
	/// This is essentially a tightly packed of vector of 64k booleans = 8KB storage.<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImFontGlyphRangesBuilder
	{
		/// <summary>
		/// Store 1-bit per Unicode code point (0=unused, 1=used)<br/>
		/// </summary>
		public ImVectorImU32 UsedChars;





		/// <summary>		/// Add character		/// </summary>		public unsafe void AddChar(char c)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				ImGui.AddCharNative(@this, c);
			}
		}

		/// <summary>		/// Add ranges, e.g. builder.AddRanges(ImFontAtlas::GetGlyphRangesDefault()) to force add all of ASCIILatin+Ext		/// </summary>		public unsafe void AddRanges(char* ranges)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				ImGui.AddRangesNative(@this, ranges);
			}
		}

		/// <summary>		/// Add ranges, e.g. builder.AddRanges(ImFontAtlas::GetGlyphRangesDefault()) to force add all of ASCIILatin+Ext		/// </summary>		public unsafe void AddRanges(ref char ranges)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				fixed (char* pranges = &ranges)
				{
					ImGui.AddRangesNative(@this, (char*)pranges);
				}
			}
		}

		/// <summary>		/// Add string (each character of the UTF-8 string are added)		/// </summary>		public unsafe void AddText(byte* text, byte* textEnd)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				ImGui.AddTextNative(@this, text, textEnd);
			}
		}

		/// <summary>		/// Add string (each character of the UTF-8 string are added)		/// </summary>		public unsafe void AddText(byte* text)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				ImGui.AddTextNative(@this, text, (byte*)(default));
			}
		}

		/// <summary>		/// Add string (each character of the UTF-8 string are added)		/// </summary>		public unsafe void AddText(ref byte text, byte* textEnd)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					ImGui.AddTextNative(@this, (byte*)ptext, textEnd);
				}
			}
		}

		/// <summary>		/// Add string (each character of the UTF-8 string are added)		/// </summary>		public unsafe void AddText(ref byte text)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					ImGui.AddTextNative(@this, (byte*)ptext, (byte*)(default));
				}
			}
		}

		/// <summary>		/// Add string (each character of the UTF-8 string are added)		/// </summary>		public unsafe void AddText(string text, byte* textEnd)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, pStr0, textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>		/// Add string (each character of the UTF-8 string are added)		/// </summary>		public unsafe void AddText(string text)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, pStr0, (byte*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>		/// Add string (each character of the UTF-8 string are added)		/// </summary>		public unsafe void AddText(byte* text, ref byte textEnd)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(@this, text, (byte*)ptextEnd);
				}
			}
		}

		/// <summary>		/// Add string (each character of the UTF-8 string are added)		/// </summary>		public unsafe void AddText(byte* text, string textEnd)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, text, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>		/// Add string (each character of the UTF-8 string are added)		/// </summary>		public unsafe void AddText(ref byte text, ref byte textEnd)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, (byte*)ptext, (byte*)ptextEnd);
					}
				}
			}
		}

		/// <summary>		/// Add string (each character of the UTF-8 string are added)		/// </summary>		public unsafe void AddText(string text, string textEnd)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.AddTextNative(@this, pStr0, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>		/// Output new ranges		/// </summary>		public unsafe void BuildRanges(ImVectorImWcharPtr outRanges)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				ImGui.BuildRangesNative(@this, outRanges);
			}
		}

		/// <summary>		/// Output new ranges		/// </summary>		public unsafe void BuildRanges(ref ImVectorImWchar outRanges)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				fixed (ImVectorImWchar* poutRanges = &outRanges)
				{
					ImGui.BuildRangesNative(@this, (ImVectorImWchar*)poutRanges);
				}
			}
		}

		public unsafe void Clear()
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				ImGui.ClearNative(@this);
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		/// <summary>		/// Get bit n in the array		/// </summary>		public unsafe bool GetBit(nuint n)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				byte ret = ImGui.GetBitNative(@this, n);
				return ret != 0;
			}
		}

		/// <summary>		/// Set bit n in the array		/// </summary>		public unsafe void SetBit(nuint n)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				ImGui.SetBitNative(@this, n);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImFontGlyphRangesBuilderPtr : IEquatable<ImFontGlyphRangesBuilderPtr>
	{
		public ImFontGlyphRangesBuilderPtr(ImFontGlyphRangesBuilder* handle) { Handle = handle; }

		public ImFontGlyphRangesBuilder* Handle;

		public bool IsNull => Handle == null;

		public static ImFontGlyphRangesBuilderPtr Null => new ImFontGlyphRangesBuilderPtr(null);

		public static implicit operator ImFontGlyphRangesBuilderPtr(ImFontGlyphRangesBuilder* handle) => new ImFontGlyphRangesBuilderPtr(handle);

		public static implicit operator ImFontGlyphRangesBuilder*(ImFontGlyphRangesBuilderPtr handle) => handle.Handle;

		public static bool operator ==(ImFontGlyphRangesBuilderPtr left, ImFontGlyphRangesBuilderPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImFontGlyphRangesBuilderPtr left, ImFontGlyphRangesBuilderPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImFontGlyphRangesBuilderPtr left, ImFontGlyphRangesBuilder* right) => left.Handle == right;

		public static bool operator !=(ImFontGlyphRangesBuilderPtr left, ImFontGlyphRangesBuilder* right) => left.Handle != right;

		public bool Equals(ImFontGlyphRangesBuilderPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImFontGlyphRangesBuilderPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImFontGlyphRangesBuilderPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		/// <summary>
		/// Store 1-bit per Unicode code point (0=unused, 1=used)<br/>
		/// </summary>
		public ref ImVectorImU32 UsedChars => ref Unsafe.AsRef<ImVectorImU32>(&Handle->UsedChars);

		/// <summary>		/// Add character		/// </summary>		public unsafe void AddChar(char c)
		{
			ImGui.AddCharNative(Handle, c);
		}

		/// <summary>		/// Add ranges, e.g. builder.AddRanges(ImFontAtlas::GetGlyphRangesDefault()) to force add all of ASCIILatin+Ext		/// </summary>		public unsafe void AddRanges(char* ranges)
		{
			ImGui.AddRangesNative(Handle, ranges);
		}

		/// <summary>		/// Add ranges, e.g. builder.AddRanges(ImFontAtlas::GetGlyphRangesDefault()) to force add all of ASCIILatin+Ext		/// </summary>		public unsafe void AddRanges(ref char ranges)
		{
			fixed (char* pranges = &ranges)
			{
				ImGui.AddRangesNative(Handle, (char*)pranges);
			}
		}

		/// <summary>		/// Add string (each character of the UTF-8 string are added)		/// </summary>		public unsafe void AddText(byte* text, byte* textEnd)
		{
			ImGui.AddTextNative(Handle, text, textEnd);
		}

		/// <summary>		/// Add string (each character of the UTF-8 string are added)		/// </summary>		public unsafe void AddText(byte* text)
		{
			ImGui.AddTextNative(Handle, text, (byte*)(default));
		}

		/// <summary>		/// Add string (each character of the UTF-8 string are added)		/// </summary>		public unsafe void AddText(ref byte text, byte* textEnd)
		{
			fixed (byte* ptext = &text)
			{
				ImGui.AddTextNative(Handle, (byte*)ptext, textEnd);
			}
		}

		/// <summary>		/// Add string (each character of the UTF-8 string are added)		/// </summary>		public unsafe void AddText(ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				ImGui.AddTextNative(Handle, (byte*)ptext, (byte*)(default));
			}
		}

		/// <summary>		/// Add string (each character of the UTF-8 string are added)		/// </summary>		public unsafe void AddText(string text, byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.AddTextNative(Handle, pStr0, textEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>		/// Add string (each character of the UTF-8 string are added)		/// </summary>		public unsafe void AddText(string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.AddTextNative(Handle, pStr0, (byte*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>		/// Add string (each character of the UTF-8 string are added)		/// </summary>		public unsafe void AddText(byte* text, ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				ImGui.AddTextNative(Handle, text, (byte*)ptextEnd);
			}
		}

		/// <summary>		/// Add string (each character of the UTF-8 string are added)		/// </summary>		public unsafe void AddText(byte* text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.AddTextNative(Handle, text, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>		/// Add string (each character of the UTF-8 string are added)		/// </summary>		public unsafe void AddText(ref byte text, ref byte textEnd)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(Handle, (byte*)ptext, (byte*)ptextEnd);
				}
			}
		}

		/// <summary>		/// Add string (each character of the UTF-8 string are added)		/// </summary>		public unsafe void AddText(string text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ImGui.AddTextNative(Handle, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>		/// Output new ranges		/// </summary>		public unsafe void BuildRanges(ImVectorImWcharPtr outRanges)
		{
			ImGui.BuildRangesNative(Handle, outRanges);
		}

		/// <summary>		/// Output new ranges		/// </summary>		public unsafe void BuildRanges(ref ImVectorImWchar outRanges)
		{
			fixed (ImVectorImWchar* poutRanges = &outRanges)
			{
				ImGui.BuildRangesNative(Handle, (ImVectorImWchar*)poutRanges);
			}
		}

		public unsafe void Clear()
		{
			ImGui.ClearNative(Handle);
		}

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

		/// <summary>		/// Get bit n in the array		/// </summary>		public unsafe bool GetBit(nuint n)
		{
			byte ret = ImGui.GetBitNative(Handle, n);
			return ret != 0;
		}

		/// <summary>		/// Set bit n in the array		/// </summary>		public unsafe void SetBit(nuint n)
		{
			ImGui.SetBitNative(Handle, n);
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImU32
	{
		public int Size;
		public int Capacity;
		public unsafe uint* Data;


	}

	/// <summary>
	/// Helpers: ImVec2ImVec4 operators<br/>
	/// - It is important that we are keeping those disabled by default so they don't leak in user space.<br/>
	/// - This is in order to allow user enabling implicit cast operators between ImVec2ImVec4 and their own types (using IM_VEC2_CLASS_EXTRA in imconfig.h)<br/>
	/// - You can use '#define IMGUI_DEFINE_MATH_OPERATORS' to import our operators, provided as a courtesy.<br/>
	/// Helpers macros to generate 32-bit encoded colors<br/>
	/// User can declare their own format by #defining the 5 _SHIFT_MASK macros in their imconfig file.<br/>
	/// Helper: ImColor() implicitly converts colors to either ImU32 (packed 4x1 byte) or ImVec4 (4x1 float)<br/>
	/// Prefer using IM_COL32() macros if you want a guaranteed compile-time ImU32 for usage with ImDrawList API.<br/>
	/// **Avoid storing ImColor! Store either u32 of ImVec4. This is not a full-featured color class. MAY OBSOLETE.<br/>
	/// **None of the ImGui API are using ImColor directly but you can use it as a convenience to pass colors in either ImU32 or ImVec4 formats. Explicitly cast to ImU32 or ImVec4 if needed.<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImColor
	{
		public Vector4 Value;




		public unsafe void Destroy()
		{
			fixed (ImColor* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe void HSV(float h, float s, float v, float a)
		{
			fixed (ImColor* @this = &this)
			{
				ImGui.HSVNative(@this, h, s, v, a);
			}
		}

		public unsafe void HSV(float h, float s, float v)
		{
			fixed (ImColor* @this = &this)
			{
				ImGui.HSVNative(@this, h, s, v, (float)(1.0f));
			}
		}

		public unsafe void SetHSV(float h, float s, float v, float a)
		{
			fixed (ImColor* @this = &this)
			{
				ImGui.SetHSVNative(@this, h, s, v, a);
			}
		}

		public unsafe void SetHSV(float h, float s, float v)
		{
			fixed (ImColor* @this = &this)
			{
				ImGui.SetHSVNative(@this, h, s, v, (float)(1.0f));
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImColorPtr : IEquatable<ImColorPtr>
	{
		public ImColorPtr(ImColor* handle) { Handle = handle; }

		public ImColor* Handle;

		public bool IsNull => Handle == null;

		public static ImColorPtr Null => new ImColorPtr(null);

		public static implicit operator ImColorPtr(ImColor* handle) => new ImColorPtr(handle);

		public static implicit operator ImColor*(ImColorPtr handle) => handle.Handle;

		public static bool operator ==(ImColorPtr left, ImColorPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImColorPtr left, ImColorPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImColorPtr left, ImColor* right) => left.Handle == right;

		public static bool operator !=(ImColorPtr left, ImColor* right) => left.Handle != right;

		public bool Equals(ImColorPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImColorPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImColorPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref Vector4 Value => ref Unsafe.AsRef<Vector4>(&Handle->Value);

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

		public unsafe void HSV(float h, float s, float v, float a)
		{
			ImGui.HSVNative(Handle, h, s, v, a);
		}

		public unsafe void HSV(float h, float s, float v)
		{
			ImGui.HSVNative(Handle, h, s, v, (float)(1.0f));
		}

		public unsafe void SetHSV(float h, float s, float v, float a)
		{
			ImGui.SetHSVNative(Handle, h, s, v, a);
		}

		public unsafe void SetHSV(float h, float s, float v)
		{
			ImGui.SetHSVNative(Handle, h, s, v, (float)(1.0f));
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiContext
	{
		public byte Initialized;
		/// <summary>
		/// IO.Fonts-&gt; is owned by the ImGuiContext and will be destructed along with it.<br/>
		/// </summary>
		public byte FontAtlasOwnedByContext;

		public ImGuiIO IO;
		public ImGuiPlatformIO PlatformIO;
		public ImGuiStyle Style;
		/// <summary>
		/// = g.IO.ConfigFlags at the time of NewFrame()<br/>
		/// </summary>
		public ImGuiConfigFlags ConfigFlagsCurrFrame;

		public ImGuiConfigFlags ConfigFlagsLastFrame;
		/// <summary>
		/// (Shortcut) == FontStack.empty() ? IO.Font : FontStack.back()<br/>
		/// </summary>
		public unsafe ImFont* Font;

		/// <summary>
		/// (Shortcut) == FontBaseSize * g.CurrentWindow-&gt;FontWindowScale == window-&gt;FontSize(). Text height for current window.<br/>
		/// </summary>
		public float FontSize;

		/// <summary>
		/// (Shortcut) == IO.FontGlobalScale * Font-&gt;Scale * Font-&gt;FontSize. Base text height.<br/>
		/// </summary>
		public float FontBaseSize;

		public ImDrawListSharedData DrawListSharedData;
		public double Time;
		public int FrameCount;
		public int FrameCountEnded;
		public int FrameCountPlatformEnded;
		public int FrameCountRendered;
		/// <summary>
		/// Set by NewFrame(), cleared by EndFrame()<br/>
		/// </summary>
		public byte WithinFrameScope;

		/// <summary>
		/// Set by NewFrame(), cleared by EndFrame() when the implicit debug window has been pushed<br/>
		/// </summary>
		public byte WithinFrameScopeWithImplicitWindow;

		/// <summary>
		/// Set within EndChild()<br/>
		/// </summary>
		public byte WithinEndChild;

		/// <summary>
		/// Request full GC<br/>
		/// </summary>
		public byte GcCompactAll;

		/// <summary>
		/// Will call test engine hooks: ImGuiTestEngineHook_ItemAdd(), ImGuiTestEngineHook_ItemInfo(), ImGuiTestEngineHook_Log()<br/>
		/// </summary>
		public byte TestEngineHookItems;

		/// <summary>
		/// Test engine user data<br/>
		/// </summary>
		public unsafe void* TestEngine;

		/// <summary>
		/// Inputs Input events which will be trickledwritten into IO structure.<br/>
		/// </summary>
		public ImVectorImGuiInputEvent InputEventsQueue;

		/// <summary>
		/// Past input events processed in NewFrame(). This is to allow domain-specific application to access e.g mousepen trail.<br/>
		/// </summary>
		public ImVectorImGuiInputEvent InputEventsTrail;

		public ImGuiMouseSource InputEventsNextMouseSource;
		public uint InputEventsNextEventId;
		/// <summary>
		/// Windows state Windows, sorted in display order, back to front<br/>
		/// </summary>
		public ImVectorImGuiWindowPtr Windows;

		/// <summary>
		/// Root windows, sorted in focus order, back to front.<br/>
		/// </summary>
		public ImVectorImGuiWindowPtr WindowsFocusOrder;

		/// <summary>
		/// Temporary buffer used in EndFrame() to reorder windows so parents are kept before their child<br/>
		/// </summary>
		public ImVectorImGuiWindowPtr WindowsTempSortBuffer;

		public ImVectorImGuiWindowStackData CurrentWindowStack;
		/// <summary>
		/// Map window's ImGuiID to ImGuiWindow*<br/>
		/// </summary>
		public ImGuiStorage WindowsById;

		/// <summary>
		/// Number of unique windows submitted by frame<br/>
		/// </summary>
		public int WindowsActiveCount;

		/// <summary>
		/// Padding around resizable windows for which hovering on counts as hovering the window == ImMax(style.TouchExtraPadding, WINDOWS_HOVER_PADDING)<br/>
		/// </summary>
		public Vector2 WindowsHoverPadding;

		/// <summary>
		/// Window being drawn into<br/>
		/// </summary>
		public unsafe ImGuiWindow* CurrentWindow;

		/// <summary>
		/// Window the mouse is hovering. Will typically catch mouse inputs.<br/>
		/// </summary>
		public unsafe ImGuiWindow* HoveredWindow;

		/// <summary>
		/// Hovered window ignoring MovingWindow. Only set if MovingWindow is set.<br/>
		/// </summary>
		public unsafe ImGuiWindow* HoveredWindowUnderMovingWindow;

		/// <summary>
		/// Track the window we clicked on (in order to preserve focus). The actual window that is moved is generally MovingWindow-&gt;RootWindowDockTree.<br/>
		/// </summary>
		public unsafe ImGuiWindow* MovingWindow;

		/// <summary>
		/// Track the window we started mouse-wheeling on. Until a timer elapse or mouse has moved, generally keep scrolling the same window even if during the course of scrolling the mouse ends up hovering a child window.<br/>
		/// </summary>
		public unsafe ImGuiWindow* WheelingWindow;

		public Vector2 WheelingWindowRefMousePos;
		/// <summary>
		/// This may be set one frame before WheelingWindow is != NULL<br/>
		/// </summary>
		public int WheelingWindowStartFrame;

		public float WheelingWindowReleaseTimer;
		public Vector2 WheelingWindowWheelRemainder;
		public Vector2 WheelingAxisAvg;
		/// <summary>
		/// Itemwidgets state and tracking information Will call core hooks: DebugHookIdInfo() from GetID functions, used by Stack Tool [next HoveredIdActiveId to not pull in an extra cache-line]<br/>
		/// </summary>
		public int DebugHookIdInfo;

		/// <summary>
		/// Hovered widget, filled during the frame<br/>
		/// </summary>
		public int HoveredId;

		public int HoveredIdPreviousFrame;
		public byte HoveredIdAllowOverlap;
		/// <summary>
		/// At least one widget passed the rect test, but has been discarded by disabled flag or popup inhibit. May be true even if HoveredId == 0.<br/>
		/// </summary>
		public byte HoveredIdDisabled;

		/// <summary>
		/// Measure contiguous hovering time<br/>
		/// </summary>
		public float HoveredIdTimer;

		/// <summary>
		/// Measure contiguous hovering time where the item has not been active<br/>
		/// </summary>
		public float HoveredIdNotActiveTimer;

		/// <summary>
		/// Active widget<br/>
		/// </summary>
		public int ActiveId;

		/// <summary>
		/// Active widget has been seen this frame (we can't use a bool as the ActiveId may change within the frame)<br/>
		/// </summary>
		public int ActiveIdIsAlive;

		public float ActiveIdTimer;
		/// <summary>
		/// Set at the time of activation for one frame<br/>
		/// </summary>
		public byte ActiveIdIsJustActivated;

		/// <summary>
		/// Active widget allows another widget to steal active id (generally for overlapping widgets, but not always)<br/>
		/// </summary>
		public byte ActiveIdAllowOverlap;

		/// <summary>
		/// Disable losing active id if the active id window gets unfocused.<br/>
		/// </summary>
		public byte ActiveIdNoClearOnFocusLoss;

		/// <summary>
		/// Track whether the active id led to a press (this is to allow changing between PressOnClick and PressOnRelease without pressing twice). Used by range_select branch.<br/>
		/// </summary>
		public byte ActiveIdHasBeenPressedBefore;

		/// <summary>
		/// Was the value associated to the widget Edited over the course of the Active state.<br/>
		/// </summary>
		public byte ActiveIdHasBeenEditedBefore;

		public byte ActiveIdHasBeenEditedThisFrame;
		/// <summary>
		/// Clicked offset from upper-left corner, if applicable (currently only set by ButtonBehavior)<br/>
		/// </summary>
		public Vector2 ActiveIdClickOffset;

		public unsafe ImGuiWindow* ActiveIdWindow;
		/// <summary>
		/// Activating source: ImGuiInputSource_Mouse OR ImGuiInputSource_Keyboard OR ImGuiInputSource_Gamepad<br/>
		/// </summary>
		public ImGuiInputSource ActiveIdSource;

		public int ActiveIdMouseButton;
		public int ActiveIdPreviousFrame;
		public byte ActiveIdPreviousFrameIsAlive;
		public byte ActiveIdPreviousFrameHasBeenEditedBefore;
		public unsafe ImGuiWindow* ActiveIdPreviousFrameWindow;
		/// <summary>
		/// Store the last non-zero ActiveId, useful for animation.<br/>
		/// </summary>
		public int LastActiveId;

		/// <summary>
		/// Store the last non-zero ActiveId timer since the beginning of activation, useful for animation.<br/>
		/// </summary>
		public float LastActiveIdTimer;

		public ImGuiKeyOwnerData KeysOwnerData_0;
		public ImGuiKeyOwnerData KeysOwnerData_1;
		public ImGuiKeyOwnerData KeysOwnerData_2;
		public ImGuiKeyOwnerData KeysOwnerData_3;
		public ImGuiKeyOwnerData KeysOwnerData_4;
		public ImGuiKeyOwnerData KeysOwnerData_5;
		public ImGuiKeyOwnerData KeysOwnerData_6;
		public ImGuiKeyOwnerData KeysOwnerData_7;
		public ImGuiKeyOwnerData KeysOwnerData_8;
		public ImGuiKeyOwnerData KeysOwnerData_9;
		public ImGuiKeyOwnerData KeysOwnerData_10;
		public ImGuiKeyOwnerData KeysOwnerData_11;
		public ImGuiKeyOwnerData KeysOwnerData_12;
		public ImGuiKeyOwnerData KeysOwnerData_13;
		public ImGuiKeyOwnerData KeysOwnerData_14;
		public ImGuiKeyOwnerData KeysOwnerData_15;
		public ImGuiKeyOwnerData KeysOwnerData_16;
		public ImGuiKeyOwnerData KeysOwnerData_17;
		public ImGuiKeyOwnerData KeysOwnerData_18;
		public ImGuiKeyOwnerData KeysOwnerData_19;
		public ImGuiKeyOwnerData KeysOwnerData_20;
		public ImGuiKeyOwnerData KeysOwnerData_21;
		public ImGuiKeyOwnerData KeysOwnerData_22;
		public ImGuiKeyOwnerData KeysOwnerData_23;
		public ImGuiKeyOwnerData KeysOwnerData_24;
		public ImGuiKeyOwnerData KeysOwnerData_25;
		public ImGuiKeyOwnerData KeysOwnerData_26;
		public ImGuiKeyOwnerData KeysOwnerData_27;
		public ImGuiKeyOwnerData KeysOwnerData_28;
		public ImGuiKeyOwnerData KeysOwnerData_29;
		public ImGuiKeyOwnerData KeysOwnerData_30;
		public ImGuiKeyOwnerData KeysOwnerData_31;
		public ImGuiKeyOwnerData KeysOwnerData_32;
		public ImGuiKeyOwnerData KeysOwnerData_33;
		public ImGuiKeyOwnerData KeysOwnerData_34;
		public ImGuiKeyOwnerData KeysOwnerData_35;
		public ImGuiKeyOwnerData KeysOwnerData_36;
		public ImGuiKeyOwnerData KeysOwnerData_37;
		public ImGuiKeyOwnerData KeysOwnerData_38;
		public ImGuiKeyOwnerData KeysOwnerData_39;
		public ImGuiKeyOwnerData KeysOwnerData_40;
		public ImGuiKeyOwnerData KeysOwnerData_41;
		public ImGuiKeyOwnerData KeysOwnerData_42;
		public ImGuiKeyOwnerData KeysOwnerData_43;
		public ImGuiKeyOwnerData KeysOwnerData_44;
		public ImGuiKeyOwnerData KeysOwnerData_45;
		public ImGuiKeyOwnerData KeysOwnerData_46;
		public ImGuiKeyOwnerData KeysOwnerData_47;
		public ImGuiKeyOwnerData KeysOwnerData_48;
		public ImGuiKeyOwnerData KeysOwnerData_49;
		public ImGuiKeyOwnerData KeysOwnerData_50;
		public ImGuiKeyOwnerData KeysOwnerData_51;
		public ImGuiKeyOwnerData KeysOwnerData_52;
		public ImGuiKeyOwnerData KeysOwnerData_53;
		public ImGuiKeyOwnerData KeysOwnerData_54;
		public ImGuiKeyOwnerData KeysOwnerData_55;
		public ImGuiKeyOwnerData KeysOwnerData_56;
		public ImGuiKeyOwnerData KeysOwnerData_57;
		public ImGuiKeyOwnerData KeysOwnerData_58;
		public ImGuiKeyOwnerData KeysOwnerData_59;
		public ImGuiKeyOwnerData KeysOwnerData_60;
		public ImGuiKeyOwnerData KeysOwnerData_61;
		public ImGuiKeyOwnerData KeysOwnerData_62;
		public ImGuiKeyOwnerData KeysOwnerData_63;
		public ImGuiKeyOwnerData KeysOwnerData_64;
		public ImGuiKeyOwnerData KeysOwnerData_65;
		public ImGuiKeyOwnerData KeysOwnerData_66;
		public ImGuiKeyOwnerData KeysOwnerData_67;
		public ImGuiKeyOwnerData KeysOwnerData_68;
		public ImGuiKeyOwnerData KeysOwnerData_69;
		public ImGuiKeyOwnerData KeysOwnerData_70;
		public ImGuiKeyOwnerData KeysOwnerData_71;
		public ImGuiKeyOwnerData KeysOwnerData_72;
		public ImGuiKeyOwnerData KeysOwnerData_73;
		public ImGuiKeyOwnerData KeysOwnerData_74;
		public ImGuiKeyOwnerData KeysOwnerData_75;
		public ImGuiKeyOwnerData KeysOwnerData_76;
		public ImGuiKeyOwnerData KeysOwnerData_77;
		public ImGuiKeyOwnerData KeysOwnerData_78;
		public ImGuiKeyOwnerData KeysOwnerData_79;
		public ImGuiKeyOwnerData KeysOwnerData_80;
		public ImGuiKeyOwnerData KeysOwnerData_81;
		public ImGuiKeyOwnerData KeysOwnerData_82;
		public ImGuiKeyOwnerData KeysOwnerData_83;
		public ImGuiKeyOwnerData KeysOwnerData_84;
		public ImGuiKeyOwnerData KeysOwnerData_85;
		public ImGuiKeyOwnerData KeysOwnerData_86;
		public ImGuiKeyOwnerData KeysOwnerData_87;
		public ImGuiKeyOwnerData KeysOwnerData_88;
		public ImGuiKeyOwnerData KeysOwnerData_89;
		public ImGuiKeyOwnerData KeysOwnerData_90;
		public ImGuiKeyOwnerData KeysOwnerData_91;
		public ImGuiKeyOwnerData KeysOwnerData_92;
		public ImGuiKeyOwnerData KeysOwnerData_93;
		public ImGuiKeyOwnerData KeysOwnerData_94;
		public ImGuiKeyOwnerData KeysOwnerData_95;
		public ImGuiKeyOwnerData KeysOwnerData_96;
		public ImGuiKeyOwnerData KeysOwnerData_97;
		public ImGuiKeyOwnerData KeysOwnerData_98;
		public ImGuiKeyOwnerData KeysOwnerData_99;
		public ImGuiKeyOwnerData KeysOwnerData_100;
		public ImGuiKeyOwnerData KeysOwnerData_101;
		public ImGuiKeyOwnerData KeysOwnerData_102;
		public ImGuiKeyOwnerData KeysOwnerData_103;
		public ImGuiKeyOwnerData KeysOwnerData_104;
		public ImGuiKeyOwnerData KeysOwnerData_105;
		public ImGuiKeyOwnerData KeysOwnerData_106;
		public ImGuiKeyOwnerData KeysOwnerData_107;
		public ImGuiKeyOwnerData KeysOwnerData_108;
		public ImGuiKeyOwnerData KeysOwnerData_109;
		public ImGuiKeyOwnerData KeysOwnerData_110;
		public ImGuiKeyOwnerData KeysOwnerData_111;
		public ImGuiKeyOwnerData KeysOwnerData_112;
		public ImGuiKeyOwnerData KeysOwnerData_113;
		public ImGuiKeyOwnerData KeysOwnerData_114;
		public ImGuiKeyOwnerData KeysOwnerData_115;
		public ImGuiKeyOwnerData KeysOwnerData_116;
		public ImGuiKeyOwnerData KeysOwnerData_117;
		public ImGuiKeyOwnerData KeysOwnerData_118;
		public ImGuiKeyOwnerData KeysOwnerData_119;
		public ImGuiKeyOwnerData KeysOwnerData_120;
		public ImGuiKeyOwnerData KeysOwnerData_121;
		public ImGuiKeyOwnerData KeysOwnerData_122;
		public ImGuiKeyOwnerData KeysOwnerData_123;
		public ImGuiKeyOwnerData KeysOwnerData_124;
		public ImGuiKeyOwnerData KeysOwnerData_125;
		public ImGuiKeyOwnerData KeysOwnerData_126;
		public ImGuiKeyOwnerData KeysOwnerData_127;
		public ImGuiKeyOwnerData KeysOwnerData_128;
		public ImGuiKeyOwnerData KeysOwnerData_129;
		public ImGuiKeyOwnerData KeysOwnerData_130;
		public ImGuiKeyOwnerData KeysOwnerData_131;
		public ImGuiKeyOwnerData KeysOwnerData_132;
		public ImGuiKeyOwnerData KeysOwnerData_133;
		public ImGuiKeyOwnerData KeysOwnerData_134;
		public ImGuiKeyOwnerData KeysOwnerData_135;
		public ImGuiKeyOwnerData KeysOwnerData_136;
		public ImGuiKeyOwnerData KeysOwnerData_137;
		public ImGuiKeyOwnerData KeysOwnerData_138;
		public ImGuiKeyOwnerData KeysOwnerData_139;
		public ImGuiKeyRoutingTable KeysRoutingTable;
		/// <summary>
		/// Active widget will want to read those nav move requests (e.g. can activate a button and move away from it)<br/>
		/// </summary>
		public uint ActiveIdUsingNavDirMask;

		/// <summary>
		/// Active widget will want to read all keyboard keys inputs. (FIXME: This is a shortcut for not taking ownership of 100+ keys but perhaps best to not have the inconsistency)<br/>
		/// </summary>
		public byte ActiveIdUsingAllKeyboardKeys;

		/// <summary>
		/// If you used this. Since (IMGUI_VERSION_NUM &gt;= 18804) : 'g.ActiveIdUsingNavInputMask |= (1 &lt;&lt; ImGuiNavInput_Cancel);' becomes 'SetKeyOwner(ImGuiKey_Escape, g.ActiveId) andor SetKeyOwner(ImGuiKey_NavGamepadCancel, g.ActiveId);'<br/>
		/// </summary>
		public uint ActiveIdUsingNavInputMask;

		/// <summary>
		/// Next windowitem data == g.FocusScopeStack.back()<br/>
		/// </summary>
		public int CurrentFocusScopeId;

		/// <summary>
		/// == g.ItemFlagsStack.back()<br/>
		/// </summary>
		public ImGuiItemFlags CurrentItemFlags;

		/// <summary>
		/// Storage for DebugLocateItemOnHover() feature: this is read by ItemAdd() so we keep it in a hotcached location<br/>
		/// </summary>
		public int DebugLocateId;

		/// <summary>
		/// Storage for SetNextItem** functions<br/>
		/// </summary>
		public ImGuiNextItemData NextItemData;

		/// <summary>
		/// Storage for last submitted item (setup by ItemAdd)<br/>
		/// </summary>
		public ImGuiLastItemData LastItemData;

		/// <summary>
		/// Storage for SetNextWindow** functions<br/>
		/// </summary>
		public ImGuiNextWindowData NextWindowData;

		/// <summary>
		/// Shared stacks Stack for PushStyleColor()PopStyleColor() - inherited by Begin()<br/>
		/// </summary>
		public ImVectorImGuiColorMod ColorStack;

		/// <summary>
		/// Stack for PushStyleVar()PopStyleVar() - inherited by Begin()<br/>
		/// </summary>
		public ImVectorImGuiStyleMod StyleVarStack;

		/// <summary>
		/// Stack for PushFont()PopFont() - inherited by Begin()<br/>
		/// </summary>
		public ImVectorImFontPtr FontStack;

		/// <summary>
		/// Stack for PushFocusScope()PopFocusScope() - inherited by BeginChild(), pushed into by Begin()<br/>
		/// </summary>
		public ImVectorImGuiID FocusScopeStack;

		/// <summary>
		/// Stack for PushItemFlag()PopItemFlag() - inherited by Begin()<br/>
		/// </summary>
		public ImVectorImGuiItemFlags ItemFlagsStack;

		/// <summary>
		/// Stack for BeginGroup()EndGroup() - not inherited by Begin()<br/>
		/// </summary>
		public ImVectorImGuiGroupData GroupStack;

		/// <summary>
		/// Which popups are open (persistent)<br/>
		/// </summary>
		public ImVectorImGuiPopupData OpenPopupStack;

		/// <summary>
		/// Which level of BeginPopup() we are in (reset every frame)<br/>
		/// </summary>
		public ImVectorImGuiPopupData BeginPopupStack;

		public int BeginMenuCount;
		/// <summary>
		/// Viewports Active viewports (always 1+, and generally 1 unless multi-viewports are enabled). Each viewports hold their copy of ImDrawData.<br/>
		/// </summary>
		public ImVectorImGuiViewportPPtr Viewports;

		/// <summary>
		/// == CurrentViewport-&gt;DpiScale<br/>
		/// </summary>
		public float CurrentDpiScale;

		/// <summary>
		/// We track changes of viewport (happening in Begin) so we can call Platform_OnChangedViewport()<br/>
		/// </summary>
		public unsafe ImGuiViewportP* CurrentViewport;

		public unsafe ImGuiViewportP* MouseViewport;
		/// <summary>
		/// Last known viewport that was hovered by mouse (even if we are not hovering any viewport any more) + honoring the _NoInputs flag.<br/>
		/// </summary>
		public unsafe ImGuiViewportP* MouseLastHoveredViewport;

		public int PlatformLastFocusedViewportId;
		/// <summary>
		/// Virtual monitor used as fallback if backend doesn't provide monitor information.<br/>
		/// </summary>
		public ImGuiPlatformMonitor FallbackMonitor;

		/// <summary>
		/// Unique sequential creation counter (mostly for testingdebugging)<br/>
		/// </summary>
		public int ViewportCreatedCount;

		/// <summary>
		/// Unique sequential creation counter (mostly for testingdebugging)<br/>
		/// </summary>
		public int PlatformWindowsCreatedCount;

		/// <summary>
		/// Every time the front-most window changes, we stamp its viewport with an incrementing counter<br/>
		/// </summary>
		public int ViewportFocusedStampCount;

		/// <summary>
		/// Gamepadkeyboard Navigation Focused window for navigation. Could be called 'FocusedWindow'<br/>
		/// </summary>
		public unsafe ImGuiWindow* NavWindow;

		/// <summary>
		/// Focused item for navigation<br/>
		/// </summary>
		public int NavId;

		/// <summary>
		/// Identify a selection scope (selection code often wants to "clear other items" when landing on an item of the selection set)<br/>
		/// </summary>
		public int NavFocusScopeId;

		/// <summary>
		/// ~~ (g.ActiveId == 0) &amp;&amp; (IsKeyPressed(ImGuiKey_Space) || IsKeyDown(ImGuiKey_Enter) || IsKeyPressed(ImGuiKey_NavGamepadActivate)) ? NavId : 0, also set when calling ActivateItem()<br/>
		/// </summary>
		public int NavActivateId;

		/// <summary>
		/// ~~ IsKeyDown(ImGuiKey_Space) || IsKeyDown(ImGuiKey_Enter) || IsKeyDown(ImGuiKey_NavGamepadActivate) ? NavId : 0<br/>
		/// </summary>
		public int NavActivateDownId;

		/// <summary>
		/// ~~ IsKeyPressed(ImGuiKey_Space) || IsKeyPressed(ImGuiKey_Enter) || IsKeyPressed(ImGuiKey_NavGamepadActivate) ? NavId : 0 (no repeat)<br/>
		/// </summary>
		public int NavActivatePressedId;

		public ImGuiActivateFlags NavActivateFlags;
		/// <summary>
		/// Just navigated to this id (result of a successfully MoveRequest).<br/>
		/// </summary>
		public int NavJustMovedToId;

		/// <summary>
		/// Just navigated to this focus scope id (result of a successfully MoveRequest).<br/>
		/// </summary>
		public int NavJustMovedToFocusScopeId;

		public int NavJustMovedToKeyMods;
		/// <summary>
		/// Set by ActivateItem(), queued until next frame.<br/>
		/// </summary>
		public int NavNextActivateId;

		public ImGuiActivateFlags NavNextActivateFlags;
		/// <summary>
		/// Keyboard or Gamepad mode? THIS CAN ONLY BE ImGuiInputSource_Keyboard or ImGuiInputSource_Mouse<br/>
		/// </summary>
		public ImGuiInputSource NavInputSource;

		/// <summary>
		/// Layer we are navigating on. For now the system is hard-coded for 0=main contents and 1=menutitle bar, may expose layers later.<br/>
		/// </summary>
		public ImGuiNavLayer NavLayer;

		/// <summary>
		/// Nav widget has been seen this frame ~~ NavRectRel is valid<br/>
		/// </summary>
		public byte NavIdIsAlive;

		/// <summary>
		/// When set we will update mouse position if (io.ConfigFlags &amp; ImGuiConfigFlags_NavEnableSetMousePos) if set (NB: this not enabled by default)<br/>
		/// </summary>
		public byte NavMousePosDirty;

		/// <summary>
		/// When user starts using mouse, we hide gamepadkeyboard highlight (NB: but they are still available, which is why NavDisableHighlight isn't always != NavDisableMouseHover)<br/>
		/// </summary>
		public byte NavDisableHighlight;

		/// <summary>
		/// When user starts using gamepadkeyboard, we hide mouse hovering highlight until mouse is touched again.<br/>
		/// </summary>
		public byte NavDisableMouseHover;

		/// <summary>
		/// Navigation: Init &amp; Move Requests ~~ NavMoveRequest || NavInitRequest this is to perform early out in ItemAdd()<br/>
		/// </summary>
		public byte NavAnyRequest;

		/// <summary>
		/// Init request for appearing window to select first item<br/>
		/// </summary>
		public byte NavInitRequest;

		public byte NavInitRequestFromMove;
		/// <summary>
		/// Init request result (first item of the window, or one for which SetItemDefaultFocus() was called)<br/>
		/// </summary>
		public ImGuiNavItemData NavInitResult;

		/// <summary>
		/// Move request submitted, will process result on next NewFrame()<br/>
		/// </summary>
		public byte NavMoveSubmitted;

		/// <summary>
		/// Move request submitted, still scoring incoming items<br/>
		/// </summary>
		public byte NavMoveScoringItems;

		public byte NavMoveForwardToNextFrame;
		public ImGuiNavMoveFlags NavMoveFlags;
		public ImGuiScrollFlags NavMoveScrollFlags;
		public int NavMoveKeyMods;
		/// <summary>
		/// Direction of the move request (leftrightupdown)<br/>
		/// </summary>
		public ImGuiDir NavMoveDir;

		public ImGuiDir NavMoveDirForDebug;
		/// <summary>
		/// FIXME-NAV: Describe the purpose of this better. Might want to rename?<br/>
		/// </summary>
		public ImGuiDir NavMoveClipDir;

		/// <summary>
		/// Rectangle used for scoring, in screen space. Based of window-&gt;NavRectRel[], modified for directional navigation scoring.<br/>
		/// </summary>
		public ImRect NavScoringRect;

		/// <summary>
		/// Some nav operations (such as PageUpPageDown) enforce a region which clipper will attempt to always keep submitted<br/>
		/// </summary>
		public ImRect NavScoringNoClipRect;

		/// <summary>
		/// Metrics for debugging<br/>
		/// </summary>
		public int NavScoringDebugCount;

		/// <summary>
		/// Generally -1 or +1, 0 when tabbing without a nav id<br/>
		/// </summary>
		public int NavTabbingDir;

		/// <summary>
		/// &gt;0 when counting items for tabbing<br/>
		/// </summary>
		public int NavTabbingCounter;

		/// <summary>
		/// Best move request candidate within NavWindow<br/>
		/// </summary>
		public ImGuiNavItemData NavMoveResultLocal;

		/// <summary>
		/// Best move request candidate within NavWindow that are mostly visible (when using ImGuiNavMoveFlags_AlsoScoreVisibleSet flag)<br/>
		/// </summary>
		public ImGuiNavItemData NavMoveResultLocalVisible;

		/// <summary>
		/// Best move request candidate within NavWindow's flattened hierarchy (when using ImGuiWindowFlags_NavFlattened flag)<br/>
		/// </summary>
		public ImGuiNavItemData NavMoveResultOther;

		/// <summary>
		/// First tabbing request candidate within NavWindow and flattened hierarchy<br/>
		/// </summary>
		public ImGuiNavItemData NavTabbingResultFirst;

		/// <summary>
		/// Navigation: Windowing (CTRL+TAB for list, or Menu button + keys or directional pads to moveresize) = ImGuiMod_Ctrl | ImGuiKey_Tab, for reconfiguration (see #4828)<br/>
		/// </summary>
		public int ConfigNavWindowingKeyNext;

		/// <summary>
		/// = ImGuiMod_Ctrl | ImGuiMod_Shift | ImGuiKey_Tab<br/>
		/// </summary>
		public int ConfigNavWindowingKeyPrev;

		/// <summary>
		/// Target window when doing CTRL+Tab (or Pad Menu + FocusPrevNext), this window is temporarily displayed top-most!<br/>
		/// </summary>
		public unsafe ImGuiWindow* NavWindowingTarget;

		/// <summary>
		/// Record of last valid NavWindowingTarget until DimBgRatio and NavWindowingHighlightAlpha becomes 0.0f, so the fade-out can stay on it.<br/>
		/// </summary>
		public unsafe ImGuiWindow* NavWindowingTargetAnim;

		/// <summary>
		/// Internal window actually listing the CTRL+Tab contents<br/>
		/// </summary>
		public unsafe ImGuiWindow* NavWindowingListWindow;

		public float NavWindowingTimer;
		public float NavWindowingHighlightAlpha;
		public byte NavWindowingToggleLayer;
		public Vector2 NavWindowingAccumDeltaPos;
		public Vector2 NavWindowingAccumDeltaSize;
		/// <summary>
		/// Render 0.0..1.0 animation when fading in a dimming background (for modal window and CTRL+TAB list)<br/>
		/// </summary>
		public float DimBgRatio;

		public byte DragDropActive;
		/// <summary>
		/// Set when within a BeginDragDropXXXEndDragDropXXX block for a drag source.<br/>
		/// </summary>
		public byte DragDropWithinSource;

		/// <summary>
		/// Set when within a BeginDragDropXXXEndDragDropXXX block for a drag target.<br/>
		/// </summary>
		public byte DragDropWithinTarget;

		public ImGuiDragDropFlags DragDropSourceFlags;
		public int DragDropSourceFrameCount;
		public int DragDropMouseButton;
		public ImGuiPayload DragDropPayload;
		/// <summary>
		/// Store rectangle of current target candidate (we favor small targets when overlapping)<br/>
		/// </summary>
		public ImRect DragDropTargetRect;

		public int DragDropTargetId;
		public ImGuiDragDropFlags DragDropAcceptFlags;
		/// <summary>
		/// Target item surface (we resolve overlapping targets by prioritizing the smaller surface)<br/>
		/// </summary>
		public float DragDropAcceptIdCurrRectSurface;

		/// <summary>
		/// Target item id (set at the time of accepting the payload)<br/>
		/// </summary>
		public int DragDropAcceptIdCurr;

		/// <summary>
		/// Target item id from previous frame (we need to store this to allow for overlapping drag and drop targets)<br/>
		/// </summary>
		public int DragDropAcceptIdPrev;

		/// <summary>
		/// Last time a target expressed a desire to accept the source<br/>
		/// </summary>
		public int DragDropAcceptFrameCount;

		/// <summary>
		/// Set when holding a payload just made ButtonBehavior() return a press.<br/>
		/// </summary>
		public int DragDropHoldJustPressedId;

		/// <summary>
		/// We don't expose the ImVector&lt;&gt; directly, ImGuiPayload only holds pointer+size<br/>
		/// </summary>
		public ImVectorUnsignedChar DragDropPayloadBufHeap;

		/// <summary>
		/// Local buffer for small payloads<br/>
		/// </summary>
		public byte DragDropPayloadBufLocal_0;
		public byte DragDropPayloadBufLocal_1;
		public byte DragDropPayloadBufLocal_2;
		public byte DragDropPayloadBufLocal_3;
		public byte DragDropPayloadBufLocal_4;
		public byte DragDropPayloadBufLocal_5;
		public byte DragDropPayloadBufLocal_6;
		public byte DragDropPayloadBufLocal_7;
		public byte DragDropPayloadBufLocal_8;
		public byte DragDropPayloadBufLocal_9;
		public byte DragDropPayloadBufLocal_10;
		public byte DragDropPayloadBufLocal_11;
		public byte DragDropPayloadBufLocal_12;
		public byte DragDropPayloadBufLocal_13;
		public byte DragDropPayloadBufLocal_14;
		public byte DragDropPayloadBufLocal_15;

		public int ClipperTempDataStacked;
		public ImVectorImGuiListClipperData ClipperTempData;
		public unsafe ImGuiTable* CurrentTable;
		/// <summary>
		/// Temporary table data size (because we leave previous instances undestructed, we generally don't use TablesTempData.Size)<br/>
		/// </summary>
		public int TablesTempDataStacked;

		/// <summary>
		/// Temporary table data (buffers reusedshared across instances, support nesting)<br/>
		/// </summary>
		public ImVectorImGuiTableTempData TablesTempData;

		/// <summary>
		/// Persistent table data<br/>
		/// </summary>
		public ImPoolImGuiTable Tables;

		/// <summary>
		/// Last used timestamp of each tables (SOA, for efficient GC)<br/>
		/// </summary>
		public ImVectorFloat TablesLastTimeActive;

		public ImVectorImDrawChannel DrawChannelsTempMergeBuffer;
		public unsafe ImGuiTabBar* CurrentTabBar;
		public ImPoolImGuiTabBar TabBars;
		public ImVectorImGuiPtrOrIndex CurrentTabBarStack;
		public ImVectorImGuiShrinkWidthItem ShrinkWidthBuffer;
		public int HoverItemDelayId;
		public int HoverItemDelayIdPreviousFrame;
		/// <summary>
		/// Currently used by IsItemHovered()<br/>
		/// </summary>
		public float HoverItemDelayTimer;

		/// <summary>
		/// Currently used by IsItemHovered(): grace time before g.TooltipHoverTimer gets cleared.<br/>
		/// </summary>
		public float HoverItemDelayClearTimer;

		/// <summary>
		/// Mouse has once been stationary on this item. Only reset after departing the item.<br/>
		/// </summary>
		public int HoverItemUnlockedStationaryId;

		/// <summary>
		/// Mouse has once been stationary on this window. Only reset after departing the window.<br/>
		/// </summary>
		public int HoverWindowUnlockedStationaryId;

		public ImGuiMouseCursor MouseCursor;
		/// <summary>
		/// Time the mouse has been stationary (with some loose heuristic)<br/>
		/// </summary>
		public float MouseStationaryTimer;

		public Vector2 MouseLastValidPos;
		public ImGuiInputTextState InputTextState;
		public ImGuiInputTextDeactivatedState InputTextDeactivatedState;
		public ImFont InputTextPasswordFont;
		/// <summary>
		/// Temporary text input when CTRL+clicking on a slider, etc.<br/>
		/// </summary>
		public int TempInputId;

		/// <summary>
		/// Store user options for color edit widgets<br/>
		/// </summary>
		public ImGuiColorEditFlags ColorEditOptions;

		/// <summary>
		/// Set temporarily while inside of the parent-most ColorEdit4ColorPicker4 (because they call each others).<br/>
		/// </summary>
		public int ColorEditCurrentID;

		/// <summary>
		/// ID we are savingrestoring HS for<br/>
		/// </summary>
		public int ColorEditSavedID;

		/// <summary>
		/// Backup of last Hue associated to LastColor, so we can restore Hue in lossy RGB&lt;&gt;HSV round trips<br/>
		/// </summary>
		public float ColorEditSavedHue;

		/// <summary>
		/// Backup of last Saturation associated to LastColor, so we can restore Saturation in lossy RGB&lt;&gt;HSV round trips<br/>
		/// </summary>
		public float ColorEditSavedSat;

		/// <summary>
		/// RGB value with alpha set to 0.<br/>
		/// </summary>
		public uint ColorEditSavedColor;

		/// <summary>
		/// Initialreference color at the time of opening the color picker.<br/>
		/// </summary>
		public Vector4 ColorPickerRef;

		public ImGuiComboPreviewData ComboPreviewData;
		public float SliderGrabClickOffset;
		/// <summary>
		/// Accumulated slider delta when using navigation controls.<br/>
		/// </summary>
		public float SliderCurrentAccum;

		/// <summary>
		/// Has the accumulated slider delta changed since last time we tried to apply it?<br/>
		/// </summary>
		public byte SliderCurrentAccumDirty;

		public byte DragCurrentAccumDirty;
		/// <summary>
		/// Accumulator for dragging modification. Always high-precision, not rounded by end-user precision settings<br/>
		/// </summary>
		public float DragCurrentAccum;

		/// <summary>
		/// If speed == 0.0f, uses (max-min) * DragSpeedDefaultRatio<br/>
		/// </summary>
		public float DragSpeedDefaultRatio;

		/// <summary>
		/// Distance between mouse and center of grab box, normalized in parent space. Use storage?<br/>
		/// </summary>
		public float ScrollbarClickDeltaToGrabCenter;

		/// <summary>
		/// Backup for style.Alpha for BeginDisabled()<br/>
		/// </summary>
		public float DisabledAlphaBackup;

		public short DisabledStackSize;
		public short TooltipOverrideCount;
		/// <summary>
		/// If no custom clipboard handler is defined<br/>
		/// </summary>
		public ImVectorChar ClipboardHandlerData;

		/// <summary>
		/// A list of menu IDs that were rendered at least once<br/>
		/// </summary>
		public ImVectorImGuiID MenusIdSubmittedThisFrame;

		/// <summary>
		/// Platform support Data updated by current frame<br/>
		/// </summary>
		public ImGuiPlatformImeData PlatformImeData;

		/// <summary>
		/// Previous frame data (when changing we will call io.SetPlatformImeDataFn<br/>
		/// </summary>
		public ImGuiPlatformImeData PlatformImeDataPrev;

		public int PlatformImeViewport;
		/// <summary>
		/// '.' or *localeconv()-&gt;decimal_point<br/>
		/// </summary>
		public byte PlatformLocaleDecimalPoint;

		public ImGuiDockContext DockContext;
		public unsafe void* DockNodeWindowMenuHandler;
		public byte SettingsLoaded;
		/// <summary>
		/// Save .ini Settings to memory when time reaches zero<br/>
		/// </summary>
		public float SettingsDirtyTimer;

		/// <summary>
		/// In memory .ini settings<br/>
		/// </summary>
		public ImGuiTextBuffer SettingsIniData;

		/// <summary>
		/// List of .ini settings handlers<br/>
		/// </summary>
		public ImVectorImGuiSettingsHandler SettingsHandlers;

		/// <summary>
		/// ImGuiWindow .ini settings entries<br/>
		/// </summary>
		public ImChunkStreamImGuiWindowSettings SettingsWindows;

		/// <summary>
		/// ImGuiTable .ini settings entries<br/>
		/// </summary>
		public ImChunkStreamImGuiTableSettings SettingsTables;

		/// <summary>
		/// Hooks for extensions (e.g. test engine)<br/>
		/// </summary>
		public ImVectorImGuiContextHook Hooks;

		/// <summary>
		/// Next available HookId<br/>
		/// </summary>
		public int HookIdNext;

		public unsafe byte* LocalizationTable_0;
		public unsafe byte* LocalizationTable_1;
		public unsafe byte* LocalizationTable_2;
		public unsafe byte* LocalizationTable_3;
		public unsafe byte* LocalizationTable_4;
		public unsafe byte* LocalizationTable_5;
		public unsafe byte* LocalizationTable_6;
		public unsafe byte* LocalizationTable_7;
		public unsafe byte* LocalizationTable_8;
		/// <summary>
		/// CaptureLogging Currently capturing<br/>
		/// </summary>
		public byte LogEnabled;

		/// <summary>
		/// Capture target<br/>
		/// </summary>
		public ImGuiLogType LogType;

		/// <summary>
		/// If != NULL log to stdout file<br/>
		/// </summary>
		public ImFileHandle LogFile;

		/// <summary>
		/// Accumulation buffer when log to clipboard. This is pointer so our GImGui static constructor doesn't call heap allocators.<br/>
		/// </summary>
		public ImGuiTextBuffer LogBuffer;

		public unsafe byte* LogNextPrefix;
		public unsafe byte* LogNextSuffix;
		public float LogLinePosY;
		public byte LogLineFirstItem;
		public int LogDepthRef;
		public int LogDepthToExpand;
		/// <summary>
		/// Defaultstored value for LogDepthMaxExpand if not specified in the LogXXX function call.<br/>
		/// </summary>
		public int LogDepthToExpandDefault;

		public ImGuiDebugLogFlags DebugLogFlags;
		public ImGuiTextBuffer DebugLogBuf;
		public ImGuiTextIndex DebugLogIndex;
		public byte DebugLogClipperAutoDisableFrames;
		/// <summary>
		/// For DebugLocateItemOnHover(). This is used together with DebugLocateId which is in a hotcached spot above.<br/>
		/// </summary>
		public byte DebugLocateFrames;

		/// <summary>
		/// Cycle between 0..9 then wrap around.<br/>
		/// </summary>
		public sbyte DebugBeginReturnValueCullDepth;

		/// <summary>
		/// Item picker is active (started with DebugStartItemPicker())<br/>
		/// </summary>
		public byte DebugItemPickerActive;

		public byte DebugItemPickerMouseButton;
		/// <summary>
		/// Will call IM_DEBUG_BREAK() when encountering this ID<br/>
		/// </summary>
		public int DebugItemPickerBreakId;

		public ImGuiMetricsConfig DebugMetricsConfig;
		public ImGuiStackTool DebugStackTool;
		/// <summary>
		/// Hovered dock node.<br/>
		/// </summary>
		public unsafe ImGuiDockNode* DebugHoveredDockNode;

		/// <summary>
		/// Misc Calculate estimate of framerate for user over the last 60 frames..<br/>
		/// </summary>
		public float FramerateSecPerFrame_0;
		public float FramerateSecPerFrame_1;
		public float FramerateSecPerFrame_2;
		public float FramerateSecPerFrame_3;
		public float FramerateSecPerFrame_4;
		public float FramerateSecPerFrame_5;
		public float FramerateSecPerFrame_6;
		public float FramerateSecPerFrame_7;
		public float FramerateSecPerFrame_8;
		public float FramerateSecPerFrame_9;
		public float FramerateSecPerFrame_10;
		public float FramerateSecPerFrame_11;
		public float FramerateSecPerFrame_12;
		public float FramerateSecPerFrame_13;
		public float FramerateSecPerFrame_14;
		public float FramerateSecPerFrame_15;
		public float FramerateSecPerFrame_16;
		public float FramerateSecPerFrame_17;
		public float FramerateSecPerFrame_18;
		public float FramerateSecPerFrame_19;
		public float FramerateSecPerFrame_20;
		public float FramerateSecPerFrame_21;
		public float FramerateSecPerFrame_22;
		public float FramerateSecPerFrame_23;
		public float FramerateSecPerFrame_24;
		public float FramerateSecPerFrame_25;
		public float FramerateSecPerFrame_26;
		public float FramerateSecPerFrame_27;
		public float FramerateSecPerFrame_28;
		public float FramerateSecPerFrame_29;
		public float FramerateSecPerFrame_30;
		public float FramerateSecPerFrame_31;
		public float FramerateSecPerFrame_32;
		public float FramerateSecPerFrame_33;
		public float FramerateSecPerFrame_34;
		public float FramerateSecPerFrame_35;
		public float FramerateSecPerFrame_36;
		public float FramerateSecPerFrame_37;
		public float FramerateSecPerFrame_38;
		public float FramerateSecPerFrame_39;
		public float FramerateSecPerFrame_40;
		public float FramerateSecPerFrame_41;
		public float FramerateSecPerFrame_42;
		public float FramerateSecPerFrame_43;
		public float FramerateSecPerFrame_44;
		public float FramerateSecPerFrame_45;
		public float FramerateSecPerFrame_46;
		public float FramerateSecPerFrame_47;
		public float FramerateSecPerFrame_48;
		public float FramerateSecPerFrame_49;
		public float FramerateSecPerFrame_50;
		public float FramerateSecPerFrame_51;
		public float FramerateSecPerFrame_52;
		public float FramerateSecPerFrame_53;
		public float FramerateSecPerFrame_54;
		public float FramerateSecPerFrame_55;
		public float FramerateSecPerFrame_56;
		public float FramerateSecPerFrame_57;
		public float FramerateSecPerFrame_58;
		public float FramerateSecPerFrame_59;

		public int FramerateSecPerFrameIdx;
		public int FramerateSecPerFrameCount;
		public float FramerateSecPerFrameAccum;
		/// <summary>
		/// Explicit capture override via SetNextFrameWantCaptureMouse()SetNextFrameWantCaptureKeyboard(). Default to -1.<br/>
		/// </summary>
		public int WantCaptureMouseNextFrame;

		/// <summary>
		/// "<br/>
		/// </summary>
		public int WantCaptureKeyboardNextFrame;

		public int WantTextInputNextFrame;
		/// <summary>
		/// Temporary text buffer<br/>
		/// </summary>
		public ImVectorChar TempBuffer;




		public unsafe Span<ImGuiKeyOwnerData> KeysOwnerData
		
		{
			get
			{
				fixed (ImGuiKeyOwnerData* p = &this.KeysOwnerData_0)
				{
					return new Span<ImGuiKeyOwnerData>(p, 140);
				}
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImGuiContext* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiContextPtr : IEquatable<ImGuiContextPtr>
	{
		public ImGuiContextPtr(ImGuiContext* handle) { Handle = handle; }

		public ImGuiContext* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiContextPtr Null => new ImGuiContextPtr(null);

		public static implicit operator ImGuiContextPtr(ImGuiContext* handle) => new ImGuiContextPtr(handle);

		public static implicit operator ImGuiContext*(ImGuiContextPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiContextPtr left, ImGuiContextPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiContextPtr left, ImGuiContextPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiContextPtr left, ImGuiContext* right) => left.Handle == right;

		public static bool operator !=(ImGuiContextPtr left, ImGuiContext* right) => left.Handle != right;

		public bool Equals(ImGuiContextPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiContextPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiContextPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref bool Initialized => ref Unsafe.AsRef<bool>(&Handle->Initialized);
		/// <summary>
		/// IO.Fonts-&gt; is owned by the ImGuiContext and will be destructed along with it.<br/>
		/// </summary>
		public ref bool FontAtlasOwnedByContext => ref Unsafe.AsRef<bool>(&Handle->FontAtlasOwnedByContext);
		public ref ImGuiIO IO => ref Unsafe.AsRef<ImGuiIO>(&Handle->IO);
		public ref ImGuiPlatformIO PlatformIO => ref Unsafe.AsRef<ImGuiPlatformIO>(&Handle->PlatformIO);
		public ref ImGuiStyle Style => ref Unsafe.AsRef<ImGuiStyle>(&Handle->Style);
		/// <summary>
		/// = g.IO.ConfigFlags at the time of NewFrame()<br/>
		/// </summary>
		public ref ImGuiConfigFlags ConfigFlagsCurrFrame => ref Unsafe.AsRef<ImGuiConfigFlags>(&Handle->ConfigFlagsCurrFrame);
		public ref ImGuiConfigFlags ConfigFlagsLastFrame => ref Unsafe.AsRef<ImGuiConfigFlags>(&Handle->ConfigFlagsLastFrame);
		/// <summary>
		/// (Shortcut) == FontStack.empty() ? IO.Font : FontStack.back()<br/>
		/// </summary>
		public ref ImFontPtr Font => ref Unsafe.AsRef<ImFontPtr>(&Handle->Font);
		/// <summary>
		/// (Shortcut) == FontBaseSize * g.CurrentWindow-&gt;FontWindowScale == window-&gt;FontSize(). Text height for current window.<br/>
		/// </summary>
		public ref float FontSize => ref Unsafe.AsRef<float>(&Handle->FontSize);
		/// <summary>
		/// (Shortcut) == IO.FontGlobalScale * Font-&gt;Scale * Font-&gt;FontSize. Base text height.<br/>
		/// </summary>
		public ref float FontBaseSize => ref Unsafe.AsRef<float>(&Handle->FontBaseSize);
		public ref ImDrawListSharedData DrawListSharedData => ref Unsafe.AsRef<ImDrawListSharedData>(&Handle->DrawListSharedData);
		public ref double Time => ref Unsafe.AsRef<double>(&Handle->Time);
		public ref int FrameCount => ref Unsafe.AsRef<int>(&Handle->FrameCount);
		public ref int FrameCountEnded => ref Unsafe.AsRef<int>(&Handle->FrameCountEnded);
		public ref int FrameCountPlatformEnded => ref Unsafe.AsRef<int>(&Handle->FrameCountPlatformEnded);
		public ref int FrameCountRendered => ref Unsafe.AsRef<int>(&Handle->FrameCountRendered);
		/// <summary>
		/// Set by NewFrame(), cleared by EndFrame()<br/>
		/// </summary>
		public ref bool WithinFrameScope => ref Unsafe.AsRef<bool>(&Handle->WithinFrameScope);
		/// <summary>
		/// Set by NewFrame(), cleared by EndFrame() when the implicit debug window has been pushed<br/>
		/// </summary>
		public ref bool WithinFrameScopeWithImplicitWindow => ref Unsafe.AsRef<bool>(&Handle->WithinFrameScopeWithImplicitWindow);
		/// <summary>
		/// Set within EndChild()<br/>
		/// </summary>
		public ref bool WithinEndChild => ref Unsafe.AsRef<bool>(&Handle->WithinEndChild);
		/// <summary>
		/// Request full GC<br/>
		/// </summary>
		public ref bool GcCompactAll => ref Unsafe.AsRef<bool>(&Handle->GcCompactAll);
		/// <summary>
		/// Will call test engine hooks: ImGuiTestEngineHook_ItemAdd(), ImGuiTestEngineHook_ItemInfo(), ImGuiTestEngineHook_Log()<br/>
		/// </summary>
		public ref bool TestEngineHookItems => ref Unsafe.AsRef<bool>(&Handle->TestEngineHookItems);
		/// <summary>
		/// Test engine user data<br/>
		/// </summary>
		public void* TestEngine { get => Handle->TestEngine; set => Handle->TestEngine = value; }
		/// <summary>
		/// Inputs Input events which will be trickledwritten into IO structure.<br/>
		/// </summary>
		public ref ImVectorImGuiInputEvent InputEventsQueue => ref Unsafe.AsRef<ImVectorImGuiInputEvent>(&Handle->InputEventsQueue);
		/// <summary>
		/// Past input events processed in NewFrame(). This is to allow domain-specific application to access e.g mousepen trail.<br/>
		/// </summary>
		public ref ImVectorImGuiInputEvent InputEventsTrail => ref Unsafe.AsRef<ImVectorImGuiInputEvent>(&Handle->InputEventsTrail);
		public ref ImGuiMouseSource InputEventsNextMouseSource => ref Unsafe.AsRef<ImGuiMouseSource>(&Handle->InputEventsNextMouseSource);
		public ref uint InputEventsNextEventId => ref Unsafe.AsRef<uint>(&Handle->InputEventsNextEventId);
		/// <summary>
		/// Windows state Windows, sorted in display order, back to front<br/>
		/// </summary>
		public ref ImVectorImGuiWindowPtr Windows => ref Unsafe.AsRef<ImVectorImGuiWindowPtr>(&Handle->Windows);
		/// <summary>
		/// Root windows, sorted in focus order, back to front.<br/>
		/// </summary>
		public ref ImVectorImGuiWindowPtr WindowsFocusOrder => ref Unsafe.AsRef<ImVectorImGuiWindowPtr>(&Handle->WindowsFocusOrder);
		/// <summary>
		/// Temporary buffer used in EndFrame() to reorder windows so parents are kept before their child<br/>
		/// </summary>
		public ref ImVectorImGuiWindowPtr WindowsTempSortBuffer => ref Unsafe.AsRef<ImVectorImGuiWindowPtr>(&Handle->WindowsTempSortBuffer);
		public ref ImVectorImGuiWindowStackData CurrentWindowStack => ref Unsafe.AsRef<ImVectorImGuiWindowStackData>(&Handle->CurrentWindowStack);
		/// <summary>
		/// Map window's ImGuiID to ImGuiWindow*<br/>
		/// </summary>
		public ref ImGuiStorage WindowsById => ref Unsafe.AsRef<ImGuiStorage>(&Handle->WindowsById);
		/// <summary>
		/// Number of unique windows submitted by frame<br/>
		/// </summary>
		public ref int WindowsActiveCount => ref Unsafe.AsRef<int>(&Handle->WindowsActiveCount);
		/// <summary>
		/// Padding around resizable windows for which hovering on counts as hovering the window == ImMax(style.TouchExtraPadding, WINDOWS_HOVER_PADDING)<br/>
		/// </summary>
		public ref Vector2 WindowsHoverPadding => ref Unsafe.AsRef<Vector2>(&Handle->WindowsHoverPadding);
		/// <summary>
		/// Window being drawn into<br/>
		/// </summary>
		public ref ImGuiWindowPtr CurrentWindow => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->CurrentWindow);
		/// <summary>
		/// Window the mouse is hovering. Will typically catch mouse inputs.<br/>
		/// </summary>
		public ref ImGuiWindowPtr HoveredWindow => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->HoveredWindow);
		/// <summary>
		/// Hovered window ignoring MovingWindow. Only set if MovingWindow is set.<br/>
		/// </summary>
		public ref ImGuiWindowPtr HoveredWindowUnderMovingWindow => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->HoveredWindowUnderMovingWindow);
		/// <summary>
		/// Track the window we clicked on (in order to preserve focus). The actual window that is moved is generally MovingWindow-&gt;RootWindowDockTree.<br/>
		/// </summary>
		public ref ImGuiWindowPtr MovingWindow => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->MovingWindow);
		/// <summary>
		/// Track the window we started mouse-wheeling on. Until a timer elapse or mouse has moved, generally keep scrolling the same window even if during the course of scrolling the mouse ends up hovering a child window.<br/>
		/// </summary>
		public ref ImGuiWindowPtr WheelingWindow => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->WheelingWindow);
		public ref Vector2 WheelingWindowRefMousePos => ref Unsafe.AsRef<Vector2>(&Handle->WheelingWindowRefMousePos);
		/// <summary>
		/// This may be set one frame before WheelingWindow is != NULL<br/>
		/// </summary>
		public ref int WheelingWindowStartFrame => ref Unsafe.AsRef<int>(&Handle->WheelingWindowStartFrame);
		public ref float WheelingWindowReleaseTimer => ref Unsafe.AsRef<float>(&Handle->WheelingWindowReleaseTimer);
		public ref Vector2 WheelingWindowWheelRemainder => ref Unsafe.AsRef<Vector2>(&Handle->WheelingWindowWheelRemainder);
		public ref Vector2 WheelingAxisAvg => ref Unsafe.AsRef<Vector2>(&Handle->WheelingAxisAvg);
		/// <summary>
		/// Itemwidgets state and tracking information Will call core hooks: DebugHookIdInfo() from GetID functions, used by Stack Tool [next HoveredIdActiveId to not pull in an extra cache-line]<br/>
		/// </summary>
		public ref int DebugHookIdInfo => ref Unsafe.AsRef<int>(&Handle->DebugHookIdInfo);
		/// <summary>
		/// Hovered widget, filled during the frame<br/>
		/// </summary>
		public ref int HoveredId => ref Unsafe.AsRef<int>(&Handle->HoveredId);
		public ref int HoveredIdPreviousFrame => ref Unsafe.AsRef<int>(&Handle->HoveredIdPreviousFrame);
		public ref bool HoveredIdAllowOverlap => ref Unsafe.AsRef<bool>(&Handle->HoveredIdAllowOverlap);
		/// <summary>
		/// At least one widget passed the rect test, but has been discarded by disabled flag or popup inhibit. May be true even if HoveredId == 0.<br/>
		/// </summary>
		public ref bool HoveredIdDisabled => ref Unsafe.AsRef<bool>(&Handle->HoveredIdDisabled);
		/// <summary>
		/// Measure contiguous hovering time<br/>
		/// </summary>
		public ref float HoveredIdTimer => ref Unsafe.AsRef<float>(&Handle->HoveredIdTimer);
		/// <summary>
		/// Measure contiguous hovering time where the item has not been active<br/>
		/// </summary>
		public ref float HoveredIdNotActiveTimer => ref Unsafe.AsRef<float>(&Handle->HoveredIdNotActiveTimer);
		/// <summary>
		/// Active widget<br/>
		/// </summary>
		public ref int ActiveId => ref Unsafe.AsRef<int>(&Handle->ActiveId);
		/// <summary>
		/// Active widget has been seen this frame (we can't use a bool as the ActiveId may change within the frame)<br/>
		/// </summary>
		public ref int ActiveIdIsAlive => ref Unsafe.AsRef<int>(&Handle->ActiveIdIsAlive);
		public ref float ActiveIdTimer => ref Unsafe.AsRef<float>(&Handle->ActiveIdTimer);
		/// <summary>
		/// Set at the time of activation for one frame<br/>
		/// </summary>
		public ref bool ActiveIdIsJustActivated => ref Unsafe.AsRef<bool>(&Handle->ActiveIdIsJustActivated);
		/// <summary>
		/// Active widget allows another widget to steal active id (generally for overlapping widgets, but not always)<br/>
		/// </summary>
		public ref bool ActiveIdAllowOverlap => ref Unsafe.AsRef<bool>(&Handle->ActiveIdAllowOverlap);
		/// <summary>
		/// Disable losing active id if the active id window gets unfocused.<br/>
		/// </summary>
		public ref bool ActiveIdNoClearOnFocusLoss => ref Unsafe.AsRef<bool>(&Handle->ActiveIdNoClearOnFocusLoss);
		/// <summary>
		/// Track whether the active id led to a press (this is to allow changing between PressOnClick and PressOnRelease without pressing twice). Used by range_select branch.<br/>
		/// </summary>
		public ref bool ActiveIdHasBeenPressedBefore => ref Unsafe.AsRef<bool>(&Handle->ActiveIdHasBeenPressedBefore);
		/// <summary>
		/// Was the value associated to the widget Edited over the course of the Active state.<br/>
		/// </summary>
		public ref bool ActiveIdHasBeenEditedBefore => ref Unsafe.AsRef<bool>(&Handle->ActiveIdHasBeenEditedBefore);
		public ref bool ActiveIdHasBeenEditedThisFrame => ref Unsafe.AsRef<bool>(&Handle->ActiveIdHasBeenEditedThisFrame);
		/// <summary>
		/// Clicked offset from upper-left corner, if applicable (currently only set by ButtonBehavior)<br/>
		/// </summary>
		public ref Vector2 ActiveIdClickOffset => ref Unsafe.AsRef<Vector2>(&Handle->ActiveIdClickOffset);
		public ref ImGuiWindowPtr ActiveIdWindow => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->ActiveIdWindow);
		/// <summary>
		/// Activating source: ImGuiInputSource_Mouse OR ImGuiInputSource_Keyboard OR ImGuiInputSource_Gamepad<br/>
		/// </summary>
		public ref ImGuiInputSource ActiveIdSource => ref Unsafe.AsRef<ImGuiInputSource>(&Handle->ActiveIdSource);
		public ref int ActiveIdMouseButton => ref Unsafe.AsRef<int>(&Handle->ActiveIdMouseButton);
		public ref int ActiveIdPreviousFrame => ref Unsafe.AsRef<int>(&Handle->ActiveIdPreviousFrame);
		public ref bool ActiveIdPreviousFrameIsAlive => ref Unsafe.AsRef<bool>(&Handle->ActiveIdPreviousFrameIsAlive);
		public ref bool ActiveIdPreviousFrameHasBeenEditedBefore => ref Unsafe.AsRef<bool>(&Handle->ActiveIdPreviousFrameHasBeenEditedBefore);
		public ref ImGuiWindowPtr ActiveIdPreviousFrameWindow => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->ActiveIdPreviousFrameWindow);
		/// <summary>
		/// Store the last non-zero ActiveId, useful for animation.<br/>
		/// </summary>
		public ref int LastActiveId => ref Unsafe.AsRef<int>(&Handle->LastActiveId);
		/// <summary>
		/// Store the last non-zero ActiveId timer since the beginning of activation, useful for animation.<br/>
		/// </summary>
		public ref float LastActiveIdTimer => ref Unsafe.AsRef<float>(&Handle->LastActiveIdTimer);
		public unsafe Span<ImGuiKeyOwnerData> KeysOwnerData
		
		{
			get
			{
				return new Span<ImGuiKeyOwnerData>(&Handle->KeysOwnerData_0, 140);
			}
		}
		public ref ImGuiKeyRoutingTable KeysRoutingTable => ref Unsafe.AsRef<ImGuiKeyRoutingTable>(&Handle->KeysRoutingTable);
		/// <summary>
		/// Active widget will want to read those nav move requests (e.g. can activate a button and move away from it)<br/>
		/// </summary>
		public ref uint ActiveIdUsingNavDirMask => ref Unsafe.AsRef<uint>(&Handle->ActiveIdUsingNavDirMask);
		/// <summary>
		/// Active widget will want to read all keyboard keys inputs. (FIXME: This is a shortcut for not taking ownership of 100+ keys but perhaps best to not have the inconsistency)<br/>
		/// </summary>
		public ref bool ActiveIdUsingAllKeyboardKeys => ref Unsafe.AsRef<bool>(&Handle->ActiveIdUsingAllKeyboardKeys);
		/// <summary>
		/// If you used this. Since (IMGUI_VERSION_NUM &gt;= 18804) : 'g.ActiveIdUsingNavInputMask |= (1 &lt;&lt; ImGuiNavInput_Cancel);' becomes 'SetKeyOwner(ImGuiKey_Escape, g.ActiveId) andor SetKeyOwner(ImGuiKey_NavGamepadCancel, g.ActiveId);'<br/>
		/// </summary>
		public ref uint ActiveIdUsingNavInputMask => ref Unsafe.AsRef<uint>(&Handle->ActiveIdUsingNavInputMask);
		/// <summary>
		/// Next windowitem data == g.FocusScopeStack.back()<br/>
		/// </summary>
		public ref int CurrentFocusScopeId => ref Unsafe.AsRef<int>(&Handle->CurrentFocusScopeId);
		/// <summary>
		/// == g.ItemFlagsStack.back()<br/>
		/// </summary>
		public ref ImGuiItemFlags CurrentItemFlags => ref Unsafe.AsRef<ImGuiItemFlags>(&Handle->CurrentItemFlags);
		/// <summary>
		/// Storage for DebugLocateItemOnHover() feature: this is read by ItemAdd() so we keep it in a hotcached location<br/>
		/// </summary>
		public ref int DebugLocateId => ref Unsafe.AsRef<int>(&Handle->DebugLocateId);
		/// <summary>
		/// Storage for SetNextItem** functions<br/>
		/// </summary>
		public ref ImGuiNextItemData NextItemData => ref Unsafe.AsRef<ImGuiNextItemData>(&Handle->NextItemData);
		/// <summary>
		/// Storage for last submitted item (setup by ItemAdd)<br/>
		/// </summary>
		public ref ImGuiLastItemData LastItemData => ref Unsafe.AsRef<ImGuiLastItemData>(&Handle->LastItemData);
		/// <summary>
		/// Storage for SetNextWindow** functions<br/>
		/// </summary>
		public ref ImGuiNextWindowData NextWindowData => ref Unsafe.AsRef<ImGuiNextWindowData>(&Handle->NextWindowData);
		/// <summary>
		/// Shared stacks Stack for PushStyleColor()PopStyleColor() - inherited by Begin()<br/>
		/// </summary>
		public ref ImVectorImGuiColorMod ColorStack => ref Unsafe.AsRef<ImVectorImGuiColorMod>(&Handle->ColorStack);
		/// <summary>
		/// Stack for PushStyleVar()PopStyleVar() - inherited by Begin()<br/>
		/// </summary>
		public ref ImVectorImGuiStyleMod StyleVarStack => ref Unsafe.AsRef<ImVectorImGuiStyleMod>(&Handle->StyleVarStack);
		/// <summary>
		/// Stack for PushFont()PopFont() - inherited by Begin()<br/>
		/// </summary>
		public ref ImVectorImFontPtr FontStack => ref Unsafe.AsRef<ImVectorImFontPtr>(&Handle->FontStack);
		/// <summary>
		/// Stack for PushFocusScope()PopFocusScope() - inherited by BeginChild(), pushed into by Begin()<br/>
		/// </summary>
		public ref ImVectorImGuiID FocusScopeStack => ref Unsafe.AsRef<ImVectorImGuiID>(&Handle->FocusScopeStack);
		/// <summary>
		/// Stack for PushItemFlag()PopItemFlag() - inherited by Begin()<br/>
		/// </summary>
		public ref ImVectorImGuiItemFlags ItemFlagsStack => ref Unsafe.AsRef<ImVectorImGuiItemFlags>(&Handle->ItemFlagsStack);
		/// <summary>
		/// Stack for BeginGroup()EndGroup() - not inherited by Begin()<br/>
		/// </summary>
		public ref ImVectorImGuiGroupData GroupStack => ref Unsafe.AsRef<ImVectorImGuiGroupData>(&Handle->GroupStack);
		/// <summary>
		/// Which popups are open (persistent)<br/>
		/// </summary>
		public ref ImVectorImGuiPopupData OpenPopupStack => ref Unsafe.AsRef<ImVectorImGuiPopupData>(&Handle->OpenPopupStack);
		/// <summary>
		/// Which level of BeginPopup() we are in (reset every frame)<br/>
		/// </summary>
		public ref ImVectorImGuiPopupData BeginPopupStack => ref Unsafe.AsRef<ImVectorImGuiPopupData>(&Handle->BeginPopupStack);
		public ref int BeginMenuCount => ref Unsafe.AsRef<int>(&Handle->BeginMenuCount);
		/// <summary>
		/// Viewports Active viewports (always 1+, and generally 1 unless multi-viewports are enabled). Each viewports hold their copy of ImDrawData.<br/>
		/// </summary>
		public ref ImVectorImGuiViewportPPtr Viewports => ref Unsafe.AsRef<ImVectorImGuiViewportPPtr>(&Handle->Viewports);
		/// <summary>
		/// == CurrentViewport-&gt;DpiScale<br/>
		/// </summary>
		public ref float CurrentDpiScale => ref Unsafe.AsRef<float>(&Handle->CurrentDpiScale);
		/// <summary>
		/// We track changes of viewport (happening in Begin) so we can call Platform_OnChangedViewport()<br/>
		/// </summary>
		public ref ImGuiViewportPPtr CurrentViewport => ref Unsafe.AsRef<ImGuiViewportPPtr>(&Handle->CurrentViewport);
		public ref ImGuiViewportPPtr MouseViewport => ref Unsafe.AsRef<ImGuiViewportPPtr>(&Handle->MouseViewport);
		/// <summary>
		/// Last known viewport that was hovered by mouse (even if we are not hovering any viewport any more) + honoring the _NoInputs flag.<br/>
		/// </summary>
		public ref ImGuiViewportPPtr MouseLastHoveredViewport => ref Unsafe.AsRef<ImGuiViewportPPtr>(&Handle->MouseLastHoveredViewport);
		public ref int PlatformLastFocusedViewportId => ref Unsafe.AsRef<int>(&Handle->PlatformLastFocusedViewportId);
		/// <summary>
		/// Virtual monitor used as fallback if backend doesn't provide monitor information.<br/>
		/// </summary>
		public ref ImGuiPlatformMonitor FallbackMonitor => ref Unsafe.AsRef<ImGuiPlatformMonitor>(&Handle->FallbackMonitor);
		/// <summary>
		/// Unique sequential creation counter (mostly for testingdebugging)<br/>
		/// </summary>
		public ref int ViewportCreatedCount => ref Unsafe.AsRef<int>(&Handle->ViewportCreatedCount);
		/// <summary>
		/// Unique sequential creation counter (mostly for testingdebugging)<br/>
		/// </summary>
		public ref int PlatformWindowsCreatedCount => ref Unsafe.AsRef<int>(&Handle->PlatformWindowsCreatedCount);
		/// <summary>
		/// Every time the front-most window changes, we stamp its viewport with an incrementing counter<br/>
		/// </summary>
		public ref int ViewportFocusedStampCount => ref Unsafe.AsRef<int>(&Handle->ViewportFocusedStampCount);
		/// <summary>
		/// Gamepadkeyboard Navigation Focused window for navigation. Could be called 'FocusedWindow'<br/>
		/// </summary>
		public ref ImGuiWindowPtr NavWindow => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->NavWindow);
		/// <summary>
		/// Focused item for navigation<br/>
		/// </summary>
		public ref int NavId => ref Unsafe.AsRef<int>(&Handle->NavId);
		/// <summary>
		/// Identify a selection scope (selection code often wants to "clear other items" when landing on an item of the selection set)<br/>
		/// </summary>
		public ref int NavFocusScopeId => ref Unsafe.AsRef<int>(&Handle->NavFocusScopeId);
		/// <summary>
		/// ~~ (g.ActiveId == 0) &amp;&amp; (IsKeyPressed(ImGuiKey_Space) || IsKeyDown(ImGuiKey_Enter) || IsKeyPressed(ImGuiKey_NavGamepadActivate)) ? NavId : 0, also set when calling ActivateItem()<br/>
		/// </summary>
		public ref int NavActivateId => ref Unsafe.AsRef<int>(&Handle->NavActivateId);
		/// <summary>
		/// ~~ IsKeyDown(ImGuiKey_Space) || IsKeyDown(ImGuiKey_Enter) || IsKeyDown(ImGuiKey_NavGamepadActivate) ? NavId : 0<br/>
		/// </summary>
		public ref int NavActivateDownId => ref Unsafe.AsRef<int>(&Handle->NavActivateDownId);
		/// <summary>
		/// ~~ IsKeyPressed(ImGuiKey_Space) || IsKeyPressed(ImGuiKey_Enter) || IsKeyPressed(ImGuiKey_NavGamepadActivate) ? NavId : 0 (no repeat)<br/>
		/// </summary>
		public ref int NavActivatePressedId => ref Unsafe.AsRef<int>(&Handle->NavActivatePressedId);
		public ref ImGuiActivateFlags NavActivateFlags => ref Unsafe.AsRef<ImGuiActivateFlags>(&Handle->NavActivateFlags);
		/// <summary>
		/// Just navigated to this id (result of a successfully MoveRequest).<br/>
		/// </summary>
		public ref int NavJustMovedToId => ref Unsafe.AsRef<int>(&Handle->NavJustMovedToId);
		/// <summary>
		/// Just navigated to this focus scope id (result of a successfully MoveRequest).<br/>
		/// </summary>
		public ref int NavJustMovedToFocusScopeId => ref Unsafe.AsRef<int>(&Handle->NavJustMovedToFocusScopeId);
		public ref int NavJustMovedToKeyMods => ref Unsafe.AsRef<int>(&Handle->NavJustMovedToKeyMods);
		/// <summary>
		/// Set by ActivateItem(), queued until next frame.<br/>
		/// </summary>
		public ref int NavNextActivateId => ref Unsafe.AsRef<int>(&Handle->NavNextActivateId);
		public ref ImGuiActivateFlags NavNextActivateFlags => ref Unsafe.AsRef<ImGuiActivateFlags>(&Handle->NavNextActivateFlags);
		/// <summary>
		/// Keyboard or Gamepad mode? THIS CAN ONLY BE ImGuiInputSource_Keyboard or ImGuiInputSource_Mouse<br/>
		/// </summary>
		public ref ImGuiInputSource NavInputSource => ref Unsafe.AsRef<ImGuiInputSource>(&Handle->NavInputSource);
		/// <summary>
		/// Layer we are navigating on. For now the system is hard-coded for 0=main contents and 1=menutitle bar, may expose layers later.<br/>
		/// </summary>
		public ref ImGuiNavLayer NavLayer => ref Unsafe.AsRef<ImGuiNavLayer>(&Handle->NavLayer);
		/// <summary>
		/// Nav widget has been seen this frame ~~ NavRectRel is valid<br/>
		/// </summary>
		public ref bool NavIdIsAlive => ref Unsafe.AsRef<bool>(&Handle->NavIdIsAlive);
		/// <summary>
		/// When set we will update mouse position if (io.ConfigFlags &amp; ImGuiConfigFlags_NavEnableSetMousePos) if set (NB: this not enabled by default)<br/>
		/// </summary>
		public ref bool NavMousePosDirty => ref Unsafe.AsRef<bool>(&Handle->NavMousePosDirty);
		/// <summary>
		/// When user starts using mouse, we hide gamepadkeyboard highlight (NB: but they are still available, which is why NavDisableHighlight isn't always != NavDisableMouseHover)<br/>
		/// </summary>
		public ref bool NavDisableHighlight => ref Unsafe.AsRef<bool>(&Handle->NavDisableHighlight);
		/// <summary>
		/// When user starts using gamepadkeyboard, we hide mouse hovering highlight until mouse is touched again.<br/>
		/// </summary>
		public ref bool NavDisableMouseHover => ref Unsafe.AsRef<bool>(&Handle->NavDisableMouseHover);
		/// <summary>
		/// Navigation: Init &amp; Move Requests ~~ NavMoveRequest || NavInitRequest this is to perform early out in ItemAdd()<br/>
		/// </summary>
		public ref bool NavAnyRequest => ref Unsafe.AsRef<bool>(&Handle->NavAnyRequest);
		/// <summary>
		/// Init request for appearing window to select first item<br/>
		/// </summary>
		public ref bool NavInitRequest => ref Unsafe.AsRef<bool>(&Handle->NavInitRequest);
		public ref bool NavInitRequestFromMove => ref Unsafe.AsRef<bool>(&Handle->NavInitRequestFromMove);
		/// <summary>
		/// Init request result (first item of the window, or one for which SetItemDefaultFocus() was called)<br/>
		/// </summary>
		public ref ImGuiNavItemData NavInitResult => ref Unsafe.AsRef<ImGuiNavItemData>(&Handle->NavInitResult);
		/// <summary>
		/// Move request submitted, will process result on next NewFrame()<br/>
		/// </summary>
		public ref bool NavMoveSubmitted => ref Unsafe.AsRef<bool>(&Handle->NavMoveSubmitted);
		/// <summary>
		/// Move request submitted, still scoring incoming items<br/>
		/// </summary>
		public ref bool NavMoveScoringItems => ref Unsafe.AsRef<bool>(&Handle->NavMoveScoringItems);
		public ref bool NavMoveForwardToNextFrame => ref Unsafe.AsRef<bool>(&Handle->NavMoveForwardToNextFrame);
		public ref ImGuiNavMoveFlags NavMoveFlags => ref Unsafe.AsRef<ImGuiNavMoveFlags>(&Handle->NavMoveFlags);
		public ref ImGuiScrollFlags NavMoveScrollFlags => ref Unsafe.AsRef<ImGuiScrollFlags>(&Handle->NavMoveScrollFlags);
		public ref int NavMoveKeyMods => ref Unsafe.AsRef<int>(&Handle->NavMoveKeyMods);
		/// <summary>
		/// Direction of the move request (leftrightupdown)<br/>
		/// </summary>
		public ref ImGuiDir NavMoveDir => ref Unsafe.AsRef<ImGuiDir>(&Handle->NavMoveDir);
		public ref ImGuiDir NavMoveDirForDebug => ref Unsafe.AsRef<ImGuiDir>(&Handle->NavMoveDirForDebug);
		/// <summary>
		/// FIXME-NAV: Describe the purpose of this better. Might want to rename?<br/>
		/// </summary>
		public ref ImGuiDir NavMoveClipDir => ref Unsafe.AsRef<ImGuiDir>(&Handle->NavMoveClipDir);
		/// <summary>
		/// Rectangle used for scoring, in screen space. Based of window-&gt;NavRectRel[], modified for directional navigation scoring.<br/>
		/// </summary>
		public ref ImRect NavScoringRect => ref Unsafe.AsRef<ImRect>(&Handle->NavScoringRect);
		/// <summary>
		/// Some nav operations (such as PageUpPageDown) enforce a region which clipper will attempt to always keep submitted<br/>
		/// </summary>
		public ref ImRect NavScoringNoClipRect => ref Unsafe.AsRef<ImRect>(&Handle->NavScoringNoClipRect);
		/// <summary>
		/// Metrics for debugging<br/>
		/// </summary>
		public ref int NavScoringDebugCount => ref Unsafe.AsRef<int>(&Handle->NavScoringDebugCount);
		/// <summary>
		/// Generally -1 or +1, 0 when tabbing without a nav id<br/>
		/// </summary>
		public ref int NavTabbingDir => ref Unsafe.AsRef<int>(&Handle->NavTabbingDir);
		/// <summary>
		/// &gt;0 when counting items for tabbing<br/>
		/// </summary>
		public ref int NavTabbingCounter => ref Unsafe.AsRef<int>(&Handle->NavTabbingCounter);
		/// <summary>
		/// Best move request candidate within NavWindow<br/>
		/// </summary>
		public ref ImGuiNavItemData NavMoveResultLocal => ref Unsafe.AsRef<ImGuiNavItemData>(&Handle->NavMoveResultLocal);
		/// <summary>
		/// Best move request candidate within NavWindow that are mostly visible (when using ImGuiNavMoveFlags_AlsoScoreVisibleSet flag)<br/>
		/// </summary>
		public ref ImGuiNavItemData NavMoveResultLocalVisible => ref Unsafe.AsRef<ImGuiNavItemData>(&Handle->NavMoveResultLocalVisible);
		/// <summary>
		/// Best move request candidate within NavWindow's flattened hierarchy (when using ImGuiWindowFlags_NavFlattened flag)<br/>
		/// </summary>
		public ref ImGuiNavItemData NavMoveResultOther => ref Unsafe.AsRef<ImGuiNavItemData>(&Handle->NavMoveResultOther);
		/// <summary>
		/// First tabbing request candidate within NavWindow and flattened hierarchy<br/>
		/// </summary>
		public ref ImGuiNavItemData NavTabbingResultFirst => ref Unsafe.AsRef<ImGuiNavItemData>(&Handle->NavTabbingResultFirst);
		/// <summary>
		/// Navigation: Windowing (CTRL+TAB for list, or Menu button + keys or directional pads to moveresize) = ImGuiMod_Ctrl | ImGuiKey_Tab, for reconfiguration (see #4828)<br/>
		/// </summary>
		public ref int ConfigNavWindowingKeyNext => ref Unsafe.AsRef<int>(&Handle->ConfigNavWindowingKeyNext);
		/// <summary>
		/// = ImGuiMod_Ctrl | ImGuiMod_Shift | ImGuiKey_Tab<br/>
		/// </summary>
		public ref int ConfigNavWindowingKeyPrev => ref Unsafe.AsRef<int>(&Handle->ConfigNavWindowingKeyPrev);
		/// <summary>
		/// Target window when doing CTRL+Tab (or Pad Menu + FocusPrevNext), this window is temporarily displayed top-most!<br/>
		/// </summary>
		public ref ImGuiWindowPtr NavWindowingTarget => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->NavWindowingTarget);
		/// <summary>
		/// Record of last valid NavWindowingTarget until DimBgRatio and NavWindowingHighlightAlpha becomes 0.0f, so the fade-out can stay on it.<br/>
		/// </summary>
		public ref ImGuiWindowPtr NavWindowingTargetAnim => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->NavWindowingTargetAnim);
		/// <summary>
		/// Internal window actually listing the CTRL+Tab contents<br/>
		/// </summary>
		public ref ImGuiWindowPtr NavWindowingListWindow => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->NavWindowingListWindow);
		public ref float NavWindowingTimer => ref Unsafe.AsRef<float>(&Handle->NavWindowingTimer);
		public ref float NavWindowingHighlightAlpha => ref Unsafe.AsRef<float>(&Handle->NavWindowingHighlightAlpha);
		public ref bool NavWindowingToggleLayer => ref Unsafe.AsRef<bool>(&Handle->NavWindowingToggleLayer);
		public ref Vector2 NavWindowingAccumDeltaPos => ref Unsafe.AsRef<Vector2>(&Handle->NavWindowingAccumDeltaPos);
		public ref Vector2 NavWindowingAccumDeltaSize => ref Unsafe.AsRef<Vector2>(&Handle->NavWindowingAccumDeltaSize);
		/// <summary>
		/// Render 0.0..1.0 animation when fading in a dimming background (for modal window and CTRL+TAB list)<br/>
		/// </summary>
		public ref float DimBgRatio => ref Unsafe.AsRef<float>(&Handle->DimBgRatio);
		public ref bool DragDropActive => ref Unsafe.AsRef<bool>(&Handle->DragDropActive);
		/// <summary>
		/// Set when within a BeginDragDropXXXEndDragDropXXX block for a drag source.<br/>
		/// </summary>
		public ref bool DragDropWithinSource => ref Unsafe.AsRef<bool>(&Handle->DragDropWithinSource);
		/// <summary>
		/// Set when within a BeginDragDropXXXEndDragDropXXX block for a drag target.<br/>
		/// </summary>
		public ref bool DragDropWithinTarget => ref Unsafe.AsRef<bool>(&Handle->DragDropWithinTarget);
		public ref ImGuiDragDropFlags DragDropSourceFlags => ref Unsafe.AsRef<ImGuiDragDropFlags>(&Handle->DragDropSourceFlags);
		public ref int DragDropSourceFrameCount => ref Unsafe.AsRef<int>(&Handle->DragDropSourceFrameCount);
		public ref int DragDropMouseButton => ref Unsafe.AsRef<int>(&Handle->DragDropMouseButton);
		public ref ImGuiPayload DragDropPayload => ref Unsafe.AsRef<ImGuiPayload>(&Handle->DragDropPayload);
		/// <summary>
		/// Store rectangle of current target candidate (we favor small targets when overlapping)<br/>
		/// </summary>
		public ref ImRect DragDropTargetRect => ref Unsafe.AsRef<ImRect>(&Handle->DragDropTargetRect);
		public ref int DragDropTargetId => ref Unsafe.AsRef<int>(&Handle->DragDropTargetId);
		public ref ImGuiDragDropFlags DragDropAcceptFlags => ref Unsafe.AsRef<ImGuiDragDropFlags>(&Handle->DragDropAcceptFlags);
		/// <summary>
		/// Target item surface (we resolve overlapping targets by prioritizing the smaller surface)<br/>
		/// </summary>
		public ref float DragDropAcceptIdCurrRectSurface => ref Unsafe.AsRef<float>(&Handle->DragDropAcceptIdCurrRectSurface);
		/// <summary>
		/// Target item id (set at the time of accepting the payload)<br/>
		/// </summary>
		public ref int DragDropAcceptIdCurr => ref Unsafe.AsRef<int>(&Handle->DragDropAcceptIdCurr);
		/// <summary>
		/// Target item id from previous frame (we need to store this to allow for overlapping drag and drop targets)<br/>
		/// </summary>
		public ref int DragDropAcceptIdPrev => ref Unsafe.AsRef<int>(&Handle->DragDropAcceptIdPrev);
		/// <summary>
		/// Last time a target expressed a desire to accept the source<br/>
		/// </summary>
		public ref int DragDropAcceptFrameCount => ref Unsafe.AsRef<int>(&Handle->DragDropAcceptFrameCount);
		/// <summary>
		/// Set when holding a payload just made ButtonBehavior() return a press.<br/>
		/// </summary>
		public ref int DragDropHoldJustPressedId => ref Unsafe.AsRef<int>(&Handle->DragDropHoldJustPressedId);
		/// <summary>
		/// We don't expose the ImVector&lt;&gt; directly, ImGuiPayload only holds pointer+size<br/>
		/// </summary>
		public ref ImVectorUnsignedChar DragDropPayloadBufHeap => ref Unsafe.AsRef<ImVectorUnsignedChar>(&Handle->DragDropPayloadBufHeap);
		/// <summary>
		/// Local buffer for small payloads<br/>
		/// </summary>
		public unsafe Span<byte> DragDropPayloadBufLocal
		
		{
			get
			{
				return new Span<byte>(&Handle->DragDropPayloadBufLocal_0, 16);
			}
		}
		public ref int ClipperTempDataStacked => ref Unsafe.AsRef<int>(&Handle->ClipperTempDataStacked);
		public ref ImVectorImGuiListClipperData ClipperTempData => ref Unsafe.AsRef<ImVectorImGuiListClipperData>(&Handle->ClipperTempData);
		public ref ImGuiTablePtr CurrentTable => ref Unsafe.AsRef<ImGuiTablePtr>(&Handle->CurrentTable);
		/// <summary>
		/// Temporary table data size (because we leave previous instances undestructed, we generally don't use TablesTempData.Size)<br/>
		/// </summary>
		public ref int TablesTempDataStacked => ref Unsafe.AsRef<int>(&Handle->TablesTempDataStacked);
		/// <summary>
		/// Temporary table data (buffers reusedshared across instances, support nesting)<br/>
		/// </summary>
		public ref ImVectorImGuiTableTempData TablesTempData => ref Unsafe.AsRef<ImVectorImGuiTableTempData>(&Handle->TablesTempData);
		/// <summary>
		/// Persistent table data<br/>
		/// </summary>
		public ref ImPoolImGuiTable Tables => ref Unsafe.AsRef<ImPoolImGuiTable>(&Handle->Tables);
		/// <summary>
		/// Last used timestamp of each tables (SOA, for efficient GC)<br/>
		/// </summary>
		public ref ImVectorFloat TablesLastTimeActive => ref Unsafe.AsRef<ImVectorFloat>(&Handle->TablesLastTimeActive);
		public ref ImVectorImDrawChannel DrawChannelsTempMergeBuffer => ref Unsafe.AsRef<ImVectorImDrawChannel>(&Handle->DrawChannelsTempMergeBuffer);
		public ref ImGuiTabBarPtr CurrentTabBar => ref Unsafe.AsRef<ImGuiTabBarPtr>(&Handle->CurrentTabBar);
		public ref ImPoolImGuiTabBar TabBars => ref Unsafe.AsRef<ImPoolImGuiTabBar>(&Handle->TabBars);
		public ref ImVectorImGuiPtrOrIndex CurrentTabBarStack => ref Unsafe.AsRef<ImVectorImGuiPtrOrIndex>(&Handle->CurrentTabBarStack);
		public ref ImVectorImGuiShrinkWidthItem ShrinkWidthBuffer => ref Unsafe.AsRef<ImVectorImGuiShrinkWidthItem>(&Handle->ShrinkWidthBuffer);
		public ref int HoverItemDelayId => ref Unsafe.AsRef<int>(&Handle->HoverItemDelayId);
		public ref int HoverItemDelayIdPreviousFrame => ref Unsafe.AsRef<int>(&Handle->HoverItemDelayIdPreviousFrame);
		/// <summary>
		/// Currently used by IsItemHovered()<br/>
		/// </summary>
		public ref float HoverItemDelayTimer => ref Unsafe.AsRef<float>(&Handle->HoverItemDelayTimer);
		/// <summary>
		/// Currently used by IsItemHovered(): grace time before g.TooltipHoverTimer gets cleared.<br/>
		/// </summary>
		public ref float HoverItemDelayClearTimer => ref Unsafe.AsRef<float>(&Handle->HoverItemDelayClearTimer);
		/// <summary>
		/// Mouse has once been stationary on this item. Only reset after departing the item.<br/>
		/// </summary>
		public ref int HoverItemUnlockedStationaryId => ref Unsafe.AsRef<int>(&Handle->HoverItemUnlockedStationaryId);
		/// <summary>
		/// Mouse has once been stationary on this window. Only reset after departing the window.<br/>
		/// </summary>
		public ref int HoverWindowUnlockedStationaryId => ref Unsafe.AsRef<int>(&Handle->HoverWindowUnlockedStationaryId);
		public ref ImGuiMouseCursor MouseCursor => ref Unsafe.AsRef<ImGuiMouseCursor>(&Handle->MouseCursor);
		/// <summary>
		/// Time the mouse has been stationary (with some loose heuristic)<br/>
		/// </summary>
		public ref float MouseStationaryTimer => ref Unsafe.AsRef<float>(&Handle->MouseStationaryTimer);
		public ref Vector2 MouseLastValidPos => ref Unsafe.AsRef<Vector2>(&Handle->MouseLastValidPos);
		public ref ImGuiInputTextState InputTextState => ref Unsafe.AsRef<ImGuiInputTextState>(&Handle->InputTextState);
		public ref ImGuiInputTextDeactivatedState InputTextDeactivatedState => ref Unsafe.AsRef<ImGuiInputTextDeactivatedState>(&Handle->InputTextDeactivatedState);
		public ref ImFont InputTextPasswordFont => ref Unsafe.AsRef<ImFont>(&Handle->InputTextPasswordFont);
		/// <summary>
		/// Temporary text input when CTRL+clicking on a slider, etc.<br/>
		/// </summary>
		public ref int TempInputId => ref Unsafe.AsRef<int>(&Handle->TempInputId);
		/// <summary>
		/// Store user options for color edit widgets<br/>
		/// </summary>
		public ref ImGuiColorEditFlags ColorEditOptions => ref Unsafe.AsRef<ImGuiColorEditFlags>(&Handle->ColorEditOptions);
		/// <summary>
		/// Set temporarily while inside of the parent-most ColorEdit4ColorPicker4 (because they call each others).<br/>
		/// </summary>
		public ref int ColorEditCurrentID => ref Unsafe.AsRef<int>(&Handle->ColorEditCurrentID);
		/// <summary>
		/// ID we are savingrestoring HS for<br/>
		/// </summary>
		public ref int ColorEditSavedID => ref Unsafe.AsRef<int>(&Handle->ColorEditSavedID);
		/// <summary>
		/// Backup of last Hue associated to LastColor, so we can restore Hue in lossy RGB&lt;&gt;HSV round trips<br/>
		/// </summary>
		public ref float ColorEditSavedHue => ref Unsafe.AsRef<float>(&Handle->ColorEditSavedHue);
		/// <summary>
		/// Backup of last Saturation associated to LastColor, so we can restore Saturation in lossy RGB&lt;&gt;HSV round trips<br/>
		/// </summary>
		public ref float ColorEditSavedSat => ref Unsafe.AsRef<float>(&Handle->ColorEditSavedSat);
		/// <summary>
		/// RGB value with alpha set to 0.<br/>
		/// </summary>
		public ref uint ColorEditSavedColor => ref Unsafe.AsRef<uint>(&Handle->ColorEditSavedColor);
		/// <summary>
		/// Initialreference color at the time of opening the color picker.<br/>
		/// </summary>
		public ref Vector4 ColorPickerRef => ref Unsafe.AsRef<Vector4>(&Handle->ColorPickerRef);
		public ref ImGuiComboPreviewData ComboPreviewData => ref Unsafe.AsRef<ImGuiComboPreviewData>(&Handle->ComboPreviewData);
		public ref float SliderGrabClickOffset => ref Unsafe.AsRef<float>(&Handle->SliderGrabClickOffset);
		/// <summary>
		/// Accumulated slider delta when using navigation controls.<br/>
		/// </summary>
		public ref float SliderCurrentAccum => ref Unsafe.AsRef<float>(&Handle->SliderCurrentAccum);
		/// <summary>
		/// Has the accumulated slider delta changed since last time we tried to apply it?<br/>
		/// </summary>
		public ref bool SliderCurrentAccumDirty => ref Unsafe.AsRef<bool>(&Handle->SliderCurrentAccumDirty);
		public ref bool DragCurrentAccumDirty => ref Unsafe.AsRef<bool>(&Handle->DragCurrentAccumDirty);
		/// <summary>
		/// Accumulator for dragging modification. Always high-precision, not rounded by end-user precision settings<br/>
		/// </summary>
		public ref float DragCurrentAccum => ref Unsafe.AsRef<float>(&Handle->DragCurrentAccum);
		/// <summary>
		/// If speed == 0.0f, uses (max-min) * DragSpeedDefaultRatio<br/>
		/// </summary>
		public ref float DragSpeedDefaultRatio => ref Unsafe.AsRef<float>(&Handle->DragSpeedDefaultRatio);
		/// <summary>
		/// Distance between mouse and center of grab box, normalized in parent space. Use storage?<br/>
		/// </summary>
		public ref float ScrollbarClickDeltaToGrabCenter => ref Unsafe.AsRef<float>(&Handle->ScrollbarClickDeltaToGrabCenter);
		/// <summary>
		/// Backup for style.Alpha for BeginDisabled()<br/>
		/// </summary>
		public ref float DisabledAlphaBackup => ref Unsafe.AsRef<float>(&Handle->DisabledAlphaBackup);
		public ref short DisabledStackSize => ref Unsafe.AsRef<short>(&Handle->DisabledStackSize);
		public ref short TooltipOverrideCount => ref Unsafe.AsRef<short>(&Handle->TooltipOverrideCount);
		/// <summary>
		/// If no custom clipboard handler is defined<br/>
		/// </summary>
		public ref ImVectorChar ClipboardHandlerData => ref Unsafe.AsRef<ImVectorChar>(&Handle->ClipboardHandlerData);
		/// <summary>
		/// A list of menu IDs that were rendered at least once<br/>
		/// </summary>
		public ref ImVectorImGuiID MenusIdSubmittedThisFrame => ref Unsafe.AsRef<ImVectorImGuiID>(&Handle->MenusIdSubmittedThisFrame);
		/// <summary>
		/// Platform support Data updated by current frame<br/>
		/// </summary>
		public ref ImGuiPlatformImeData PlatformImeData => ref Unsafe.AsRef<ImGuiPlatformImeData>(&Handle->PlatformImeData);
		/// <summary>
		/// Previous frame data (when changing we will call io.SetPlatformImeDataFn<br/>
		/// </summary>
		public ref ImGuiPlatformImeData PlatformImeDataPrev => ref Unsafe.AsRef<ImGuiPlatformImeData>(&Handle->PlatformImeDataPrev);
		public ref int PlatformImeViewport => ref Unsafe.AsRef<int>(&Handle->PlatformImeViewport);
		/// <summary>
		/// '.' or *localeconv()-&gt;decimal_point<br/>
		/// </summary>
		public ref byte PlatformLocaleDecimalPoint => ref Unsafe.AsRef<byte>(&Handle->PlatformLocaleDecimalPoint);
		public ref ImGuiDockContext DockContext => ref Unsafe.AsRef<ImGuiDockContext>(&Handle->DockContext);
		public void* DockNodeWindowMenuHandler { get => Handle->DockNodeWindowMenuHandler; set => Handle->DockNodeWindowMenuHandler = value; }
		public ref bool SettingsLoaded => ref Unsafe.AsRef<bool>(&Handle->SettingsLoaded);
		/// <summary>
		/// Save .ini Settings to memory when time reaches zero<br/>
		/// </summary>
		public ref float SettingsDirtyTimer => ref Unsafe.AsRef<float>(&Handle->SettingsDirtyTimer);
		/// <summary>
		/// In memory .ini settings<br/>
		/// </summary>
		public ref ImGuiTextBuffer SettingsIniData => ref Unsafe.AsRef<ImGuiTextBuffer>(&Handle->SettingsIniData);
		/// <summary>
		/// List of .ini settings handlers<br/>
		/// </summary>
		public ref ImVectorImGuiSettingsHandler SettingsHandlers => ref Unsafe.AsRef<ImVectorImGuiSettingsHandler>(&Handle->SettingsHandlers);
		/// <summary>
		/// ImGuiWindow .ini settings entries<br/>
		/// </summary>
		public ref ImChunkStreamImGuiWindowSettings SettingsWindows => ref Unsafe.AsRef<ImChunkStreamImGuiWindowSettings>(&Handle->SettingsWindows);
		/// <summary>
		/// ImGuiTable .ini settings entries<br/>
		/// </summary>
		public ref ImChunkStreamImGuiTableSettings SettingsTables => ref Unsafe.AsRef<ImChunkStreamImGuiTableSettings>(&Handle->SettingsTables);
		/// <summary>
		/// Hooks for extensions (e.g. test engine)<br/>
		/// </summary>
		public ref ImVectorImGuiContextHook Hooks => ref Unsafe.AsRef<ImVectorImGuiContextHook>(&Handle->Hooks);
		/// <summary>
		/// Next available HookId<br/>
		/// </summary>
		public ref int HookIdNext => ref Unsafe.AsRef<int>(&Handle->HookIdNext);
		/// <summary>
		/// CaptureLogging Currently capturing<br/>
		/// </summary>
		public ref bool LogEnabled => ref Unsafe.AsRef<bool>(&Handle->LogEnabled);
		/// <summary>
		/// Capture target<br/>
		/// </summary>
		public ref ImGuiLogType LogType => ref Unsafe.AsRef<ImGuiLogType>(&Handle->LogType);
		/// <summary>
		/// If != NULL log to stdout file<br/>
		/// </summary>
		public ref ImFileHandle LogFile => ref Unsafe.AsRef<ImFileHandle>(&Handle->LogFile);
		/// <summary>
		/// Accumulation buffer when log to clipboard. This is pointer so our GImGui static constructor doesn't call heap allocators.<br/>
		/// </summary>
		public ref ImGuiTextBuffer LogBuffer => ref Unsafe.AsRef<ImGuiTextBuffer>(&Handle->LogBuffer);
		public byte* LogNextPrefix { get => Handle->LogNextPrefix; set => Handle->LogNextPrefix = value; }
		public byte* LogNextSuffix { get => Handle->LogNextSuffix; set => Handle->LogNextSuffix = value; }
		public ref float LogLinePosY => ref Unsafe.AsRef<float>(&Handle->LogLinePosY);
		public ref bool LogLineFirstItem => ref Unsafe.AsRef<bool>(&Handle->LogLineFirstItem);
		public ref int LogDepthRef => ref Unsafe.AsRef<int>(&Handle->LogDepthRef);
		public ref int LogDepthToExpand => ref Unsafe.AsRef<int>(&Handle->LogDepthToExpand);
		/// <summary>
		/// Defaultstored value for LogDepthMaxExpand if not specified in the LogXXX function call.<br/>
		/// </summary>
		public ref int LogDepthToExpandDefault => ref Unsafe.AsRef<int>(&Handle->LogDepthToExpandDefault);
		public ref ImGuiDebugLogFlags DebugLogFlags => ref Unsafe.AsRef<ImGuiDebugLogFlags>(&Handle->DebugLogFlags);
		public ref ImGuiTextBuffer DebugLogBuf => ref Unsafe.AsRef<ImGuiTextBuffer>(&Handle->DebugLogBuf);
		public ref ImGuiTextIndex DebugLogIndex => ref Unsafe.AsRef<ImGuiTextIndex>(&Handle->DebugLogIndex);
		public ref byte DebugLogClipperAutoDisableFrames => ref Unsafe.AsRef<byte>(&Handle->DebugLogClipperAutoDisableFrames);
		/// <summary>
		/// For DebugLocateItemOnHover(). This is used together with DebugLocateId which is in a hotcached spot above.<br/>
		/// </summary>
		public ref byte DebugLocateFrames => ref Unsafe.AsRef<byte>(&Handle->DebugLocateFrames);
		/// <summary>
		/// Cycle between 0..9 then wrap around.<br/>
		/// </summary>
		public ref sbyte DebugBeginReturnValueCullDepth => ref Unsafe.AsRef<sbyte>(&Handle->DebugBeginReturnValueCullDepth);
		/// <summary>
		/// Item picker is active (started with DebugStartItemPicker())<br/>
		/// </summary>
		public ref bool DebugItemPickerActive => ref Unsafe.AsRef<bool>(&Handle->DebugItemPickerActive);
		public ref byte DebugItemPickerMouseButton => ref Unsafe.AsRef<byte>(&Handle->DebugItemPickerMouseButton);
		/// <summary>
		/// Will call IM_DEBUG_BREAK() when encountering this ID<br/>
		/// </summary>
		public ref int DebugItemPickerBreakId => ref Unsafe.AsRef<int>(&Handle->DebugItemPickerBreakId);
		public ref ImGuiMetricsConfig DebugMetricsConfig => ref Unsafe.AsRef<ImGuiMetricsConfig>(&Handle->DebugMetricsConfig);
		public ref ImGuiStackTool DebugStackTool => ref Unsafe.AsRef<ImGuiStackTool>(&Handle->DebugStackTool);
		/// <summary>
		/// Hovered dock node.<br/>
		/// </summary>
		public ref ImGuiDockNodePtr DebugHoveredDockNode => ref Unsafe.AsRef<ImGuiDockNodePtr>(&Handle->DebugHoveredDockNode);
		/// <summary>
		/// Misc Calculate estimate of framerate for user over the last 60 frames..<br/>
		/// </summary>
		public unsafe Span<float> FramerateSecPerFrame
		
		{
			get
			{
				return new Span<float>(&Handle->FramerateSecPerFrame_0, 60);
			}
		}
		public ref int FramerateSecPerFrameIdx => ref Unsafe.AsRef<int>(&Handle->FramerateSecPerFrameIdx);
		public ref int FramerateSecPerFrameCount => ref Unsafe.AsRef<int>(&Handle->FramerateSecPerFrameCount);
		public ref float FramerateSecPerFrameAccum => ref Unsafe.AsRef<float>(&Handle->FramerateSecPerFrameAccum);
		/// <summary>
		/// Explicit capture override via SetNextFrameWantCaptureMouse()SetNextFrameWantCaptureKeyboard(). Default to -1.<br/>
		/// </summary>
		public ref int WantCaptureMouseNextFrame => ref Unsafe.AsRef<int>(&Handle->WantCaptureMouseNextFrame);
		/// <summary>
		/// "<br/>
		/// </summary>
		public ref int WantCaptureKeyboardNextFrame => ref Unsafe.AsRef<int>(&Handle->WantCaptureKeyboardNextFrame);
		public ref int WantTextInputNextFrame => ref Unsafe.AsRef<int>(&Handle->WantTextInputNextFrame);
		/// <summary>
		/// Temporary text buffer<br/>
		/// </summary>
		public ref ImVectorChar TempBuffer => ref Unsafe.AsRef<ImVectorChar>(&Handle->TempBuffer);

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiIO
	{
		/// <summary>
		/// = 0               See ImGuiConfigFlags_ enum. Set by userapplication. Gamepadkeyboard navigation options, etc.<br/>
		/// </summary>
		public ImGuiConfigFlags ConfigFlags;

		/// <summary>
		/// = 0               See ImGuiBackendFlags_ enum. Set by backend (imgui_impl_xxx files or custom backend) to communicate features supported by the backend.<br/>
		/// </summary>
		public ImGuiBackendFlags BackendFlags;

		/// <summary>
		/// &lt;unset&gt;           Main display size, in pixels (generally == GetMainViewport()-&gt;Size). May change every frame.<br/>
		/// </summary>
		public Vector2 DisplaySize;

		/// <summary>
		/// = 1.0f60.0f      Time elapsed since last frame, in seconds. May change every frame.<br/>
		/// </summary>
		public float DeltaTime;

		/// <summary>
		/// = 5.0f            Minimum time between saving positionssizes to .ini file, in seconds.<br/>
		/// </summary>
		public float IniSavingRate;

		/// <summary>
		/// = "imgui.ini"     Path to .ini file (important: default "imgui.ini" is relative to current working dir!). Set NULL to disable automatic .ini loadingsaving or if you want to manually call LoadIniSettingsXXX()  SaveIniSettingsXXX() functions.<br/>
		/// </summary>
		public unsafe byte* IniFilename;

		/// <summary>
		/// = "imgui_log.txt" Path to .log file (default parameter to ImGui::LogToFile when no file is specified).<br/>
		/// </summary>
		public unsafe byte* LogFilename;

		/// <summary>
		/// = NULL            Store your own data.<br/>
		/// </summary>
		public unsafe void* UserData;

		/// <summary>
		/// &lt;auto&gt;            Font atlas: load, rasterize and pack one or more fonts into a single texture.<br/>
		/// </summary>
		public unsafe ImFontAtlas* Fonts;

		/// <summary>
		/// = 1.0f            Global scale all fonts<br/>
		/// </summary>
		public float FontGlobalScale;

		/// <summary>
		/// = false           Allow user scaling text of individual window with CTRL+Wheel.<br/>
		/// </summary>
		public byte FontAllowUserScaling;

		/// <summary>
		/// = NULL            Font to use on NewFrame(). Use NULL to uses Fonts-&gt;Fonts[0].<br/>
		/// </summary>
		public unsafe ImFont* FontDefault;

		/// <summary>
		/// = (1, 1)          For retina display or other situations where window coordinates are different from framebuffer coordinates. This generally ends up in ImDrawData::FramebufferScale.<br/>
		/// </summary>
		public Vector2 DisplayFramebufferScale;

		/// <summary>
		/// Docking options (when ImGuiConfigFlags_DockingEnable is set) = false           Simplified docking mode: disable window splitting, so docking is limited to merging multiple windows together into tab-bars.<br/>
		/// </summary>
		public byte ConfigDockingNoSplit;

		/// <summary>
		/// = false           Enable docking with holding Shift key (reduce visual noise, allows dropping in wider space)<br/>
		/// </summary>
		public byte ConfigDockingWithShift;

		/// <summary>
		/// = false           [BETA] [FIXME: This currently creates regression with auto-sizing and general overhead] Make every single floating window display within a docking node.<br/>
		/// </summary>
		public byte ConfigDockingAlwaysTabBar;

		/// <summary>
		/// = false           [BETA] Make window or viewport transparent when docking and only display docking boxes on the target viewport. Useful if rendering of multiple viewport cannot be synced. Best used with ConfigViewportsNoAutoMerge.<br/>
		/// </summary>
		public byte ConfigDockingTransparentPayload;

		/// <summary>
		/// Viewport options (when ImGuiConfigFlags_ViewportsEnable is set) = false;          Set to make all floating imgui windows always create their own viewport. Otherwise, they are merged into the main host viewports when overlapping it. May also set ImGuiViewportFlags_NoAutoMerge on individual viewport.<br/>
		/// </summary>
		public byte ConfigViewportsNoAutoMerge;

		/// <summary>
		/// = false           Disable default OS task bar icon flag for secondary viewports. When a viewport doesn't want a task bar icon, ImGuiViewportFlags_NoTaskBarIcon will be set on it.<br/>
		/// </summary>
		public byte ConfigViewportsNoTaskBarIcon;

		/// <summary>
		/// = true            Disable default OS window decoration flag for secondary viewports. When a viewport doesn't want window decorations, ImGuiViewportFlags_NoDecoration will be set on it. Enabling decoration can create subsequent issues at OS levels (e.g. minimum window size).<br/>
		/// </summary>
		public byte ConfigViewportsNoDecoration;

		/// <summary>
		/// = false           Disable default OS parenting to main viewport for secondary viewports. By default, viewports are marked with ParentViewportId = &lt;main_viewport&gt;, expecting the platform backend to setup a parentchild relationship between the OS windows (some backend may ignore this). Set to true if you want the default to be 0, then all viewports will be top-level OS windows.<br/>
		/// </summary>
		public byte ConfigViewportsNoDefaultParent;

		/// <summary>
		/// Miscellaneous options = false           Request ImGui to draw a mouse cursor for you (if you are on a platform without a mouse cursor). Cannot be easily renamed to 'io.ConfigXXX' because this is frequently used by backend implementations.<br/>
		/// </summary>
		public byte MouseDrawCursor;

		/// <summary>
		/// = defined(__APPLE__)  OS X style: Text editing cursor movement using Alt instead of Ctrl, Shortcuts using CmdSuper instead of Ctrl, LineText Start and End using Cmd+Arrows instead of HomeEnd, Double click selects by word instead of selecting whole text, Multi-selection in lists uses CmdSuper instead of Ctrl.<br/>
		/// </summary>
		public byte ConfigMacOSXBehaviors;

		/// <summary>
		/// = true            Enable input queue trickling: some types of events submitted during the same frame (e.g. button down + up) will be spread over multiple frames, improving interactions with low framerates.<br/>
		/// </summary>
		public byte ConfigInputTrickleEventQueue;

		/// <summary>
		/// = true            Enable blinking cursor (optional as some users consider it to be distracting).<br/>
		/// </summary>
		public byte ConfigInputTextCursorBlink;

		/// <summary>
		/// = false           [BETA] Pressing Enter will keep item active and select contents (single-line only).<br/>
		/// </summary>
		public byte ConfigInputTextEnterKeepActive;

		/// <summary>
		/// = false           [BETA] Enable turning DragXXX widgets into text input with a simple mouse click-release (without moving). Not desirable on devices without a keyboard.<br/>
		/// </summary>
		public byte ConfigDragClickToInputText;

		/// <summary>
		/// = true            Enable resizing of windows from their edges and from the lower-left corner. This requires (io.BackendFlags &amp; ImGuiBackendFlags_HasMouseCursors) because it needs mouse cursor feedback. (This used to be a per-window ImGuiWindowFlags_ResizeFromAnySide flag)<br/>
		/// </summary>
		public byte ConfigWindowsResizeFromEdges;

		/// <summary>
		/// = false        Enable allowing to move windows only when clicking on their title bar. Does not apply to windows without a title bar.<br/>
		/// </summary>
		public byte ConfigWindowsMoveFromTitleBarOnly;

		/// <summary>
		/// = 60.0f           Timer (in seconds) to free transient windowstables memory buffers when unused. Set to -1.0f to disable.<br/>
		/// </summary>
		public float ConfigMemoryCompactTimer;

		/// <summary>
		/// Inputs Behaviors<br/>
		/// (other variables, ones which are expected to be tweaked within UI code, are exposed in ImGuiStyle) = 0.30f           Time for a double-click, in seconds.<br/>
		/// </summary>
		public float MouseDoubleClickTime;

		/// <summary>
		/// = 6.0f            Distance threshold to stay in to validate a double-click, in pixels.<br/>
		/// </summary>
		public float MouseDoubleClickMaxDist;

		/// <summary>
		/// = 6.0f            Distance threshold before considering we are dragging.<br/>
		/// </summary>
		public float MouseDragThreshold;

		/// <summary>
		/// = 0.275f          When holding a keybutton, time before it starts repeating, in seconds (for buttons in Repeat mode, etc.).<br/>
		/// </summary>
		public float KeyRepeatDelay;

		/// <summary>
		/// = 0.050f          When holding a keybutton, rate at which it repeats, in seconds.<br/>
		/// </summary>
		public float KeyRepeatRate;

		/// <summary>
		/// Tools to test correct BeginEnd and BeginChildEndChild behaviors.<br/>
		/// Presently Begin()End() and BeginChild()EndChild() needs to ALWAYS be called in tandem, regardless of return value of BeginXXX()<br/>
		/// This is inconsistent with other BeginXXX functions and create confusion for many users.<br/>
		/// We expect to update the API eventually. In the meanwhile we provide tools to facilitate checking user-code behavior. = false           First-time calls to Begin()BeginChild() will return false. NEEDS TO BE SET AT APPLICATION BOOT TIME if you don't want to miss windows.<br/>
		/// </summary>
		public byte ConfigDebugBeginReturnValueOnce;

		/// <summary>
		/// = false           Some calls to Begin()BeginChild() will return false. Will cycle through window depths then repeat. Suggested use: add "io.ConfigDebugBeginReturnValue = io.KeyShift" in your main loop then occasionally press SHIFT. Windows should be flickering while running.<br/>
		/// </summary>
		public byte ConfigDebugBeginReturnValueLoop;

		/// <summary>
		/// Option to deactivate io.AddFocusEvent(false) handling. May facilitate interactions with a debugger when focus loss leads to clearing inputs data.<br/>
		/// Backends may have other side-effects on focus loss, so this will reduce side-effects but not necessary remove all of them.<br/>
		/// Consider using e.g. Win32's IsDebuggerPresent() as an additional filter (or see ImOsIsDebuggerPresent() in imgui_test_engineimgui_te_utils.cpp for a Unix compatible version). = false           Ignore io.AddFocusEvent(false), consequently not calling io.ClearInputKeys() in input processing.<br/>
		/// </summary>
		public byte ConfigDebugIgnoreFocusLoss;

		/// <summary>
		/// Option to audit .ini data = false           Save .ini data with extra comments (particularly helpful for Docking, but makes saving slower)<br/>
		/// </summary>
		public byte ConfigDebugIniSettings;

		/// <summary>
		/// Optional: PlatformRenderer backend name (informational only! will be displayed in About Window) + User data for backendwrappers to store their own stuff. = NULL<br/>
		/// </summary>
		public unsafe byte* BackendPlatformName;

		/// <summary>
		/// = NULL<br/>
		/// </summary>
		public unsafe byte* BackendRendererName;

		/// <summary>
		/// = NULL            User data for platform backend<br/>
		/// </summary>
		public unsafe void* BackendPlatformUserData;

		/// <summary>
		/// = NULL            User data for renderer backend<br/>
		/// </summary>
		public unsafe void* BackendRendererUserData;

		/// <summary>
		/// = NULL            User data for non C++ programming language backend<br/>
		/// </summary>
		public unsafe void* BackendLanguageUserData;

		public unsafe void* GetClipboardTextFn;
		public unsafe void* SetClipboardTextFn;
		public unsafe void* ClipboardUserData;
		public unsafe void* SetPlatformImeDataFn;
		/// <summary>
		/// Unused field to keep data structure the same size.<br/>
		/// </summary>
		public unsafe void* UnusedPadding;

		/// <summary>
		/// Set when Dear ImGui will use mouse inputs, in this case do not dispatch them to your main gameapplication (either way, always pass on mouse inputs to imgui). (e.g. unclicked mouse is hovering over an imgui window, widget is active, mouse was clicked over an imgui window, etc.).<br/>
		/// </summary>
		public byte WantCaptureMouse;

		/// <summary>
		/// Set when Dear ImGui will use keyboard inputs, in this case do not dispatch them to your main gameapplication (either way, always pass keyboard inputs to imgui). (e.g. InputText active, or an imgui window is focused and navigation is enabled, etc.).<br/>
		/// </summary>
		public byte WantCaptureKeyboard;

		/// <summary>
		/// Mobileconsole: when set, you may display an on-screen keyboard. This is set by Dear ImGui when it wants textual keyboard input to happen (e.g. when a InputText widget is active).<br/>
		/// </summary>
		public byte WantTextInput;

		/// <summary>
		/// MousePos has been altered, backend should reposition mouse on next frame. Rarely used! Set only when ImGuiConfigFlags_NavEnableSetMousePos flag is enabled.<br/>
		/// </summary>
		public byte WantSetMousePos;

		/// <summary>
		/// When manual .ini loadsave is active (io.IniFilename == NULL), this will be set to notify your application that you can call SaveIniSettingsToMemory() and save yourself. Important: clear io.WantSaveIniSettings yourself after saving!<br/>
		/// </summary>
		public byte WantSaveIniSettings;

		/// <summary>
		/// KeyboardGamepad navigation is currently allowed (will handle ImGuiKey_NavXXX events) = a window is focused and it doesn't use the ImGuiWindowFlags_NoNavInputs flag.<br/>
		/// </summary>
		public byte NavActive;

		/// <summary>
		/// KeyboardGamepad navigation is visible and allowed (will handle ImGuiKey_NavXXX events).<br/>
		/// </summary>
		public byte NavVisible;

		/// <summary>
		/// Estimate of application framerate (rolling average over 60 frames, based on io.DeltaTime), in frame per second. Solely for convenience. Slow applications may not want to use a moving average or may want to reset underlying buffers occasionally.<br/>
		/// </summary>
		public float Framerate;

		/// <summary>
		/// Vertices output during last call to Render()<br/>
		/// </summary>
		public int MetricsRenderVertices;

		/// <summary>
		/// Indices output during last call to Render() = number of triangles * 3<br/>
		/// </summary>
		public int MetricsRenderIndices;

		/// <summary>
		/// Number of visible windows<br/>
		/// </summary>
		public int MetricsRenderWindows;

		/// <summary>
		/// Number of active windows<br/>
		/// </summary>
		public int MetricsActiveWindows;

		/// <summary>
		/// Number of active allocations, updated by MemAllocMemFree based on current context. May be off if you have multiple imgui contexts.<br/>
		/// </summary>
		public int MetricsActiveAllocations;

		/// <summary>
		/// Mouse delta. Note that this is zero if either current or previous position are invalid (-FLT_MAX,-FLT_MAX), so a disappearingreappearing mouse won't have a huge delta.<br/>
		/// </summary>
		public Vector2 MouseDelta;

		/// <summary>
		/// [LEGACY] Input: map of indices into the KeysDown[512] entries array which represent your "native" keyboard state. The first 512 are now unused and should be kept zero. Legacy backend will write into KeyMap[] using ImGuiKey_ indices which are always &gt;512.<br/>
		/// </summary>
		public int KeyMap_0;
		public int KeyMap_1;
		public int KeyMap_2;
		public int KeyMap_3;
		public int KeyMap_4;
		public int KeyMap_5;
		public int KeyMap_6;
		public int KeyMap_7;
		public int KeyMap_8;
		public int KeyMap_9;
		public int KeyMap_10;
		public int KeyMap_11;
		public int KeyMap_12;
		public int KeyMap_13;
		public int KeyMap_14;
		public int KeyMap_15;
		public int KeyMap_16;
		public int KeyMap_17;
		public int KeyMap_18;
		public int KeyMap_19;
		public int KeyMap_20;
		public int KeyMap_21;
		public int KeyMap_22;
		public int KeyMap_23;
		public int KeyMap_24;
		public int KeyMap_25;
		public int KeyMap_26;
		public int KeyMap_27;
		public int KeyMap_28;
		public int KeyMap_29;
		public int KeyMap_30;
		public int KeyMap_31;
		public int KeyMap_32;
		public int KeyMap_33;
		public int KeyMap_34;
		public int KeyMap_35;
		public int KeyMap_36;
		public int KeyMap_37;
		public int KeyMap_38;
		public int KeyMap_39;
		public int KeyMap_40;
		public int KeyMap_41;
		public int KeyMap_42;
		public int KeyMap_43;
		public int KeyMap_44;
		public int KeyMap_45;
		public int KeyMap_46;
		public int KeyMap_47;
		public int KeyMap_48;
		public int KeyMap_49;
		public int KeyMap_50;
		public int KeyMap_51;
		public int KeyMap_52;
		public int KeyMap_53;
		public int KeyMap_54;
		public int KeyMap_55;
		public int KeyMap_56;
		public int KeyMap_57;
		public int KeyMap_58;
		public int KeyMap_59;
		public int KeyMap_60;
		public int KeyMap_61;
		public int KeyMap_62;
		public int KeyMap_63;
		public int KeyMap_64;
		public int KeyMap_65;
		public int KeyMap_66;
		public int KeyMap_67;
		public int KeyMap_68;
		public int KeyMap_69;
		public int KeyMap_70;
		public int KeyMap_71;
		public int KeyMap_72;
		public int KeyMap_73;
		public int KeyMap_74;
		public int KeyMap_75;
		public int KeyMap_76;
		public int KeyMap_77;
		public int KeyMap_78;
		public int KeyMap_79;
		public int KeyMap_80;
		public int KeyMap_81;
		public int KeyMap_82;
		public int KeyMap_83;
		public int KeyMap_84;
		public int KeyMap_85;
		public int KeyMap_86;
		public int KeyMap_87;
		public int KeyMap_88;
		public int KeyMap_89;
		public int KeyMap_90;
		public int KeyMap_91;
		public int KeyMap_92;
		public int KeyMap_93;
		public int KeyMap_94;
		public int KeyMap_95;
		public int KeyMap_96;
		public int KeyMap_97;
		public int KeyMap_98;
		public int KeyMap_99;
		public int KeyMap_100;
		public int KeyMap_101;
		public int KeyMap_102;
		public int KeyMap_103;
		public int KeyMap_104;
		public int KeyMap_105;
		public int KeyMap_106;
		public int KeyMap_107;
		public int KeyMap_108;
		public int KeyMap_109;
		public int KeyMap_110;
		public int KeyMap_111;
		public int KeyMap_112;
		public int KeyMap_113;
		public int KeyMap_114;
		public int KeyMap_115;
		public int KeyMap_116;
		public int KeyMap_117;
		public int KeyMap_118;
		public int KeyMap_119;
		public int KeyMap_120;
		public int KeyMap_121;
		public int KeyMap_122;
		public int KeyMap_123;
		public int KeyMap_124;
		public int KeyMap_125;
		public int KeyMap_126;
		public int KeyMap_127;
		public int KeyMap_128;
		public int KeyMap_129;
		public int KeyMap_130;
		public int KeyMap_131;
		public int KeyMap_132;
		public int KeyMap_133;
		public int KeyMap_134;
		public int KeyMap_135;
		public int KeyMap_136;
		public int KeyMap_137;
		public int KeyMap_138;
		public int KeyMap_139;
		public int KeyMap_140;
		public int KeyMap_141;
		public int KeyMap_142;
		public int KeyMap_143;
		public int KeyMap_144;
		public int KeyMap_145;
		public int KeyMap_146;
		public int KeyMap_147;
		public int KeyMap_148;
		public int KeyMap_149;
		public int KeyMap_150;
		public int KeyMap_151;
		public int KeyMap_152;
		public int KeyMap_153;
		public int KeyMap_154;
		public int KeyMap_155;
		public int KeyMap_156;
		public int KeyMap_157;
		public int KeyMap_158;
		public int KeyMap_159;
		public int KeyMap_160;
		public int KeyMap_161;
		public int KeyMap_162;
		public int KeyMap_163;
		public int KeyMap_164;
		public int KeyMap_165;
		public int KeyMap_166;
		public int KeyMap_167;
		public int KeyMap_168;
		public int KeyMap_169;
		public int KeyMap_170;
		public int KeyMap_171;
		public int KeyMap_172;
		public int KeyMap_173;
		public int KeyMap_174;
		public int KeyMap_175;
		public int KeyMap_176;
		public int KeyMap_177;
		public int KeyMap_178;
		public int KeyMap_179;
		public int KeyMap_180;
		public int KeyMap_181;
		public int KeyMap_182;
		public int KeyMap_183;
		public int KeyMap_184;
		public int KeyMap_185;
		public int KeyMap_186;
		public int KeyMap_187;
		public int KeyMap_188;
		public int KeyMap_189;
		public int KeyMap_190;
		public int KeyMap_191;
		public int KeyMap_192;
		public int KeyMap_193;
		public int KeyMap_194;
		public int KeyMap_195;
		public int KeyMap_196;
		public int KeyMap_197;
		public int KeyMap_198;
		public int KeyMap_199;
		public int KeyMap_200;
		public int KeyMap_201;
		public int KeyMap_202;
		public int KeyMap_203;
		public int KeyMap_204;
		public int KeyMap_205;
		public int KeyMap_206;
		public int KeyMap_207;
		public int KeyMap_208;
		public int KeyMap_209;
		public int KeyMap_210;
		public int KeyMap_211;
		public int KeyMap_212;
		public int KeyMap_213;
		public int KeyMap_214;
		public int KeyMap_215;
		public int KeyMap_216;
		public int KeyMap_217;
		public int KeyMap_218;
		public int KeyMap_219;
		public int KeyMap_220;
		public int KeyMap_221;
		public int KeyMap_222;
		public int KeyMap_223;
		public int KeyMap_224;
		public int KeyMap_225;
		public int KeyMap_226;
		public int KeyMap_227;
		public int KeyMap_228;
		public int KeyMap_229;
		public int KeyMap_230;
		public int KeyMap_231;
		public int KeyMap_232;
		public int KeyMap_233;
		public int KeyMap_234;
		public int KeyMap_235;
		public int KeyMap_236;
		public int KeyMap_237;
		public int KeyMap_238;
		public int KeyMap_239;
		public int KeyMap_240;
		public int KeyMap_241;
		public int KeyMap_242;
		public int KeyMap_243;
		public int KeyMap_244;
		public int KeyMap_245;
		public int KeyMap_246;
		public int KeyMap_247;
		public int KeyMap_248;
		public int KeyMap_249;
		public int KeyMap_250;
		public int KeyMap_251;
		public int KeyMap_252;
		public int KeyMap_253;
		public int KeyMap_254;
		public int KeyMap_255;
		public int KeyMap_256;
		public int KeyMap_257;
		public int KeyMap_258;
		public int KeyMap_259;
		public int KeyMap_260;
		public int KeyMap_261;
		public int KeyMap_262;
		public int KeyMap_263;
		public int KeyMap_264;
		public int KeyMap_265;
		public int KeyMap_266;
		public int KeyMap_267;
		public int KeyMap_268;
		public int KeyMap_269;
		public int KeyMap_270;
		public int KeyMap_271;
		public int KeyMap_272;
		public int KeyMap_273;
		public int KeyMap_274;
		public int KeyMap_275;
		public int KeyMap_276;
		public int KeyMap_277;
		public int KeyMap_278;
		public int KeyMap_279;
		public int KeyMap_280;
		public int KeyMap_281;
		public int KeyMap_282;
		public int KeyMap_283;
		public int KeyMap_284;
		public int KeyMap_285;
		public int KeyMap_286;
		public int KeyMap_287;
		public int KeyMap_288;
		public int KeyMap_289;
		public int KeyMap_290;
		public int KeyMap_291;
		public int KeyMap_292;
		public int KeyMap_293;
		public int KeyMap_294;
		public int KeyMap_295;
		public int KeyMap_296;
		public int KeyMap_297;
		public int KeyMap_298;
		public int KeyMap_299;
		public int KeyMap_300;
		public int KeyMap_301;
		public int KeyMap_302;
		public int KeyMap_303;
		public int KeyMap_304;
		public int KeyMap_305;
		public int KeyMap_306;
		public int KeyMap_307;
		public int KeyMap_308;
		public int KeyMap_309;
		public int KeyMap_310;
		public int KeyMap_311;
		public int KeyMap_312;
		public int KeyMap_313;
		public int KeyMap_314;
		public int KeyMap_315;
		public int KeyMap_316;
		public int KeyMap_317;
		public int KeyMap_318;
		public int KeyMap_319;
		public int KeyMap_320;
		public int KeyMap_321;
		public int KeyMap_322;
		public int KeyMap_323;
		public int KeyMap_324;
		public int KeyMap_325;
		public int KeyMap_326;
		public int KeyMap_327;
		public int KeyMap_328;
		public int KeyMap_329;
		public int KeyMap_330;
		public int KeyMap_331;
		public int KeyMap_332;
		public int KeyMap_333;
		public int KeyMap_334;
		public int KeyMap_335;
		public int KeyMap_336;
		public int KeyMap_337;
		public int KeyMap_338;
		public int KeyMap_339;
		public int KeyMap_340;
		public int KeyMap_341;
		public int KeyMap_342;
		public int KeyMap_343;
		public int KeyMap_344;
		public int KeyMap_345;
		public int KeyMap_346;
		public int KeyMap_347;
		public int KeyMap_348;
		public int KeyMap_349;
		public int KeyMap_350;
		public int KeyMap_351;
		public int KeyMap_352;
		public int KeyMap_353;
		public int KeyMap_354;
		public int KeyMap_355;
		public int KeyMap_356;
		public int KeyMap_357;
		public int KeyMap_358;
		public int KeyMap_359;
		public int KeyMap_360;
		public int KeyMap_361;
		public int KeyMap_362;
		public int KeyMap_363;
		public int KeyMap_364;
		public int KeyMap_365;
		public int KeyMap_366;
		public int KeyMap_367;
		public int KeyMap_368;
		public int KeyMap_369;
		public int KeyMap_370;
		public int KeyMap_371;
		public int KeyMap_372;
		public int KeyMap_373;
		public int KeyMap_374;
		public int KeyMap_375;
		public int KeyMap_376;
		public int KeyMap_377;
		public int KeyMap_378;
		public int KeyMap_379;
		public int KeyMap_380;
		public int KeyMap_381;
		public int KeyMap_382;
		public int KeyMap_383;
		public int KeyMap_384;
		public int KeyMap_385;
		public int KeyMap_386;
		public int KeyMap_387;
		public int KeyMap_388;
		public int KeyMap_389;
		public int KeyMap_390;
		public int KeyMap_391;
		public int KeyMap_392;
		public int KeyMap_393;
		public int KeyMap_394;
		public int KeyMap_395;
		public int KeyMap_396;
		public int KeyMap_397;
		public int KeyMap_398;
		public int KeyMap_399;
		public int KeyMap_400;
		public int KeyMap_401;
		public int KeyMap_402;
		public int KeyMap_403;
		public int KeyMap_404;
		public int KeyMap_405;
		public int KeyMap_406;
		public int KeyMap_407;
		public int KeyMap_408;
		public int KeyMap_409;
		public int KeyMap_410;
		public int KeyMap_411;
		public int KeyMap_412;
		public int KeyMap_413;
		public int KeyMap_414;
		public int KeyMap_415;
		public int KeyMap_416;
		public int KeyMap_417;
		public int KeyMap_418;
		public int KeyMap_419;
		public int KeyMap_420;
		public int KeyMap_421;
		public int KeyMap_422;
		public int KeyMap_423;
		public int KeyMap_424;
		public int KeyMap_425;
		public int KeyMap_426;
		public int KeyMap_427;
		public int KeyMap_428;
		public int KeyMap_429;
		public int KeyMap_430;
		public int KeyMap_431;
		public int KeyMap_432;
		public int KeyMap_433;
		public int KeyMap_434;
		public int KeyMap_435;
		public int KeyMap_436;
		public int KeyMap_437;
		public int KeyMap_438;
		public int KeyMap_439;
		public int KeyMap_440;
		public int KeyMap_441;
		public int KeyMap_442;
		public int KeyMap_443;
		public int KeyMap_444;
		public int KeyMap_445;
		public int KeyMap_446;
		public int KeyMap_447;
		public int KeyMap_448;
		public int KeyMap_449;
		public int KeyMap_450;
		public int KeyMap_451;
		public int KeyMap_452;
		public int KeyMap_453;
		public int KeyMap_454;
		public int KeyMap_455;
		public int KeyMap_456;
		public int KeyMap_457;
		public int KeyMap_458;
		public int KeyMap_459;
		public int KeyMap_460;
		public int KeyMap_461;
		public int KeyMap_462;
		public int KeyMap_463;
		public int KeyMap_464;
		public int KeyMap_465;
		public int KeyMap_466;
		public int KeyMap_467;
		public int KeyMap_468;
		public int KeyMap_469;
		public int KeyMap_470;
		public int KeyMap_471;
		public int KeyMap_472;
		public int KeyMap_473;
		public int KeyMap_474;
		public int KeyMap_475;
		public int KeyMap_476;
		public int KeyMap_477;
		public int KeyMap_478;
		public int KeyMap_479;
		public int KeyMap_480;
		public int KeyMap_481;
		public int KeyMap_482;
		public int KeyMap_483;
		public int KeyMap_484;
		public int KeyMap_485;
		public int KeyMap_486;
		public int KeyMap_487;
		public int KeyMap_488;
		public int KeyMap_489;
		public int KeyMap_490;
		public int KeyMap_491;
		public int KeyMap_492;
		public int KeyMap_493;
		public int KeyMap_494;
		public int KeyMap_495;
		public int KeyMap_496;
		public int KeyMap_497;
		public int KeyMap_498;
		public int KeyMap_499;
		public int KeyMap_500;
		public int KeyMap_501;
		public int KeyMap_502;
		public int KeyMap_503;
		public int KeyMap_504;
		public int KeyMap_505;
		public int KeyMap_506;
		public int KeyMap_507;
		public int KeyMap_508;
		public int KeyMap_509;
		public int KeyMap_510;
		public int KeyMap_511;
		public int KeyMap_512;
		public int KeyMap_513;
		public int KeyMap_514;
		public int KeyMap_515;
		public int KeyMap_516;
		public int KeyMap_517;
		public int KeyMap_518;
		public int KeyMap_519;
		public int KeyMap_520;
		public int KeyMap_521;
		public int KeyMap_522;
		public int KeyMap_523;
		public int KeyMap_524;
		public int KeyMap_525;
		public int KeyMap_526;
		public int KeyMap_527;
		public int KeyMap_528;
		public int KeyMap_529;
		public int KeyMap_530;
		public int KeyMap_531;
		public int KeyMap_532;
		public int KeyMap_533;
		public int KeyMap_534;
		public int KeyMap_535;
		public int KeyMap_536;
		public int KeyMap_537;
		public int KeyMap_538;
		public int KeyMap_539;
		public int KeyMap_540;
		public int KeyMap_541;
		public int KeyMap_542;
		public int KeyMap_543;
		public int KeyMap_544;
		public int KeyMap_545;
		public int KeyMap_546;
		public int KeyMap_547;
		public int KeyMap_548;
		public int KeyMap_549;
		public int KeyMap_550;
		public int KeyMap_551;
		public int KeyMap_552;
		public int KeyMap_553;
		public int KeyMap_554;
		public int KeyMap_555;
		public int KeyMap_556;
		public int KeyMap_557;
		public int KeyMap_558;
		public int KeyMap_559;
		public int KeyMap_560;
		public int KeyMap_561;
		public int KeyMap_562;
		public int KeyMap_563;
		public int KeyMap_564;
		public int KeyMap_565;
		public int KeyMap_566;
		public int KeyMap_567;
		public int KeyMap_568;
		public int KeyMap_569;
		public int KeyMap_570;
		public int KeyMap_571;
		public int KeyMap_572;
		public int KeyMap_573;
		public int KeyMap_574;
		public int KeyMap_575;
		public int KeyMap_576;
		public int KeyMap_577;
		public int KeyMap_578;
		public int KeyMap_579;
		public int KeyMap_580;
		public int KeyMap_581;
		public int KeyMap_582;
		public int KeyMap_583;
		public int KeyMap_584;
		public int KeyMap_585;
		public int KeyMap_586;
		public int KeyMap_587;
		public int KeyMap_588;
		public int KeyMap_589;
		public int KeyMap_590;
		public int KeyMap_591;
		public int KeyMap_592;
		public int KeyMap_593;
		public int KeyMap_594;
		public int KeyMap_595;
		public int KeyMap_596;
		public int KeyMap_597;
		public int KeyMap_598;
		public int KeyMap_599;
		public int KeyMap_600;
		public int KeyMap_601;
		public int KeyMap_602;
		public int KeyMap_603;
		public int KeyMap_604;
		public int KeyMap_605;
		public int KeyMap_606;
		public int KeyMap_607;
		public int KeyMap_608;
		public int KeyMap_609;
		public int KeyMap_610;
		public int KeyMap_611;
		public int KeyMap_612;
		public int KeyMap_613;
		public int KeyMap_614;
		public int KeyMap_615;
		public int KeyMap_616;
		public int KeyMap_617;
		public int KeyMap_618;
		public int KeyMap_619;
		public int KeyMap_620;
		public int KeyMap_621;
		public int KeyMap_622;
		public int KeyMap_623;
		public int KeyMap_624;
		public int KeyMap_625;
		public int KeyMap_626;
		public int KeyMap_627;
		public int KeyMap_628;
		public int KeyMap_629;
		public int KeyMap_630;
		public int KeyMap_631;
		public int KeyMap_632;
		public int KeyMap_633;
		public int KeyMap_634;
		public int KeyMap_635;
		public int KeyMap_636;
		public int KeyMap_637;
		public int KeyMap_638;
		public int KeyMap_639;
		public int KeyMap_640;
		public int KeyMap_641;
		public int KeyMap_642;
		public int KeyMap_643;
		public int KeyMap_644;
		public int KeyMap_645;
		public int KeyMap_646;
		public int KeyMap_647;
		public int KeyMap_648;
		public int KeyMap_649;
		public int KeyMap_650;
		public int KeyMap_651;

		/// <summary>
		/// [LEGACY] Input: Keyboard keys that are pressed (ideally left in the "native" order your engine has access to keyboard keys, so you can use your own definesenums for keys). This used to be [512] sized. It is now ImGuiKey_COUNT to allow legacy io.KeysDown[GetKeyIndex(...)] to work without an overflow.<br/>
		/// </summary>
		public bool KeysDown_0;
		public bool KeysDown_1;
		public bool KeysDown_2;
		public bool KeysDown_3;
		public bool KeysDown_4;
		public bool KeysDown_5;
		public bool KeysDown_6;
		public bool KeysDown_7;
		public bool KeysDown_8;
		public bool KeysDown_9;
		public bool KeysDown_10;
		public bool KeysDown_11;
		public bool KeysDown_12;
		public bool KeysDown_13;
		public bool KeysDown_14;
		public bool KeysDown_15;
		public bool KeysDown_16;
		public bool KeysDown_17;
		public bool KeysDown_18;
		public bool KeysDown_19;
		public bool KeysDown_20;
		public bool KeysDown_21;
		public bool KeysDown_22;
		public bool KeysDown_23;
		public bool KeysDown_24;
		public bool KeysDown_25;
		public bool KeysDown_26;
		public bool KeysDown_27;
		public bool KeysDown_28;
		public bool KeysDown_29;
		public bool KeysDown_30;
		public bool KeysDown_31;
		public bool KeysDown_32;
		public bool KeysDown_33;
		public bool KeysDown_34;
		public bool KeysDown_35;
		public bool KeysDown_36;
		public bool KeysDown_37;
		public bool KeysDown_38;
		public bool KeysDown_39;
		public bool KeysDown_40;
		public bool KeysDown_41;
		public bool KeysDown_42;
		public bool KeysDown_43;
		public bool KeysDown_44;
		public bool KeysDown_45;
		public bool KeysDown_46;
		public bool KeysDown_47;
		public bool KeysDown_48;
		public bool KeysDown_49;
		public bool KeysDown_50;
		public bool KeysDown_51;
		public bool KeysDown_52;
		public bool KeysDown_53;
		public bool KeysDown_54;
		public bool KeysDown_55;
		public bool KeysDown_56;
		public bool KeysDown_57;
		public bool KeysDown_58;
		public bool KeysDown_59;
		public bool KeysDown_60;
		public bool KeysDown_61;
		public bool KeysDown_62;
		public bool KeysDown_63;
		public bool KeysDown_64;
		public bool KeysDown_65;
		public bool KeysDown_66;
		public bool KeysDown_67;
		public bool KeysDown_68;
		public bool KeysDown_69;
		public bool KeysDown_70;
		public bool KeysDown_71;
		public bool KeysDown_72;
		public bool KeysDown_73;
		public bool KeysDown_74;
		public bool KeysDown_75;
		public bool KeysDown_76;
		public bool KeysDown_77;
		public bool KeysDown_78;
		public bool KeysDown_79;
		public bool KeysDown_80;
		public bool KeysDown_81;
		public bool KeysDown_82;
		public bool KeysDown_83;
		public bool KeysDown_84;
		public bool KeysDown_85;
		public bool KeysDown_86;
		public bool KeysDown_87;
		public bool KeysDown_88;
		public bool KeysDown_89;
		public bool KeysDown_90;
		public bool KeysDown_91;
		public bool KeysDown_92;
		public bool KeysDown_93;
		public bool KeysDown_94;
		public bool KeysDown_95;
		public bool KeysDown_96;
		public bool KeysDown_97;
		public bool KeysDown_98;
		public bool KeysDown_99;
		public bool KeysDown_100;
		public bool KeysDown_101;
		public bool KeysDown_102;
		public bool KeysDown_103;
		public bool KeysDown_104;
		public bool KeysDown_105;
		public bool KeysDown_106;
		public bool KeysDown_107;
		public bool KeysDown_108;
		public bool KeysDown_109;
		public bool KeysDown_110;
		public bool KeysDown_111;
		public bool KeysDown_112;
		public bool KeysDown_113;
		public bool KeysDown_114;
		public bool KeysDown_115;
		public bool KeysDown_116;
		public bool KeysDown_117;
		public bool KeysDown_118;
		public bool KeysDown_119;
		public bool KeysDown_120;
		public bool KeysDown_121;
		public bool KeysDown_122;
		public bool KeysDown_123;
		public bool KeysDown_124;
		public bool KeysDown_125;
		public bool KeysDown_126;
		public bool KeysDown_127;
		public bool KeysDown_128;
		public bool KeysDown_129;
		public bool KeysDown_130;
		public bool KeysDown_131;
		public bool KeysDown_132;
		public bool KeysDown_133;
		public bool KeysDown_134;
		public bool KeysDown_135;
		public bool KeysDown_136;
		public bool KeysDown_137;
		public bool KeysDown_138;
		public bool KeysDown_139;
		public bool KeysDown_140;
		public bool KeysDown_141;
		public bool KeysDown_142;
		public bool KeysDown_143;
		public bool KeysDown_144;
		public bool KeysDown_145;
		public bool KeysDown_146;
		public bool KeysDown_147;
		public bool KeysDown_148;
		public bool KeysDown_149;
		public bool KeysDown_150;
		public bool KeysDown_151;
		public bool KeysDown_152;
		public bool KeysDown_153;
		public bool KeysDown_154;
		public bool KeysDown_155;
		public bool KeysDown_156;
		public bool KeysDown_157;
		public bool KeysDown_158;
		public bool KeysDown_159;
		public bool KeysDown_160;
		public bool KeysDown_161;
		public bool KeysDown_162;
		public bool KeysDown_163;
		public bool KeysDown_164;
		public bool KeysDown_165;
		public bool KeysDown_166;
		public bool KeysDown_167;
		public bool KeysDown_168;
		public bool KeysDown_169;
		public bool KeysDown_170;
		public bool KeysDown_171;
		public bool KeysDown_172;
		public bool KeysDown_173;
		public bool KeysDown_174;
		public bool KeysDown_175;
		public bool KeysDown_176;
		public bool KeysDown_177;
		public bool KeysDown_178;
		public bool KeysDown_179;
		public bool KeysDown_180;
		public bool KeysDown_181;
		public bool KeysDown_182;
		public bool KeysDown_183;
		public bool KeysDown_184;
		public bool KeysDown_185;
		public bool KeysDown_186;
		public bool KeysDown_187;
		public bool KeysDown_188;
		public bool KeysDown_189;
		public bool KeysDown_190;
		public bool KeysDown_191;
		public bool KeysDown_192;
		public bool KeysDown_193;
		public bool KeysDown_194;
		public bool KeysDown_195;
		public bool KeysDown_196;
		public bool KeysDown_197;
		public bool KeysDown_198;
		public bool KeysDown_199;
		public bool KeysDown_200;
		public bool KeysDown_201;
		public bool KeysDown_202;
		public bool KeysDown_203;
		public bool KeysDown_204;
		public bool KeysDown_205;
		public bool KeysDown_206;
		public bool KeysDown_207;
		public bool KeysDown_208;
		public bool KeysDown_209;
		public bool KeysDown_210;
		public bool KeysDown_211;
		public bool KeysDown_212;
		public bool KeysDown_213;
		public bool KeysDown_214;
		public bool KeysDown_215;
		public bool KeysDown_216;
		public bool KeysDown_217;
		public bool KeysDown_218;
		public bool KeysDown_219;
		public bool KeysDown_220;
		public bool KeysDown_221;
		public bool KeysDown_222;
		public bool KeysDown_223;
		public bool KeysDown_224;
		public bool KeysDown_225;
		public bool KeysDown_226;
		public bool KeysDown_227;
		public bool KeysDown_228;
		public bool KeysDown_229;
		public bool KeysDown_230;
		public bool KeysDown_231;
		public bool KeysDown_232;
		public bool KeysDown_233;
		public bool KeysDown_234;
		public bool KeysDown_235;
		public bool KeysDown_236;
		public bool KeysDown_237;
		public bool KeysDown_238;
		public bool KeysDown_239;
		public bool KeysDown_240;
		public bool KeysDown_241;
		public bool KeysDown_242;
		public bool KeysDown_243;
		public bool KeysDown_244;
		public bool KeysDown_245;
		public bool KeysDown_246;
		public bool KeysDown_247;
		public bool KeysDown_248;
		public bool KeysDown_249;
		public bool KeysDown_250;
		public bool KeysDown_251;
		public bool KeysDown_252;
		public bool KeysDown_253;
		public bool KeysDown_254;
		public bool KeysDown_255;
		public bool KeysDown_256;
		public bool KeysDown_257;
		public bool KeysDown_258;
		public bool KeysDown_259;
		public bool KeysDown_260;
		public bool KeysDown_261;
		public bool KeysDown_262;
		public bool KeysDown_263;
		public bool KeysDown_264;
		public bool KeysDown_265;
		public bool KeysDown_266;
		public bool KeysDown_267;
		public bool KeysDown_268;
		public bool KeysDown_269;
		public bool KeysDown_270;
		public bool KeysDown_271;
		public bool KeysDown_272;
		public bool KeysDown_273;
		public bool KeysDown_274;
		public bool KeysDown_275;
		public bool KeysDown_276;
		public bool KeysDown_277;
		public bool KeysDown_278;
		public bool KeysDown_279;
		public bool KeysDown_280;
		public bool KeysDown_281;
		public bool KeysDown_282;
		public bool KeysDown_283;
		public bool KeysDown_284;
		public bool KeysDown_285;
		public bool KeysDown_286;
		public bool KeysDown_287;
		public bool KeysDown_288;
		public bool KeysDown_289;
		public bool KeysDown_290;
		public bool KeysDown_291;
		public bool KeysDown_292;
		public bool KeysDown_293;
		public bool KeysDown_294;
		public bool KeysDown_295;
		public bool KeysDown_296;
		public bool KeysDown_297;
		public bool KeysDown_298;
		public bool KeysDown_299;
		public bool KeysDown_300;
		public bool KeysDown_301;
		public bool KeysDown_302;
		public bool KeysDown_303;
		public bool KeysDown_304;
		public bool KeysDown_305;
		public bool KeysDown_306;
		public bool KeysDown_307;
		public bool KeysDown_308;
		public bool KeysDown_309;
		public bool KeysDown_310;
		public bool KeysDown_311;
		public bool KeysDown_312;
		public bool KeysDown_313;
		public bool KeysDown_314;
		public bool KeysDown_315;
		public bool KeysDown_316;
		public bool KeysDown_317;
		public bool KeysDown_318;
		public bool KeysDown_319;
		public bool KeysDown_320;
		public bool KeysDown_321;
		public bool KeysDown_322;
		public bool KeysDown_323;
		public bool KeysDown_324;
		public bool KeysDown_325;
		public bool KeysDown_326;
		public bool KeysDown_327;
		public bool KeysDown_328;
		public bool KeysDown_329;
		public bool KeysDown_330;
		public bool KeysDown_331;
		public bool KeysDown_332;
		public bool KeysDown_333;
		public bool KeysDown_334;
		public bool KeysDown_335;
		public bool KeysDown_336;
		public bool KeysDown_337;
		public bool KeysDown_338;
		public bool KeysDown_339;
		public bool KeysDown_340;
		public bool KeysDown_341;
		public bool KeysDown_342;
		public bool KeysDown_343;
		public bool KeysDown_344;
		public bool KeysDown_345;
		public bool KeysDown_346;
		public bool KeysDown_347;
		public bool KeysDown_348;
		public bool KeysDown_349;
		public bool KeysDown_350;
		public bool KeysDown_351;
		public bool KeysDown_352;
		public bool KeysDown_353;
		public bool KeysDown_354;
		public bool KeysDown_355;
		public bool KeysDown_356;
		public bool KeysDown_357;
		public bool KeysDown_358;
		public bool KeysDown_359;
		public bool KeysDown_360;
		public bool KeysDown_361;
		public bool KeysDown_362;
		public bool KeysDown_363;
		public bool KeysDown_364;
		public bool KeysDown_365;
		public bool KeysDown_366;
		public bool KeysDown_367;
		public bool KeysDown_368;
		public bool KeysDown_369;
		public bool KeysDown_370;
		public bool KeysDown_371;
		public bool KeysDown_372;
		public bool KeysDown_373;
		public bool KeysDown_374;
		public bool KeysDown_375;
		public bool KeysDown_376;
		public bool KeysDown_377;
		public bool KeysDown_378;
		public bool KeysDown_379;
		public bool KeysDown_380;
		public bool KeysDown_381;
		public bool KeysDown_382;
		public bool KeysDown_383;
		public bool KeysDown_384;
		public bool KeysDown_385;
		public bool KeysDown_386;
		public bool KeysDown_387;
		public bool KeysDown_388;
		public bool KeysDown_389;
		public bool KeysDown_390;
		public bool KeysDown_391;
		public bool KeysDown_392;
		public bool KeysDown_393;
		public bool KeysDown_394;
		public bool KeysDown_395;
		public bool KeysDown_396;
		public bool KeysDown_397;
		public bool KeysDown_398;
		public bool KeysDown_399;
		public bool KeysDown_400;
		public bool KeysDown_401;
		public bool KeysDown_402;
		public bool KeysDown_403;
		public bool KeysDown_404;
		public bool KeysDown_405;
		public bool KeysDown_406;
		public bool KeysDown_407;
		public bool KeysDown_408;
		public bool KeysDown_409;
		public bool KeysDown_410;
		public bool KeysDown_411;
		public bool KeysDown_412;
		public bool KeysDown_413;
		public bool KeysDown_414;
		public bool KeysDown_415;
		public bool KeysDown_416;
		public bool KeysDown_417;
		public bool KeysDown_418;
		public bool KeysDown_419;
		public bool KeysDown_420;
		public bool KeysDown_421;
		public bool KeysDown_422;
		public bool KeysDown_423;
		public bool KeysDown_424;
		public bool KeysDown_425;
		public bool KeysDown_426;
		public bool KeysDown_427;
		public bool KeysDown_428;
		public bool KeysDown_429;
		public bool KeysDown_430;
		public bool KeysDown_431;
		public bool KeysDown_432;
		public bool KeysDown_433;
		public bool KeysDown_434;
		public bool KeysDown_435;
		public bool KeysDown_436;
		public bool KeysDown_437;
		public bool KeysDown_438;
		public bool KeysDown_439;
		public bool KeysDown_440;
		public bool KeysDown_441;
		public bool KeysDown_442;
		public bool KeysDown_443;
		public bool KeysDown_444;
		public bool KeysDown_445;
		public bool KeysDown_446;
		public bool KeysDown_447;
		public bool KeysDown_448;
		public bool KeysDown_449;
		public bool KeysDown_450;
		public bool KeysDown_451;
		public bool KeysDown_452;
		public bool KeysDown_453;
		public bool KeysDown_454;
		public bool KeysDown_455;
		public bool KeysDown_456;
		public bool KeysDown_457;
		public bool KeysDown_458;
		public bool KeysDown_459;
		public bool KeysDown_460;
		public bool KeysDown_461;
		public bool KeysDown_462;
		public bool KeysDown_463;
		public bool KeysDown_464;
		public bool KeysDown_465;
		public bool KeysDown_466;
		public bool KeysDown_467;
		public bool KeysDown_468;
		public bool KeysDown_469;
		public bool KeysDown_470;
		public bool KeysDown_471;
		public bool KeysDown_472;
		public bool KeysDown_473;
		public bool KeysDown_474;
		public bool KeysDown_475;
		public bool KeysDown_476;
		public bool KeysDown_477;
		public bool KeysDown_478;
		public bool KeysDown_479;
		public bool KeysDown_480;
		public bool KeysDown_481;
		public bool KeysDown_482;
		public bool KeysDown_483;
		public bool KeysDown_484;
		public bool KeysDown_485;
		public bool KeysDown_486;
		public bool KeysDown_487;
		public bool KeysDown_488;
		public bool KeysDown_489;
		public bool KeysDown_490;
		public bool KeysDown_491;
		public bool KeysDown_492;
		public bool KeysDown_493;
		public bool KeysDown_494;
		public bool KeysDown_495;
		public bool KeysDown_496;
		public bool KeysDown_497;
		public bool KeysDown_498;
		public bool KeysDown_499;
		public bool KeysDown_500;
		public bool KeysDown_501;
		public bool KeysDown_502;
		public bool KeysDown_503;
		public bool KeysDown_504;
		public bool KeysDown_505;
		public bool KeysDown_506;
		public bool KeysDown_507;
		public bool KeysDown_508;
		public bool KeysDown_509;
		public bool KeysDown_510;
		public bool KeysDown_511;
		public bool KeysDown_512;
		public bool KeysDown_513;
		public bool KeysDown_514;
		public bool KeysDown_515;
		public bool KeysDown_516;
		public bool KeysDown_517;
		public bool KeysDown_518;
		public bool KeysDown_519;
		public bool KeysDown_520;
		public bool KeysDown_521;
		public bool KeysDown_522;
		public bool KeysDown_523;
		public bool KeysDown_524;
		public bool KeysDown_525;
		public bool KeysDown_526;
		public bool KeysDown_527;
		public bool KeysDown_528;
		public bool KeysDown_529;
		public bool KeysDown_530;
		public bool KeysDown_531;
		public bool KeysDown_532;
		public bool KeysDown_533;
		public bool KeysDown_534;
		public bool KeysDown_535;
		public bool KeysDown_536;
		public bool KeysDown_537;
		public bool KeysDown_538;
		public bool KeysDown_539;
		public bool KeysDown_540;
		public bool KeysDown_541;
		public bool KeysDown_542;
		public bool KeysDown_543;
		public bool KeysDown_544;
		public bool KeysDown_545;
		public bool KeysDown_546;
		public bool KeysDown_547;
		public bool KeysDown_548;
		public bool KeysDown_549;
		public bool KeysDown_550;
		public bool KeysDown_551;
		public bool KeysDown_552;
		public bool KeysDown_553;
		public bool KeysDown_554;
		public bool KeysDown_555;
		public bool KeysDown_556;
		public bool KeysDown_557;
		public bool KeysDown_558;
		public bool KeysDown_559;
		public bool KeysDown_560;
		public bool KeysDown_561;
		public bool KeysDown_562;
		public bool KeysDown_563;
		public bool KeysDown_564;
		public bool KeysDown_565;
		public bool KeysDown_566;
		public bool KeysDown_567;
		public bool KeysDown_568;
		public bool KeysDown_569;
		public bool KeysDown_570;
		public bool KeysDown_571;
		public bool KeysDown_572;
		public bool KeysDown_573;
		public bool KeysDown_574;
		public bool KeysDown_575;
		public bool KeysDown_576;
		public bool KeysDown_577;
		public bool KeysDown_578;
		public bool KeysDown_579;
		public bool KeysDown_580;
		public bool KeysDown_581;
		public bool KeysDown_582;
		public bool KeysDown_583;
		public bool KeysDown_584;
		public bool KeysDown_585;
		public bool KeysDown_586;
		public bool KeysDown_587;
		public bool KeysDown_588;
		public bool KeysDown_589;
		public bool KeysDown_590;
		public bool KeysDown_591;
		public bool KeysDown_592;
		public bool KeysDown_593;
		public bool KeysDown_594;
		public bool KeysDown_595;
		public bool KeysDown_596;
		public bool KeysDown_597;
		public bool KeysDown_598;
		public bool KeysDown_599;
		public bool KeysDown_600;
		public bool KeysDown_601;
		public bool KeysDown_602;
		public bool KeysDown_603;
		public bool KeysDown_604;
		public bool KeysDown_605;
		public bool KeysDown_606;
		public bool KeysDown_607;
		public bool KeysDown_608;
		public bool KeysDown_609;
		public bool KeysDown_610;
		public bool KeysDown_611;
		public bool KeysDown_612;
		public bool KeysDown_613;
		public bool KeysDown_614;
		public bool KeysDown_615;
		public bool KeysDown_616;
		public bool KeysDown_617;
		public bool KeysDown_618;
		public bool KeysDown_619;
		public bool KeysDown_620;
		public bool KeysDown_621;
		public bool KeysDown_622;
		public bool KeysDown_623;
		public bool KeysDown_624;
		public bool KeysDown_625;
		public bool KeysDown_626;
		public bool KeysDown_627;
		public bool KeysDown_628;
		public bool KeysDown_629;
		public bool KeysDown_630;
		public bool KeysDown_631;
		public bool KeysDown_632;
		public bool KeysDown_633;
		public bool KeysDown_634;
		public bool KeysDown_635;
		public bool KeysDown_636;
		public bool KeysDown_637;
		public bool KeysDown_638;
		public bool KeysDown_639;
		public bool KeysDown_640;
		public bool KeysDown_641;
		public bool KeysDown_642;
		public bool KeysDown_643;
		public bool KeysDown_644;
		public bool KeysDown_645;
		public bool KeysDown_646;
		public bool KeysDown_647;
		public bool KeysDown_648;
		public bool KeysDown_649;
		public bool KeysDown_650;
		public bool KeysDown_651;

		/// <summary>
		/// [LEGACY] Since 1.88, NavInputs[] was removed. Backends from 1.60 to 1.86 won't build. Feed gamepad inputs via io.AddKeyEvent() and ImGuiKey_GamepadXXX enums.<br/>
		/// </summary>
		public float NavInputs_0;
		public float NavInputs_1;
		public float NavInputs_2;
		public float NavInputs_3;
		public float NavInputs_4;
		public float NavInputs_5;
		public float NavInputs_6;
		public float NavInputs_7;
		public float NavInputs_8;
		public float NavInputs_9;
		public float NavInputs_10;
		public float NavInputs_11;
		public float NavInputs_12;
		public float NavInputs_13;
		public float NavInputs_14;
		public float NavInputs_15;

		/// <summary>
		/// Parent UI context (needs to be set explicitly by parent).<br/>
		/// </summary>
		public unsafe ImGuiContext* Ctx;

		/// <summary>
		/// Main Input State<br/>
		/// (this block used to be written by backend, since 1.87 it is best to NOT write to those directly, call the AddXXX functions above instead)<br/>
		/// (reading from those variables is fair game, as they are extremely unlikely to be moving anywhere) Mouse position, in pixels. Set to ImVec2(-FLT_MAX, -FLT_MAX) if mouse is unavailable (on another screen, etc.)<br/>
		/// </summary>
		public Vector2 MousePos;

		/// <summary>
		/// Mouse buttons: 0=left, 1=right, 2=middle + extras (ImGuiMouseButton_COUNT == 5). Dear ImGui mostly uses left and right buttons. Other buttons allow us to track if the mouse is being used by your application + available to user as a convenience via IsMouse** API.<br/>
		/// </summary>
		public bool MouseDown_0;
		public bool MouseDown_1;
		public bool MouseDown_2;
		public bool MouseDown_3;
		public bool MouseDown_4;

		/// <summary>
		/// Mouse wheel Vertical: 1 unit scrolls about 5 lines text. &gt;0 scrolls Up, &lt;0 scrolls Down. Hold SHIFT to turn vertical scroll into horizontal scroll.<br/>
		/// </summary>
		public float MouseWheel;

		/// <summary>
		/// Mouse wheel Horizontal. &gt;0 scrolls Left, &lt;0 scrolls Right. Most users don't have a mouse with a horizontal wheel, may not be filled by all backends.<br/>
		/// </summary>
		public float MouseWheelH;

		/// <summary>
		/// Mouse actual input peripheral (MouseTouchScreenPen).<br/>
		/// </summary>
		public ImGuiMouseSource MouseSource;

		/// <summary>
		/// (Optional) Modify using io.AddMouseViewportEvent(). With multi-viewports: viewport the OS mouse is hovering. If possible _IGNORING_ viewports with the ImGuiViewportFlags_NoInputs flag is much better (few backends can handle that). Set io.BackendFlags |= ImGuiBackendFlags_HasMouseHoveredViewport if you can provide this info. If you don't imgui will infer the value using the rectangles and last focused time of the viewports it knows about (ignoring other OS windows).<br/>
		/// </summary>
		public int MouseHoveredViewport;

		/// <summary>
		/// Keyboard modifier down: Control<br/>
		/// </summary>
		public byte KeyCtrl;

		/// <summary>
		/// Keyboard modifier down: Shift<br/>
		/// </summary>
		public byte KeyShift;

		/// <summary>
		/// Keyboard modifier down: Alt<br/>
		/// </summary>
		public byte KeyAlt;

		/// <summary>
		/// Keyboard modifier down: CmdSuperWindows<br/>
		/// </summary>
		public byte KeySuper;

		/// <summary>
		/// Other state maintained from data above + IO function calls Key mods flags (any of ImGuiMod_CtrlImGuiMod_ShiftImGuiMod_AltImGuiMod_Super flags, same as io.KeyCtrlKeyShiftKeyAltKeySuper but merged into flags. DOES NOT CONTAINS ImGuiMod_Shortcut which is pretranslated). Read-only, updated by NewFrame()<br/>
		/// </summary>
		public int KeyMods;

		/// <summary>
		/// Key state for all known keys. Use IsKeyXXX() functions to access this.<br/>
		/// </summary>
		public ImGuiKeyData KeysData_0;
		public ImGuiKeyData KeysData_1;
		public ImGuiKeyData KeysData_2;
		public ImGuiKeyData KeysData_3;
		public ImGuiKeyData KeysData_4;
		public ImGuiKeyData KeysData_5;
		public ImGuiKeyData KeysData_6;
		public ImGuiKeyData KeysData_7;
		public ImGuiKeyData KeysData_8;
		public ImGuiKeyData KeysData_9;
		public ImGuiKeyData KeysData_10;
		public ImGuiKeyData KeysData_11;
		public ImGuiKeyData KeysData_12;
		public ImGuiKeyData KeysData_13;
		public ImGuiKeyData KeysData_14;
		public ImGuiKeyData KeysData_15;
		public ImGuiKeyData KeysData_16;
		public ImGuiKeyData KeysData_17;
		public ImGuiKeyData KeysData_18;
		public ImGuiKeyData KeysData_19;
		public ImGuiKeyData KeysData_20;
		public ImGuiKeyData KeysData_21;
		public ImGuiKeyData KeysData_22;
		public ImGuiKeyData KeysData_23;
		public ImGuiKeyData KeysData_24;
		public ImGuiKeyData KeysData_25;
		public ImGuiKeyData KeysData_26;
		public ImGuiKeyData KeysData_27;
		public ImGuiKeyData KeysData_28;
		public ImGuiKeyData KeysData_29;
		public ImGuiKeyData KeysData_30;
		public ImGuiKeyData KeysData_31;
		public ImGuiKeyData KeysData_32;
		public ImGuiKeyData KeysData_33;
		public ImGuiKeyData KeysData_34;
		public ImGuiKeyData KeysData_35;
		public ImGuiKeyData KeysData_36;
		public ImGuiKeyData KeysData_37;
		public ImGuiKeyData KeysData_38;
		public ImGuiKeyData KeysData_39;
		public ImGuiKeyData KeysData_40;
		public ImGuiKeyData KeysData_41;
		public ImGuiKeyData KeysData_42;
		public ImGuiKeyData KeysData_43;
		public ImGuiKeyData KeysData_44;
		public ImGuiKeyData KeysData_45;
		public ImGuiKeyData KeysData_46;
		public ImGuiKeyData KeysData_47;
		public ImGuiKeyData KeysData_48;
		public ImGuiKeyData KeysData_49;
		public ImGuiKeyData KeysData_50;
		public ImGuiKeyData KeysData_51;
		public ImGuiKeyData KeysData_52;
		public ImGuiKeyData KeysData_53;
		public ImGuiKeyData KeysData_54;
		public ImGuiKeyData KeysData_55;
		public ImGuiKeyData KeysData_56;
		public ImGuiKeyData KeysData_57;
		public ImGuiKeyData KeysData_58;
		public ImGuiKeyData KeysData_59;
		public ImGuiKeyData KeysData_60;
		public ImGuiKeyData KeysData_61;
		public ImGuiKeyData KeysData_62;
		public ImGuiKeyData KeysData_63;
		public ImGuiKeyData KeysData_64;
		public ImGuiKeyData KeysData_65;
		public ImGuiKeyData KeysData_66;
		public ImGuiKeyData KeysData_67;
		public ImGuiKeyData KeysData_68;
		public ImGuiKeyData KeysData_69;
		public ImGuiKeyData KeysData_70;
		public ImGuiKeyData KeysData_71;
		public ImGuiKeyData KeysData_72;
		public ImGuiKeyData KeysData_73;
		public ImGuiKeyData KeysData_74;
		public ImGuiKeyData KeysData_75;
		public ImGuiKeyData KeysData_76;
		public ImGuiKeyData KeysData_77;
		public ImGuiKeyData KeysData_78;
		public ImGuiKeyData KeysData_79;
		public ImGuiKeyData KeysData_80;
		public ImGuiKeyData KeysData_81;
		public ImGuiKeyData KeysData_82;
		public ImGuiKeyData KeysData_83;
		public ImGuiKeyData KeysData_84;
		public ImGuiKeyData KeysData_85;
		public ImGuiKeyData KeysData_86;
		public ImGuiKeyData KeysData_87;
		public ImGuiKeyData KeysData_88;
		public ImGuiKeyData KeysData_89;
		public ImGuiKeyData KeysData_90;
		public ImGuiKeyData KeysData_91;
		public ImGuiKeyData KeysData_92;
		public ImGuiKeyData KeysData_93;
		public ImGuiKeyData KeysData_94;
		public ImGuiKeyData KeysData_95;
		public ImGuiKeyData KeysData_96;
		public ImGuiKeyData KeysData_97;
		public ImGuiKeyData KeysData_98;
		public ImGuiKeyData KeysData_99;
		public ImGuiKeyData KeysData_100;
		public ImGuiKeyData KeysData_101;
		public ImGuiKeyData KeysData_102;
		public ImGuiKeyData KeysData_103;
		public ImGuiKeyData KeysData_104;
		public ImGuiKeyData KeysData_105;
		public ImGuiKeyData KeysData_106;
		public ImGuiKeyData KeysData_107;
		public ImGuiKeyData KeysData_108;
		public ImGuiKeyData KeysData_109;
		public ImGuiKeyData KeysData_110;
		public ImGuiKeyData KeysData_111;
		public ImGuiKeyData KeysData_112;
		public ImGuiKeyData KeysData_113;
		public ImGuiKeyData KeysData_114;
		public ImGuiKeyData KeysData_115;
		public ImGuiKeyData KeysData_116;
		public ImGuiKeyData KeysData_117;
		public ImGuiKeyData KeysData_118;
		public ImGuiKeyData KeysData_119;
		public ImGuiKeyData KeysData_120;
		public ImGuiKeyData KeysData_121;
		public ImGuiKeyData KeysData_122;
		public ImGuiKeyData KeysData_123;
		public ImGuiKeyData KeysData_124;
		public ImGuiKeyData KeysData_125;
		public ImGuiKeyData KeysData_126;
		public ImGuiKeyData KeysData_127;
		public ImGuiKeyData KeysData_128;
		public ImGuiKeyData KeysData_129;
		public ImGuiKeyData KeysData_130;
		public ImGuiKeyData KeysData_131;
		public ImGuiKeyData KeysData_132;
		public ImGuiKeyData KeysData_133;
		public ImGuiKeyData KeysData_134;
		public ImGuiKeyData KeysData_135;
		public ImGuiKeyData KeysData_136;
		public ImGuiKeyData KeysData_137;
		public ImGuiKeyData KeysData_138;
		public ImGuiKeyData KeysData_139;
		public ImGuiKeyData KeysData_140;
		public ImGuiKeyData KeysData_141;
		public ImGuiKeyData KeysData_142;
		public ImGuiKeyData KeysData_143;
		public ImGuiKeyData KeysData_144;
		public ImGuiKeyData KeysData_145;
		public ImGuiKeyData KeysData_146;
		public ImGuiKeyData KeysData_147;
		public ImGuiKeyData KeysData_148;
		public ImGuiKeyData KeysData_149;
		public ImGuiKeyData KeysData_150;
		public ImGuiKeyData KeysData_151;
		public ImGuiKeyData KeysData_152;
		public ImGuiKeyData KeysData_153;
		public ImGuiKeyData KeysData_154;
		public ImGuiKeyData KeysData_155;
		public ImGuiKeyData KeysData_156;
		public ImGuiKeyData KeysData_157;
		public ImGuiKeyData KeysData_158;
		public ImGuiKeyData KeysData_159;
		public ImGuiKeyData KeysData_160;
		public ImGuiKeyData KeysData_161;
		public ImGuiKeyData KeysData_162;
		public ImGuiKeyData KeysData_163;
		public ImGuiKeyData KeysData_164;
		public ImGuiKeyData KeysData_165;
		public ImGuiKeyData KeysData_166;
		public ImGuiKeyData KeysData_167;
		public ImGuiKeyData KeysData_168;
		public ImGuiKeyData KeysData_169;
		public ImGuiKeyData KeysData_170;
		public ImGuiKeyData KeysData_171;
		public ImGuiKeyData KeysData_172;
		public ImGuiKeyData KeysData_173;
		public ImGuiKeyData KeysData_174;
		public ImGuiKeyData KeysData_175;
		public ImGuiKeyData KeysData_176;
		public ImGuiKeyData KeysData_177;
		public ImGuiKeyData KeysData_178;
		public ImGuiKeyData KeysData_179;
		public ImGuiKeyData KeysData_180;
		public ImGuiKeyData KeysData_181;
		public ImGuiKeyData KeysData_182;
		public ImGuiKeyData KeysData_183;
		public ImGuiKeyData KeysData_184;
		public ImGuiKeyData KeysData_185;
		public ImGuiKeyData KeysData_186;
		public ImGuiKeyData KeysData_187;
		public ImGuiKeyData KeysData_188;
		public ImGuiKeyData KeysData_189;
		public ImGuiKeyData KeysData_190;
		public ImGuiKeyData KeysData_191;
		public ImGuiKeyData KeysData_192;
		public ImGuiKeyData KeysData_193;
		public ImGuiKeyData KeysData_194;
		public ImGuiKeyData KeysData_195;
		public ImGuiKeyData KeysData_196;
		public ImGuiKeyData KeysData_197;
		public ImGuiKeyData KeysData_198;
		public ImGuiKeyData KeysData_199;
		public ImGuiKeyData KeysData_200;
		public ImGuiKeyData KeysData_201;
		public ImGuiKeyData KeysData_202;
		public ImGuiKeyData KeysData_203;
		public ImGuiKeyData KeysData_204;
		public ImGuiKeyData KeysData_205;
		public ImGuiKeyData KeysData_206;
		public ImGuiKeyData KeysData_207;
		public ImGuiKeyData KeysData_208;
		public ImGuiKeyData KeysData_209;
		public ImGuiKeyData KeysData_210;
		public ImGuiKeyData KeysData_211;
		public ImGuiKeyData KeysData_212;
		public ImGuiKeyData KeysData_213;
		public ImGuiKeyData KeysData_214;
		public ImGuiKeyData KeysData_215;
		public ImGuiKeyData KeysData_216;
		public ImGuiKeyData KeysData_217;
		public ImGuiKeyData KeysData_218;
		public ImGuiKeyData KeysData_219;
		public ImGuiKeyData KeysData_220;
		public ImGuiKeyData KeysData_221;
		public ImGuiKeyData KeysData_222;
		public ImGuiKeyData KeysData_223;
		public ImGuiKeyData KeysData_224;
		public ImGuiKeyData KeysData_225;
		public ImGuiKeyData KeysData_226;
		public ImGuiKeyData KeysData_227;
		public ImGuiKeyData KeysData_228;
		public ImGuiKeyData KeysData_229;
		public ImGuiKeyData KeysData_230;
		public ImGuiKeyData KeysData_231;
		public ImGuiKeyData KeysData_232;
		public ImGuiKeyData KeysData_233;
		public ImGuiKeyData KeysData_234;
		public ImGuiKeyData KeysData_235;
		public ImGuiKeyData KeysData_236;
		public ImGuiKeyData KeysData_237;
		public ImGuiKeyData KeysData_238;
		public ImGuiKeyData KeysData_239;
		public ImGuiKeyData KeysData_240;
		public ImGuiKeyData KeysData_241;
		public ImGuiKeyData KeysData_242;
		public ImGuiKeyData KeysData_243;
		public ImGuiKeyData KeysData_244;
		public ImGuiKeyData KeysData_245;
		public ImGuiKeyData KeysData_246;
		public ImGuiKeyData KeysData_247;
		public ImGuiKeyData KeysData_248;
		public ImGuiKeyData KeysData_249;
		public ImGuiKeyData KeysData_250;
		public ImGuiKeyData KeysData_251;
		public ImGuiKeyData KeysData_252;
		public ImGuiKeyData KeysData_253;
		public ImGuiKeyData KeysData_254;
		public ImGuiKeyData KeysData_255;
		public ImGuiKeyData KeysData_256;
		public ImGuiKeyData KeysData_257;
		public ImGuiKeyData KeysData_258;
		public ImGuiKeyData KeysData_259;
		public ImGuiKeyData KeysData_260;
		public ImGuiKeyData KeysData_261;
		public ImGuiKeyData KeysData_262;
		public ImGuiKeyData KeysData_263;
		public ImGuiKeyData KeysData_264;
		public ImGuiKeyData KeysData_265;
		public ImGuiKeyData KeysData_266;
		public ImGuiKeyData KeysData_267;
		public ImGuiKeyData KeysData_268;
		public ImGuiKeyData KeysData_269;
		public ImGuiKeyData KeysData_270;
		public ImGuiKeyData KeysData_271;
		public ImGuiKeyData KeysData_272;
		public ImGuiKeyData KeysData_273;
		public ImGuiKeyData KeysData_274;
		public ImGuiKeyData KeysData_275;
		public ImGuiKeyData KeysData_276;
		public ImGuiKeyData KeysData_277;
		public ImGuiKeyData KeysData_278;
		public ImGuiKeyData KeysData_279;
		public ImGuiKeyData KeysData_280;
		public ImGuiKeyData KeysData_281;
		public ImGuiKeyData KeysData_282;
		public ImGuiKeyData KeysData_283;
		public ImGuiKeyData KeysData_284;
		public ImGuiKeyData KeysData_285;
		public ImGuiKeyData KeysData_286;
		public ImGuiKeyData KeysData_287;
		public ImGuiKeyData KeysData_288;
		public ImGuiKeyData KeysData_289;
		public ImGuiKeyData KeysData_290;
		public ImGuiKeyData KeysData_291;
		public ImGuiKeyData KeysData_292;
		public ImGuiKeyData KeysData_293;
		public ImGuiKeyData KeysData_294;
		public ImGuiKeyData KeysData_295;
		public ImGuiKeyData KeysData_296;
		public ImGuiKeyData KeysData_297;
		public ImGuiKeyData KeysData_298;
		public ImGuiKeyData KeysData_299;
		public ImGuiKeyData KeysData_300;
		public ImGuiKeyData KeysData_301;
		public ImGuiKeyData KeysData_302;
		public ImGuiKeyData KeysData_303;
		public ImGuiKeyData KeysData_304;
		public ImGuiKeyData KeysData_305;
		public ImGuiKeyData KeysData_306;
		public ImGuiKeyData KeysData_307;
		public ImGuiKeyData KeysData_308;
		public ImGuiKeyData KeysData_309;
		public ImGuiKeyData KeysData_310;
		public ImGuiKeyData KeysData_311;
		public ImGuiKeyData KeysData_312;
		public ImGuiKeyData KeysData_313;
		public ImGuiKeyData KeysData_314;
		public ImGuiKeyData KeysData_315;
		public ImGuiKeyData KeysData_316;
		public ImGuiKeyData KeysData_317;
		public ImGuiKeyData KeysData_318;
		public ImGuiKeyData KeysData_319;
		public ImGuiKeyData KeysData_320;
		public ImGuiKeyData KeysData_321;
		public ImGuiKeyData KeysData_322;
		public ImGuiKeyData KeysData_323;
		public ImGuiKeyData KeysData_324;
		public ImGuiKeyData KeysData_325;
		public ImGuiKeyData KeysData_326;
		public ImGuiKeyData KeysData_327;
		public ImGuiKeyData KeysData_328;
		public ImGuiKeyData KeysData_329;
		public ImGuiKeyData KeysData_330;
		public ImGuiKeyData KeysData_331;
		public ImGuiKeyData KeysData_332;
		public ImGuiKeyData KeysData_333;
		public ImGuiKeyData KeysData_334;
		public ImGuiKeyData KeysData_335;
		public ImGuiKeyData KeysData_336;
		public ImGuiKeyData KeysData_337;
		public ImGuiKeyData KeysData_338;
		public ImGuiKeyData KeysData_339;
		public ImGuiKeyData KeysData_340;
		public ImGuiKeyData KeysData_341;
		public ImGuiKeyData KeysData_342;
		public ImGuiKeyData KeysData_343;
		public ImGuiKeyData KeysData_344;
		public ImGuiKeyData KeysData_345;
		public ImGuiKeyData KeysData_346;
		public ImGuiKeyData KeysData_347;
		public ImGuiKeyData KeysData_348;
		public ImGuiKeyData KeysData_349;
		public ImGuiKeyData KeysData_350;
		public ImGuiKeyData KeysData_351;
		public ImGuiKeyData KeysData_352;
		public ImGuiKeyData KeysData_353;
		public ImGuiKeyData KeysData_354;
		public ImGuiKeyData KeysData_355;
		public ImGuiKeyData KeysData_356;
		public ImGuiKeyData KeysData_357;
		public ImGuiKeyData KeysData_358;
		public ImGuiKeyData KeysData_359;
		public ImGuiKeyData KeysData_360;
		public ImGuiKeyData KeysData_361;
		public ImGuiKeyData KeysData_362;
		public ImGuiKeyData KeysData_363;
		public ImGuiKeyData KeysData_364;
		public ImGuiKeyData KeysData_365;
		public ImGuiKeyData KeysData_366;
		public ImGuiKeyData KeysData_367;
		public ImGuiKeyData KeysData_368;
		public ImGuiKeyData KeysData_369;
		public ImGuiKeyData KeysData_370;
		public ImGuiKeyData KeysData_371;
		public ImGuiKeyData KeysData_372;
		public ImGuiKeyData KeysData_373;
		public ImGuiKeyData KeysData_374;
		public ImGuiKeyData KeysData_375;
		public ImGuiKeyData KeysData_376;
		public ImGuiKeyData KeysData_377;
		public ImGuiKeyData KeysData_378;
		public ImGuiKeyData KeysData_379;
		public ImGuiKeyData KeysData_380;
		public ImGuiKeyData KeysData_381;
		public ImGuiKeyData KeysData_382;
		public ImGuiKeyData KeysData_383;
		public ImGuiKeyData KeysData_384;
		public ImGuiKeyData KeysData_385;
		public ImGuiKeyData KeysData_386;
		public ImGuiKeyData KeysData_387;
		public ImGuiKeyData KeysData_388;
		public ImGuiKeyData KeysData_389;
		public ImGuiKeyData KeysData_390;
		public ImGuiKeyData KeysData_391;
		public ImGuiKeyData KeysData_392;
		public ImGuiKeyData KeysData_393;
		public ImGuiKeyData KeysData_394;
		public ImGuiKeyData KeysData_395;
		public ImGuiKeyData KeysData_396;
		public ImGuiKeyData KeysData_397;
		public ImGuiKeyData KeysData_398;
		public ImGuiKeyData KeysData_399;
		public ImGuiKeyData KeysData_400;
		public ImGuiKeyData KeysData_401;
		public ImGuiKeyData KeysData_402;
		public ImGuiKeyData KeysData_403;
		public ImGuiKeyData KeysData_404;
		public ImGuiKeyData KeysData_405;
		public ImGuiKeyData KeysData_406;
		public ImGuiKeyData KeysData_407;
		public ImGuiKeyData KeysData_408;
		public ImGuiKeyData KeysData_409;
		public ImGuiKeyData KeysData_410;
		public ImGuiKeyData KeysData_411;
		public ImGuiKeyData KeysData_412;
		public ImGuiKeyData KeysData_413;
		public ImGuiKeyData KeysData_414;
		public ImGuiKeyData KeysData_415;
		public ImGuiKeyData KeysData_416;
		public ImGuiKeyData KeysData_417;
		public ImGuiKeyData KeysData_418;
		public ImGuiKeyData KeysData_419;
		public ImGuiKeyData KeysData_420;
		public ImGuiKeyData KeysData_421;
		public ImGuiKeyData KeysData_422;
		public ImGuiKeyData KeysData_423;
		public ImGuiKeyData KeysData_424;
		public ImGuiKeyData KeysData_425;
		public ImGuiKeyData KeysData_426;
		public ImGuiKeyData KeysData_427;
		public ImGuiKeyData KeysData_428;
		public ImGuiKeyData KeysData_429;
		public ImGuiKeyData KeysData_430;
		public ImGuiKeyData KeysData_431;
		public ImGuiKeyData KeysData_432;
		public ImGuiKeyData KeysData_433;
		public ImGuiKeyData KeysData_434;
		public ImGuiKeyData KeysData_435;
		public ImGuiKeyData KeysData_436;
		public ImGuiKeyData KeysData_437;
		public ImGuiKeyData KeysData_438;
		public ImGuiKeyData KeysData_439;
		public ImGuiKeyData KeysData_440;
		public ImGuiKeyData KeysData_441;
		public ImGuiKeyData KeysData_442;
		public ImGuiKeyData KeysData_443;
		public ImGuiKeyData KeysData_444;
		public ImGuiKeyData KeysData_445;
		public ImGuiKeyData KeysData_446;
		public ImGuiKeyData KeysData_447;
		public ImGuiKeyData KeysData_448;
		public ImGuiKeyData KeysData_449;
		public ImGuiKeyData KeysData_450;
		public ImGuiKeyData KeysData_451;
		public ImGuiKeyData KeysData_452;
		public ImGuiKeyData KeysData_453;
		public ImGuiKeyData KeysData_454;
		public ImGuiKeyData KeysData_455;
		public ImGuiKeyData KeysData_456;
		public ImGuiKeyData KeysData_457;
		public ImGuiKeyData KeysData_458;
		public ImGuiKeyData KeysData_459;
		public ImGuiKeyData KeysData_460;
		public ImGuiKeyData KeysData_461;
		public ImGuiKeyData KeysData_462;
		public ImGuiKeyData KeysData_463;
		public ImGuiKeyData KeysData_464;
		public ImGuiKeyData KeysData_465;
		public ImGuiKeyData KeysData_466;
		public ImGuiKeyData KeysData_467;
		public ImGuiKeyData KeysData_468;
		public ImGuiKeyData KeysData_469;
		public ImGuiKeyData KeysData_470;
		public ImGuiKeyData KeysData_471;
		public ImGuiKeyData KeysData_472;
		public ImGuiKeyData KeysData_473;
		public ImGuiKeyData KeysData_474;
		public ImGuiKeyData KeysData_475;
		public ImGuiKeyData KeysData_476;
		public ImGuiKeyData KeysData_477;
		public ImGuiKeyData KeysData_478;
		public ImGuiKeyData KeysData_479;
		public ImGuiKeyData KeysData_480;
		public ImGuiKeyData KeysData_481;
		public ImGuiKeyData KeysData_482;
		public ImGuiKeyData KeysData_483;
		public ImGuiKeyData KeysData_484;
		public ImGuiKeyData KeysData_485;
		public ImGuiKeyData KeysData_486;
		public ImGuiKeyData KeysData_487;
		public ImGuiKeyData KeysData_488;
		public ImGuiKeyData KeysData_489;
		public ImGuiKeyData KeysData_490;
		public ImGuiKeyData KeysData_491;
		public ImGuiKeyData KeysData_492;
		public ImGuiKeyData KeysData_493;
		public ImGuiKeyData KeysData_494;
		public ImGuiKeyData KeysData_495;
		public ImGuiKeyData KeysData_496;
		public ImGuiKeyData KeysData_497;
		public ImGuiKeyData KeysData_498;
		public ImGuiKeyData KeysData_499;
		public ImGuiKeyData KeysData_500;
		public ImGuiKeyData KeysData_501;
		public ImGuiKeyData KeysData_502;
		public ImGuiKeyData KeysData_503;
		public ImGuiKeyData KeysData_504;
		public ImGuiKeyData KeysData_505;
		public ImGuiKeyData KeysData_506;
		public ImGuiKeyData KeysData_507;
		public ImGuiKeyData KeysData_508;
		public ImGuiKeyData KeysData_509;
		public ImGuiKeyData KeysData_510;
		public ImGuiKeyData KeysData_511;
		public ImGuiKeyData KeysData_512;
		public ImGuiKeyData KeysData_513;
		public ImGuiKeyData KeysData_514;
		public ImGuiKeyData KeysData_515;
		public ImGuiKeyData KeysData_516;
		public ImGuiKeyData KeysData_517;
		public ImGuiKeyData KeysData_518;
		public ImGuiKeyData KeysData_519;
		public ImGuiKeyData KeysData_520;
		public ImGuiKeyData KeysData_521;
		public ImGuiKeyData KeysData_522;
		public ImGuiKeyData KeysData_523;
		public ImGuiKeyData KeysData_524;
		public ImGuiKeyData KeysData_525;
		public ImGuiKeyData KeysData_526;
		public ImGuiKeyData KeysData_527;
		public ImGuiKeyData KeysData_528;
		public ImGuiKeyData KeysData_529;
		public ImGuiKeyData KeysData_530;
		public ImGuiKeyData KeysData_531;
		public ImGuiKeyData KeysData_532;
		public ImGuiKeyData KeysData_533;
		public ImGuiKeyData KeysData_534;
		public ImGuiKeyData KeysData_535;
		public ImGuiKeyData KeysData_536;
		public ImGuiKeyData KeysData_537;
		public ImGuiKeyData KeysData_538;
		public ImGuiKeyData KeysData_539;
		public ImGuiKeyData KeysData_540;
		public ImGuiKeyData KeysData_541;
		public ImGuiKeyData KeysData_542;
		public ImGuiKeyData KeysData_543;
		public ImGuiKeyData KeysData_544;
		public ImGuiKeyData KeysData_545;
		public ImGuiKeyData KeysData_546;
		public ImGuiKeyData KeysData_547;
		public ImGuiKeyData KeysData_548;
		public ImGuiKeyData KeysData_549;
		public ImGuiKeyData KeysData_550;
		public ImGuiKeyData KeysData_551;
		public ImGuiKeyData KeysData_552;
		public ImGuiKeyData KeysData_553;
		public ImGuiKeyData KeysData_554;
		public ImGuiKeyData KeysData_555;
		public ImGuiKeyData KeysData_556;
		public ImGuiKeyData KeysData_557;
		public ImGuiKeyData KeysData_558;
		public ImGuiKeyData KeysData_559;
		public ImGuiKeyData KeysData_560;
		public ImGuiKeyData KeysData_561;
		public ImGuiKeyData KeysData_562;
		public ImGuiKeyData KeysData_563;
		public ImGuiKeyData KeysData_564;
		public ImGuiKeyData KeysData_565;
		public ImGuiKeyData KeysData_566;
		public ImGuiKeyData KeysData_567;
		public ImGuiKeyData KeysData_568;
		public ImGuiKeyData KeysData_569;
		public ImGuiKeyData KeysData_570;
		public ImGuiKeyData KeysData_571;
		public ImGuiKeyData KeysData_572;
		public ImGuiKeyData KeysData_573;
		public ImGuiKeyData KeysData_574;
		public ImGuiKeyData KeysData_575;
		public ImGuiKeyData KeysData_576;
		public ImGuiKeyData KeysData_577;
		public ImGuiKeyData KeysData_578;
		public ImGuiKeyData KeysData_579;
		public ImGuiKeyData KeysData_580;
		public ImGuiKeyData KeysData_581;
		public ImGuiKeyData KeysData_582;
		public ImGuiKeyData KeysData_583;
		public ImGuiKeyData KeysData_584;
		public ImGuiKeyData KeysData_585;
		public ImGuiKeyData KeysData_586;
		public ImGuiKeyData KeysData_587;
		public ImGuiKeyData KeysData_588;
		public ImGuiKeyData KeysData_589;
		public ImGuiKeyData KeysData_590;
		public ImGuiKeyData KeysData_591;
		public ImGuiKeyData KeysData_592;
		public ImGuiKeyData KeysData_593;
		public ImGuiKeyData KeysData_594;
		public ImGuiKeyData KeysData_595;
		public ImGuiKeyData KeysData_596;
		public ImGuiKeyData KeysData_597;
		public ImGuiKeyData KeysData_598;
		public ImGuiKeyData KeysData_599;
		public ImGuiKeyData KeysData_600;
		public ImGuiKeyData KeysData_601;
		public ImGuiKeyData KeysData_602;
		public ImGuiKeyData KeysData_603;
		public ImGuiKeyData KeysData_604;
		public ImGuiKeyData KeysData_605;
		public ImGuiKeyData KeysData_606;
		public ImGuiKeyData KeysData_607;
		public ImGuiKeyData KeysData_608;
		public ImGuiKeyData KeysData_609;
		public ImGuiKeyData KeysData_610;
		public ImGuiKeyData KeysData_611;
		public ImGuiKeyData KeysData_612;
		public ImGuiKeyData KeysData_613;
		public ImGuiKeyData KeysData_614;
		public ImGuiKeyData KeysData_615;
		public ImGuiKeyData KeysData_616;
		public ImGuiKeyData KeysData_617;
		public ImGuiKeyData KeysData_618;
		public ImGuiKeyData KeysData_619;
		public ImGuiKeyData KeysData_620;
		public ImGuiKeyData KeysData_621;
		public ImGuiKeyData KeysData_622;
		public ImGuiKeyData KeysData_623;
		public ImGuiKeyData KeysData_624;
		public ImGuiKeyData KeysData_625;
		public ImGuiKeyData KeysData_626;
		public ImGuiKeyData KeysData_627;
		public ImGuiKeyData KeysData_628;
		public ImGuiKeyData KeysData_629;
		public ImGuiKeyData KeysData_630;
		public ImGuiKeyData KeysData_631;
		public ImGuiKeyData KeysData_632;
		public ImGuiKeyData KeysData_633;
		public ImGuiKeyData KeysData_634;
		public ImGuiKeyData KeysData_635;
		public ImGuiKeyData KeysData_636;
		public ImGuiKeyData KeysData_637;
		public ImGuiKeyData KeysData_638;
		public ImGuiKeyData KeysData_639;
		public ImGuiKeyData KeysData_640;
		public ImGuiKeyData KeysData_641;
		public ImGuiKeyData KeysData_642;
		public ImGuiKeyData KeysData_643;
		public ImGuiKeyData KeysData_644;
		public ImGuiKeyData KeysData_645;
		public ImGuiKeyData KeysData_646;
		public ImGuiKeyData KeysData_647;
		public ImGuiKeyData KeysData_648;
		public ImGuiKeyData KeysData_649;
		public ImGuiKeyData KeysData_650;
		public ImGuiKeyData KeysData_651;

		/// <summary>
		/// Alternative to WantCaptureMouse: (WantCaptureMouse == true &amp;&amp; WantCaptureMouseUnlessPopupClose == false) when a click over void is expected to close a popup.<br/>
		/// </summary>
		public byte WantCaptureMouseUnlessPopupClose;

		/// <summary>
		/// Previous mouse position (note that MouseDelta is not necessary == MousePos-MousePosPrev, in case either position is invalid)<br/>
		/// </summary>
		public Vector2 MousePosPrev;

		/// <summary>
		/// Position at time of clicking<br/>
		/// </summary>
		public Vector2 MouseClickedPos_0;
		public Vector2 MouseClickedPos_1;
		public Vector2 MouseClickedPos_2;
		public Vector2 MouseClickedPos_3;
		public Vector2 MouseClickedPos_4;

		/// <summary>
		/// Time of last click (used to figure out double-click)<br/>
		/// </summary>
		public double MouseClickedTime_0;
		public double MouseClickedTime_1;
		public double MouseClickedTime_2;
		public double MouseClickedTime_3;
		public double MouseClickedTime_4;

		/// <summary>
		/// Mouse button went from !Down to Down (same as MouseClickedCount[x] != 0)<br/>
		/// </summary>
		public bool MouseClicked_0;
		public bool MouseClicked_1;
		public bool MouseClicked_2;
		public bool MouseClicked_3;
		public bool MouseClicked_4;

		/// <summary>
		/// Has mouse button been double-clicked? (same as MouseClickedCount[x] == 2)<br/>
		/// </summary>
		public bool MouseDoubleClicked_0;
		public bool MouseDoubleClicked_1;
		public bool MouseDoubleClicked_2;
		public bool MouseDoubleClicked_3;
		public bool MouseDoubleClicked_4;

		/// <summary>
		/// == 0 (not clicked), == 1 (same as MouseClicked[]), == 2 (double-clicked), == 3 (triple-clicked) etc. when going from !Down to Down<br/>
		/// </summary>
		public ushort MouseClickedCount_0;
		public ushort MouseClickedCount_1;
		public ushort MouseClickedCount_2;
		public ushort MouseClickedCount_3;
		public ushort MouseClickedCount_4;

		/// <summary>
		/// Count successive number of clicks. Stays valid after mouse release. Reset after another click is done.<br/>
		/// </summary>
		public ushort MouseClickedLastCount_0;
		public ushort MouseClickedLastCount_1;
		public ushort MouseClickedLastCount_2;
		public ushort MouseClickedLastCount_3;
		public ushort MouseClickedLastCount_4;

		/// <summary>
		/// Mouse button went from Down to !Down<br/>
		/// </summary>
		public bool MouseReleased_0;
		public bool MouseReleased_1;
		public bool MouseReleased_2;
		public bool MouseReleased_3;
		public bool MouseReleased_4;

		/// <summary>
		/// Track if button was clicked inside a dear imgui window or over void blocked by a popup. We don't request mouse capture from the application if click started outside ImGui bounds.<br/>
		/// </summary>
		public bool MouseDownOwned_0;
		public bool MouseDownOwned_1;
		public bool MouseDownOwned_2;
		public bool MouseDownOwned_3;
		public bool MouseDownOwned_4;

		/// <summary>
		/// Track if button was clicked inside a dear imgui window.<br/>
		/// </summary>
		public bool MouseDownOwnedUnlessPopupClose_0;
		public bool MouseDownOwnedUnlessPopupClose_1;
		public bool MouseDownOwnedUnlessPopupClose_2;
		public bool MouseDownOwnedUnlessPopupClose_3;
		public bool MouseDownOwnedUnlessPopupClose_4;

		/// <summary>
		/// On a non-Mac system, holding SHIFT requests WheelY to perform the equivalent of a WheelX event. On a Mac system this is already enforced by the system.<br/>
		/// </summary>
		public byte MouseWheelRequestAxisSwap;

		/// <summary>
		/// Duration the mouse button has been down (0.0f == just clicked)<br/>
		/// </summary>
		public float MouseDownDuration_0;
		public float MouseDownDuration_1;
		public float MouseDownDuration_2;
		public float MouseDownDuration_3;
		public float MouseDownDuration_4;

		/// <summary>
		/// Previous time the mouse button has been down<br/>
		/// </summary>
		public float MouseDownDurationPrev_0;
		public float MouseDownDurationPrev_1;
		public float MouseDownDurationPrev_2;
		public float MouseDownDurationPrev_3;
		public float MouseDownDurationPrev_4;

		/// <summary>
		/// Maximum distance, absolute, on each axis, of how much mouse has traveled from the clicking point<br/>
		/// </summary>
		public Vector2 MouseDragMaxDistanceAbs_0;
		public Vector2 MouseDragMaxDistanceAbs_1;
		public Vector2 MouseDragMaxDistanceAbs_2;
		public Vector2 MouseDragMaxDistanceAbs_3;
		public Vector2 MouseDragMaxDistanceAbs_4;

		/// <summary>
		/// Squared maximum distance of how much mouse has traveled from the clicking point (used for moving thresholds)<br/>
		/// </summary>
		public float MouseDragMaxDistanceSqr_0;
		public float MouseDragMaxDistanceSqr_1;
		public float MouseDragMaxDistanceSqr_2;
		public float MouseDragMaxDistanceSqr_3;
		public float MouseDragMaxDistanceSqr_4;

		/// <summary>
		/// TouchPen pressure (0.0f to 1.0f, should be &gt;0.0f only when MouseDown[0] == true). Helper storage currently unused by Dear ImGui.<br/>
		/// </summary>
		public float PenPressure;

		/// <summary>
		/// Only modify via AddFocusEvent()<br/>
		/// </summary>
		public byte AppFocusLost;

		/// <summary>
		/// Only modify via SetAppAcceptingEvents()<br/>
		/// </summary>
		public byte AppAcceptingEvents;

		/// <summary>
		/// -1: unknown, 0: using AddKeyEvent(), 1: using legacy io.KeysDown[]<br/>
		/// </summary>
		public sbyte BackendUsingLegacyKeyArrays;

		/// <summary>
		/// 0: using AddKeyAnalogEvent(), 1: writing to legacy io.NavInputs[] directly<br/>
		/// </summary>
		public byte BackendUsingLegacyNavInputArray;

		/// <summary>
		/// For AddInputCharacterUTF16()<br/>
		/// </summary>
		public char InputQueueSurrogate;

		/// <summary>
		/// Queue of _characters_ input (obtained by platform backend). Fill using AddInputCharacter() helper.<br/>
		/// </summary>
		public ImVectorImWchar InputQueueCharacters;




		public unsafe Span<ImGuiKeyData> KeysData
		
		{
			get
			{
				fixed (ImGuiKeyData* p = &this.KeysData_0)
				{
					return new Span<ImGuiKeyData>(p, 652);
				}
			}
		}
		public unsafe Span<Vector2> MouseClickedPos
		
		{
			get
			{
				fixed (Vector2* p = &this.MouseClickedPos_0)
				{
					return new Span<Vector2>(p, 5);
				}
			}
		}
		public unsafe Span<Vector2> MouseDragMaxDistanceAbs
		
		{
			get
			{
				fixed (Vector2* p = &this.MouseDragMaxDistanceAbs_0)
				{
					return new Span<Vector2>(p, 5);
				}
			}
		}

		/// <summary>		/// Queue a gainloss of focus for the application (generally based on OSplatform focus of your window)		/// </summary>		public unsafe void AddFocusEvent(bool focused)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.AddFocusEventNative(@this, focused ? (byte)1 : (byte)0);
			}
		}

		/// <summary>		/// Queue a new character input		/// </summary>		public unsafe void AddInputCharacter(uint c)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.AddInputCharacterNative(@this, c);
			}
		}

		/// <summary>		/// Queue a new characters input from a UTF-8 string		/// </summary>		public unsafe void AddInputCharactersUTF8(byte* str)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.AddInputCharactersUTF8Native(@this, str);
			}
		}

		/// <summary>		/// Queue a new characters input from a UTF-8 string		/// </summary>		public unsafe void AddInputCharactersUTF8(ref byte str)
		{
			fixed (ImGuiIO* @this = &this)
			{
				fixed (byte* pstr = &str)
				{
					ImGui.AddInputCharactersUTF8Native(@this, (byte*)pstr);
				}
			}
		}

		/// <summary>		/// Queue a new characters input from a UTF-8 string		/// </summary>		public unsafe void AddInputCharactersUTF8(string str)
		{
			fixed (ImGuiIO* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddInputCharactersUTF8Native(@this, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>		/// Queue a new character input from a UTF-16 character, it can be a surrogate		/// </summary>		public unsafe void AddInputCharacterUTF16(char c)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.AddInputCharacterUTF16Native(@this, c);
			}
		}

		/// <summary>		/// Queue a new key downup event for analog values (e.g. ImGuiKey_Gamepad_ values). Dead-zones should be handled by the backend.		/// </summary>		public unsafe void AddKeyAnalogEvent(ImGuiKey key, bool down, float v)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.AddKeyAnalogEventNative(@this, key, down ? (byte)1 : (byte)0, v);
			}
		}

		/// <summary>		/// Queue a new key downup event. Key should be "translated" (as in, generally ImGuiKey_A matches the key end-user would use to emit an 'A' character)		/// </summary>		public unsafe void AddKeyEvent(ImGuiKey key, bool down)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.AddKeyEventNative(@this, key, down ? (byte)1 : (byte)0);
			}
		}

		/// <summary>		/// Queue a mouse button change		/// </summary>		public unsafe void AddMouseButtonEvent(int button, bool down)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.AddMouseButtonEventNative(@this, button, down ? (byte)1 : (byte)0);
			}
		}

		/// <summary>		/// Queue a mouse position update. Use -FLT_MAX,-FLT_MAX to signify no mouse (e.g. app not focused and not hovered)		/// </summary>		public unsafe void AddMousePosEvent(float x, float y)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.AddMousePosEventNative(@this, x, y);
			}
		}

		/// <summary>		/// Queue a mouse source change (MouseTouchScreenPen)		/// </summary>		public unsafe void AddMouseSourceEvent(ImGuiMouseSource source)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.AddMouseSourceEventNative(@this, source);
			}
		}

		/// <summary>		/// Queue a mouse hovered viewport. Requires backend to set ImGuiBackendFlags_HasMouseHoveredViewport to call this (for multi-viewport support).		/// </summary>		public unsafe void AddMouseViewportEvent(int id)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.AddMouseViewportEventNative(@this, id);
			}
		}

		/// <summary>		/// Queue a mouse wheel update. wheel_y<0: scroll down, wheel_y>0: scroll up, wheel_x<0: scroll right, wheel_x>0: scroll left.		/// </summary>		public unsafe void AddMouseWheelEvent(float wheelX, float wheelY)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.AddMouseWheelEventNative(@this, wheelX, wheelY);
			}
		}

		/// <summary>		/// [Internal] Clear the text input buffer manually		/// </summary>		public unsafe void ClearInputCharacters()
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.ClearInputCharactersNative(@this);
			}
		}

		/// <summary>		/// [Internal] Release all keys		/// </summary>		public unsafe void ClearInputKeys()
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.ClearInputKeysNative(@this);
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		/// <summary>		/// Set master flag for accepting keymousetext events (default to true). Useful if you have native dialog boxes that are interrupting your application looprefresh, and you want to disable events being queued while your app is frozen.		/// </summary>		public unsafe void SetAppAcceptingEvents(bool acceptingEvents)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.SetAppAcceptingEventsNative(@this, acceptingEvents ? (byte)1 : (byte)0);
			}
		}

		/// <summary>		/// [Optional] Specify index for legacy <1.87 IsKeyXXX() functions with native indices + specify native keycode, scancode.		/// </summary>		public unsafe void SetKeyEventNativeData(ImGuiKey key, int nativeKeycode, int nativeScancode, int nativeLegacyIndex)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.SetKeyEventNativeDataNative(@this, key, nativeKeycode, nativeScancode, nativeLegacyIndex);
			}
		}

		/// <summary>		/// [Optional] Specify index for legacy <1.87 IsKeyXXX() functions with native indices + specify native keycode, scancode.		/// </summary>		public unsafe void SetKeyEventNativeData(ImGuiKey key, int nativeKeycode, int nativeScancode)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.SetKeyEventNativeDataNative(@this, key, nativeKeycode, nativeScancode, (int)(-1));
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiIOPtr : IEquatable<ImGuiIOPtr>
	{
		public ImGuiIOPtr(ImGuiIO* handle) { Handle = handle; }

		public ImGuiIO* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiIOPtr Null => new ImGuiIOPtr(null);

		public static implicit operator ImGuiIOPtr(ImGuiIO* handle) => new ImGuiIOPtr(handle);

		public static implicit operator ImGuiIO*(ImGuiIOPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiIOPtr left, ImGuiIOPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiIOPtr left, ImGuiIOPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiIOPtr left, ImGuiIO* right) => left.Handle == right;

		public static bool operator !=(ImGuiIOPtr left, ImGuiIO* right) => left.Handle != right;

		public bool Equals(ImGuiIOPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiIOPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiIOPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		/// <summary>
		/// = 0               See ImGuiConfigFlags_ enum. Set by userapplication. Gamepadkeyboard navigation options, etc.<br/>
		/// </summary>
		public ref ImGuiConfigFlags ConfigFlags => ref Unsafe.AsRef<ImGuiConfigFlags>(&Handle->ConfigFlags);
		/// <summary>
		/// = 0               See ImGuiBackendFlags_ enum. Set by backend (imgui_impl_xxx files or custom backend) to communicate features supported by the backend.<br/>
		/// </summary>
		public ref ImGuiBackendFlags BackendFlags => ref Unsafe.AsRef<ImGuiBackendFlags>(&Handle->BackendFlags);
		/// <summary>
		/// &lt;unset&gt;           Main display size, in pixels (generally == GetMainViewport()-&gt;Size). May change every frame.<br/>
		/// </summary>
		public ref Vector2 DisplaySize => ref Unsafe.AsRef<Vector2>(&Handle->DisplaySize);
		/// <summary>
		/// = 1.0f60.0f      Time elapsed since last frame, in seconds. May change every frame.<br/>
		/// </summary>
		public ref float DeltaTime => ref Unsafe.AsRef<float>(&Handle->DeltaTime);
		/// <summary>
		/// = 5.0f            Minimum time between saving positionssizes to .ini file, in seconds.<br/>
		/// </summary>
		public ref float IniSavingRate => ref Unsafe.AsRef<float>(&Handle->IniSavingRate);
		/// <summary>
		/// = "imgui.ini"     Path to .ini file (important: default "imgui.ini" is relative to current working dir!). Set NULL to disable automatic .ini loadingsaving or if you want to manually call LoadIniSettingsXXX()  SaveIniSettingsXXX() functions.<br/>
		/// </summary>
		public byte* IniFilename { get => Handle->IniFilename; set => Handle->IniFilename = value; }
		/// <summary>
		/// = "imgui_log.txt" Path to .log file (default parameter to ImGui::LogToFile when no file is specified).<br/>
		/// </summary>
		public byte* LogFilename { get => Handle->LogFilename; set => Handle->LogFilename = value; }
		/// <summary>
		/// = NULL            Store your own data.<br/>
		/// </summary>
		public void* UserData { get => Handle->UserData; set => Handle->UserData = value; }
		/// <summary>
		/// &lt;auto&gt;            Font atlas: load, rasterize and pack one or more fonts into a single texture.<br/>
		/// </summary>
		public ref ImFontAtlasPtr Fonts => ref Unsafe.AsRef<ImFontAtlasPtr>(&Handle->Fonts);
		/// <summary>
		/// = 1.0f            Global scale all fonts<br/>
		/// </summary>
		public ref float FontGlobalScale => ref Unsafe.AsRef<float>(&Handle->FontGlobalScale);
		/// <summary>
		/// = false           Allow user scaling text of individual window with CTRL+Wheel.<br/>
		/// </summary>
		public ref bool FontAllowUserScaling => ref Unsafe.AsRef<bool>(&Handle->FontAllowUserScaling);
		/// <summary>
		/// = NULL            Font to use on NewFrame(). Use NULL to uses Fonts-&gt;Fonts[0].<br/>
		/// </summary>
		public ref ImFontPtr FontDefault => ref Unsafe.AsRef<ImFontPtr>(&Handle->FontDefault);
		/// <summary>
		/// = (1, 1)          For retina display or other situations where window coordinates are different from framebuffer coordinates. This generally ends up in ImDrawData::FramebufferScale.<br/>
		/// </summary>
		public ref Vector2 DisplayFramebufferScale => ref Unsafe.AsRef<Vector2>(&Handle->DisplayFramebufferScale);
		/// <summary>
		/// Docking options (when ImGuiConfigFlags_DockingEnable is set) = false           Simplified docking mode: disable window splitting, so docking is limited to merging multiple windows together into tab-bars.<br/>
		/// </summary>
		public ref bool ConfigDockingNoSplit => ref Unsafe.AsRef<bool>(&Handle->ConfigDockingNoSplit);
		/// <summary>
		/// = false           Enable docking with holding Shift key (reduce visual noise, allows dropping in wider space)<br/>
		/// </summary>
		public ref bool ConfigDockingWithShift => ref Unsafe.AsRef<bool>(&Handle->ConfigDockingWithShift);
		/// <summary>
		/// = false           [BETA] [FIXME: This currently creates regression with auto-sizing and general overhead] Make every single floating window display within a docking node.<br/>
		/// </summary>
		public ref bool ConfigDockingAlwaysTabBar => ref Unsafe.AsRef<bool>(&Handle->ConfigDockingAlwaysTabBar);
		/// <summary>
		/// = false           [BETA] Make window or viewport transparent when docking and only display docking boxes on the target viewport. Useful if rendering of multiple viewport cannot be synced. Best used with ConfigViewportsNoAutoMerge.<br/>
		/// </summary>
		public ref bool ConfigDockingTransparentPayload => ref Unsafe.AsRef<bool>(&Handle->ConfigDockingTransparentPayload);
		/// <summary>
		/// Viewport options (when ImGuiConfigFlags_ViewportsEnable is set) = false;          Set to make all floating imgui windows always create their own viewport. Otherwise, they are merged into the main host viewports when overlapping it. May also set ImGuiViewportFlags_NoAutoMerge on individual viewport.<br/>
		/// </summary>
		public ref bool ConfigViewportsNoAutoMerge => ref Unsafe.AsRef<bool>(&Handle->ConfigViewportsNoAutoMerge);
		/// <summary>
		/// = false           Disable default OS task bar icon flag for secondary viewports. When a viewport doesn't want a task bar icon, ImGuiViewportFlags_NoTaskBarIcon will be set on it.<br/>
		/// </summary>
		public ref bool ConfigViewportsNoTaskBarIcon => ref Unsafe.AsRef<bool>(&Handle->ConfigViewportsNoTaskBarIcon);
		/// <summary>
		/// = true            Disable default OS window decoration flag for secondary viewports. When a viewport doesn't want window decorations, ImGuiViewportFlags_NoDecoration will be set on it. Enabling decoration can create subsequent issues at OS levels (e.g. minimum window size).<br/>
		/// </summary>
		public ref bool ConfigViewportsNoDecoration => ref Unsafe.AsRef<bool>(&Handle->ConfigViewportsNoDecoration);
		/// <summary>
		/// = false           Disable default OS parenting to main viewport for secondary viewports. By default, viewports are marked with ParentViewportId = &lt;main_viewport&gt;, expecting the platform backend to setup a parentchild relationship between the OS windows (some backend may ignore this). Set to true if you want the default to be 0, then all viewports will be top-level OS windows.<br/>
		/// </summary>
		public ref bool ConfigViewportsNoDefaultParent => ref Unsafe.AsRef<bool>(&Handle->ConfigViewportsNoDefaultParent);
		/// <summary>
		/// Miscellaneous options = false           Request ImGui to draw a mouse cursor for you (if you are on a platform without a mouse cursor). Cannot be easily renamed to 'io.ConfigXXX' because this is frequently used by backend implementations.<br/>
		/// </summary>
		public ref bool MouseDrawCursor => ref Unsafe.AsRef<bool>(&Handle->MouseDrawCursor);
		/// <summary>
		/// = defined(__APPLE__)  OS X style: Text editing cursor movement using Alt instead of Ctrl, Shortcuts using CmdSuper instead of Ctrl, LineText Start and End using Cmd+Arrows instead of HomeEnd, Double click selects by word instead of selecting whole text, Multi-selection in lists uses CmdSuper instead of Ctrl.<br/>
		/// </summary>
		public ref bool ConfigMacOSXBehaviors => ref Unsafe.AsRef<bool>(&Handle->ConfigMacOSXBehaviors);
		/// <summary>
		/// = true            Enable input queue trickling: some types of events submitted during the same frame (e.g. button down + up) will be spread over multiple frames, improving interactions with low framerates.<br/>
		/// </summary>
		public ref bool ConfigInputTrickleEventQueue => ref Unsafe.AsRef<bool>(&Handle->ConfigInputTrickleEventQueue);
		/// <summary>
		/// = true            Enable blinking cursor (optional as some users consider it to be distracting).<br/>
		/// </summary>
		public ref bool ConfigInputTextCursorBlink => ref Unsafe.AsRef<bool>(&Handle->ConfigInputTextCursorBlink);
		/// <summary>
		/// = false           [BETA] Pressing Enter will keep item active and select contents (single-line only).<br/>
		/// </summary>
		public ref bool ConfigInputTextEnterKeepActive => ref Unsafe.AsRef<bool>(&Handle->ConfigInputTextEnterKeepActive);
		/// <summary>
		/// = false           [BETA] Enable turning DragXXX widgets into text input with a simple mouse click-release (without moving). Not desirable on devices without a keyboard.<br/>
		/// </summary>
		public ref bool ConfigDragClickToInputText => ref Unsafe.AsRef<bool>(&Handle->ConfigDragClickToInputText);
		/// <summary>
		/// = true            Enable resizing of windows from their edges and from the lower-left corner. This requires (io.BackendFlags &amp; ImGuiBackendFlags_HasMouseCursors) because it needs mouse cursor feedback. (This used to be a per-window ImGuiWindowFlags_ResizeFromAnySide flag)<br/>
		/// </summary>
		public ref bool ConfigWindowsResizeFromEdges => ref Unsafe.AsRef<bool>(&Handle->ConfigWindowsResizeFromEdges);
		/// <summary>
		/// = false        Enable allowing to move windows only when clicking on their title bar. Does not apply to windows without a title bar.<br/>
		/// </summary>
		public ref bool ConfigWindowsMoveFromTitleBarOnly => ref Unsafe.AsRef<bool>(&Handle->ConfigWindowsMoveFromTitleBarOnly);
		/// <summary>
		/// = 60.0f           Timer (in seconds) to free transient windowstables memory buffers when unused. Set to -1.0f to disable.<br/>
		/// </summary>
		public ref float ConfigMemoryCompactTimer => ref Unsafe.AsRef<float>(&Handle->ConfigMemoryCompactTimer);
		/// <summary>
		/// Inputs Behaviors<br/>
		/// (other variables, ones which are expected to be tweaked within UI code, are exposed in ImGuiStyle) = 0.30f           Time for a double-click, in seconds.<br/>
		/// </summary>
		public ref float MouseDoubleClickTime => ref Unsafe.AsRef<float>(&Handle->MouseDoubleClickTime);
		/// <summary>
		/// = 6.0f            Distance threshold to stay in to validate a double-click, in pixels.<br/>
		/// </summary>
		public ref float MouseDoubleClickMaxDist => ref Unsafe.AsRef<float>(&Handle->MouseDoubleClickMaxDist);
		/// <summary>
		/// = 6.0f            Distance threshold before considering we are dragging.<br/>
		/// </summary>
		public ref float MouseDragThreshold => ref Unsafe.AsRef<float>(&Handle->MouseDragThreshold);
		/// <summary>
		/// = 0.275f          When holding a keybutton, time before it starts repeating, in seconds (for buttons in Repeat mode, etc.).<br/>
		/// </summary>
		public ref float KeyRepeatDelay => ref Unsafe.AsRef<float>(&Handle->KeyRepeatDelay);
		/// <summary>
		/// = 0.050f          When holding a keybutton, rate at which it repeats, in seconds.<br/>
		/// </summary>
		public ref float KeyRepeatRate => ref Unsafe.AsRef<float>(&Handle->KeyRepeatRate);
		/// <summary>
		/// Tools to test correct BeginEnd and BeginChildEndChild behaviors.<br/>
		/// Presently Begin()End() and BeginChild()EndChild() needs to ALWAYS be called in tandem, regardless of return value of BeginXXX()<br/>
		/// This is inconsistent with other BeginXXX functions and create confusion for many users.<br/>
		/// We expect to update the API eventually. In the meanwhile we provide tools to facilitate checking user-code behavior. = false           First-time calls to Begin()BeginChild() will return false. NEEDS TO BE SET AT APPLICATION BOOT TIME if you don't want to miss windows.<br/>
		/// </summary>
		public ref bool ConfigDebugBeginReturnValueOnce => ref Unsafe.AsRef<bool>(&Handle->ConfigDebugBeginReturnValueOnce);
		/// <summary>
		/// = false           Some calls to Begin()BeginChild() will return false. Will cycle through window depths then repeat. Suggested use: add "io.ConfigDebugBeginReturnValue = io.KeyShift" in your main loop then occasionally press SHIFT. Windows should be flickering while running.<br/>
		/// </summary>
		public ref bool ConfigDebugBeginReturnValueLoop => ref Unsafe.AsRef<bool>(&Handle->ConfigDebugBeginReturnValueLoop);
		/// <summary>
		/// Option to deactivate io.AddFocusEvent(false) handling. May facilitate interactions with a debugger when focus loss leads to clearing inputs data.<br/>
		/// Backends may have other side-effects on focus loss, so this will reduce side-effects but not necessary remove all of them.<br/>
		/// Consider using e.g. Win32's IsDebuggerPresent() as an additional filter (or see ImOsIsDebuggerPresent() in imgui_test_engineimgui_te_utils.cpp for a Unix compatible version). = false           Ignore io.AddFocusEvent(false), consequently not calling io.ClearInputKeys() in input processing.<br/>
		/// </summary>
		public ref bool ConfigDebugIgnoreFocusLoss => ref Unsafe.AsRef<bool>(&Handle->ConfigDebugIgnoreFocusLoss);
		/// <summary>
		/// Option to audit .ini data = false           Save .ini data with extra comments (particularly helpful for Docking, but makes saving slower)<br/>
		/// </summary>
		public ref bool ConfigDebugIniSettings => ref Unsafe.AsRef<bool>(&Handle->ConfigDebugIniSettings);
		/// <summary>
		/// Optional: PlatformRenderer backend name (informational only! will be displayed in About Window) + User data for backendwrappers to store their own stuff. = NULL<br/>
		/// </summary>
		public byte* BackendPlatformName { get => Handle->BackendPlatformName; set => Handle->BackendPlatformName = value; }
		/// <summary>
		/// = NULL<br/>
		/// </summary>
		public byte* BackendRendererName { get => Handle->BackendRendererName; set => Handle->BackendRendererName = value; }
		/// <summary>
		/// = NULL            User data for platform backend<br/>
		/// </summary>
		public void* BackendPlatformUserData { get => Handle->BackendPlatformUserData; set => Handle->BackendPlatformUserData = value; }
		/// <summary>
		/// = NULL            User data for renderer backend<br/>
		/// </summary>
		public void* BackendRendererUserData { get => Handle->BackendRendererUserData; set => Handle->BackendRendererUserData = value; }
		/// <summary>
		/// = NULL            User data for non C++ programming language backend<br/>
		/// </summary>
		public void* BackendLanguageUserData { get => Handle->BackendLanguageUserData; set => Handle->BackendLanguageUserData = value; }
		public void* GetClipboardTextFn { get => Handle->GetClipboardTextFn; set => Handle->GetClipboardTextFn = value; }
		public void* SetClipboardTextFn { get => Handle->SetClipboardTextFn; set => Handle->SetClipboardTextFn = value; }
		public void* ClipboardUserData { get => Handle->ClipboardUserData; set => Handle->ClipboardUserData = value; }
		public void* SetPlatformImeDataFn { get => Handle->SetPlatformImeDataFn; set => Handle->SetPlatformImeDataFn = value; }
		/// <summary>
		/// Unused field to keep data structure the same size.<br/>
		/// </summary>
		public void* UnusedPadding { get => Handle->UnusedPadding; set => Handle->UnusedPadding = value; }
		/// <summary>
		/// Set when Dear ImGui will use mouse inputs, in this case do not dispatch them to your main gameapplication (either way, always pass on mouse inputs to imgui). (e.g. unclicked mouse is hovering over an imgui window, widget is active, mouse was clicked over an imgui window, etc.).<br/>
		/// </summary>
		public ref bool WantCaptureMouse => ref Unsafe.AsRef<bool>(&Handle->WantCaptureMouse);
		/// <summary>
		/// Set when Dear ImGui will use keyboard inputs, in this case do not dispatch them to your main gameapplication (either way, always pass keyboard inputs to imgui). (e.g. InputText active, or an imgui window is focused and navigation is enabled, etc.).<br/>
		/// </summary>
		public ref bool WantCaptureKeyboard => ref Unsafe.AsRef<bool>(&Handle->WantCaptureKeyboard);
		/// <summary>
		/// Mobileconsole: when set, you may display an on-screen keyboard. This is set by Dear ImGui when it wants textual keyboard input to happen (e.g. when a InputText widget is active).<br/>
		/// </summary>
		public ref bool WantTextInput => ref Unsafe.AsRef<bool>(&Handle->WantTextInput);
		/// <summary>
		/// MousePos has been altered, backend should reposition mouse on next frame. Rarely used! Set only when ImGuiConfigFlags_NavEnableSetMousePos flag is enabled.<br/>
		/// </summary>
		public ref bool WantSetMousePos => ref Unsafe.AsRef<bool>(&Handle->WantSetMousePos);
		/// <summary>
		/// When manual .ini loadsave is active (io.IniFilename == NULL), this will be set to notify your application that you can call SaveIniSettingsToMemory() and save yourself. Important: clear io.WantSaveIniSettings yourself after saving!<br/>
		/// </summary>
		public ref bool WantSaveIniSettings => ref Unsafe.AsRef<bool>(&Handle->WantSaveIniSettings);
		/// <summary>
		/// KeyboardGamepad navigation is currently allowed (will handle ImGuiKey_NavXXX events) = a window is focused and it doesn't use the ImGuiWindowFlags_NoNavInputs flag.<br/>
		/// </summary>
		public ref bool NavActive => ref Unsafe.AsRef<bool>(&Handle->NavActive);
		/// <summary>
		/// KeyboardGamepad navigation is visible and allowed (will handle ImGuiKey_NavXXX events).<br/>
		/// </summary>
		public ref bool NavVisible => ref Unsafe.AsRef<bool>(&Handle->NavVisible);
		/// <summary>
		/// Estimate of application framerate (rolling average over 60 frames, based on io.DeltaTime), in frame per second. Solely for convenience. Slow applications may not want to use a moving average or may want to reset underlying buffers occasionally.<br/>
		/// </summary>
		public ref float Framerate => ref Unsafe.AsRef<float>(&Handle->Framerate);
		/// <summary>
		/// Vertices output during last call to Render()<br/>
		/// </summary>
		public ref int MetricsRenderVertices => ref Unsafe.AsRef<int>(&Handle->MetricsRenderVertices);
		/// <summary>
		/// Indices output during last call to Render() = number of triangles * 3<br/>
		/// </summary>
		public ref int MetricsRenderIndices => ref Unsafe.AsRef<int>(&Handle->MetricsRenderIndices);
		/// <summary>
		/// Number of visible windows<br/>
		/// </summary>
		public ref int MetricsRenderWindows => ref Unsafe.AsRef<int>(&Handle->MetricsRenderWindows);
		/// <summary>
		/// Number of active windows<br/>
		/// </summary>
		public ref int MetricsActiveWindows => ref Unsafe.AsRef<int>(&Handle->MetricsActiveWindows);
		/// <summary>
		/// Number of active allocations, updated by MemAllocMemFree based on current context. May be off if you have multiple imgui contexts.<br/>
		/// </summary>
		public ref int MetricsActiveAllocations => ref Unsafe.AsRef<int>(&Handle->MetricsActiveAllocations);
		/// <summary>
		/// Mouse delta. Note that this is zero if either current or previous position are invalid (-FLT_MAX,-FLT_MAX), so a disappearingreappearing mouse won't have a huge delta.<br/>
		/// </summary>
		public ref Vector2 MouseDelta => ref Unsafe.AsRef<Vector2>(&Handle->MouseDelta);
		/// <summary>
		/// [LEGACY] Input: map of indices into the KeysDown[512] entries array which represent your "native" keyboard state. The first 512 are now unused and should be kept zero. Legacy backend will write into KeyMap[] using ImGuiKey_ indices which are always &gt;512.<br/>
		/// </summary>
		public unsafe Span<int> KeyMap
		
		{
			get
			{
				return new Span<int>(&Handle->KeyMap_0, 652);
			}
		}
		/// <summary>
		/// [LEGACY] Input: Keyboard keys that are pressed (ideally left in the "native" order your engine has access to keyboard keys, so you can use your own definesenums for keys). This used to be [512] sized. It is now ImGuiKey_COUNT to allow legacy io.KeysDown[GetKeyIndex(...)] to work without an overflow.<br/>
		/// </summary>
		public unsafe Span<bool> KeysDown
		
		{
			get
			{
				return new Span<bool>(&Handle->KeysDown_0, 652);
			}
		}
		/// <summary>
		/// [LEGACY] Since 1.88, NavInputs[] was removed. Backends from 1.60 to 1.86 won't build. Feed gamepad inputs via io.AddKeyEvent() and ImGuiKey_GamepadXXX enums.<br/>
		/// </summary>
		public unsafe Span<float> NavInputs
		
		{
			get
			{
				return new Span<float>(&Handle->NavInputs_0, 16);
			}
		}
		/// <summary>
		/// Parent UI context (needs to be set explicitly by parent).<br/>
		/// </summary>
		public ref ImGuiContextPtr Ctx => ref Unsafe.AsRef<ImGuiContextPtr>(&Handle->Ctx);
		/// <summary>
		/// Main Input State<br/>
		/// (this block used to be written by backend, since 1.87 it is best to NOT write to those directly, call the AddXXX functions above instead)<br/>
		/// (reading from those variables is fair game, as they are extremely unlikely to be moving anywhere) Mouse position, in pixels. Set to ImVec2(-FLT_MAX, -FLT_MAX) if mouse is unavailable (on another screen, etc.)<br/>
		/// </summary>
		public ref Vector2 MousePos => ref Unsafe.AsRef<Vector2>(&Handle->MousePos);
		/// <summary>
		/// Mouse buttons: 0=left, 1=right, 2=middle + extras (ImGuiMouseButton_COUNT == 5). Dear ImGui mostly uses left and right buttons. Other buttons allow us to track if the mouse is being used by your application + available to user as a convenience via IsMouse** API.<br/>
		/// </summary>
		public unsafe Span<bool> MouseDown
		
		{
			get
			{
				return new Span<bool>(&Handle->MouseDown_0, 5);
			}
		}
		/// <summary>
		/// Mouse wheel Vertical: 1 unit scrolls about 5 lines text. &gt;0 scrolls Up, &lt;0 scrolls Down. Hold SHIFT to turn vertical scroll into horizontal scroll.<br/>
		/// </summary>
		public ref float MouseWheel => ref Unsafe.AsRef<float>(&Handle->MouseWheel);
		/// <summary>
		/// Mouse wheel Horizontal. &gt;0 scrolls Left, &lt;0 scrolls Right. Most users don't have a mouse with a horizontal wheel, may not be filled by all backends.<br/>
		/// </summary>
		public ref float MouseWheelH => ref Unsafe.AsRef<float>(&Handle->MouseWheelH);
		/// <summary>
		/// Mouse actual input peripheral (MouseTouchScreenPen).<br/>
		/// </summary>
		public ref ImGuiMouseSource MouseSource => ref Unsafe.AsRef<ImGuiMouseSource>(&Handle->MouseSource);
		/// <summary>
		/// (Optional) Modify using io.AddMouseViewportEvent(). With multi-viewports: viewport the OS mouse is hovering. If possible _IGNORING_ viewports with the ImGuiViewportFlags_NoInputs flag is much better (few backends can handle that). Set io.BackendFlags |= ImGuiBackendFlags_HasMouseHoveredViewport if you can provide this info. If you don't imgui will infer the value using the rectangles and last focused time of the viewports it knows about (ignoring other OS windows).<br/>
		/// </summary>
		public ref int MouseHoveredViewport => ref Unsafe.AsRef<int>(&Handle->MouseHoveredViewport);
		/// <summary>
		/// Keyboard modifier down: Control<br/>
		/// </summary>
		public ref bool KeyCtrl => ref Unsafe.AsRef<bool>(&Handle->KeyCtrl);
		/// <summary>
		/// Keyboard modifier down: Shift<br/>
		/// </summary>
		public ref bool KeyShift => ref Unsafe.AsRef<bool>(&Handle->KeyShift);
		/// <summary>
		/// Keyboard modifier down: Alt<br/>
		/// </summary>
		public ref bool KeyAlt => ref Unsafe.AsRef<bool>(&Handle->KeyAlt);
		/// <summary>
		/// Keyboard modifier down: CmdSuperWindows<br/>
		/// </summary>
		public ref bool KeySuper => ref Unsafe.AsRef<bool>(&Handle->KeySuper);
		/// <summary>
		/// Other state maintained from data above + IO function calls Key mods flags (any of ImGuiMod_CtrlImGuiMod_ShiftImGuiMod_AltImGuiMod_Super flags, same as io.KeyCtrlKeyShiftKeyAltKeySuper but merged into flags. DOES NOT CONTAINS ImGuiMod_Shortcut which is pretranslated). Read-only, updated by NewFrame()<br/>
		/// </summary>
		public ref int KeyMods => ref Unsafe.AsRef<int>(&Handle->KeyMods);
		/// <summary>
		/// Key state for all known keys. Use IsKeyXXX() functions to access this.<br/>
		/// </summary>
		public unsafe Span<ImGuiKeyData> KeysData
		
		{
			get
			{
				return new Span<ImGuiKeyData>(&Handle->KeysData_0, 652);
			}
		}
		/// <summary>
		/// Alternative to WantCaptureMouse: (WantCaptureMouse == true &amp;&amp; WantCaptureMouseUnlessPopupClose == false) when a click over void is expected to close a popup.<br/>
		/// </summary>
		public ref bool WantCaptureMouseUnlessPopupClose => ref Unsafe.AsRef<bool>(&Handle->WantCaptureMouseUnlessPopupClose);
		/// <summary>
		/// Previous mouse position (note that MouseDelta is not necessary == MousePos-MousePosPrev, in case either position is invalid)<br/>
		/// </summary>
		public ref Vector2 MousePosPrev => ref Unsafe.AsRef<Vector2>(&Handle->MousePosPrev);
		/// <summary>
		/// Position at time of clicking<br/>
		/// </summary>
		public unsafe Span<Vector2> MouseClickedPos
		
		{
			get
			{
				return new Span<Vector2>(&Handle->MouseClickedPos_0, 5);
			}
		}
		/// <summary>
		/// Time of last click (used to figure out double-click)<br/>
		/// </summary>
		public unsafe Span<double> MouseClickedTime
		
		{
			get
			{
				return new Span<double>(&Handle->MouseClickedTime_0, 5);
			}
		}
		/// <summary>
		/// Mouse button went from !Down to Down (same as MouseClickedCount[x] != 0)<br/>
		/// </summary>
		public unsafe Span<bool> MouseClicked
		
		{
			get
			{
				return new Span<bool>(&Handle->MouseClicked_0, 5);
			}
		}
		/// <summary>
		/// Has mouse button been double-clicked? (same as MouseClickedCount[x] == 2)<br/>
		/// </summary>
		public unsafe Span<bool> MouseDoubleClicked
		
		{
			get
			{
				return new Span<bool>(&Handle->MouseDoubleClicked_0, 5);
			}
		}
		/// <summary>
		/// == 0 (not clicked), == 1 (same as MouseClicked[]), == 2 (double-clicked), == 3 (triple-clicked) etc. when going from !Down to Down<br/>
		/// </summary>
		public unsafe Span<ushort> MouseClickedCount
		
		{
			get
			{
				return new Span<ushort>(&Handle->MouseClickedCount_0, 5);
			}
		}
		/// <summary>
		/// Count successive number of clicks. Stays valid after mouse release. Reset after another click is done.<br/>
		/// </summary>
		public unsafe Span<ushort> MouseClickedLastCount
		
		{
			get
			{
				return new Span<ushort>(&Handle->MouseClickedLastCount_0, 5);
			}
		}
		/// <summary>
		/// Mouse button went from Down to !Down<br/>
		/// </summary>
		public unsafe Span<bool> MouseReleased
		
		{
			get
			{
				return new Span<bool>(&Handle->MouseReleased_0, 5);
			}
		}
		/// <summary>
		/// Track if button was clicked inside a dear imgui window or over void blocked by a popup. We don't request mouse capture from the application if click started outside ImGui bounds.<br/>
		/// </summary>
		public unsafe Span<bool> MouseDownOwned
		
		{
			get
			{
				return new Span<bool>(&Handle->MouseDownOwned_0, 5);
			}
		}
		/// <summary>
		/// Track if button was clicked inside a dear imgui window.<br/>
		/// </summary>
		public unsafe Span<bool> MouseDownOwnedUnlessPopupClose
		
		{
			get
			{
				return new Span<bool>(&Handle->MouseDownOwnedUnlessPopupClose_0, 5);
			}
		}
		/// <summary>
		/// On a non-Mac system, holding SHIFT requests WheelY to perform the equivalent of a WheelX event. On a Mac system this is already enforced by the system.<br/>
		/// </summary>
		public ref bool MouseWheelRequestAxisSwap => ref Unsafe.AsRef<bool>(&Handle->MouseWheelRequestAxisSwap);
		/// <summary>
		/// Duration the mouse button has been down (0.0f == just clicked)<br/>
		/// </summary>
		public unsafe Span<float> MouseDownDuration
		
		{
			get
			{
				return new Span<float>(&Handle->MouseDownDuration_0, 5);
			}
		}
		/// <summary>
		/// Previous time the mouse button has been down<br/>
		/// </summary>
		public unsafe Span<float> MouseDownDurationPrev
		
		{
			get
			{
				return new Span<float>(&Handle->MouseDownDurationPrev_0, 5);
			}
		}
		/// <summary>
		/// Maximum distance, absolute, on each axis, of how much mouse has traveled from the clicking point<br/>
		/// </summary>
		public unsafe Span<Vector2> MouseDragMaxDistanceAbs
		
		{
			get
			{
				return new Span<Vector2>(&Handle->MouseDragMaxDistanceAbs_0, 5);
			}
		}
		/// <summary>
		/// Squared maximum distance of how much mouse has traveled from the clicking point (used for moving thresholds)<br/>
		/// </summary>
		public unsafe Span<float> MouseDragMaxDistanceSqr
		
		{
			get
			{
				return new Span<float>(&Handle->MouseDragMaxDistanceSqr_0, 5);
			}
		}
		/// <summary>
		/// TouchPen pressure (0.0f to 1.0f, should be &gt;0.0f only when MouseDown[0] == true). Helper storage currently unused by Dear ImGui.<br/>
		/// </summary>
		public ref float PenPressure => ref Unsafe.AsRef<float>(&Handle->PenPressure);
		/// <summary>
		/// Only modify via AddFocusEvent()<br/>
		/// </summary>
		public ref bool AppFocusLost => ref Unsafe.AsRef<bool>(&Handle->AppFocusLost);
		/// <summary>
		/// Only modify via SetAppAcceptingEvents()<br/>
		/// </summary>
		public ref bool AppAcceptingEvents => ref Unsafe.AsRef<bool>(&Handle->AppAcceptingEvents);
		/// <summary>
		/// -1: unknown, 0: using AddKeyEvent(), 1: using legacy io.KeysDown[]<br/>
		/// </summary>
		public ref sbyte BackendUsingLegacyKeyArrays => ref Unsafe.AsRef<sbyte>(&Handle->BackendUsingLegacyKeyArrays);
		/// <summary>
		/// 0: using AddKeyAnalogEvent(), 1: writing to legacy io.NavInputs[] directly<br/>
		/// </summary>
		public ref bool BackendUsingLegacyNavInputArray => ref Unsafe.AsRef<bool>(&Handle->BackendUsingLegacyNavInputArray);
		/// <summary>
		/// For AddInputCharacterUTF16()<br/>
		/// </summary>
		public ref char InputQueueSurrogate => ref Unsafe.AsRef<char>(&Handle->InputQueueSurrogate);
		/// <summary>
		/// Queue of _characters_ input (obtained by platform backend). Fill using AddInputCharacter() helper.<br/>
		/// </summary>
		public ref ImVectorImWchar InputQueueCharacters => ref Unsafe.AsRef<ImVectorImWchar>(&Handle->InputQueueCharacters);

		/// <summary>		/// Queue a gainloss of focus for the application (generally based on OSplatform focus of your window)		/// </summary>		public unsafe void AddFocusEvent(bool focused)
		{
			ImGui.AddFocusEventNative(Handle, focused ? (byte)1 : (byte)0);
		}

		/// <summary>		/// Queue a new character input		/// </summary>		public unsafe void AddInputCharacter(uint c)
		{
			ImGui.AddInputCharacterNative(Handle, c);
		}

		/// <summary>		/// Queue a new characters input from a UTF-8 string		/// </summary>		public unsafe void AddInputCharactersUTF8(byte* str)
		{
			ImGui.AddInputCharactersUTF8Native(Handle, str);
		}

		/// <summary>		/// Queue a new characters input from a UTF-8 string		/// </summary>		public unsafe void AddInputCharactersUTF8(ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				ImGui.AddInputCharactersUTF8Native(Handle, (byte*)pstr);
			}
		}

		/// <summary>		/// Queue a new characters input from a UTF-8 string		/// </summary>		public unsafe void AddInputCharactersUTF8(string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.AddInputCharactersUTF8Native(Handle, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>		/// Queue a new character input from a UTF-16 character, it can be a surrogate		/// </summary>		public unsafe void AddInputCharacterUTF16(char c)
		{
			ImGui.AddInputCharacterUTF16Native(Handle, c);
		}

		/// <summary>		/// Queue a new key downup event for analog values (e.g. ImGuiKey_Gamepad_ values). Dead-zones should be handled by the backend.		/// </summary>		public unsafe void AddKeyAnalogEvent(ImGuiKey key, bool down, float v)
		{
			ImGui.AddKeyAnalogEventNative(Handle, key, down ? (byte)1 : (byte)0, v);
		}

		/// <summary>		/// Queue a new key downup event. Key should be "translated" (as in, generally ImGuiKey_A matches the key end-user would use to emit an 'A' character)		/// </summary>		public unsafe void AddKeyEvent(ImGuiKey key, bool down)
		{
			ImGui.AddKeyEventNative(Handle, key, down ? (byte)1 : (byte)0);
		}

		/// <summary>		/// Queue a mouse button change		/// </summary>		public unsafe void AddMouseButtonEvent(int button, bool down)
		{
			ImGui.AddMouseButtonEventNative(Handle, button, down ? (byte)1 : (byte)0);
		}

		/// <summary>		/// Queue a mouse position update. Use -FLT_MAX,-FLT_MAX to signify no mouse (e.g. app not focused and not hovered)		/// </summary>		public unsafe void AddMousePosEvent(float x, float y)
		{
			ImGui.AddMousePosEventNative(Handle, x, y);
		}

		/// <summary>		/// Queue a mouse source change (MouseTouchScreenPen)		/// </summary>		public unsafe void AddMouseSourceEvent(ImGuiMouseSource source)
		{
			ImGui.AddMouseSourceEventNative(Handle, source);
		}

		/// <summary>		/// Queue a mouse hovered viewport. Requires backend to set ImGuiBackendFlags_HasMouseHoveredViewport to call this (for multi-viewport support).		/// </summary>		public unsafe void AddMouseViewportEvent(int id)
		{
			ImGui.AddMouseViewportEventNative(Handle, id);
		}

		/// <summary>		/// Queue a mouse wheel update. wheel_y<0: scroll down, wheel_y>0: scroll up, wheel_x<0: scroll right, wheel_x>0: scroll left.		/// </summary>		public unsafe void AddMouseWheelEvent(float wheelX, float wheelY)
		{
			ImGui.AddMouseWheelEventNative(Handle, wheelX, wheelY);
		}

		/// <summary>		/// [Internal] Clear the text input buffer manually		/// </summary>		public unsafe void ClearInputCharacters()
		{
			ImGui.ClearInputCharactersNative(Handle);
		}

		/// <summary>		/// [Internal] Release all keys		/// </summary>		public unsafe void ClearInputKeys()
		{
			ImGui.ClearInputKeysNative(Handle);
		}

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

		/// <summary>		/// Set master flag for accepting keymousetext events (default to true). Useful if you have native dialog boxes that are interrupting your application looprefresh, and you want to disable events being queued while your app is frozen.		/// </summary>		public unsafe void SetAppAcceptingEvents(bool acceptingEvents)
		{
			ImGui.SetAppAcceptingEventsNative(Handle, acceptingEvents ? (byte)1 : (byte)0);
		}

		/// <summary>		/// [Optional] Specify index for legacy <1.87 IsKeyXXX() functions with native indices + specify native keycode, scancode.		/// </summary>		public unsafe void SetKeyEventNativeData(ImGuiKey key, int nativeKeycode, int nativeScancode, int nativeLegacyIndex)
		{
			ImGui.SetKeyEventNativeDataNative(Handle, key, nativeKeycode, nativeScancode, nativeLegacyIndex);
		}

		/// <summary>		/// [Optional] Specify index for legacy <1.87 IsKeyXXX() functions with native indices + specify native keycode, scancode.		/// </summary>		public unsafe void SetKeyEventNativeData(ImGuiKey key, int nativeKeycode, int nativeScancode)
		{
			ImGui.SetKeyEventNativeDataNative(Handle, key, nativeKeycode, nativeScancode, (int)(-1));
		}

	}

	/// <summary>
	/// (Optional) Support for IME (Input Method Editor) via the io.SetPlatformImeDataFn() function.<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiPlatformImeData
	{
		/// <summary>
		/// A widget wants the IME to be visible<br/>
		/// </summary>
		public byte WantVisible;

		/// <summary>
		/// Position of the input cursor<br/>
		/// </summary>
		public Vector2 InputPos;

		/// <summary>
		/// Line height<br/>
		/// </summary>
		public float InputLineHeight;





		public unsafe void Destroy()
		{
			fixed (ImGuiPlatformImeData* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiPlatformImeDataPtr : IEquatable<ImGuiPlatformImeDataPtr>
	{
		public ImGuiPlatformImeDataPtr(ImGuiPlatformImeData* handle) { Handle = handle; }

		public ImGuiPlatformImeData* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiPlatformImeDataPtr Null => new ImGuiPlatformImeDataPtr(null);

		public static implicit operator ImGuiPlatformImeDataPtr(ImGuiPlatformImeData* handle) => new ImGuiPlatformImeDataPtr(handle);

		public static implicit operator ImGuiPlatformImeData*(ImGuiPlatformImeDataPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiPlatformImeDataPtr left, ImGuiPlatformImeDataPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiPlatformImeDataPtr left, ImGuiPlatformImeDataPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiPlatformImeDataPtr left, ImGuiPlatformImeData* right) => left.Handle == right;

		public static bool operator !=(ImGuiPlatformImeDataPtr left, ImGuiPlatformImeData* right) => left.Handle != right;

		public bool Equals(ImGuiPlatformImeDataPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiPlatformImeDataPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiPlatformImeDataPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		/// <summary>
		/// A widget wants the IME to be visible<br/>
		/// </summary>
		public ref bool WantVisible => ref Unsafe.AsRef<bool>(&Handle->WantVisible);
		/// <summary>
		/// Position of the input cursor<br/>
		/// </summary>
		public ref Vector2 InputPos => ref Unsafe.AsRef<Vector2>(&Handle->InputPos);
		/// <summary>
		/// Line height<br/>
		/// </summary>
		public ref float InputLineHeight => ref Unsafe.AsRef<float>(&Handle->InputLineHeight);

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

	}

	/// <summary>
	/// [Internal] Storage used by IsKeyDown(), IsKeyPressed() etc functions.<br/>
	/// If prior to 1.87 you used io.KeysDownDuration[] (which was marked as internal), you should use GetKeyData(key)-&gt;DownDuration and *NOT* io.KeysData[key]-&gt;DownDuration.<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiKeyData
	{
		/// <summary>
		/// True for if key is down<br/>
		/// </summary>
		public byte Down;

		/// <summary>
		/// Duration the key has been down (&lt;0.0f: not pressed, 0.0f: just pressed, &gt;0.0f: time held)<br/>
		/// </summary>
		public float DownDuration;

		/// <summary>
		/// Last frame duration the key has been down<br/>
		/// </summary>
		public float DownDurationPrev;

		/// <summary>
		/// 0.0f..1.0f for gamepad values<br/>
		/// </summary>
		public float AnalogValue;



	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiKeyDataPtr : IEquatable<ImGuiKeyDataPtr>
	{
		public ImGuiKeyDataPtr(ImGuiKeyData* handle) { Handle = handle; }

		public ImGuiKeyData* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiKeyDataPtr Null => new ImGuiKeyDataPtr(null);

		public static implicit operator ImGuiKeyDataPtr(ImGuiKeyData* handle) => new ImGuiKeyDataPtr(handle);

		public static implicit operator ImGuiKeyData*(ImGuiKeyDataPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiKeyDataPtr left, ImGuiKeyDataPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiKeyDataPtr left, ImGuiKeyDataPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiKeyDataPtr left, ImGuiKeyData* right) => left.Handle == right;

		public static bool operator !=(ImGuiKeyDataPtr left, ImGuiKeyData* right) => left.Handle != right;

		public bool Equals(ImGuiKeyDataPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiKeyDataPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiKeyDataPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		/// <summary>
		/// True for if key is down<br/>
		/// </summary>
		public ref bool Down => ref Unsafe.AsRef<bool>(&Handle->Down);
		/// <summary>
		/// Duration the key has been down (&lt;0.0f: not pressed, 0.0f: just pressed, &gt;0.0f: time held)<br/>
		/// </summary>
		public ref float DownDuration => ref Unsafe.AsRef<float>(&Handle->DownDuration);
		/// <summary>
		/// Last frame duration the key has been down<br/>
		/// </summary>
		public ref float DownDurationPrev => ref Unsafe.AsRef<float>(&Handle->DownDurationPrev);
		/// <summary>
		/// 0.0f..1.0f for gamepad values<br/>
		/// </summary>
		public ref float AnalogValue => ref Unsafe.AsRef<float>(&Handle->AnalogValue);
	}

	/// <summary>
	/// (Optional) Access via ImGui::GetPlatformIO()<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiPlatformIO
	{
		/// <summary>
		/// Platform function --------------------------------------------------- Called by ----- . . U . .   Create a new platform window for the given viewport<br/>
		/// </summary>
		public unsafe void* PlatformCreateWindow;

		/// <summary>
		/// N . U . D<br/>
		/// </summary>
		public unsafe void* PlatformDestroyWindow;

		/// <summary>
		/// . . U . .   Newly created windows are initially hidden so SetWindowPosSizeTitle can be called on them before showing the window<br/>
		/// </summary>
		public unsafe void* PlatformShowWindow;

		/// <summary>
		/// . . U . .   Set platform window position (given the upper-left corner of client area)<br/>
		/// </summary>
		public unsafe void* PlatformSetWindowPos;

		/// <summary>
		/// N . . . .<br/>
		/// </summary>
		public unsafe void* PlatformGetWindowPos;

		/// <summary>
		/// . . U . .   Set platform window client area size (ignoring OS decorations such as OS title bar etc.)<br/>
		/// </summary>
		public unsafe void* PlatformSetWindowSize;

		/// <summary>
		/// N . . . .   Get platform window client area size<br/>
		/// </summary>
		public unsafe void* PlatformGetWindowSize;

		/// <summary>
		/// N . . . .   Move window to front and set input focus<br/>
		/// </summary>
		public unsafe void* PlatformSetWindowFocus;

		/// <summary>
		/// . . U . .<br/>
		/// </summary>
		public unsafe void* PlatformGetWindowFocus;

		/// <summary>
		/// N . . . .   Get platform window minimized state. When minimized, we generally won't attempt to getset size and contents will be culled more easily<br/>
		/// </summary>
		public unsafe void* PlatformGetWindowMinimized;

		/// <summary>
		/// . . U . .   Set platform window title (given an UTF-8 string)<br/>
		/// </summary>
		public unsafe void* PlatformSetWindowTitle;

		/// <summary>
		/// . . U . .   (Optional) Setup global transparency (not per-pixel transparency)<br/>
		/// </summary>
		public unsafe void* PlatformSetWindowAlpha;

		/// <summary>
		/// . . U . .   (Optional) Called by UpdatePlatformWindows(). Optional hook to allow the platform backend from doing general book-keeping every frame.<br/>
		/// </summary>
		public unsafe void* PlatformUpdateWindow;

		/// <summary>
		/// . . . R .   (Optional) Main rendering (platform side! This is often unused, or just setting a "current" context for OpenGL bindings). 'render_arg' is the value passed to RenderPlatformWindowsDefault().<br/>
		/// </summary>
		public unsafe void* PlatformRenderWindow;

		/// <summary>
		/// . . . R .   (Optional) Call PresentSwapBuffers (platform side! This is often unused!). 'render_arg' is the value passed to RenderPlatformWindowsDefault().<br/>
		/// </summary>
		public unsafe void* PlatformSwapBuffers;

		/// <summary>
		/// N . . . .   (Optional) [BETA] FIXME-DPI: DPI handling: Return DPI scale for this viewport. 1.0f = 96 DPI.<br/>
		/// </summary>
		public unsafe void* PlatformGetWindowDpiScale;

		/// <summary>
		/// . F . . .   (Optional) [BETA] FIXME-DPI: DPI handling: Called during Begin() every time the viewport we are outputting into changes, so backend has a chance to swap fonts to adjust style.<br/>
		/// </summary>
		public unsafe void* PlatformOnChangedViewport;

		/// <summary>
		/// (Optional) For a Vulkan Renderer to call into Platform code (since the surface creation needs to tie them both).<br/>
		/// </summary>
		public unsafe void* PlatformCreateVkSurface;

		/// <summary>
		/// (Optional) Renderer functions (e.g. DirectX, OpenGL, Vulkan) . . U . .   Create swap chain, frame buffers etc. (called after Platform_CreateWindow)<br/>
		/// </summary>
		public unsafe void* RendererCreateWindow;

		/// <summary>
		/// N . U . D   Destroy swap chain, frame buffers etc. (called before Platform_DestroyWindow)<br/>
		/// </summary>
		public unsafe void* RendererDestroyWindow;

		/// <summary>
		/// . . U . .   Resize swap chain, frame buffers etc. (called after Platform_SetWindowSize)<br/>
		/// </summary>
		public unsafe void* RendererSetWindowSize;

		/// <summary>
		/// . . . R .   (Optional) Clear framebuffer, setup render target, then render the viewport-&gt;DrawData. 'render_arg' is the value passed to RenderPlatformWindowsDefault().<br/>
		/// </summary>
		public unsafe void* RendererRenderWindow;

		/// <summary>
		/// . . . R .   (Optional) Call PresentSwapBuffers. 'render_arg' is the value passed to RenderPlatformWindowsDefault().<br/>
		/// </summary>
		public unsafe void* RendererSwapBuffers;

		public ImVectorImGuiPlatformMonitor Monitors;
		/// <summary>
		/// Viewports list (the list is updated by calling ImGui::EndFrame or ImGui::Render)<br/>
		/// (in the future we will attempt to organize this feature to remove the need for a "main viewport") Main viewports, followed by all secondary viewports.<br/>
		/// </summary>
		public ImVectorImGuiViewportPtr Viewports;





		public unsafe void Destroy()
		{
			fixed (ImGuiPlatformIO* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiPlatformIOPtr : IEquatable<ImGuiPlatformIOPtr>
	{
		public ImGuiPlatformIOPtr(ImGuiPlatformIO* handle) { Handle = handle; }

		public ImGuiPlatformIO* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiPlatformIOPtr Null => new ImGuiPlatformIOPtr(null);

		public static implicit operator ImGuiPlatformIOPtr(ImGuiPlatformIO* handle) => new ImGuiPlatformIOPtr(handle);

		public static implicit operator ImGuiPlatformIO*(ImGuiPlatformIOPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiPlatformIOPtr left, ImGuiPlatformIOPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiPlatformIOPtr left, ImGuiPlatformIOPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiPlatformIOPtr left, ImGuiPlatformIO* right) => left.Handle == right;

		public static bool operator !=(ImGuiPlatformIOPtr left, ImGuiPlatformIO* right) => left.Handle != right;

		public bool Equals(ImGuiPlatformIOPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiPlatformIOPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiPlatformIOPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		/// <summary>
		/// Platform function --------------------------------------------------- Called by ----- . . U . .   Create a new platform window for the given viewport<br/>
		/// </summary>
		public void* PlatformCreateWindow { get => Handle->PlatformCreateWindow; set => Handle->PlatformCreateWindow = value; }
		/// <summary>
		/// N . U . D<br/>
		/// </summary>
		public void* PlatformDestroyWindow { get => Handle->PlatformDestroyWindow; set => Handle->PlatformDestroyWindow = value; }
		/// <summary>
		/// . . U . .   Newly created windows are initially hidden so SetWindowPosSizeTitle can be called on them before showing the window<br/>
		/// </summary>
		public void* PlatformShowWindow { get => Handle->PlatformShowWindow; set => Handle->PlatformShowWindow = value; }
		/// <summary>
		/// . . U . .   Set platform window position (given the upper-left corner of client area)<br/>
		/// </summary>
		public void* PlatformSetWindowPos { get => Handle->PlatformSetWindowPos; set => Handle->PlatformSetWindowPos = value; }
		/// <summary>
		/// N . . . .<br/>
		/// </summary>
		public void* PlatformGetWindowPos { get => Handle->PlatformGetWindowPos; set => Handle->PlatformGetWindowPos = value; }
		/// <summary>
		/// . . U . .   Set platform window client area size (ignoring OS decorations such as OS title bar etc.)<br/>
		/// </summary>
		public void* PlatformSetWindowSize { get => Handle->PlatformSetWindowSize; set => Handle->PlatformSetWindowSize = value; }
		/// <summary>
		/// N . . . .   Get platform window client area size<br/>
		/// </summary>
		public void* PlatformGetWindowSize { get => Handle->PlatformGetWindowSize; set => Handle->PlatformGetWindowSize = value; }
		/// <summary>
		/// N . . . .   Move window to front and set input focus<br/>
		/// </summary>
		public void* PlatformSetWindowFocus { get => Handle->PlatformSetWindowFocus; set => Handle->PlatformSetWindowFocus = value; }
		/// <summary>
		/// . . U . .<br/>
		/// </summary>
		public void* PlatformGetWindowFocus { get => Handle->PlatformGetWindowFocus; set => Handle->PlatformGetWindowFocus = value; }
		/// <summary>
		/// N . . . .   Get platform window minimized state. When minimized, we generally won't attempt to getset size and contents will be culled more easily<br/>
		/// </summary>
		public void* PlatformGetWindowMinimized { get => Handle->PlatformGetWindowMinimized; set => Handle->PlatformGetWindowMinimized = value; }
		/// <summary>
		/// . . U . .   Set platform window title (given an UTF-8 string)<br/>
		/// </summary>
		public void* PlatformSetWindowTitle { get => Handle->PlatformSetWindowTitle; set => Handle->PlatformSetWindowTitle = value; }
		/// <summary>
		/// . . U . .   (Optional) Setup global transparency (not per-pixel transparency)<br/>
		/// </summary>
		public void* PlatformSetWindowAlpha { get => Handle->PlatformSetWindowAlpha; set => Handle->PlatformSetWindowAlpha = value; }
		/// <summary>
		/// . . U . .   (Optional) Called by UpdatePlatformWindows(). Optional hook to allow the platform backend from doing general book-keeping every frame.<br/>
		/// </summary>
		public void* PlatformUpdateWindow { get => Handle->PlatformUpdateWindow; set => Handle->PlatformUpdateWindow = value; }
		/// <summary>
		/// . . . R .   (Optional) Main rendering (platform side! This is often unused, or just setting a "current" context for OpenGL bindings). 'render_arg' is the value passed to RenderPlatformWindowsDefault().<br/>
		/// </summary>
		public void* PlatformRenderWindow { get => Handle->PlatformRenderWindow; set => Handle->PlatformRenderWindow = value; }
		/// <summary>
		/// . . . R .   (Optional) Call PresentSwapBuffers (platform side! This is often unused!). 'render_arg' is the value passed to RenderPlatformWindowsDefault().<br/>
		/// </summary>
		public void* PlatformSwapBuffers { get => Handle->PlatformSwapBuffers; set => Handle->PlatformSwapBuffers = value; }
		/// <summary>
		/// N . . . .   (Optional) [BETA] FIXME-DPI: DPI handling: Return DPI scale for this viewport. 1.0f = 96 DPI.<br/>
		/// </summary>
		public void* PlatformGetWindowDpiScale { get => Handle->PlatformGetWindowDpiScale; set => Handle->PlatformGetWindowDpiScale = value; }
		/// <summary>
		/// . F . . .   (Optional) [BETA] FIXME-DPI: DPI handling: Called during Begin() every time the viewport we are outputting into changes, so backend has a chance to swap fonts to adjust style.<br/>
		/// </summary>
		public void* PlatformOnChangedViewport { get => Handle->PlatformOnChangedViewport; set => Handle->PlatformOnChangedViewport = value; }
		/// <summary>
		/// (Optional) For a Vulkan Renderer to call into Platform code (since the surface creation needs to tie them both).<br/>
		/// </summary>
		public void* PlatformCreateVkSurface { get => Handle->PlatformCreateVkSurface; set => Handle->PlatformCreateVkSurface = value; }
		/// <summary>
		/// (Optional) Renderer functions (e.g. DirectX, OpenGL, Vulkan) . . U . .   Create swap chain, frame buffers etc. (called after Platform_CreateWindow)<br/>
		/// </summary>
		public void* RendererCreateWindow { get => Handle->RendererCreateWindow; set => Handle->RendererCreateWindow = value; }
		/// <summary>
		/// N . U . D   Destroy swap chain, frame buffers etc. (called before Platform_DestroyWindow)<br/>
		/// </summary>
		public void* RendererDestroyWindow { get => Handle->RendererDestroyWindow; set => Handle->RendererDestroyWindow = value; }
		/// <summary>
		/// . . U . .   Resize swap chain, frame buffers etc. (called after Platform_SetWindowSize)<br/>
		/// </summary>
		public void* RendererSetWindowSize { get => Handle->RendererSetWindowSize; set => Handle->RendererSetWindowSize = value; }
		/// <summary>
		/// . . . R .   (Optional) Clear framebuffer, setup render target, then render the viewport-&gt;DrawData. 'render_arg' is the value passed to RenderPlatformWindowsDefault().<br/>
		/// </summary>
		public void* RendererRenderWindow { get => Handle->RendererRenderWindow; set => Handle->RendererRenderWindow = value; }
		/// <summary>
		/// . . . R .   (Optional) Call PresentSwapBuffers. 'render_arg' is the value passed to RenderPlatformWindowsDefault().<br/>
		/// </summary>
		public void* RendererSwapBuffers { get => Handle->RendererSwapBuffers; set => Handle->RendererSwapBuffers = value; }
		public ref ImVectorImGuiPlatformMonitor Monitors => ref Unsafe.AsRef<ImVectorImGuiPlatformMonitor>(&Handle->Monitors);
		/// <summary>
		/// Viewports list (the list is updated by calling ImGui::EndFrame or ImGui::Render)<br/>
		/// (in the future we will attempt to organize this feature to remove the need for a "main viewport") Main viewports, followed by all secondary viewports.<br/>
		/// </summary>
		public ref ImVectorImGuiViewportPtr Viewports => ref Unsafe.AsRef<ImVectorImGuiViewportPtr>(&Handle->Viewports);

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiPlatformMonitor
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiPlatformMonitor* Data;


	}

	/// <summary>
	/// (Optional) This is required when enabling multi-viewport. Represent the bounds of each connected monitordisplay and their DPI.<br/>
	/// We use this information for multiple DPI support + clamping the position of popups and tooltips so they don't straddle multiple monitors.<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiPlatformMonitor
	{
		/// <summary>
		/// Coordinates of the area displayed on this monitor (Min = upper left, Max = bottom right)<br/>
		/// </summary>
		public Vector2 MainPos;

		/// <summary>
		/// Coordinates of the area displayed on this monitor (Min = upper left, Max = bottom right)<br/>
		/// </summary>
		public Vector2 MainSize;

		/// <summary>
		/// Coordinates without task bars  side bars  menu bars. Used to avoid positioning popupstooltips inside this region. If you don't have this info, please copy the value for MainPosMainSize.<br/>
		/// </summary>
		public Vector2 WorkPos;

		/// <summary>
		/// Coordinates without task bars  side bars  menu bars. Used to avoid positioning popupstooltips inside this region. If you don't have this info, please copy the value for MainPosMainSize.<br/>
		/// </summary>
		public Vector2 WorkSize;

		/// <summary>
		/// 1.0f = 96 DPI<br/>
		/// </summary>
		public float DpiScale;

		/// <summary>
		/// Backend dependant data (e.g. HMONITOR, GLFWmonitor*, SDL Display Index, NSScreen*)<br/>
		/// </summary>
		public unsafe void* PlatformHandle;





		public unsafe void Destroy()
		{
			fixed (ImGuiPlatformMonitor* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiPlatformMonitorPtr : IEquatable<ImGuiPlatformMonitorPtr>
	{
		public ImGuiPlatformMonitorPtr(ImGuiPlatformMonitor* handle) { Handle = handle; }

		public ImGuiPlatformMonitor* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiPlatformMonitorPtr Null => new ImGuiPlatformMonitorPtr(null);

		public static implicit operator ImGuiPlatformMonitorPtr(ImGuiPlatformMonitor* handle) => new ImGuiPlatformMonitorPtr(handle);

		public static implicit operator ImGuiPlatformMonitor*(ImGuiPlatformMonitorPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiPlatformMonitorPtr left, ImGuiPlatformMonitorPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiPlatformMonitorPtr left, ImGuiPlatformMonitorPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiPlatformMonitorPtr left, ImGuiPlatformMonitor* right) => left.Handle == right;

		public static bool operator !=(ImGuiPlatformMonitorPtr left, ImGuiPlatformMonitor* right) => left.Handle != right;

		public bool Equals(ImGuiPlatformMonitorPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiPlatformMonitorPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiPlatformMonitorPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		/// <summary>
		/// Coordinates of the area displayed on this monitor (Min = upper left, Max = bottom right)<br/>
		/// </summary>
		public ref Vector2 MainPos => ref Unsafe.AsRef<Vector2>(&Handle->MainPos);
		/// <summary>
		/// Coordinates of the area displayed on this monitor (Min = upper left, Max = bottom right)<br/>
		/// </summary>
		public ref Vector2 MainSize => ref Unsafe.AsRef<Vector2>(&Handle->MainSize);
		/// <summary>
		/// Coordinates without task bars  side bars  menu bars. Used to avoid positioning popupstooltips inside this region. If you don't have this info, please copy the value for MainPosMainSize.<br/>
		/// </summary>
		public ref Vector2 WorkPos => ref Unsafe.AsRef<Vector2>(&Handle->WorkPos);
		/// <summary>
		/// Coordinates without task bars  side bars  menu bars. Used to avoid positioning popupstooltips inside this region. If you don't have this info, please copy the value for MainPosMainSize.<br/>
		/// </summary>
		public ref Vector2 WorkSize => ref Unsafe.AsRef<Vector2>(&Handle->WorkSize);
		/// <summary>
		/// 1.0f = 96 DPI<br/>
		/// </summary>
		public ref float DpiScale => ref Unsafe.AsRef<float>(&Handle->DpiScale);
		/// <summary>
		/// Backend dependant data (e.g. HMONITOR, GLFWmonitor*, SDL Display Index, NSScreen*)<br/>
		/// </summary>
		public void* PlatformHandle { get => Handle->PlatformHandle; set => Handle->PlatformHandle = value; }

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiViewportPtr
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiViewport** Data;


	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiStyle
	{
		/// <summary>
		/// Global alpha applies to everything in Dear ImGui.<br/>
		/// </summary>
		public float Alpha;

		/// <summary>
		/// Additional alpha multiplier applied by BeginDisabled(). Multiply over current value of Alpha.<br/>
		/// </summary>
		public float DisabledAlpha;

		/// <summary>
		/// Padding within a window.<br/>
		/// </summary>
		public Vector2 WindowPadding;

		/// <summary>
		/// Radius of window corners rounding. Set to 0.0f to have rectangular windows. Large values tend to lead to variety of artifacts and are not recommended.<br/>
		/// </summary>
		public float WindowRounding;

		/// <summary>
		/// Thickness of border around windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPUGPU costly).<br/>
		/// </summary>
		public float WindowBorderSize;

		/// <summary>
		/// Minimum window size. This is a global setting. If you want to constrain individual windows, use SetNextWindowSizeConstraints().<br/>
		/// </summary>
		public Vector2 WindowMinSize;

		/// <summary>
		/// Alignment for title bar text. Defaults to (0.0f,0.5f) for left-aligned,vertically centered.<br/>
		/// </summary>
		public Vector2 WindowTitleAlign;

		/// <summary>
		/// Side of the collapsingdocking button in the title bar (NoneLeftRight). Defaults to ImGuiDir_Left.<br/>
		/// </summary>
		public ImGuiDir WindowMenuButtonPosition;

		/// <summary>
		/// Radius of child window corners rounding. Set to 0.0f to have rectangular windows.<br/>
		/// </summary>
		public float ChildRounding;

		/// <summary>
		/// Thickness of border around child windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPUGPU costly).<br/>
		/// </summary>
		public float ChildBorderSize;

		/// <summary>
		/// Radius of popup window corners rounding. (Note that tooltip windows use WindowRounding)<br/>
		/// </summary>
		public float PopupRounding;

		/// <summary>
		/// Thickness of border around popuptooltip windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPUGPU costly).<br/>
		/// </summary>
		public float PopupBorderSize;

		/// <summary>
		/// Padding within a framed rectangle (used by most widgets).<br/>
		/// </summary>
		public Vector2 FramePadding;

		/// <summary>
		/// Radius of frame corners rounding. Set to 0.0f to have rectangular frame (used by most widgets).<br/>
		/// </summary>
		public float FrameRounding;

		/// <summary>
		/// Thickness of border around frames. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPUGPU costly).<br/>
		/// </summary>
		public float FrameBorderSize;

		/// <summary>
		/// Horizontal and vertical spacing between widgetslines.<br/>
		/// </summary>
		public Vector2 ItemSpacing;

		/// <summary>
		/// Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label).<br/>
		/// </summary>
		public Vector2 ItemInnerSpacing;

		/// <summary>
		/// Padding within a table cell<br/>
		/// </summary>
		public Vector2 CellPadding;

		/// <summary>
		/// Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much!<br/>
		/// </summary>
		public Vector2 TouchExtraPadding;

		/// <summary>
		/// Horizontal indentation when e.g. entering a tree node. Generally == (FontSize + FramePadding.x*2).<br/>
		/// </summary>
		public float IndentSpacing;

		/// <summary>
		/// Minimum horizontal spacing between two columns. Preferably &gt; (FramePadding.x + 1).<br/>
		/// </summary>
		public float ColumnsMinSpacing;

		/// <summary>
		/// Width of the vertical scrollbar, Height of the horizontal scrollbar.<br/>
		/// </summary>
		public float ScrollbarSize;

		/// <summary>
		/// Radius of grab corners for scrollbar.<br/>
		/// </summary>
		public float ScrollbarRounding;

		/// <summary>
		/// Minimum widthheight of a grab box for sliderscrollbar.<br/>
		/// </summary>
		public float GrabMinSize;

		/// <summary>
		/// Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.<br/>
		/// </summary>
		public float GrabRounding;

		/// <summary>
		/// The size in pixels of the dead-zone around zero on logarithmic sliders that cross zero.<br/>
		/// </summary>
		public float LogSliderDeadzone;

		/// <summary>
		/// Radius of upper corners of a tab. Set to 0.0f to have rectangular tabs.<br/>
		/// </summary>
		public float TabRounding;

		/// <summary>
		/// Thickness of border around tabs.<br/>
		/// </summary>
		public float TabBorderSize;

		/// <summary>
		/// Minimum width for close button to appear on an unselected tab when hovered. Set to 0.0f to always show when hovering, set to FLT_MAX to never show close button unless selected.<br/>
		/// </summary>
		public float TabMinWidthForCloseButton;

		/// <summary>
		/// Side of the color button in the ColorEdit4 widget (leftright). Defaults to ImGuiDir_Right.<br/>
		/// </summary>
		public ImGuiDir ColorButtonPosition;

		/// <summary>
		/// Alignment of button text when button is larger than text. Defaults to (0.5f, 0.5f) (centered).<br/>
		/// </summary>
		public Vector2 ButtonTextAlign;

		/// <summary>
		/// Alignment of selectable text. Defaults to (0.0f, 0.0f) (top-left aligned). It's generally important to keep this left-aligned if you want to lay multiple items on a same line.<br/>
		/// </summary>
		public Vector2 SelectableTextAlign;

		/// <summary>
		/// Thickkness of border in SeparatorText()<br/>
		/// </summary>
		public float SeparatorTextBorderSize;

		/// <summary>
		/// Alignment of text within the separator. Defaults to (0.0f, 0.5f) (left aligned, center).<br/>
		/// </summary>
		public Vector2 SeparatorTextAlign;

		/// <summary>
		/// Horizontal offset of text from each edge of the separator + spacing on other axis. Generally small values. .y is recommended to be == FramePadding.y.<br/>
		/// </summary>
		public Vector2 SeparatorTextPadding;

		/// <summary>
		/// Window position are clamped to be visible within the display area or monitors by at least this amount. Only applies to regular windows.<br/>
		/// </summary>
		public Vector2 DisplayWindowPadding;

		/// <summary>
		/// If you cannot see the edges of your screen (e.g. on a TV) increase the safe area padding. Apply to popupstooltips as well regular windows. NB: Prefer configuring your TV sets correctly!<br/>
		/// </summary>
		public Vector2 DisplaySafeAreaPadding;

		/// <summary>
		/// Scale software rendered mouse cursor (when io.MouseDrawCursor is enabled). We apply per-monitor DPI scaling over this scale. May be removed later.<br/>
		/// </summary>
		public float MouseCursorScale;

		/// <summary>
		/// Enable anti-aliased linesborders. Disable if you are really tight on CPUGPU. Latched at the beginning of the frame (copied to ImDrawList).<br/>
		/// </summary>
		public byte AntiAliasedLines;

		/// <summary>
		/// Enable anti-aliased linesborders using textures where possible. Require backend to render with bilinear filtering (NOT pointnearest filtering). Latched at the beginning of the frame (copied to ImDrawList).<br/>
		/// </summary>
		public byte AntiAliasedLinesUseTex;

		/// <summary>
		/// Enable anti-aliased edges around filled shapes (rounded rectangles, circles, etc.). Disable if you are really tight on CPUGPU. Latched at the beginning of the frame (copied to ImDrawList).<br/>
		/// </summary>
		public byte AntiAliasedFill;

		/// <summary>
		/// Tessellation tolerance when using PathBezierCurveTo() without a specific number of segments. Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality.<br/>
		/// </summary>
		public float CurveTessellationTol;

		/// <summary>
		/// Maximum error (in pixels) allowed when using AddCircle()AddCircleFilled() or drawing rounded corner rectangles with no explicit segment count specified. Decrease for higher quality but more geometry.<br/>
		/// </summary>
		public float CircleTessellationMaxError;

		public Vector4 Colors_0;
		public Vector4 Colors_1;
		public Vector4 Colors_2;
		public Vector4 Colors_3;
		public Vector4 Colors_4;
		public Vector4 Colors_5;
		public Vector4 Colors_6;
		public Vector4 Colors_7;
		public Vector4 Colors_8;
		public Vector4 Colors_9;
		public Vector4 Colors_10;
		public Vector4 Colors_11;
		public Vector4 Colors_12;
		public Vector4 Colors_13;
		public Vector4 Colors_14;
		public Vector4 Colors_15;
		public Vector4 Colors_16;
		public Vector4 Colors_17;
		public Vector4 Colors_18;
		public Vector4 Colors_19;
		public Vector4 Colors_20;
		public Vector4 Colors_21;
		public Vector4 Colors_22;
		public Vector4 Colors_23;
		public Vector4 Colors_24;
		public Vector4 Colors_25;
		public Vector4 Colors_26;
		public Vector4 Colors_27;
		public Vector4 Colors_28;
		public Vector4 Colors_29;
		public Vector4 Colors_30;
		public Vector4 Colors_31;
		public Vector4 Colors_32;
		public Vector4 Colors_33;
		public Vector4 Colors_34;
		public Vector4 Colors_35;
		public Vector4 Colors_36;
		public Vector4 Colors_37;
		public Vector4 Colors_38;
		public Vector4 Colors_39;
		public Vector4 Colors_40;
		public Vector4 Colors_41;
		public Vector4 Colors_42;
		public Vector4 Colors_43;
		public Vector4 Colors_44;
		public Vector4 Colors_45;
		public Vector4 Colors_46;
		public Vector4 Colors_47;
		public Vector4 Colors_48;
		public Vector4 Colors_49;
		public Vector4 Colors_50;
		public Vector4 Colors_51;
		public Vector4 Colors_52;
		public Vector4 Colors_53;
		public Vector4 Colors_54;
		/// <summary>
		/// Behaviors<br/>
		/// (It is possible to modify those fields mid-frame if specific behavior need it, unlike e.g. configuration fields in ImGuiIO) Delay for IsItemHovered(ImGuiHoveredFlags_Stationary). Time required to consider mouse stationary.<br/>
		/// </summary>
		public float HoverStationaryDelay;

		/// <summary>
		/// Delay for IsItemHovered(ImGuiHoveredFlags_DelayShort). Usually used along with HoverStationaryDelay.<br/>
		/// </summary>
		public float HoverDelayShort;

		/// <summary>
		/// Delay for IsItemHovered(ImGuiHoveredFlags_DelayNormal). "<br/>
		/// </summary>
		public float HoverDelayNormal;

		/// <summary>
		/// Default flags when using IsItemHovered(ImGuiHoveredFlags_ForTooltip) or BeginItemTooltip()SetItemTooltip() while using mouse.<br/>
		/// </summary>
		public ImGuiHoveredFlags HoverFlagsForTooltipMouse;

		/// <summary>
		/// Default flags when using IsItemHovered(ImGuiHoveredFlags_ForTooltip) or BeginItemTooltip()SetItemTooltip() while using keyboardgamepad.<br/>
		/// </summary>
		public ImGuiHoveredFlags HoverFlagsForTooltipNav;




		public unsafe Span<Vector4> Colors
		
		{
			get
			{
				fixed (Vector4* p = &this.Colors_0)
				{
					return new Span<Vector4>(p, 55);
				}
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImGuiStyle* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe void ScaleAllSizes(float scaleFactor)
		{
			fixed (ImGuiStyle* @this = &this)
			{
				ImGui.ScaleAllSizesNative(@this, scaleFactor);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiStylePtr : IEquatable<ImGuiStylePtr>
	{
		public ImGuiStylePtr(ImGuiStyle* handle) { Handle = handle; }

		public ImGuiStyle* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiStylePtr Null => new ImGuiStylePtr(null);

		public static implicit operator ImGuiStylePtr(ImGuiStyle* handle) => new ImGuiStylePtr(handle);

		public static implicit operator ImGuiStyle*(ImGuiStylePtr handle) => handle.Handle;

		public static bool operator ==(ImGuiStylePtr left, ImGuiStylePtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiStylePtr left, ImGuiStylePtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiStylePtr left, ImGuiStyle* right) => left.Handle == right;

		public static bool operator !=(ImGuiStylePtr left, ImGuiStyle* right) => left.Handle != right;

		public bool Equals(ImGuiStylePtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiStylePtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiStylePtr [0x{0}]", ((nuint)Handle).ToString("X"));
		/// <summary>
		/// Global alpha applies to everything in Dear ImGui.<br/>
		/// </summary>
		public ref float Alpha => ref Unsafe.AsRef<float>(&Handle->Alpha);
		/// <summary>
		/// Additional alpha multiplier applied by BeginDisabled(). Multiply over current value of Alpha.<br/>
		/// </summary>
		public ref float DisabledAlpha => ref Unsafe.AsRef<float>(&Handle->DisabledAlpha);
		/// <summary>
		/// Padding within a window.<br/>
		/// </summary>
		public ref Vector2 WindowPadding => ref Unsafe.AsRef<Vector2>(&Handle->WindowPadding);
		/// <summary>
		/// Radius of window corners rounding. Set to 0.0f to have rectangular windows. Large values tend to lead to variety of artifacts and are not recommended.<br/>
		/// </summary>
		public ref float WindowRounding => ref Unsafe.AsRef<float>(&Handle->WindowRounding);
		/// <summary>
		/// Thickness of border around windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPUGPU costly).<br/>
		/// </summary>
		public ref float WindowBorderSize => ref Unsafe.AsRef<float>(&Handle->WindowBorderSize);
		/// <summary>
		/// Minimum window size. This is a global setting. If you want to constrain individual windows, use SetNextWindowSizeConstraints().<br/>
		/// </summary>
		public ref Vector2 WindowMinSize => ref Unsafe.AsRef<Vector2>(&Handle->WindowMinSize);
		/// <summary>
		/// Alignment for title bar text. Defaults to (0.0f,0.5f) for left-aligned,vertically centered.<br/>
		/// </summary>
		public ref Vector2 WindowTitleAlign => ref Unsafe.AsRef<Vector2>(&Handle->WindowTitleAlign);
		/// <summary>
		/// Side of the collapsingdocking button in the title bar (NoneLeftRight). Defaults to ImGuiDir_Left.<br/>
		/// </summary>
		public ref ImGuiDir WindowMenuButtonPosition => ref Unsafe.AsRef<ImGuiDir>(&Handle->WindowMenuButtonPosition);
		/// <summary>
		/// Radius of child window corners rounding. Set to 0.0f to have rectangular windows.<br/>
		/// </summary>
		public ref float ChildRounding => ref Unsafe.AsRef<float>(&Handle->ChildRounding);
		/// <summary>
		/// Thickness of border around child windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPUGPU costly).<br/>
		/// </summary>
		public ref float ChildBorderSize => ref Unsafe.AsRef<float>(&Handle->ChildBorderSize);
		/// <summary>
		/// Radius of popup window corners rounding. (Note that tooltip windows use WindowRounding)<br/>
		/// </summary>
		public ref float PopupRounding => ref Unsafe.AsRef<float>(&Handle->PopupRounding);
		/// <summary>
		/// Thickness of border around popuptooltip windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPUGPU costly).<br/>
		/// </summary>
		public ref float PopupBorderSize => ref Unsafe.AsRef<float>(&Handle->PopupBorderSize);
		/// <summary>
		/// Padding within a framed rectangle (used by most widgets).<br/>
		/// </summary>
		public ref Vector2 FramePadding => ref Unsafe.AsRef<Vector2>(&Handle->FramePadding);
		/// <summary>
		/// Radius of frame corners rounding. Set to 0.0f to have rectangular frame (used by most widgets).<br/>
		/// </summary>
		public ref float FrameRounding => ref Unsafe.AsRef<float>(&Handle->FrameRounding);
		/// <summary>
		/// Thickness of border around frames. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPUGPU costly).<br/>
		/// </summary>
		public ref float FrameBorderSize => ref Unsafe.AsRef<float>(&Handle->FrameBorderSize);
		/// <summary>
		/// Horizontal and vertical spacing between widgetslines.<br/>
		/// </summary>
		public ref Vector2 ItemSpacing => ref Unsafe.AsRef<Vector2>(&Handle->ItemSpacing);
		/// <summary>
		/// Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label).<br/>
		/// </summary>
		public ref Vector2 ItemInnerSpacing => ref Unsafe.AsRef<Vector2>(&Handle->ItemInnerSpacing);
		/// <summary>
		/// Padding within a table cell<br/>
		/// </summary>
		public ref Vector2 CellPadding => ref Unsafe.AsRef<Vector2>(&Handle->CellPadding);
		/// <summary>
		/// Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much!<br/>
		/// </summary>
		public ref Vector2 TouchExtraPadding => ref Unsafe.AsRef<Vector2>(&Handle->TouchExtraPadding);
		/// <summary>
		/// Horizontal indentation when e.g. entering a tree node. Generally == (FontSize + FramePadding.x*2).<br/>
		/// </summary>
		public ref float IndentSpacing => ref Unsafe.AsRef<float>(&Handle->IndentSpacing);
		/// <summary>
		/// Minimum horizontal spacing between two columns. Preferably &gt; (FramePadding.x + 1).<br/>
		/// </summary>
		public ref float ColumnsMinSpacing => ref Unsafe.AsRef<float>(&Handle->ColumnsMinSpacing);
		/// <summary>
		/// Width of the vertical scrollbar, Height of the horizontal scrollbar.<br/>
		/// </summary>
		public ref float ScrollbarSize => ref Unsafe.AsRef<float>(&Handle->ScrollbarSize);
		/// <summary>
		/// Radius of grab corners for scrollbar.<br/>
		/// </summary>
		public ref float ScrollbarRounding => ref Unsafe.AsRef<float>(&Handle->ScrollbarRounding);
		/// <summary>
		/// Minimum widthheight of a grab box for sliderscrollbar.<br/>
		/// </summary>
		public ref float GrabMinSize => ref Unsafe.AsRef<float>(&Handle->GrabMinSize);
		/// <summary>
		/// Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.<br/>
		/// </summary>
		public ref float GrabRounding => ref Unsafe.AsRef<float>(&Handle->GrabRounding);
		/// <summary>
		/// The size in pixels of the dead-zone around zero on logarithmic sliders that cross zero.<br/>
		/// </summary>
		public ref float LogSliderDeadzone => ref Unsafe.AsRef<float>(&Handle->LogSliderDeadzone);
		/// <summary>
		/// Radius of upper corners of a tab. Set to 0.0f to have rectangular tabs.<br/>
		/// </summary>
		public ref float TabRounding => ref Unsafe.AsRef<float>(&Handle->TabRounding);
		/// <summary>
		/// Thickness of border around tabs.<br/>
		/// </summary>
		public ref float TabBorderSize => ref Unsafe.AsRef<float>(&Handle->TabBorderSize);
		/// <summary>
		/// Minimum width for close button to appear on an unselected tab when hovered. Set to 0.0f to always show when hovering, set to FLT_MAX to never show close button unless selected.<br/>
		/// </summary>
		public ref float TabMinWidthForCloseButton => ref Unsafe.AsRef<float>(&Handle->TabMinWidthForCloseButton);
		/// <summary>
		/// Side of the color button in the ColorEdit4 widget (leftright). Defaults to ImGuiDir_Right.<br/>
		/// </summary>
		public ref ImGuiDir ColorButtonPosition => ref Unsafe.AsRef<ImGuiDir>(&Handle->ColorButtonPosition);
		/// <summary>
		/// Alignment of button text when button is larger than text. Defaults to (0.5f, 0.5f) (centered).<br/>
		/// </summary>
		public ref Vector2 ButtonTextAlign => ref Unsafe.AsRef<Vector2>(&Handle->ButtonTextAlign);
		/// <summary>
		/// Alignment of selectable text. Defaults to (0.0f, 0.0f) (top-left aligned). It's generally important to keep this left-aligned if you want to lay multiple items on a same line.<br/>
		/// </summary>
		public ref Vector2 SelectableTextAlign => ref Unsafe.AsRef<Vector2>(&Handle->SelectableTextAlign);
		/// <summary>
		/// Thickkness of border in SeparatorText()<br/>
		/// </summary>
		public ref float SeparatorTextBorderSize => ref Unsafe.AsRef<float>(&Handle->SeparatorTextBorderSize);
		/// <summary>
		/// Alignment of text within the separator. Defaults to (0.0f, 0.5f) (left aligned, center).<br/>
		/// </summary>
		public ref Vector2 SeparatorTextAlign => ref Unsafe.AsRef<Vector2>(&Handle->SeparatorTextAlign);
		/// <summary>
		/// Horizontal offset of text from each edge of the separator + spacing on other axis. Generally small values. .y is recommended to be == FramePadding.y.<br/>
		/// </summary>
		public ref Vector2 SeparatorTextPadding => ref Unsafe.AsRef<Vector2>(&Handle->SeparatorTextPadding);
		/// <summary>
		/// Window position are clamped to be visible within the display area or monitors by at least this amount. Only applies to regular windows.<br/>
		/// </summary>
		public ref Vector2 DisplayWindowPadding => ref Unsafe.AsRef<Vector2>(&Handle->DisplayWindowPadding);
		/// <summary>
		/// If you cannot see the edges of your screen (e.g. on a TV) increase the safe area padding. Apply to popupstooltips as well regular windows. NB: Prefer configuring your TV sets correctly!<br/>
		/// </summary>
		public ref Vector2 DisplaySafeAreaPadding => ref Unsafe.AsRef<Vector2>(&Handle->DisplaySafeAreaPadding);
		/// <summary>
		/// Scale software rendered mouse cursor (when io.MouseDrawCursor is enabled). We apply per-monitor DPI scaling over this scale. May be removed later.<br/>
		/// </summary>
		public ref float MouseCursorScale => ref Unsafe.AsRef<float>(&Handle->MouseCursorScale);
		/// <summary>
		/// Enable anti-aliased linesborders. Disable if you are really tight on CPUGPU. Latched at the beginning of the frame (copied to ImDrawList).<br/>
		/// </summary>
		public ref bool AntiAliasedLines => ref Unsafe.AsRef<bool>(&Handle->AntiAliasedLines);
		/// <summary>
		/// Enable anti-aliased linesborders using textures where possible. Require backend to render with bilinear filtering (NOT pointnearest filtering). Latched at the beginning of the frame (copied to ImDrawList).<br/>
		/// </summary>
		public ref bool AntiAliasedLinesUseTex => ref Unsafe.AsRef<bool>(&Handle->AntiAliasedLinesUseTex);
		/// <summary>
		/// Enable anti-aliased edges around filled shapes (rounded rectangles, circles, etc.). Disable if you are really tight on CPUGPU. Latched at the beginning of the frame (copied to ImDrawList).<br/>
		/// </summary>
		public ref bool AntiAliasedFill => ref Unsafe.AsRef<bool>(&Handle->AntiAliasedFill);
		/// <summary>
		/// Tessellation tolerance when using PathBezierCurveTo() without a specific number of segments. Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality.<br/>
		/// </summary>
		public ref float CurveTessellationTol => ref Unsafe.AsRef<float>(&Handle->CurveTessellationTol);
		/// <summary>
		/// Maximum error (in pixels) allowed when using AddCircle()AddCircleFilled() or drawing rounded corner rectangles with no explicit segment count specified. Decrease for higher quality but more geometry.<br/>
		/// </summary>
		public ref float CircleTessellationMaxError => ref Unsafe.AsRef<float>(&Handle->CircleTessellationMaxError);
		public unsafe Span<Vector4> Colors
		
		{
			get
			{
				return new Span<Vector4>(&Handle->Colors_0, 55);
			}
		}
		/// <summary>
		/// Behaviors<br/>
		/// (It is possible to modify those fields mid-frame if specific behavior need it, unlike e.g. configuration fields in ImGuiIO) Delay for IsItemHovered(ImGuiHoveredFlags_Stationary). Time required to consider mouse stationary.<br/>
		/// </summary>
		public ref float HoverStationaryDelay => ref Unsafe.AsRef<float>(&Handle->HoverStationaryDelay);
		/// <summary>
		/// Delay for IsItemHovered(ImGuiHoveredFlags_DelayShort). Usually used along with HoverStationaryDelay.<br/>
		/// </summary>
		public ref float HoverDelayShort => ref Unsafe.AsRef<float>(&Handle->HoverDelayShort);
		/// <summary>
		/// Delay for IsItemHovered(ImGuiHoveredFlags_DelayNormal). "<br/>
		/// </summary>
		public ref float HoverDelayNormal => ref Unsafe.AsRef<float>(&Handle->HoverDelayNormal);
		/// <summary>
		/// Default flags when using IsItemHovered(ImGuiHoveredFlags_ForTooltip) or BeginItemTooltip()SetItemTooltip() while using mouse.<br/>
		/// </summary>
		public ref ImGuiHoveredFlags HoverFlagsForTooltipMouse => ref Unsafe.AsRef<ImGuiHoveredFlags>(&Handle->HoverFlagsForTooltipMouse);
		/// <summary>
		/// Default flags when using IsItemHovered(ImGuiHoveredFlags_ForTooltip) or BeginItemTooltip()SetItemTooltip() while using keyboardgamepad.<br/>
		/// </summary>
		public ref ImGuiHoveredFlags HoverFlagsForTooltipNav => ref Unsafe.AsRef<ImGuiHoveredFlags>(&Handle->HoverFlagsForTooltipNav);

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

		public unsafe void ScaleAllSizes(float scaleFactor)
		{
			ImGui.ScaleAllSizesNative(Handle, scaleFactor);
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiInputEvent
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiInputEvent* Data;


	}

	[StructLayout(LayoutKind.Explicit)]
	public partial struct ImGuiInputEventUnion
	{
		[FieldOffset(0)]
		public ImGuiInputEventMousePos MousePos;
		[FieldOffset(0)]
		public ImGuiInputEventMouseWheel MouseWheel;
		[FieldOffset(0)]
		public ImGuiInputEventMouseButton MouseButton;
		[FieldOffset(0)]
		public ImGuiInputEventMouseViewport MouseViewport;
		[FieldOffset(0)]
		public ImGuiInputEventKey Key;
		[FieldOffset(0)]
		public ImGuiInputEventText Text;
		[FieldOffset(0)]
		public ImGuiInputEventAppFocused AppFocused;


	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiInputEvent
	{
		public ImGuiInputEventType Type;
		public ImGuiInputSource Source;
		/// <summary>
		/// Unique, sequential increasing integer to identify an event (if you need to correlate them to other data).<br/>
		/// </summary>
		public uint EventId;

		/// <summary>
		/// if Type == ImGuiInputEventType_MousePos if Type == ImGuiInputEventType_MouseWheel if Type == ImGuiInputEventType_MouseButton if Type == ImGuiInputEventType_MouseViewport if Type == ImGuiInputEventType_Key if Type == ImGuiInputEventType_Text if Type == ImGuiInputEventType_Focus<br/>
		/// </summary>
		public ImGuiInputEventUnion ImGuiInputEventUnion;

		public byte AddedByTestEngine;




		public unsafe void Destroy()
		{
			fixed (ImGuiInputEvent* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiInputEventPtr : IEquatable<ImGuiInputEventPtr>
	{
		public ImGuiInputEventPtr(ImGuiInputEvent* handle) { Handle = handle; }

		public ImGuiInputEvent* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiInputEventPtr Null => new ImGuiInputEventPtr(null);

		public static implicit operator ImGuiInputEventPtr(ImGuiInputEvent* handle) => new ImGuiInputEventPtr(handle);

		public static implicit operator ImGuiInputEvent*(ImGuiInputEventPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiInputEventPtr left, ImGuiInputEventPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiInputEventPtr left, ImGuiInputEventPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiInputEventPtr left, ImGuiInputEvent* right) => left.Handle == right;

		public static bool operator !=(ImGuiInputEventPtr left, ImGuiInputEvent* right) => left.Handle != right;

		public bool Equals(ImGuiInputEventPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiInputEventPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiInputEventPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref ImGuiInputEventType Type => ref Unsafe.AsRef<ImGuiInputEventType>(&Handle->Type);
		public ref ImGuiInputSource Source => ref Unsafe.AsRef<ImGuiInputSource>(&Handle->Source);
		/// <summary>
		/// Unique, sequential increasing integer to identify an event (if you need to correlate them to other data).<br/>
		/// </summary>
		public ref uint EventId => ref Unsafe.AsRef<uint>(&Handle->EventId);
		/// <summary>
		/// if Type == ImGuiInputEventType_MousePos if Type == ImGuiInputEventType_MouseWheel if Type == ImGuiInputEventType_MouseButton if Type == ImGuiInputEventType_MouseViewport if Type == ImGuiInputEventType_Key if Type == ImGuiInputEventType_Text if Type == ImGuiInputEventType_Focus<br/>
		/// </summary>
		public ref ImGuiInputEventUnion ImGuiInputEventUnion => ref Unsafe.AsRef<ImGuiInputEventUnion>(&Handle->ImGuiInputEventUnion);
		public ref bool AddedByTestEngine => ref Unsafe.AsRef<bool>(&Handle->AddedByTestEngine);

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

	}

	/// <summary>
	/// FIXME: Structures in the union below need to be declared as anonymous unions appears to be an extension?<br/>
	/// Using ImVec2() would fail on Clang 'union member 'MousePos' has a non-trivial default constructor'<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiInputEventMousePos
	{
		public float PosX;
		public float PosY;
		public ImGuiMouseSource MouseSource;


	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiInputEventMouseWheel
	{
		public float WheelX;
		public float WheelY;
		public ImGuiMouseSource MouseSource;


	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiInputEventMouseButton
	{
		public int Button;
		public byte Down;
		public ImGuiMouseSource MouseSource;


	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiInputEventMouseViewport
	{
		public int HoveredViewportID;


	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiInputEventKey
	{
		public ImGuiKey Key;
		public byte Down;
		public float AnalogValue;


	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiInputEventText
	{
		public uint Char;


	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiInputEventAppFocused
	{
		public byte Focused;


	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiWindowPtr
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiWindow** Data;


	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImVectorImGuiWindowPtrPtr : IEquatable<ImVectorImGuiWindowPtrPtr>
	{
		public ImVectorImGuiWindowPtrPtr(ImVectorImGuiWindowPtr* handle) { Handle = handle; }

		public ImVectorImGuiWindowPtr* Handle;

		public bool IsNull => Handle == null;

		public static ImVectorImGuiWindowPtrPtr Null => new ImVectorImGuiWindowPtrPtr(null);

		public static implicit operator ImVectorImGuiWindowPtrPtr(ImVectorImGuiWindowPtr* handle) => new ImVectorImGuiWindowPtrPtr(handle);

		public static implicit operator ImVectorImGuiWindowPtr*(ImVectorImGuiWindowPtrPtr handle) => handle.Handle;

		public static bool operator ==(ImVectorImGuiWindowPtrPtr left, ImVectorImGuiWindowPtrPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImVectorImGuiWindowPtrPtr left, ImVectorImGuiWindowPtrPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImVectorImGuiWindowPtrPtr left, ImVectorImGuiWindowPtr* right) => left.Handle == right;

		public static bool operator !=(ImVectorImGuiWindowPtrPtr left, ImVectorImGuiWindowPtr* right) => left.Handle != right;

		public bool Equals(ImVectorImGuiWindowPtrPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImVectorImGuiWindowPtrPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImVectorImGuiWindowPtrPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref int Size => ref Unsafe.AsRef<int>(&Handle->Size);
		public ref int Capacity => ref Unsafe.AsRef<int>(&Handle->Capacity);
		public ref ImGuiWindowPtrPtr Data => ref Unsafe.AsRef<ImGuiWindowPtrPtr>(&Handle->Data);
	}

	/// <summary>
	/// Storage for one window<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiWindow
	{
		/// <summary>
		/// Parent UI context (needs to be set explicitly by parent).<br/>
		/// </summary>
		public unsafe ImGuiContext* Ctx;

		/// <summary>
		/// Window name, owned by the window.<br/>
		/// </summary>
		public unsafe byte* Name;

		/// <summary>
		/// == ImHashStr(Name)<br/>
		/// </summary>
		public int ID;

		/// <summary>
		/// See enum ImGuiWindowFlags_<br/>
		/// </summary>
		public ImGuiWindowFlags Flags;

		/// <summary>
		/// See enum ImGuiWindowFlags_<br/>
		/// </summary>
		public ImGuiWindowFlags FlagsPreviousFrame;

		/// <summary>
		/// Advanced users only. Set with SetNextWindowClass()<br/>
		/// </summary>
		public ImGuiWindowClass WindowClass;

		/// <summary>
		/// Always set in Begin(). Inactive windows may have a NULL value here if their viewport was discarded.<br/>
		/// </summary>
		public unsafe ImGuiViewportP* Viewport;

		/// <summary>
		/// We backup the viewport id (since the viewport may disappear or never be created if the window is inactive)<br/>
		/// </summary>
		public int ViewportId;

		/// <summary>
		/// We backup the viewport position (since the viewport may disappear or never be created if the window is inactive)<br/>
		/// </summary>
		public Vector2 ViewportPos;

		/// <summary>
		/// Reset to -1 every frame (index is guaranteed to be valid between NewFrame..EndFrame), only used in the Appearing frame of a tooltippopup to enforce clamping to a given monitor<br/>
		/// </summary>
		public int ViewportAllowPlatformMonitorExtend;

		/// <summary>
		/// Position (always rounded-up to nearest pixel)<br/>
		/// </summary>
		public Vector2 Pos;

		/// <summary>
		/// Current size (==SizeFull or collapsed title bar size)<br/>
		/// </summary>
		public Vector2 Size;

		/// <summary>
		/// Size when non collapsed<br/>
		/// </summary>
		public Vector2 SizeFull;

		/// <summary>
		/// Size of contentsscrollable client area (calculated from the extents reach of the cursor) from previous frame. Does not include window decoration or window padding.<br/>
		/// </summary>
		public Vector2 ContentSize;

		public Vector2 ContentSizeIdeal;
		/// <summary>
		/// Size of contentsscrollable client area explicitly request by the user via SetNextWindowContentSize().<br/>
		/// </summary>
		public Vector2 ContentSizeExplicit;

		/// <summary>
		/// Window padding at the time of Begin().<br/>
		/// </summary>
		public Vector2 WindowPadding;

		/// <summary>
		/// Window rounding at the time of Begin(). May be clamped lower to avoid rendering artifacts with title bar, menu bar etc.<br/>
		/// </summary>
		public float WindowRounding;

		/// <summary>
		/// Window border size at the time of Begin().<br/>
		/// </summary>
		public float WindowBorderSize;

		/// <summary>
		/// LeftUp offsets. Sum of non-scrolling outer decorations (X1 generally == 0.0f. Y1 generally = TitleBarHeight + MenuBarHeight). Locked during Begin().<br/>
		/// </summary>
		public float DecoOuterSizeX1;

		/// <summary>
		/// LeftUp offsets. Sum of non-scrolling outer decorations (X1 generally == 0.0f. Y1 generally = TitleBarHeight + MenuBarHeight). Locked during Begin().<br/>
		/// </summary>
		public float DecoOuterSizeY1;

		/// <summary>
		/// RightDown offsets (X2 generally == ScrollbarSize.x, Y2 == ScrollbarSizes.y).<br/>
		/// </summary>
		public float DecoOuterSizeX2;

		/// <summary>
		/// RightDown offsets (X2 generally == ScrollbarSize.x, Y2 == ScrollbarSizes.y).<br/>
		/// </summary>
		public float DecoOuterSizeY2;

		/// <summary>
		/// Applied AFTEROVER InnerRect. Specialized for Tables as they use specialized form of clipping and frozen rowscolumns are inside InnerRect (and not part of regular decoration sizes).<br/>
		/// </summary>
		public float DecoInnerSizeX1;

		/// <summary>
		/// Applied AFTEROVER InnerRect. Specialized for Tables as they use specialized form of clipping and frozen rowscolumns are inside InnerRect (and not part of regular decoration sizes).<br/>
		/// </summary>
		public float DecoInnerSizeY1;

		/// <summary>
		/// Size of buffer storing Name. May be larger than strlen(Name)!<br/>
		/// </summary>
		public int NameBufLen;

		/// <summary>
		/// == window-&gt;GetID("#MOVE")<br/>
		/// </summary>
		public int MoveId;

		/// <summary>
		/// == window-&gt;GetID("#TAB")<br/>
		/// </summary>
		public int TabId;

		/// <summary>
		/// ID of corresponding item in parent window (for navigation to return from child window to parent window)<br/>
		/// </summary>
		public int ChildId;

		public Vector2 Scroll;
		public Vector2 ScrollMax;
		/// <summary>
		/// target scroll position. stored as cursor position with scrolling canceled out, so the highest point is always 0.0f. (FLT_MAX for no change)<br/>
		/// </summary>
		public Vector2 ScrollTarget;

		/// <summary>
		/// 0.0f = scroll so that target position is at top, 0.5f = scroll so that target position is centered<br/>
		/// </summary>
		public Vector2 ScrollTargetCenterRatio;

		/// <summary>
		/// 0.0f = no snapping, &gt;0.0f snapping threshold<br/>
		/// </summary>
		public Vector2 ScrollTargetEdgeSnapDist;

		/// <summary>
		/// Size taken by each scrollbars on their smaller axis. Pay attention! ScrollbarSizes.x == width of the vertical scrollbar, ScrollbarSizes.y = height of the horizontal scrollbar.<br/>
		/// </summary>
		public Vector2 ScrollbarSizes;

		/// <summary>
		/// Are scrollbars visible?<br/>
		/// </summary>
		public byte ScrollbarX;

		/// <summary>
		/// Are scrollbars visible?<br/>
		/// </summary>
		public byte ScrollbarY;

		public byte ViewportOwned;
		/// <summary>
		/// Set to true on Begin(), unless Collapsed<br/>
		/// </summary>
		public byte Active;

		public byte WasActive;
		/// <summary>
		/// Set to true when any widget access the current window<br/>
		/// </summary>
		public byte WriteAccessed;

		/// <summary>
		/// Set when collapsing window to become only title-bar<br/>
		/// </summary>
		public byte Collapsed;

		public byte WantCollapseToggle;
		/// <summary>
		/// Set when items can safely be all clipped (e.g. window not visible or collapsed)<br/>
		/// </summary>
		public byte SkipItems;

		/// <summary>
		/// Set during the frame where the window is appearing (or re-appearing)<br/>
		/// </summary>
		public byte Appearing;

		/// <summary>
		/// Do not display (== HiddenFrames*** &gt; 0)<br/>
		/// </summary>
		public byte Hidden;

		/// <summary>
		/// Set on the "Debug##Default" window.<br/>
		/// </summary>
		public byte IsFallbackWindow;

		/// <summary>
		/// Set when passed _ChildWindow, left to false by BeginDocked()<br/>
		/// </summary>
		public byte IsExplicitChild;

		/// <summary>
		/// Set when the window has a close button (p_open != NULL)<br/>
		/// </summary>
		public byte HasCloseButton;

		/// <summary>
		/// Current border being held for resize (-1: none, otherwise 0-3)<br/>
		/// </summary>
		public byte ResizeBorderHeld;

		/// <summary>
		/// Number of Begin() during the current frame (generally 0 or 1, 1+ if appending via multiple BeginEnd pairs)<br/>
		/// </summary>
		public short BeginCount;

		/// <summary>
		/// Number of Begin() during the previous frame<br/>
		/// </summary>
		public short BeginCountPreviousFrame;

		/// <summary>
		/// Begin() order within immediate parent window, if we are a child window. Otherwise 0.<br/>
		/// </summary>
		public short BeginOrderWithinParent;

		/// <summary>
		/// Begin() order within entire imgui context. This is mostly used for debugging submission order related issues.<br/>
		/// </summary>
		public short BeginOrderWithinContext;

		/// <summary>
		/// Order within WindowsFocusOrder[], altered when windows are focused.<br/>
		/// </summary>
		public short FocusOrder;

		/// <summary>
		/// ID in the popup stack when this window is used as a popupmenu (because we use generic NameID for recycling)<br/>
		/// </summary>
		public int PopupId;

		public sbyte AutoFitFramesX;
		public sbyte AutoFitFramesY;
		public sbyte AutoFitChildAxises;
		public byte AutoFitOnlyGrows;
		public ImGuiDir AutoPosLastDirection;
		/// <summary>
		/// Hide the window for N frames<br/>
		/// </summary>
		public sbyte HiddenFramesCanSkipItems;

		/// <summary>
		/// Hide the window for N frames while allowing items to be submitted so we can measure their size<br/>
		/// </summary>
		public sbyte HiddenFramesCannotSkipItems;

		/// <summary>
		/// Hide the window until frame N at Render() time only<br/>
		/// </summary>
		public sbyte HiddenFramesForRenderOnly;

		/// <summary>
		/// Disable window interactions for N frames<br/>
		/// </summary>
		public sbyte DisableInputsFrames;

		/// <summary>
		/// store acceptable condition flags for SetNextWindowPos() use.<br/>
		/// </summary>
		public ImGuiCond SetWindowPosAllowFlags;

		/// <summary>
		/// store acceptable condition flags for SetNextWindowSize() use.<br/>
		/// </summary>
		public ImGuiCond SetWindowSizeAllowFlags;

		/// <summary>
		/// store acceptable condition flags for SetNextWindowCollapsed() use.<br/>
		/// </summary>
		public ImGuiCond SetWindowCollapsedAllowFlags;

		/// <summary>
		/// store acceptable condition flags for SetNextWindowDock() use.<br/>
		/// </summary>
		public ImGuiCond SetWindowDockAllowFlags;

		/// <summary>
		/// store window position when using a non-zero Pivot (position set needs to be processed when we know the window size)<br/>
		/// </summary>
		public Vector2 SetWindowPosVal;

		/// <summary>
		/// store window pivot for positioning. ImVec2(0, 0) when positioning from top-left corner; ImVec2(0.5f, 0.5f) for centering; ImVec2(1, 1) for bottom right.<br/>
		/// </summary>
		public Vector2 SetWindowPosPivot;

		/// <summary>
		/// ID stack. ID are hashes seeded with the value at the top of the stack. (In theory this should be in the TempData structure)<br/>
		/// </summary>
		public ImVectorImGuiID IDStack;

		/// <summary>
		/// Temporary per-window data, reset at the beginning of the frame. This used to be called ImGuiDrawContext, hence the "DC" variable name.<br/>
		/// </summary>
		public ImGuiWindowTempData DC;

		/// <summary>
		/// The best way to understand what those rectangles are is to use the 'Metrics-&gt;Tools-&gt;Show Windows Rectangles' viewer.<br/>
		/// The main 'OuterRect', omitted as a field, is window-&gt;Rect(). == Window-&gt;Rect() just after setup in Begin(). == window-&gt;Rect() for root window.<br/>
		/// </summary>
		public ImRect OuterRectClipped;

		/// <summary>
		/// Inner rectangle (omit title bar, menu bar, scroll bar)<br/>
		/// </summary>
		public ImRect InnerRect;

		/// <summary>
		/// == InnerRect shrunk by WindowPadding*0.5f on each side, clipped within viewport or parent clip rect.<br/>
		/// </summary>
		public ImRect InnerClipRect;

		/// <summary>
		/// Initially covers the whole scrolling region. Reduced by containers e.g columnstables when active. Shrunk by WindowPadding*1.0f on each side. This is meant to replace ContentRegionRect over time (from 1.71+ onward).<br/>
		/// </summary>
		public ImRect WorkRect;

		/// <summary>
		/// Backup of WorkRect before entering a container such as columnstables. Used by e.g. SpanAllColumns functions to easily access. Stacked containers are responsible for maintaining this.  FIXME-WORKRECT: Could be a stack?<br/>
		/// </summary>
		public ImRect ParentWorkRect;

		/// <summary>
		/// Current clippingscissoring rectangle, evolve as we are using PushClipRect(), etc. == DrawList-&gt;clip_rect_stack.back().<br/>
		/// </summary>
		public ImRect ClipRect;

		/// <summary>
		/// FIXME: This is currently confusingmisleading. It is essentially WorkRect but not handling of scrolling. We currently rely on it as rightbottom aligned sizing operation need some size to rely on.<br/>
		/// </summary>
		public ImRect ContentRegionRect;

		/// <summary>
		/// Define an optional rectangular hole where mouse will pass-through the window.<br/>
		/// </summary>
		public ImVec2Ih HitTestHoleSize;

		public ImVec2Ih HitTestHoleOffset;
		/// <summary>
		/// Last frame number the window was Active.<br/>
		/// </summary>
		public int LastFrameActive;

		/// <summary>
		/// Last frame number the window was made Focused.<br/>
		/// </summary>
		public int LastFrameJustFocused;

		/// <summary>
		/// Last timestamp the window was Active (using float as we don't need high precision there)<br/>
		/// </summary>
		public float LastTimeActive;

		public float ItemWidthDefault;
		public ImGuiStorage StateStorage;
		public ImVectorImGuiOldColumns ColumnsStorage;
		/// <summary>
		/// User scale multiplier per-window, via SetWindowFontScale()<br/>
		/// </summary>
		public float FontWindowScale;

		public float FontDpiScale;
		/// <summary>
		/// Offset into SettingsWindows[] (offsets are always valid as we only grow the array from the back)<br/>
		/// </summary>
		public int SettingsOffset;

		/// <summary>
		/// == &amp;DrawListInst (for backward compatibility reason with code using imgui_internal.h we keep this a pointer)<br/>
		/// </summary>
		public unsafe ImDrawList* DrawList;

		public ImDrawList DrawListInst;
		/// <summary>
		/// If we are a child _or_ popup _or_ docked window, this is pointing to our parent. Otherwise NULL.<br/>
		/// </summary>
		public unsafe ImGuiWindow* ParentWindow;

		public unsafe ImGuiWindow* ParentWindowInBeginStack;
		/// <summary>
		/// Point to ourself or first ancestor that is not a child window. Doesn't cross through popupsdock nodes.<br/>
		/// </summary>
		public unsafe ImGuiWindow* RootWindow;

		/// <summary>
		/// Point to ourself or first ancestor that is not a child window. Cross through popups parent&lt;&gt;child.<br/>
		/// </summary>
		public unsafe ImGuiWindow* RootWindowPopupTree;

		/// <summary>
		/// Point to ourself or first ancestor that is not a child window. Cross through dock nodes.<br/>
		/// </summary>
		public unsafe ImGuiWindow* RootWindowDockTree;

		/// <summary>
		/// Point to ourself or first ancestor which will display TitleBgActive color when this window is active.<br/>
		/// </summary>
		public unsafe ImGuiWindow* RootWindowForTitleBarHighlight;

		/// <summary>
		/// Point to ourself or first ancestor which doesn't have the NavFlattened flag.<br/>
		/// </summary>
		public unsafe ImGuiWindow* RootWindowForNav;

		/// <summary>
		/// When going to the menu bar, we remember the child window we came from. (This could probably be made implicit if we kept g.Windows sorted by last focused including child window.)<br/>
		/// </summary>
		public unsafe ImGuiWindow* NavLastChildNavWindow;

		/// <summary>
		/// Last known NavId for this window, per layer (01)<br/>
		/// </summary>
		public uint NavLastIds_0;
		public uint NavLastIds_1;

		/// <summary>
		/// Reference rectangle, in window relative space<br/>
		/// </summary>
		public ImRect NavRectRel_0;
		public ImRect NavRectRel_1;

		/// <summary>
		/// Preferred XY position updated when moving on a given axis, reset to FLT_MAX.<br/>
		/// </summary>
		public Vector2 NavPreferredScoringPosRel_0;
		public Vector2 NavPreferredScoringPosRel_1;

		/// <summary>
		/// Focus Scope ID at the time of Begin()<br/>
		/// </summary>
		public int NavRootFocusScopeId;

		/// <summary>
		/// Backup of last idxvtx count, so when waking up the window we can preallocate and avoid iterative alloccopy<br/>
		/// </summary>
		public int MemoryDrawListIdxCapacity;

		public int MemoryDrawListVtxCapacity;
		/// <summary>
		/// Set when window extraneous data have been garbage collected<br/>
		/// </summary>
		public byte MemoryCompacted;

		/// <summary>
		/// Docking When docking artifacts are actually visible. When this is set, DockNode is guaranteed to be != NULL. ~~ (DockNode != NULL) &amp;&amp; (DockNode-&gt;Windows.Size &gt; 1).<br/>
		/// </summary>
		public byte DockIsActive;

		public byte DockNodeIsVisible;
		/// <summary>
		/// Is our window visible this frame? ~~ is the corresponding tab selected?<br/>
		/// </summary>
		public byte DockTabIsVisible;

		public byte DockTabWantClose;
		/// <summary>
		/// Order of the last time the window was visible within its DockNode. This is used to reorder windows that are reappearing on the same frame. Same value between windows that were active and windows that were none are possible.<br/>
		/// </summary>
		public short DockOrder;

		public ImGuiWindowDockStyle DockStyle;
		/// <summary>
		/// Which node are we docked into. Important: Prefer testing DockIsActive in many cases as this will still be set when the dock node is hidden.<br/>
		/// </summary>
		public unsafe ImGuiDockNode* DockNode;

		/// <summary>
		/// Which node are we owning (for parent windows)<br/>
		/// </summary>
		public unsafe ImGuiDockNode* DockNodeAsHost;

		/// <summary>
		/// Backup of last valid DockNode-&gt;ID, so single window remember their dock node id even when they are not bound any more<br/>
		/// </summary>
		public int DockId;

		public ImGuiItemStatusFlags DockTabItemStatusFlags;
		public ImRect DockTabItemRect;



		public unsafe Span<ImRect> NavRectRel
		
		{
			get
			{
				fixed (ImRect* p = &this.NavRectRel_0)
				{
					return new Span<ImRect>(p, 2);
				}
			}
		}
		public unsafe Span<Vector2> NavPreferredScoringPosRel
		
		{
			get
			{
				fixed (Vector2* p = &this.NavPreferredScoringPosRel_0)
				{
					return new Span<Vector2>(p, 2);
				}
			}
		}

		public unsafe float CalcFontSize()
		{
			fixed (ImGuiWindow* @this = &this)
			{
				float ret = ImGui.CalcFontSizeNative(@this);
				return ret;
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImGuiWindow* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe int GetID(byte* str, byte* strEnd)
		{
			fixed (ImGuiWindow* @this = &this)
			{
				int ret = ImGui.GetIDNative(@this, str, strEnd);
				return ret;
			}
		}

		public unsafe int GetID(byte* str)
		{
			fixed (ImGuiWindow* @this = &this)
			{
				int ret = ImGui.GetIDNative(@this, str, (byte*)(default));
				return ret;
			}
		}

		public unsafe int GetID(ref byte str, byte* strEnd)
		{
			fixed (ImGuiWindow* @this = &this)
			{
				fixed (byte* pstr = &str)
				{
					int ret = ImGui.GetIDNative(@this, (byte*)pstr, strEnd);
					return ret;
				}
			}
		}

		public unsafe int GetID(ref byte str)
		{
			fixed (ImGuiWindow* @this = &this)
			{
				fixed (byte* pstr = &str)
				{
					int ret = ImGui.GetIDNative(@this, (byte*)pstr, (byte*)(default));
					return ret;
				}
			}
		}

		public unsafe int GetID(string str, byte* strEnd)
		{
			fixed (ImGuiWindow* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				int ret = ImGui.GetIDNative(@this, pStr0, strEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe int GetID(string str)
		{
			fixed (ImGuiWindow* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				int ret = ImGui.GetIDNative(@this, pStr0, (byte*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe int GetID(byte* str, ref byte strEnd)
		{
			fixed (ImGuiWindow* @this = &this)
			{
				fixed (byte* pstrEnd = &strEnd)
				{
					int ret = ImGui.GetIDNative(@this, str, (byte*)pstrEnd);
					return ret;
				}
			}
		}

		public unsafe int GetID(byte* str, string strEnd)
		{
			fixed (ImGuiWindow* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (strEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(strEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(strEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				int ret = ImGui.GetIDNative(@this, str, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe int GetID(ref byte str, ref byte strEnd)
		{
			fixed (ImGuiWindow* @this = &this)
			{
				fixed (byte* pstr = &str)
				{
					fixed (byte* pstrEnd = &strEnd)
					{
						int ret = ImGui.GetIDNative(@this, (byte*)pstr, (byte*)pstrEnd);
						return ret;
					}
				}
			}
		}

		public unsafe int GetID(string str, string strEnd)
		{
			fixed (ImGuiWindow* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (strEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(strEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(strEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				int ret = ImGui.GetIDNative(@this, pStr0, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe int GetID(void* ptr)
		{
			fixed (ImGuiWindow* @this = &this)
			{
				int ret = ImGui.GetIDNative(@this, ptr);
				return ret;
			}
		}

		public unsafe int GetID(int n)
		{
			fixed (ImGuiWindow* @this = &this)
			{
				int ret = ImGui.GetIDNative(@this, n);
				return ret;
			}
		}

		public unsafe int GetIDFromRectangle(ImRect rAbs)
		{
			fixed (ImGuiWindow* @this = &this)
			{
				int ret = ImGui.GetIDFromRectangleNative(@this, rAbs);
				return ret;
			}
		}

		public unsafe float MenuBarHeight()
		{
			fixed (ImGuiWindow* @this = &this)
			{
				float ret = ImGui.MenuBarHeightNative(@this);
				return ret;
			}
		}

		public unsafe float TitleBarHeight()
		{
			fixed (ImGuiWindow* @this = &this)
			{
				float ret = ImGui.TitleBarHeightNative(@this);
				return ret;
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiWindowPtr : IEquatable<ImGuiWindowPtr>
	{
		public ImGuiWindowPtr(ImGuiWindow* handle) { Handle = handle; }

		public ImGuiWindow* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiWindowPtr Null => new ImGuiWindowPtr(null);

		public static implicit operator ImGuiWindowPtr(ImGuiWindow* handle) => new ImGuiWindowPtr(handle);

		public static implicit operator ImGuiWindow*(ImGuiWindowPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiWindowPtr left, ImGuiWindowPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiWindowPtr left, ImGuiWindowPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiWindowPtr left, ImGuiWindow* right) => left.Handle == right;

		public static bool operator !=(ImGuiWindowPtr left, ImGuiWindow* right) => left.Handle != right;

		public bool Equals(ImGuiWindowPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiWindowPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiWindowPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		/// <summary>
		/// Parent UI context (needs to be set explicitly by parent).<br/>
		/// </summary>
		public ref ImGuiContextPtr Ctx => ref Unsafe.AsRef<ImGuiContextPtr>(&Handle->Ctx);
		/// <summary>
		/// Window name, owned by the window.<br/>
		/// </summary>
		public byte* Name { get => Handle->Name; set => Handle->Name = value; }
		/// <summary>
		/// == ImHashStr(Name)<br/>
		/// </summary>
		public ref int ID => ref Unsafe.AsRef<int>(&Handle->ID);
		/// <summary>
		/// See enum ImGuiWindowFlags_<br/>
		/// </summary>
		public ref ImGuiWindowFlags Flags => ref Unsafe.AsRef<ImGuiWindowFlags>(&Handle->Flags);
		/// <summary>
		/// See enum ImGuiWindowFlags_<br/>
		/// </summary>
		public ref ImGuiWindowFlags FlagsPreviousFrame => ref Unsafe.AsRef<ImGuiWindowFlags>(&Handle->FlagsPreviousFrame);
		/// <summary>
		/// Advanced users only. Set with SetNextWindowClass()<br/>
		/// </summary>
		public ref ImGuiWindowClass WindowClass => ref Unsafe.AsRef<ImGuiWindowClass>(&Handle->WindowClass);
		/// <summary>
		/// Always set in Begin(). Inactive windows may have a NULL value here if their viewport was discarded.<br/>
		/// </summary>
		public ref ImGuiViewportPPtr Viewport => ref Unsafe.AsRef<ImGuiViewportPPtr>(&Handle->Viewport);
		/// <summary>
		/// We backup the viewport id (since the viewport may disappear or never be created if the window is inactive)<br/>
		/// </summary>
		public ref int ViewportId => ref Unsafe.AsRef<int>(&Handle->ViewportId);
		/// <summary>
		/// We backup the viewport position (since the viewport may disappear or never be created if the window is inactive)<br/>
		/// </summary>
		public ref Vector2 ViewportPos => ref Unsafe.AsRef<Vector2>(&Handle->ViewportPos);
		/// <summary>
		/// Reset to -1 every frame (index is guaranteed to be valid between NewFrame..EndFrame), only used in the Appearing frame of a tooltippopup to enforce clamping to a given monitor<br/>
		/// </summary>
		public ref int ViewportAllowPlatformMonitorExtend => ref Unsafe.AsRef<int>(&Handle->ViewportAllowPlatformMonitorExtend);
		/// <summary>
		/// Position (always rounded-up to nearest pixel)<br/>
		/// </summary>
		public ref Vector2 Pos => ref Unsafe.AsRef<Vector2>(&Handle->Pos);
		/// <summary>
		/// Current size (==SizeFull or collapsed title bar size)<br/>
		/// </summary>
		public ref Vector2 Size => ref Unsafe.AsRef<Vector2>(&Handle->Size);
		/// <summary>
		/// Size when non collapsed<br/>
		/// </summary>
		public ref Vector2 SizeFull => ref Unsafe.AsRef<Vector2>(&Handle->SizeFull);
		/// <summary>
		/// Size of contentsscrollable client area (calculated from the extents reach of the cursor) from previous frame. Does not include window decoration or window padding.<br/>
		/// </summary>
		public ref Vector2 ContentSize => ref Unsafe.AsRef<Vector2>(&Handle->ContentSize);
		public ref Vector2 ContentSizeIdeal => ref Unsafe.AsRef<Vector2>(&Handle->ContentSizeIdeal);
		/// <summary>
		/// Size of contentsscrollable client area explicitly request by the user via SetNextWindowContentSize().<br/>
		/// </summary>
		public ref Vector2 ContentSizeExplicit => ref Unsafe.AsRef<Vector2>(&Handle->ContentSizeExplicit);
		/// <summary>
		/// Window padding at the time of Begin().<br/>
		/// </summary>
		public ref Vector2 WindowPadding => ref Unsafe.AsRef<Vector2>(&Handle->WindowPadding);
		/// <summary>
		/// Window rounding at the time of Begin(). May be clamped lower to avoid rendering artifacts with title bar, menu bar etc.<br/>
		/// </summary>
		public ref float WindowRounding => ref Unsafe.AsRef<float>(&Handle->WindowRounding);
		/// <summary>
		/// Window border size at the time of Begin().<br/>
		/// </summary>
		public ref float WindowBorderSize => ref Unsafe.AsRef<float>(&Handle->WindowBorderSize);
		/// <summary>
		/// LeftUp offsets. Sum of non-scrolling outer decorations (X1 generally == 0.0f. Y1 generally = TitleBarHeight + MenuBarHeight). Locked during Begin().<br/>
		/// </summary>
		public ref float DecoOuterSizeX1 => ref Unsafe.AsRef<float>(&Handle->DecoOuterSizeX1);
		/// <summary>
		/// LeftUp offsets. Sum of non-scrolling outer decorations (X1 generally == 0.0f. Y1 generally = TitleBarHeight + MenuBarHeight). Locked during Begin().<br/>
		/// </summary>
		public ref float DecoOuterSizeY1 => ref Unsafe.AsRef<float>(&Handle->DecoOuterSizeY1);
		/// <summary>
		/// RightDown offsets (X2 generally == ScrollbarSize.x, Y2 == ScrollbarSizes.y).<br/>
		/// </summary>
		public ref float DecoOuterSizeX2 => ref Unsafe.AsRef<float>(&Handle->DecoOuterSizeX2);
		/// <summary>
		/// RightDown offsets (X2 generally == ScrollbarSize.x, Y2 == ScrollbarSizes.y).<br/>
		/// </summary>
		public ref float DecoOuterSizeY2 => ref Unsafe.AsRef<float>(&Handle->DecoOuterSizeY2);
		/// <summary>
		/// Applied AFTEROVER InnerRect. Specialized for Tables as they use specialized form of clipping and frozen rowscolumns are inside InnerRect (and not part of regular decoration sizes).<br/>
		/// </summary>
		public ref float DecoInnerSizeX1 => ref Unsafe.AsRef<float>(&Handle->DecoInnerSizeX1);
		/// <summary>
		/// Applied AFTEROVER InnerRect. Specialized for Tables as they use specialized form of clipping and frozen rowscolumns are inside InnerRect (and not part of regular decoration sizes).<br/>
		/// </summary>
		public ref float DecoInnerSizeY1 => ref Unsafe.AsRef<float>(&Handle->DecoInnerSizeY1);
		/// <summary>
		/// Size of buffer storing Name. May be larger than strlen(Name)!<br/>
		/// </summary>
		public ref int NameBufLen => ref Unsafe.AsRef<int>(&Handle->NameBufLen);
		/// <summary>
		/// == window-&gt;GetID("#MOVE")<br/>
		/// </summary>
		public ref int MoveId => ref Unsafe.AsRef<int>(&Handle->MoveId);
		/// <summary>
		/// == window-&gt;GetID("#TAB")<br/>
		/// </summary>
		public ref int TabId => ref Unsafe.AsRef<int>(&Handle->TabId);
		/// <summary>
		/// ID of corresponding item in parent window (for navigation to return from child window to parent window)<br/>
		/// </summary>
		public ref int ChildId => ref Unsafe.AsRef<int>(&Handle->ChildId);
		public ref Vector2 Scroll => ref Unsafe.AsRef<Vector2>(&Handle->Scroll);
		public ref Vector2 ScrollMax => ref Unsafe.AsRef<Vector2>(&Handle->ScrollMax);
		/// <summary>
		/// target scroll position. stored as cursor position with scrolling canceled out, so the highest point is always 0.0f. (FLT_MAX for no change)<br/>
		/// </summary>
		public ref Vector2 ScrollTarget => ref Unsafe.AsRef<Vector2>(&Handle->ScrollTarget);
		/// <summary>
		/// 0.0f = scroll so that target position is at top, 0.5f = scroll so that target position is centered<br/>
		/// </summary>
		public ref Vector2 ScrollTargetCenterRatio => ref Unsafe.AsRef<Vector2>(&Handle->ScrollTargetCenterRatio);
		/// <summary>
		/// 0.0f = no snapping, &gt;0.0f snapping threshold<br/>
		/// </summary>
		public ref Vector2 ScrollTargetEdgeSnapDist => ref Unsafe.AsRef<Vector2>(&Handle->ScrollTargetEdgeSnapDist);
		/// <summary>
		/// Size taken by each scrollbars on their smaller axis. Pay attention! ScrollbarSizes.x == width of the vertical scrollbar, ScrollbarSizes.y = height of the horizontal scrollbar.<br/>
		/// </summary>
		public ref Vector2 ScrollbarSizes => ref Unsafe.AsRef<Vector2>(&Handle->ScrollbarSizes);
		/// <summary>
		/// Are scrollbars visible?<br/>
		/// </summary>
		public ref bool ScrollbarX => ref Unsafe.AsRef<bool>(&Handle->ScrollbarX);
		/// <summary>
		/// Are scrollbars visible?<br/>
		/// </summary>
		public ref bool ScrollbarY => ref Unsafe.AsRef<bool>(&Handle->ScrollbarY);
		public ref bool ViewportOwned => ref Unsafe.AsRef<bool>(&Handle->ViewportOwned);
		/// <summary>
		/// Set to true on Begin(), unless Collapsed<br/>
		/// </summary>
		public ref bool Active => ref Unsafe.AsRef<bool>(&Handle->Active);
		public ref bool WasActive => ref Unsafe.AsRef<bool>(&Handle->WasActive);
		/// <summary>
		/// Set to true when any widget access the current window<br/>
		/// </summary>
		public ref bool WriteAccessed => ref Unsafe.AsRef<bool>(&Handle->WriteAccessed);
		/// <summary>
		/// Set when collapsing window to become only title-bar<br/>
		/// </summary>
		public ref bool Collapsed => ref Unsafe.AsRef<bool>(&Handle->Collapsed);
		public ref bool WantCollapseToggle => ref Unsafe.AsRef<bool>(&Handle->WantCollapseToggle);
		/// <summary>
		/// Set when items can safely be all clipped (e.g. window not visible or collapsed)<br/>
		/// </summary>
		public ref bool SkipItems => ref Unsafe.AsRef<bool>(&Handle->SkipItems);
		/// <summary>
		/// Set during the frame where the window is appearing (or re-appearing)<br/>
		/// </summary>
		public ref bool Appearing => ref Unsafe.AsRef<bool>(&Handle->Appearing);
		/// <summary>
		/// Do not display (== HiddenFrames*** &gt; 0)<br/>
		/// </summary>
		public ref bool Hidden => ref Unsafe.AsRef<bool>(&Handle->Hidden);
		/// <summary>
		/// Set on the "Debug##Default" window.<br/>
		/// </summary>
		public ref bool IsFallbackWindow => ref Unsafe.AsRef<bool>(&Handle->IsFallbackWindow);
		/// <summary>
		/// Set when passed _ChildWindow, left to false by BeginDocked()<br/>
		/// </summary>
		public ref bool IsExplicitChild => ref Unsafe.AsRef<bool>(&Handle->IsExplicitChild);
		/// <summary>
		/// Set when the window has a close button (p_open != NULL)<br/>
		/// </summary>
		public ref bool HasCloseButton => ref Unsafe.AsRef<bool>(&Handle->HasCloseButton);
		/// <summary>
		/// Current border being held for resize (-1: none, otherwise 0-3)<br/>
		/// </summary>
		public ref byte ResizeBorderHeld => ref Unsafe.AsRef<byte>(&Handle->ResizeBorderHeld);
		/// <summary>
		/// Number of Begin() during the current frame (generally 0 or 1, 1+ if appending via multiple BeginEnd pairs)<br/>
		/// </summary>
		public ref short BeginCount => ref Unsafe.AsRef<short>(&Handle->BeginCount);
		/// <summary>
		/// Number of Begin() during the previous frame<br/>
		/// </summary>
		public ref short BeginCountPreviousFrame => ref Unsafe.AsRef<short>(&Handle->BeginCountPreviousFrame);
		/// <summary>
		/// Begin() order within immediate parent window, if we are a child window. Otherwise 0.<br/>
		/// </summary>
		public ref short BeginOrderWithinParent => ref Unsafe.AsRef<short>(&Handle->BeginOrderWithinParent);
		/// <summary>
		/// Begin() order within entire imgui context. This is mostly used for debugging submission order related issues.<br/>
		/// </summary>
		public ref short BeginOrderWithinContext => ref Unsafe.AsRef<short>(&Handle->BeginOrderWithinContext);
		/// <summary>
		/// Order within WindowsFocusOrder[], altered when windows are focused.<br/>
		/// </summary>
		public ref short FocusOrder => ref Unsafe.AsRef<short>(&Handle->FocusOrder);
		/// <summary>
		/// ID in the popup stack when this window is used as a popupmenu (because we use generic NameID for recycling)<br/>
		/// </summary>
		public ref int PopupId => ref Unsafe.AsRef<int>(&Handle->PopupId);
		public ref sbyte AutoFitFramesX => ref Unsafe.AsRef<sbyte>(&Handle->AutoFitFramesX);
		public ref sbyte AutoFitFramesY => ref Unsafe.AsRef<sbyte>(&Handle->AutoFitFramesY);
		public ref sbyte AutoFitChildAxises => ref Unsafe.AsRef<sbyte>(&Handle->AutoFitChildAxises);
		public ref bool AutoFitOnlyGrows => ref Unsafe.AsRef<bool>(&Handle->AutoFitOnlyGrows);
		public ref ImGuiDir AutoPosLastDirection => ref Unsafe.AsRef<ImGuiDir>(&Handle->AutoPosLastDirection);
		/// <summary>
		/// Hide the window for N frames<br/>
		/// </summary>
		public ref sbyte HiddenFramesCanSkipItems => ref Unsafe.AsRef<sbyte>(&Handle->HiddenFramesCanSkipItems);
		/// <summary>
		/// Hide the window for N frames while allowing items to be submitted so we can measure their size<br/>
		/// </summary>
		public ref sbyte HiddenFramesCannotSkipItems => ref Unsafe.AsRef<sbyte>(&Handle->HiddenFramesCannotSkipItems);
		/// <summary>
		/// Hide the window until frame N at Render() time only<br/>
		/// </summary>
		public ref sbyte HiddenFramesForRenderOnly => ref Unsafe.AsRef<sbyte>(&Handle->HiddenFramesForRenderOnly);
		/// <summary>
		/// Disable window interactions for N frames<br/>
		/// </summary>
		public ref sbyte DisableInputsFrames => ref Unsafe.AsRef<sbyte>(&Handle->DisableInputsFrames);
		/// <summary>
		/// store acceptable condition flags for SetNextWindowPos() use.<br/>
		/// </summary>
		public ref ImGuiCond SetWindowPosAllowFlags => ref Unsafe.AsRef<ImGuiCond>(&Handle->SetWindowPosAllowFlags);
		/// <summary>
		/// store acceptable condition flags for SetNextWindowSize() use.<br/>
		/// </summary>
		public ref ImGuiCond SetWindowSizeAllowFlags => ref Unsafe.AsRef<ImGuiCond>(&Handle->SetWindowSizeAllowFlags);
		/// <summary>
		/// store acceptable condition flags for SetNextWindowCollapsed() use.<br/>
		/// </summary>
		public ref ImGuiCond SetWindowCollapsedAllowFlags => ref Unsafe.AsRef<ImGuiCond>(&Handle->SetWindowCollapsedAllowFlags);
		/// <summary>
		/// store acceptable condition flags for SetNextWindowDock() use.<br/>
		/// </summary>
		public ref ImGuiCond SetWindowDockAllowFlags => ref Unsafe.AsRef<ImGuiCond>(&Handle->SetWindowDockAllowFlags);
		/// <summary>
		/// store window position when using a non-zero Pivot (position set needs to be processed when we know the window size)<br/>
		/// </summary>
		public ref Vector2 SetWindowPosVal => ref Unsafe.AsRef<Vector2>(&Handle->SetWindowPosVal);
		/// <summary>
		/// store window pivot for positioning. ImVec2(0, 0) when positioning from top-left corner; ImVec2(0.5f, 0.5f) for centering; ImVec2(1, 1) for bottom right.<br/>
		/// </summary>
		public ref Vector2 SetWindowPosPivot => ref Unsafe.AsRef<Vector2>(&Handle->SetWindowPosPivot);
		/// <summary>
		/// ID stack. ID are hashes seeded with the value at the top of the stack. (In theory this should be in the TempData structure)<br/>
		/// </summary>
		public ref ImVectorImGuiID IDStack => ref Unsafe.AsRef<ImVectorImGuiID>(&Handle->IDStack);
		/// <summary>
		/// Temporary per-window data, reset at the beginning of the frame. This used to be called ImGuiDrawContext, hence the "DC" variable name.<br/>
		/// </summary>
		public ref ImGuiWindowTempData DC => ref Unsafe.AsRef<ImGuiWindowTempData>(&Handle->DC);
		/// <summary>
		/// The best way to understand what those rectangles are is to use the 'Metrics-&gt;Tools-&gt;Show Windows Rectangles' viewer.<br/>
		/// The main 'OuterRect', omitted as a field, is window-&gt;Rect(). == Window-&gt;Rect() just after setup in Begin(). == window-&gt;Rect() for root window.<br/>
		/// </summary>
		public ref ImRect OuterRectClipped => ref Unsafe.AsRef<ImRect>(&Handle->OuterRectClipped);
		/// <summary>
		/// Inner rectangle (omit title bar, menu bar, scroll bar)<br/>
		/// </summary>
		public ref ImRect InnerRect => ref Unsafe.AsRef<ImRect>(&Handle->InnerRect);
		/// <summary>
		/// == InnerRect shrunk by WindowPadding*0.5f on each side, clipped within viewport or parent clip rect.<br/>
		/// </summary>
		public ref ImRect InnerClipRect => ref Unsafe.AsRef<ImRect>(&Handle->InnerClipRect);
		/// <summary>
		/// Initially covers the whole scrolling region. Reduced by containers e.g columnstables when active. Shrunk by WindowPadding*1.0f on each side. This is meant to replace ContentRegionRect over time (from 1.71+ onward).<br/>
		/// </summary>
		public ref ImRect WorkRect => ref Unsafe.AsRef<ImRect>(&Handle->WorkRect);
		/// <summary>
		/// Backup of WorkRect before entering a container such as columnstables. Used by e.g. SpanAllColumns functions to easily access. Stacked containers are responsible for maintaining this.  FIXME-WORKRECT: Could be a stack?<br/>
		/// </summary>
		public ref ImRect ParentWorkRect => ref Unsafe.AsRef<ImRect>(&Handle->ParentWorkRect);
		/// <summary>
		/// Current clippingscissoring rectangle, evolve as we are using PushClipRect(), etc. == DrawList-&gt;clip_rect_stack.back().<br/>
		/// </summary>
		public ref ImRect ClipRect => ref Unsafe.AsRef<ImRect>(&Handle->ClipRect);
		/// <summary>
		/// FIXME: This is currently confusingmisleading. It is essentially WorkRect but not handling of scrolling. We currently rely on it as rightbottom aligned sizing operation need some size to rely on.<br/>
		/// </summary>
		public ref ImRect ContentRegionRect => ref Unsafe.AsRef<ImRect>(&Handle->ContentRegionRect);
		/// <summary>
		/// Define an optional rectangular hole where mouse will pass-through the window.<br/>
		/// </summary>
		public ref ImVec2Ih HitTestHoleSize => ref Unsafe.AsRef<ImVec2Ih>(&Handle->HitTestHoleSize);
		public ref ImVec2Ih HitTestHoleOffset => ref Unsafe.AsRef<ImVec2Ih>(&Handle->HitTestHoleOffset);
		/// <summary>
		/// Last frame number the window was Active.<br/>
		/// </summary>
		public ref int LastFrameActive => ref Unsafe.AsRef<int>(&Handle->LastFrameActive);
		/// <summary>
		/// Last frame number the window was made Focused.<br/>
		/// </summary>
		public ref int LastFrameJustFocused => ref Unsafe.AsRef<int>(&Handle->LastFrameJustFocused);
		/// <summary>
		/// Last timestamp the window was Active (using float as we don't need high precision there)<br/>
		/// </summary>
		public ref float LastTimeActive => ref Unsafe.AsRef<float>(&Handle->LastTimeActive);
		public ref float ItemWidthDefault => ref Unsafe.AsRef<float>(&Handle->ItemWidthDefault);
		public ref ImGuiStorage StateStorage => ref Unsafe.AsRef<ImGuiStorage>(&Handle->StateStorage);
		public ref ImVectorImGuiOldColumns ColumnsStorage => ref Unsafe.AsRef<ImVectorImGuiOldColumns>(&Handle->ColumnsStorage);
		/// <summary>
		/// User scale multiplier per-window, via SetWindowFontScale()<br/>
		/// </summary>
		public ref float FontWindowScale => ref Unsafe.AsRef<float>(&Handle->FontWindowScale);
		public ref float FontDpiScale => ref Unsafe.AsRef<float>(&Handle->FontDpiScale);
		/// <summary>
		/// Offset into SettingsWindows[] (offsets are always valid as we only grow the array from the back)<br/>
		/// </summary>
		public ref int SettingsOffset => ref Unsafe.AsRef<int>(&Handle->SettingsOffset);
		/// <summary>
		/// == &amp;DrawListInst (for backward compatibility reason with code using imgui_internal.h we keep this a pointer)<br/>
		/// </summary>
		public ref ImDrawListPtr DrawList => ref Unsafe.AsRef<ImDrawListPtr>(&Handle->DrawList);
		public ref ImDrawList DrawListInst => ref Unsafe.AsRef<ImDrawList>(&Handle->DrawListInst);
		/// <summary>
		/// If we are a child _or_ popup _or_ docked window, this is pointing to our parent. Otherwise NULL.<br/>
		/// </summary>
		public ref ImGuiWindowPtr ParentWindow => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->ParentWindow);
		public ref ImGuiWindowPtr ParentWindowInBeginStack => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->ParentWindowInBeginStack);
		/// <summary>
		/// Point to ourself or first ancestor that is not a child window. Doesn't cross through popupsdock nodes.<br/>
		/// </summary>
		public ref ImGuiWindowPtr RootWindow => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->RootWindow);
		/// <summary>
		/// Point to ourself or first ancestor that is not a child window. Cross through popups parent&lt;&gt;child.<br/>
		/// </summary>
		public ref ImGuiWindowPtr RootWindowPopupTree => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->RootWindowPopupTree);
		/// <summary>
		/// Point to ourself or first ancestor that is not a child window. Cross through dock nodes.<br/>
		/// </summary>
		public ref ImGuiWindowPtr RootWindowDockTree => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->RootWindowDockTree);
		/// <summary>
		/// Point to ourself or first ancestor which will display TitleBgActive color when this window is active.<br/>
		/// </summary>
		public ref ImGuiWindowPtr RootWindowForTitleBarHighlight => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->RootWindowForTitleBarHighlight);
		/// <summary>
		/// Point to ourself or first ancestor which doesn't have the NavFlattened flag.<br/>
		/// </summary>
		public ref ImGuiWindowPtr RootWindowForNav => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->RootWindowForNav);
		/// <summary>
		/// When going to the menu bar, we remember the child window we came from. (This could probably be made implicit if we kept g.Windows sorted by last focused including child window.)<br/>
		/// </summary>
		public ref ImGuiWindowPtr NavLastChildNavWindow => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->NavLastChildNavWindow);
		/// <summary>
		/// Last known NavId for this window, per layer (01)<br/>
		/// </summary>
		public unsafe Span<uint> NavLastIds
		
		{
			get
			{
				return new Span<uint>(&Handle->NavLastIds_0, 2);
			}
		}
		/// <summary>
		/// Reference rectangle, in window relative space<br/>
		/// </summary>
		public unsafe Span<ImRect> NavRectRel
		
		{
			get
			{
				return new Span<ImRect>(&Handle->NavRectRel_0, 2);
			}
		}
		/// <summary>
		/// Preferred XY position updated when moving on a given axis, reset to FLT_MAX.<br/>
		/// </summary>
		public unsafe Span<Vector2> NavPreferredScoringPosRel
		
		{
			get
			{
				return new Span<Vector2>(&Handle->NavPreferredScoringPosRel_0, 2);
			}
		}
		/// <summary>
		/// Focus Scope ID at the time of Begin()<br/>
		/// </summary>
		public ref int NavRootFocusScopeId => ref Unsafe.AsRef<int>(&Handle->NavRootFocusScopeId);
		/// <summary>
		/// Backup of last idxvtx count, so when waking up the window we can preallocate and avoid iterative alloccopy<br/>
		/// </summary>
		public ref int MemoryDrawListIdxCapacity => ref Unsafe.AsRef<int>(&Handle->MemoryDrawListIdxCapacity);
		public ref int MemoryDrawListVtxCapacity => ref Unsafe.AsRef<int>(&Handle->MemoryDrawListVtxCapacity);
		/// <summary>
		/// Set when window extraneous data have been garbage collected<br/>
		/// </summary>
		public ref bool MemoryCompacted => ref Unsafe.AsRef<bool>(&Handle->MemoryCompacted);
		/// <summary>
		/// Docking When docking artifacts are actually visible. When this is set, DockNode is guaranteed to be != NULL. ~~ (DockNode != NULL) &amp;&amp; (DockNode-&gt;Windows.Size &gt; 1).<br/>
		/// </summary>
		public ref bool DockIsActive => ref Unsafe.AsRef<bool>(&Handle->DockIsActive);
		public ref bool DockNodeIsVisible => ref Unsafe.AsRef<bool>(&Handle->DockNodeIsVisible);
		/// <summary>
		/// Is our window visible this frame? ~~ is the corresponding tab selected?<br/>
		/// </summary>
		public ref bool DockTabIsVisible => ref Unsafe.AsRef<bool>(&Handle->DockTabIsVisible);
		public ref bool DockTabWantClose => ref Unsafe.AsRef<bool>(&Handle->DockTabWantClose);
		/// <summary>
		/// Order of the last time the window was visible within its DockNode. This is used to reorder windows that are reappearing on the same frame. Same value between windows that were active and windows that were none are possible.<br/>
		/// </summary>
		public ref short DockOrder => ref Unsafe.AsRef<short>(&Handle->DockOrder);
		public ref ImGuiWindowDockStyle DockStyle => ref Unsafe.AsRef<ImGuiWindowDockStyle>(&Handle->DockStyle);
		/// <summary>
		/// Which node are we docked into. Important: Prefer testing DockIsActive in many cases as this will still be set when the dock node is hidden.<br/>
		/// </summary>
		public ref ImGuiDockNodePtr DockNode => ref Unsafe.AsRef<ImGuiDockNodePtr>(&Handle->DockNode);
		/// <summary>
		/// Which node are we owning (for parent windows)<br/>
		/// </summary>
		public ref ImGuiDockNodePtr DockNodeAsHost => ref Unsafe.AsRef<ImGuiDockNodePtr>(&Handle->DockNodeAsHost);
		/// <summary>
		/// Backup of last valid DockNode-&gt;ID, so single window remember their dock node id even when they are not bound any more<br/>
		/// </summary>
		public ref int DockId => ref Unsafe.AsRef<int>(&Handle->DockId);
		public ref ImGuiItemStatusFlags DockTabItemStatusFlags => ref Unsafe.AsRef<ImGuiItemStatusFlags>(&Handle->DockTabItemStatusFlags);
		public ref ImRect DockTabItemRect => ref Unsafe.AsRef<ImRect>(&Handle->DockTabItemRect);

		public unsafe float CalcFontSize()
		{
			float ret = ImGui.CalcFontSizeNative(Handle);
			return ret;
		}

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

		public unsafe int GetID(byte* str, byte* strEnd)
		{
			int ret = ImGui.GetIDNative(Handle, str, strEnd);
			return ret;
		}

		public unsafe int GetID(byte* str)
		{
			int ret = ImGui.GetIDNative(Handle, str, (byte*)(default));
			return ret;
		}

		public unsafe int GetID(ref byte str, byte* strEnd)
		{
			fixed (byte* pstr = &str)
			{
				int ret = ImGui.GetIDNative(Handle, (byte*)pstr, strEnd);
				return ret;
			}
		}

		public unsafe int GetID(ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				int ret = ImGui.GetIDNative(Handle, (byte*)pstr, (byte*)(default));
				return ret;
			}
		}

		public unsafe int GetID(string str, byte* strEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImGui.GetIDNative(Handle, pStr0, strEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public unsafe int GetID(string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImGui.GetIDNative(Handle, pStr0, (byte*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public unsafe int GetID(byte* str, ref byte strEnd)
		{
			fixed (byte* pstrEnd = &strEnd)
			{
				int ret = ImGui.GetIDNative(Handle, str, (byte*)pstrEnd);
				return ret;
			}
		}

		public unsafe int GetID(byte* str, string strEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImGui.GetIDNative(Handle, str, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public unsafe int GetID(ref byte str, ref byte strEnd)
		{
			fixed (byte* pstr = &str)
			{
				fixed (byte* pstrEnd = &strEnd)
				{
					int ret = ImGui.GetIDNative(Handle, (byte*)pstr, (byte*)pstrEnd);
					return ret;
				}
			}
		}

		public unsafe int GetID(string str, string strEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (strEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(strEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(strEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = ImGui.GetIDNative(Handle, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public unsafe int GetID(void* ptr)
		{
			int ret = ImGui.GetIDNative(Handle, ptr);
			return ret;
		}

		public unsafe int GetID(int n)
		{
			int ret = ImGui.GetIDNative(Handle, n);
			return ret;
		}

		public unsafe int GetIDFromRectangle(ImRect rAbs)
		{
			int ret = ImGui.GetIDFromRectangleNative(Handle, rAbs);
			return ret;
		}

		public unsafe float MenuBarHeight()
		{
			float ret = ImGui.MenuBarHeightNative(Handle);
			return ret;
		}

		public unsafe float TitleBarHeight()
		{
			float ret = ImGui.TitleBarHeightNative(Handle);
			return ret;
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiWindowPtrPtr : IEquatable<ImGuiWindowPtrPtr>
	{
		public ImGuiWindowPtrPtr(ImGuiWindow** handle) { Handle = handle; }

		public ImGuiWindow** Handle;

		public bool IsNull => Handle == null;

		public static ImGuiWindowPtrPtr Null => new ImGuiWindowPtrPtr(null);

		public static implicit operator ImGuiWindowPtrPtr(ImGuiWindow** handle) => new ImGuiWindowPtrPtr(handle);

		public static implicit operator ImGuiWindow**(ImGuiWindowPtrPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiWindowPtrPtr left, ImGuiWindowPtrPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiWindowPtrPtr left, ImGuiWindowPtrPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiWindowPtrPtr left, ImGuiWindow** right) => left.Handle == right;

		public static bool operator !=(ImGuiWindowPtrPtr left, ImGuiWindow** right) => left.Handle != right;

		public bool Equals(ImGuiWindowPtrPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiWindowPtrPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiWindowPtrPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ImGuiWindowPtr this[int index]
		{
			get => Handle[index]; set => Handle[index] = value;
		}
	}

	/// <summary>
	/// [ALPHA] Rarely used  very advanced uses only. Use with SetNextWindowClass() and DockSpace() functions.<br/>
	/// Important: the content of this class is still highly WIP and likely to change and be refactored<br/>
	/// before we stabilize Docking features. Please be mindful if using this.<br/>
	/// Provide hints:<br/>
	/// - To the platform backend via altered viewport flags (enabledisable OS decoration, OS task bar icons, etc.)<br/>
	/// - To the platform backend for OS level parentchild relationships of viewport.<br/>
	/// - To the docking system for various options and filtering.<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiWindowClass
	{
		/// <summary>
		/// User data. 0 = Default class (unclassed). Windows of different classes cannot be docked with each others.<br/>
		/// </summary>
		public int ClassId;

		/// <summary>
		/// Hint for the platform backend. -1: use default. 0: request platform backend to not parent the platform. != 0: request platform backend to create a parent&lt;&gt;child relationship between the platform windows. Not conforming backends are free to e.g. parent every viewport to the main viewport or not.<br/>
		/// </summary>
		public int ParentViewportId;

		/// <summary>
		/// Viewport flags to set when a window of this class owns a viewport. This allows you to enforce OS decoration or task bar icon, override the defaults on a per-window basis.<br/>
		/// </summary>
		public ImGuiViewportFlags ViewportFlagsOverrideSet;

		/// <summary>
		/// Viewport flags to clear when a window of this class owns a viewport. This allows you to enforce OS decoration or task bar icon, override the defaults on a per-window basis.<br/>
		/// </summary>
		public ImGuiViewportFlags ViewportFlagsOverrideClear;

		/// <summary>
		/// [EXPERIMENTAL] TabItem flags to set when a window of this class gets submitted into a dock node tab bar. May use with ImGuiTabItemFlags_Leading or ImGuiTabItemFlags_Trailing.<br/>
		/// </summary>
		public ImGuiTabItemFlags TabItemFlagsOverrideSet;

		/// <summary>
		/// [EXPERIMENTAL] Dock node flags to set when a window of this class is hosted by a dock node (it doesn't have to be selected!)<br/>
		/// </summary>
		public ImGuiDockNodeFlags DockNodeFlagsOverrideSet;

		/// <summary>
		/// Set to true to enforce single floating windows of this class always having their own docking node (equivalent of setting the global io.ConfigDockingAlwaysTabBar)<br/>
		/// </summary>
		public byte DockingAlwaysTabBar;

		/// <summary>
		/// Set to true to allow windows of this class to be dockedmerged with an unclassed window.  FIXME-DOCK: Move to DockNodeFlags override?<br/>
		/// </summary>
		public byte DockingAllowUnclassed;





		public unsafe void Destroy()
		{
			fixed (ImGuiWindowClass* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiWindowClassPtr : IEquatable<ImGuiWindowClassPtr>
	{
		public ImGuiWindowClassPtr(ImGuiWindowClass* handle) { Handle = handle; }

		public ImGuiWindowClass* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiWindowClassPtr Null => new ImGuiWindowClassPtr(null);

		public static implicit operator ImGuiWindowClassPtr(ImGuiWindowClass* handle) => new ImGuiWindowClassPtr(handle);

		public static implicit operator ImGuiWindowClass*(ImGuiWindowClassPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiWindowClassPtr left, ImGuiWindowClassPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiWindowClassPtr left, ImGuiWindowClassPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiWindowClassPtr left, ImGuiWindowClass* right) => left.Handle == right;

		public static bool operator !=(ImGuiWindowClassPtr left, ImGuiWindowClass* right) => left.Handle != right;

		public bool Equals(ImGuiWindowClassPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiWindowClassPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiWindowClassPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		/// <summary>
		/// User data. 0 = Default class (unclassed). Windows of different classes cannot be docked with each others.<br/>
		/// </summary>
		public ref int ClassId => ref Unsafe.AsRef<int>(&Handle->ClassId);
		/// <summary>
		/// Hint for the platform backend. -1: use default. 0: request platform backend to not parent the platform. != 0: request platform backend to create a parent&lt;&gt;child relationship between the platform windows. Not conforming backends are free to e.g. parent every viewport to the main viewport or not.<br/>
		/// </summary>
		public ref int ParentViewportId => ref Unsafe.AsRef<int>(&Handle->ParentViewportId);
		/// <summary>
		/// Viewport flags to set when a window of this class owns a viewport. This allows you to enforce OS decoration or task bar icon, override the defaults on a per-window basis.<br/>
		/// </summary>
		public ref ImGuiViewportFlags ViewportFlagsOverrideSet => ref Unsafe.AsRef<ImGuiViewportFlags>(&Handle->ViewportFlagsOverrideSet);
		/// <summary>
		/// Viewport flags to clear when a window of this class owns a viewport. This allows you to enforce OS decoration or task bar icon, override the defaults on a per-window basis.<br/>
		/// </summary>
		public ref ImGuiViewportFlags ViewportFlagsOverrideClear => ref Unsafe.AsRef<ImGuiViewportFlags>(&Handle->ViewportFlagsOverrideClear);
		/// <summary>
		/// [EXPERIMENTAL] TabItem flags to set when a window of this class gets submitted into a dock node tab bar. May use with ImGuiTabItemFlags_Leading or ImGuiTabItemFlags_Trailing.<br/>
		/// </summary>
		public ref ImGuiTabItemFlags TabItemFlagsOverrideSet => ref Unsafe.AsRef<ImGuiTabItemFlags>(&Handle->TabItemFlagsOverrideSet);
		/// <summary>
		/// [EXPERIMENTAL] Dock node flags to set when a window of this class is hosted by a dock node (it doesn't have to be selected!)<br/>
		/// </summary>
		public ref ImGuiDockNodeFlags DockNodeFlagsOverrideSet => ref Unsafe.AsRef<ImGuiDockNodeFlags>(&Handle->DockNodeFlagsOverrideSet);
		/// <summary>
		/// Set to true to enforce single floating windows of this class always having their own docking node (equivalent of setting the global io.ConfigDockingAlwaysTabBar)<br/>
		/// </summary>
		public ref bool DockingAlwaysTabBar => ref Unsafe.AsRef<bool>(&Handle->DockingAlwaysTabBar);
		/// <summary>
		/// Set to true to allow windows of this class to be dockedmerged with an unclassed window.  FIXME-DOCK: Move to DockNodeFlags override?<br/>
		/// </summary>
		public ref bool DockingAllowUnclassed => ref Unsafe.AsRef<bool>(&Handle->DockingAllowUnclassed);

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

	}

	/// <summary>
	/// ImGuiViewport PrivateInternals fields (cardinal sin: we are using inheritance!)<br/>
	/// Every instance of ImGuiViewport is in fact a ImGuiViewportP.<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiViewportP
	{
		public ImGuiViewport ImGuiViewport;
		/// <summary>
		/// Set when the viewport is owned by a window (and ImGuiViewportFlags_CanHostOtherWindows is NOT set)<br/>
		/// </summary>
		public unsafe ImGuiWindow* Window;

		public int Idx;
		/// <summary>
		/// Last frame number this viewport was activated by a window<br/>
		/// </summary>
		public int LastFrameActive;

		/// <summary>
		/// Last stamp number from when a window hosted by this viewport was focused (by comparing this value between two viewport we have an implicit viewport z-order we use as fallback)<br/>
		/// </summary>
		public int LastFocusedStampCount;

		public int LastNameHash;
		public Vector2 LastPos;
		/// <summary>
		/// Window opacity (when dragging dockable windowsviewports we make them transparent)<br/>
		/// </summary>
		public float Alpha;

		public float LastAlpha;
		/// <summary>
		/// Instead of maintaining a LastFocusedWindow (which may harder to correctly maintain), we merely store weither NavWindow != NULL last time the viewport was focused.<br/>
		/// </summary>
		public byte LastFocusedHadNavWindow;

		public short PlatformMonitor;
		/// <summary>
		/// Last frame number the background (0) and foreground (1) draw lists were used<br/>
		/// </summary>
		public int DrawListsLastFrame_0;
		public int DrawListsLastFrame_1;

		/// <summary>
		/// Convenience background (0) and foreground (1) draw lists. We use them to draw software mouser cursor when io.MouseDrawCursor is set and to draw most debug overlays.<br/>
		/// </summary>
		public unsafe ImDrawList* DrawLists_0;
		public unsafe ImDrawList* DrawLists_1;

		public ImDrawData DrawDataP;
		public ImDrawDataBuilder DrawDataBuilder;
		public Vector2 LastPlatformPos;
		public Vector2 LastPlatformSize;
		public Vector2 LastRendererSize;
		/// <summary>
		/// Work Area: Offset from Pos to top-left corner of Work Area. Generally (0,0) or (0,+main_menu_bar_height). Work Area is Full Area but without menu-barsstatus-bars (so WorkArea always fit inside PosSize!)<br/>
		/// </summary>
		public Vector2 WorkOffsetMin;

		/// <summary>
		/// Work Area: Offset from Pos+Size to bottom-right corner of Work Area. Generally (0,0) or (0,-status_bar_height).<br/>
		/// </summary>
		public Vector2 WorkOffsetMax;

		/// <summary>
		/// Work Area: Offset being built during current frame. Generally &gt;= 0.0f.<br/>
		/// </summary>
		public Vector2 BuildWorkOffsetMin;

		/// <summary>
		/// Work Area: Offset being built during current frame. Generally &lt;= 0.0f.<br/>
		/// </summary>
		public Vector2 BuildWorkOffsetMax;





		public unsafe void ClearRequestFlags()
		{
			fixed (ImGuiViewportP* @this = &this)
			{
				ImGui.ClearRequestFlagsNative(@this);
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImGuiViewportP* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		/// <summary>		/// Update public fields		/// </summary>		public unsafe void UpdateWorkRect()
		{
			fixed (ImGuiViewportP* @this = &this)
			{
				ImGui.UpdateWorkRectNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiViewportPPtr : IEquatable<ImGuiViewportPPtr>
	{
		public ImGuiViewportPPtr(ImGuiViewportP* handle) { Handle = handle; }

		public ImGuiViewportP* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiViewportPPtr Null => new ImGuiViewportPPtr(null);

		public static implicit operator ImGuiViewportPPtr(ImGuiViewportP* handle) => new ImGuiViewportPPtr(handle);

		public static implicit operator ImGuiViewportP*(ImGuiViewportPPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiViewportPPtr left, ImGuiViewportPPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiViewportPPtr left, ImGuiViewportPPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiViewportPPtr left, ImGuiViewportP* right) => left.Handle == right;

		public static bool operator !=(ImGuiViewportPPtr left, ImGuiViewportP* right) => left.Handle != right;

		public bool Equals(ImGuiViewportPPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiViewportPPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiViewportPPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref ImGuiViewport ImGuiViewport => ref Unsafe.AsRef<ImGuiViewport>(&Handle->ImGuiViewport);
		/// <summary>
		/// Set when the viewport is owned by a window (and ImGuiViewportFlags_CanHostOtherWindows is NOT set)<br/>
		/// </summary>
		public ref ImGuiWindowPtr Window => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->Window);
		public ref int Idx => ref Unsafe.AsRef<int>(&Handle->Idx);
		/// <summary>
		/// Last frame number this viewport was activated by a window<br/>
		/// </summary>
		public ref int LastFrameActive => ref Unsafe.AsRef<int>(&Handle->LastFrameActive);
		/// <summary>
		/// Last stamp number from when a window hosted by this viewport was focused (by comparing this value between two viewport we have an implicit viewport z-order we use as fallback)<br/>
		/// </summary>
		public ref int LastFocusedStampCount => ref Unsafe.AsRef<int>(&Handle->LastFocusedStampCount);
		public ref int LastNameHash => ref Unsafe.AsRef<int>(&Handle->LastNameHash);
		public ref Vector2 LastPos => ref Unsafe.AsRef<Vector2>(&Handle->LastPos);
		/// <summary>
		/// Window opacity (when dragging dockable windowsviewports we make them transparent)<br/>
		/// </summary>
		public ref float Alpha => ref Unsafe.AsRef<float>(&Handle->Alpha);
		public ref float LastAlpha => ref Unsafe.AsRef<float>(&Handle->LastAlpha);
		/// <summary>
		/// Instead of maintaining a LastFocusedWindow (which may harder to correctly maintain), we merely store weither NavWindow != NULL last time the viewport was focused.<br/>
		/// </summary>
		public ref bool LastFocusedHadNavWindow => ref Unsafe.AsRef<bool>(&Handle->LastFocusedHadNavWindow);
		public ref short PlatformMonitor => ref Unsafe.AsRef<short>(&Handle->PlatformMonitor);
		/// <summary>
		/// Last frame number the background (0) and foreground (1) draw lists were used<br/>
		/// </summary>
		public unsafe Span<int> DrawListsLastFrame
		
		{
			get
			{
				return new Span<int>(&Handle->DrawListsLastFrame_0, 2);
			}
		}
		/// <summary>
		/// Convenience background (0) and foreground (1) draw lists. We use them to draw software mouser cursor when io.MouseDrawCursor is set and to draw most debug overlays.<br/>
		/// </summary>
		public ref ImDrawData DrawDataP => ref Unsafe.AsRef<ImDrawData>(&Handle->DrawDataP);
		public ref ImDrawDataBuilder DrawDataBuilder => ref Unsafe.AsRef<ImDrawDataBuilder>(&Handle->DrawDataBuilder);
		public ref Vector2 LastPlatformPos => ref Unsafe.AsRef<Vector2>(&Handle->LastPlatformPos);
		public ref Vector2 LastPlatformSize => ref Unsafe.AsRef<Vector2>(&Handle->LastPlatformSize);
		public ref Vector2 LastRendererSize => ref Unsafe.AsRef<Vector2>(&Handle->LastRendererSize);
		/// <summary>
		/// Work Area: Offset from Pos to top-left corner of Work Area. Generally (0,0) or (0,+main_menu_bar_height). Work Area is Full Area but without menu-barsstatus-bars (so WorkArea always fit inside PosSize!)<br/>
		/// </summary>
		public ref Vector2 WorkOffsetMin => ref Unsafe.AsRef<Vector2>(&Handle->WorkOffsetMin);
		/// <summary>
		/// Work Area: Offset from Pos+Size to bottom-right corner of Work Area. Generally (0,0) or (0,-status_bar_height).<br/>
		/// </summary>
		public ref Vector2 WorkOffsetMax => ref Unsafe.AsRef<Vector2>(&Handle->WorkOffsetMax);
		/// <summary>
		/// Work Area: Offset being built during current frame. Generally &gt;= 0.0f.<br/>
		/// </summary>
		public ref Vector2 BuildWorkOffsetMin => ref Unsafe.AsRef<Vector2>(&Handle->BuildWorkOffsetMin);
		/// <summary>
		/// Work Area: Offset being built during current frame. Generally &lt;= 0.0f.<br/>
		/// </summary>
		public ref Vector2 BuildWorkOffsetMax => ref Unsafe.AsRef<Vector2>(&Handle->BuildWorkOffsetMax);

		public unsafe void ClearRequestFlags()
		{
			ImGui.ClearRequestFlagsNative(Handle);
		}

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

		/// <summary>		/// Update public fields		/// </summary>		public unsafe void UpdateWorkRect()
		{
			ImGui.UpdateWorkRectNative(Handle);
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiViewportPPtrPtr : IEquatable<ImGuiViewportPPtrPtr>
	{
		public ImGuiViewportPPtrPtr(ImGuiViewportP** handle) { Handle = handle; }

		public ImGuiViewportP** Handle;

		public bool IsNull => Handle == null;

		public static ImGuiViewportPPtrPtr Null => new ImGuiViewportPPtrPtr(null);

		public static implicit operator ImGuiViewportPPtrPtr(ImGuiViewportP** handle) => new ImGuiViewportPPtrPtr(handle);

		public static implicit operator ImGuiViewportP**(ImGuiViewportPPtrPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiViewportPPtrPtr left, ImGuiViewportPPtrPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiViewportPPtrPtr left, ImGuiViewportPPtrPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiViewportPPtrPtr left, ImGuiViewportP** right) => left.Handle == right;

		public static bool operator !=(ImGuiViewportPPtrPtr left, ImGuiViewportP** right) => left.Handle != right;

		public bool Equals(ImGuiViewportPPtrPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiViewportPPtrPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiViewportPPtrPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ImGuiViewportPPtr this[int index]
		{
			get => Handle[index]; set => Handle[index] = value;
		}
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImDrawDataBuilder
	{
		/// <summary>
		/// Global layers for: regular, tooltip<br/>
		/// </summary>
		public ImVectorImDrawListPtr Layers_0;
		public ImVectorImDrawListPtr Layers_1;



		public unsafe Span<ImVectorImDrawListPtr> Layers
		
		{
			get
			{
				fixed (ImVectorImDrawListPtr* p = &this.Layers_0)
				{
					return new Span<ImVectorImDrawListPtr>(p, 2);
				}
			}
		}

		public unsafe void Clear()
		{
			fixed (ImDrawDataBuilder* @this = &this)
			{
				ImGui.ClearNative(@this);
			}
		}

		public unsafe void ClearFreeMemory()
		{
			fixed (ImDrawDataBuilder* @this = &this)
			{
				ImGui.ClearFreeMemoryNative(@this);
			}
		}

		public unsafe void FlattenIntoSingleLayer()
		{
			fixed (ImDrawDataBuilder* @this = &this)
			{
				ImGui.FlattenIntoSingleLayerNative(@this);
			}
		}

		public unsafe int GetDrawListCount()
		{
			fixed (ImDrawDataBuilder* @this = &this)
			{
				int ret = ImGui.GetDrawListCountNative(@this);
				return ret;
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImDrawDataBuilderPtr : IEquatable<ImDrawDataBuilderPtr>
	{
		public ImDrawDataBuilderPtr(ImDrawDataBuilder* handle) { Handle = handle; }

		public ImDrawDataBuilder* Handle;

		public bool IsNull => Handle == null;

		public static ImDrawDataBuilderPtr Null => new ImDrawDataBuilderPtr(null);

		public static implicit operator ImDrawDataBuilderPtr(ImDrawDataBuilder* handle) => new ImDrawDataBuilderPtr(handle);

		public static implicit operator ImDrawDataBuilder*(ImDrawDataBuilderPtr handle) => handle.Handle;

		public static bool operator ==(ImDrawDataBuilderPtr left, ImDrawDataBuilderPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImDrawDataBuilderPtr left, ImDrawDataBuilderPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImDrawDataBuilderPtr left, ImDrawDataBuilder* right) => left.Handle == right;

		public static bool operator !=(ImDrawDataBuilderPtr left, ImDrawDataBuilder* right) => left.Handle != right;

		public bool Equals(ImDrawDataBuilderPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImDrawDataBuilderPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImDrawDataBuilderPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		/// <summary>
		/// Global layers for: regular, tooltip<br/>
		/// </summary>
		public unsafe Span<ImVectorImDrawListPtr> Layers
		
		{
			get
			{
				return new Span<ImVectorImDrawListPtr>(&Handle->Layers_0, 2);
			}
		}

		public unsafe void Clear()
		{
			ImGui.ClearNative(Handle);
		}

		public unsafe void ClearFreeMemory()
		{
			ImGui.ClearFreeMemoryNative(Handle);
		}

		public unsafe void FlattenIntoSingleLayer()
		{
			ImGui.FlattenIntoSingleLayerNative(Handle);
		}

		public unsafe int GetDrawListCount()
		{
			int ret = ImGui.GetDrawListCountNative(Handle);
			return ret;
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImDrawListPtr
	{
		public int Size;
		public int Capacity;
		public unsafe ImDrawList** Data;


	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiID
	{
		public int Size;
		public int Capacity;
		public unsafe int* Data;


	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImVectorImGuiIDPtr : IEquatable<ImVectorImGuiIDPtr>
	{
		public ImVectorImGuiIDPtr(ImVectorImGuiID* handle) { Handle = handle; }

		public ImVectorImGuiID* Handle;

		public bool IsNull => Handle == null;

		public static ImVectorImGuiIDPtr Null => new ImVectorImGuiIDPtr(null);

		public static implicit operator ImVectorImGuiIDPtr(ImVectorImGuiID* handle) => new ImVectorImGuiIDPtr(handle);

		public static implicit operator ImVectorImGuiID*(ImVectorImGuiIDPtr handle) => handle.Handle;

		public static bool operator ==(ImVectorImGuiIDPtr left, ImVectorImGuiIDPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImVectorImGuiIDPtr left, ImVectorImGuiIDPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImVectorImGuiIDPtr left, ImVectorImGuiID* right) => left.Handle == right;

		public static bool operator !=(ImVectorImGuiIDPtr left, ImVectorImGuiID* right) => left.Handle != right;

		public bool Equals(ImVectorImGuiIDPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImVectorImGuiIDPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImVectorImGuiIDPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref int Size => ref Unsafe.AsRef<int>(&Handle->Size);
		public ref int Capacity => ref Unsafe.AsRef<int>(&Handle->Capacity);
		public int* Data { get => Handle->Data; set => Handle->Data = value; }
	}

	/// <summary>
	/// Transient per-window data, reset at the beginning of the frame. This used to be called ImGuiDrawContext, hence the DC variable name in ImGuiWindow.<br/>
	/// (That's theory, in practice the delimitation between ImGuiWindow and ImGuiWindowTempData is quite tenuous and could be reconsidered..)<br/>
	/// (This doesn't need a constructor because we zero-clear it as part of ImGuiWindow and all frame-temporary data are setup on Begin)<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiWindowTempData
	{
		/// <summary>
		/// Layout Current emitting position, in absolute coordinates.<br/>
		/// </summary>
		public Vector2 CursorPos;

		public Vector2 CursorPosPrevLine;
		/// <summary>
		/// Initial position after Begin(), generally ~ window position + WindowPadding.<br/>
		/// </summary>
		public Vector2 CursorStartPos;

		/// <summary>
		/// Used to implicitly calculate ContentSize at the beginning of next frame, for scrolling range and auto-resize. Always growing during the frame.<br/>
		/// </summary>
		public Vector2 CursorMaxPos;

		/// <summary>
		/// Used to implicitly calculate ContentSizeIdeal at the beginning of next frame, for auto-resize only. Always growing during the frame.<br/>
		/// </summary>
		public Vector2 IdealMaxPos;

		public Vector2 CurrLineSize;
		public Vector2 PrevLineSize;
		/// <summary>
		/// Baseline offset (0.0f by default on a new line, generally == style.FramePadding.y when a framed item has been added).<br/>
		/// </summary>
		public float CurrLineTextBaseOffset;

		public float PrevLineTextBaseOffset;
		public byte IsSameLine;
		public byte IsSetPos;
		/// <summary>
		/// Indentation  start position from left of window (increased by TreePushTreePop, etc.)<br/>
		/// </summary>
		public ImVec1 Indent;

		/// <summary>
		/// Offset to the current column (if ColumnsCurrent &gt; 0). FIXME: This and the above should be a stack to allow use cases like Tree-&gt;Column-&gt;Tree. Need revamp columns API.<br/>
		/// </summary>
		public ImVec1 ColumnsOffset;

		public ImVec1 GroupOffset;
		/// <summary>
		/// Record the loss of precision of CursorStartPos due to really large scrolling amount. This is used by clipper to compensate and fix the most common use case of large scroll area.<br/>
		/// </summary>
		public Vector2 CursorStartPosLossyness;

		/// <summary>
		/// KeyboardGamepad navigation Current layer, 0..31 (we currently only use 0..1)<br/>
		/// </summary>
		public ImGuiNavLayer NavLayerCurrent;

		/// <summary>
		/// Which layers have been written to (result from previous frame)<br/>
		/// </summary>
		public short NavLayersActiveMask;

		/// <summary>
		/// Which layers have been written to (accumulator for current frame)<br/>
		/// </summary>
		public short NavLayersActiveMaskNext;

		/// <summary>
		/// Set when current work location may be scrolled horizontally when moving left  right. This is generally always true UNLESS within a column.<br/>
		/// </summary>
		public byte NavIsScrollPushableX;

		public byte NavHideHighlightOneFrame;
		/// <summary>
		/// Set per window when scrolling can be used (== ScrollMax.y &gt; 0.0f)<br/>
		/// </summary>
		public byte NavWindowHasScrollY;

		/// <summary>
		/// Miscellaneous FIXME: Remove this<br/>
		/// </summary>
		public byte MenuBarAppending;

		/// <summary>
		/// MenuBarOffset.x is sort of equivalent of a per-layer CursorPos.x, savedrestored as we switch to the menu bar. The only situation when MenuBarOffset.y is &gt; 0 if when (SafeAreaPadding.y &gt; FramePadding.y), often used on TVs.<br/>
		/// </summary>
		public Vector2 MenuBarOffset;

		/// <summary>
		/// Simplified columns storage for menu items measurement<br/>
		/// </summary>
		public ImGuiMenuColumns MenuColumns;

		/// <summary>
		/// Current tree depth.<br/>
		/// </summary>
		public int TreeDepth;

		/// <summary>
		/// Store a copy of !g.NavIdIsAlive for TreeDepth 0..31.. Could be turned into a ImU64 if necessary.<br/>
		/// </summary>
		public uint TreeJumpToParentOnPopMask;

		public ImVectorImGuiWindowPtr ChildWindows;
		/// <summary>
		/// Current persistent per-window storage (store e.g. tree node openclose state)<br/>
		/// </summary>
		public unsafe ImGuiStorage* StateStorage;

		/// <summary>
		/// Current columns set<br/>
		/// </summary>
		public unsafe ImGuiOldColumns* CurrentColumns;

		/// <summary>
		/// Current table index (into g.Tables)<br/>
		/// </summary>
		public int CurrentTableIdx;

		public ImGuiLayoutType LayoutType;
		/// <summary>
		/// Layout type of parent window at the time of Begin()<br/>
		/// </summary>
		public ImGuiLayoutType ParentLayoutType;

		/// <summary>
		/// Local parameters stacks<br/>
		/// We store the current settings outside of the vectors to increase memory locality (reduce cache misses). The vectors are rarely modified. Also it allows us to not heap allocate for short-lived windows which are not using those settings. Current item width (&gt;0.0: width in pixels, &lt;0.0: align xx pixels to the right of window).<br/>
		/// </summary>
		public float ItemWidth;

		/// <summary>
		/// Current text wrap pos.<br/>
		/// </summary>
		public float TextWrapPos;

		/// <summary>
		/// Store item widths to restore (attention: .back() is not == ItemWidth)<br/>
		/// </summary>
		public ImVectorFloat ItemWidthStack;

		/// <summary>
		/// Store text wrap pos to restore (attention: .back() is not == TextWrapPos)<br/>
		/// </summary>
		public ImVectorFloat TextWrapPosStack;



	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVec1
	{
		public float X;




		public unsafe void Destroy()
		{
			fixed (ImVec1* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImVec1Ptr : IEquatable<ImVec1Ptr>
	{
		public ImVec1Ptr(ImVec1* handle) { Handle = handle; }

		public ImVec1* Handle;

		public bool IsNull => Handle == null;

		public static ImVec1Ptr Null => new ImVec1Ptr(null);

		public static implicit operator ImVec1Ptr(ImVec1* handle) => new ImVec1Ptr(handle);

		public static implicit operator ImVec1*(ImVec1Ptr handle) => handle.Handle;

		public static bool operator ==(ImVec1Ptr left, ImVec1Ptr right) => left.Handle == right.Handle;

		public static bool operator !=(ImVec1Ptr left, ImVec1Ptr right) => left.Handle != right.Handle;

		public static bool operator ==(ImVec1Ptr left, ImVec1* right) => left.Handle == right;

		public static bool operator !=(ImVec1Ptr left, ImVec1* right) => left.Handle != right;

		public bool Equals(ImVec1Ptr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImVec1Ptr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImVec1Ptr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref float X => ref Unsafe.AsRef<float>(&Handle->X);

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

	}

	/// <summary>
	/// Simple column measurement, currently used for MenuItem() only.. This is very short-sightedthrow-away code and NOT a generic helper.<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiMenuColumns
	{
		public uint TotalWidth;
		public uint NextTotalWidth;
		public ushort Spacing;
		/// <summary>
		/// Always zero for now<br/>
		/// </summary>
		public ushort OffsetIcon;

		/// <summary>
		/// Offsets are locked in Update()<br/>
		/// </summary>
		public ushort OffsetLabel;

		public ushort OffsetShortcut;
		public ushort OffsetMark;
		/// <summary>
		/// Width of:   Icon, Label, Shortcut, Mark  (accumulators for current frame)<br/>
		/// </summary>
		public ushort Widths_0;
		public ushort Widths_1;
		public ushort Widths_2;
		public ushort Widths_3;





		public unsafe void CalcNextTotalWidth(bool updateOffsets)
		{
			fixed (ImGuiMenuColumns* @this = &this)
			{
				ImGui.CalcNextTotalWidthNative(@this, updateOffsets ? (byte)1 : (byte)0);
			}
		}

		public unsafe float DeclColumns(float wIcon, float wLabel, float wShortcut, float wMark)
		{
			fixed (ImGuiMenuColumns* @this = &this)
			{
				float ret = ImGui.DeclColumnsNative(@this, wIcon, wLabel, wShortcut, wMark);
				return ret;
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImGuiMenuColumns* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe void Update(float spacing, bool windowReappearing)
		{
			fixed (ImGuiMenuColumns* @this = &this)
			{
				ImGui.UpdateNative(@this, spacing, windowReappearing ? (byte)1 : (byte)0);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiMenuColumnsPtr : IEquatable<ImGuiMenuColumnsPtr>
	{
		public ImGuiMenuColumnsPtr(ImGuiMenuColumns* handle) { Handle = handle; }

		public ImGuiMenuColumns* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiMenuColumnsPtr Null => new ImGuiMenuColumnsPtr(null);

		public static implicit operator ImGuiMenuColumnsPtr(ImGuiMenuColumns* handle) => new ImGuiMenuColumnsPtr(handle);

		public static implicit operator ImGuiMenuColumns*(ImGuiMenuColumnsPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiMenuColumnsPtr left, ImGuiMenuColumnsPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiMenuColumnsPtr left, ImGuiMenuColumnsPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiMenuColumnsPtr left, ImGuiMenuColumns* right) => left.Handle == right;

		public static bool operator !=(ImGuiMenuColumnsPtr left, ImGuiMenuColumns* right) => left.Handle != right;

		public bool Equals(ImGuiMenuColumnsPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiMenuColumnsPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiMenuColumnsPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref uint TotalWidth => ref Unsafe.AsRef<uint>(&Handle->TotalWidth);
		public ref uint NextTotalWidth => ref Unsafe.AsRef<uint>(&Handle->NextTotalWidth);
		public ref ushort Spacing => ref Unsafe.AsRef<ushort>(&Handle->Spacing);
		/// <summary>
		/// Always zero for now<br/>
		/// </summary>
		public ref ushort OffsetIcon => ref Unsafe.AsRef<ushort>(&Handle->OffsetIcon);
		/// <summary>
		/// Offsets are locked in Update()<br/>
		/// </summary>
		public ref ushort OffsetLabel => ref Unsafe.AsRef<ushort>(&Handle->OffsetLabel);
		public ref ushort OffsetShortcut => ref Unsafe.AsRef<ushort>(&Handle->OffsetShortcut);
		public ref ushort OffsetMark => ref Unsafe.AsRef<ushort>(&Handle->OffsetMark);
		/// <summary>
		/// Width of:   Icon, Label, Shortcut, Mark  (accumulators for current frame)<br/>
		/// </summary>
		public unsafe Span<ushort> Widths
		
		{
			get
			{
				return new Span<ushort>(&Handle->Widths_0, 4);
			}
		}

		public unsafe void CalcNextTotalWidth(bool updateOffsets)
		{
			ImGui.CalcNextTotalWidthNative(Handle, updateOffsets ? (byte)1 : (byte)0);
		}

		public unsafe float DeclColumns(float wIcon, float wLabel, float wShortcut, float wMark)
		{
			float ret = ImGui.DeclColumnsNative(Handle, wIcon, wLabel, wShortcut, wMark);
			return ret;
		}

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

		public unsafe void Update(float spacing, bool windowReappearing)
		{
			ImGui.UpdateNative(Handle, spacing, windowReappearing ? (byte)1 : (byte)0);
		}

	}

	/// <summary>
	/// Helper: Key-&gt;Value storage<br/>
	/// Typically you don't have to worry about this since a storage is held within each Window.<br/>
	/// We use it to e.g. store collapse state for a tree (Int 01)<br/>
	/// This is optimized for efficient lookup (dichotomy into a contiguous buffer) and rare insertion (typically tied to user interactions aka max once a frame)<br/>
	/// You can use it as custom user storage for temporary values. Declare your own storage if, for example:<br/>
	/// - You want to manipulate the openclose state of a particular sub-tree in your interface (tree node uses Int 01 to store their state).<br/>
	/// - You want to store custom debug data easily without adding or editing structures in your code (probably not efficient, but convenient)<br/>
	/// Types are NOT stored, so it is up to you to make sure your Key don't collide with different types.<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiStorage
	{
		public ImVectorImGuiStoragePair Data;



		public unsafe void BuildSortByKey()
		{
			fixed (ImGuiStorage* @this = &this)
			{
				ImGui.BuildSortByKeyNative(@this);
			}
		}

		public unsafe void Clear()
		{
			fixed (ImGuiStorage* @this = &this)
			{
				ImGui.ClearNative(@this);
			}
		}

		public unsafe bool GetBool(int key, bool defaultVal)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				byte ret = ImGui.GetBoolNative(@this, key, defaultVal ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		public unsafe bool GetBool(int key)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				byte ret = ImGui.GetBoolNative(@this, key, (byte)(0));
				return ret != 0;
			}
		}

		public unsafe byte* GetBoolRef(int key, bool defaultVal)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				byte* ret = ImGui.GetBoolRefNative(@this, key, defaultVal ? (byte)1 : (byte)0);
				return ret;
			}
		}

		public unsafe byte* GetBoolRef(int key)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				byte* ret = ImGui.GetBoolRefNative(@this, key, (byte)(0));
				return ret;
			}
		}

		public unsafe float GetFloat(int key, float defaultVal)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				float ret = ImGui.GetFloatNative(@this, key, defaultVal);
				return ret;
			}
		}

		public unsafe float GetFloat(int key)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				float ret = ImGui.GetFloatNative(@this, key, (float)(0.0f));
				return ret;
			}
		}

		public unsafe float* GetFloatRef(int key, float defaultVal)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				float* ret = ImGui.GetFloatRefNative(@this, key, defaultVal);
				return ret;
			}
		}

		public unsafe float* GetFloatRef(int key)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				float* ret = ImGui.GetFloatRefNative(@this, key, (float)(0.0f));
				return ret;
			}
		}

		public unsafe int GetInt(int key, int defaultVal)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				int ret = ImGui.GetIntNative(@this, key, defaultVal);
				return ret;
			}
		}

		public unsafe int GetInt(int key)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				int ret = ImGui.GetIntNative(@this, key, (int)(0));
				return ret;
			}
		}

		public unsafe int* GetIntRef(int key, int defaultVal)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				int* ret = ImGui.GetIntRefNative(@this, key, defaultVal);
				return ret;
			}
		}

		public unsafe int* GetIntRef(int key)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				int* ret = ImGui.GetIntRefNative(@this, key, (int)(0));
				return ret;
			}
		}

		/// <summary>		/// default_val is NULL		/// </summary>		public unsafe void* GetVoidPtr(int key)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				void* ret = ImGui.GetVoidPtrNative(@this, key);
				return ret;
			}
		}

		public unsafe void** GetVoidPtrRef(int key, void* defaultVal)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				void** ret = ImGui.GetVoidPtrRefNative(@this, key, defaultVal);
				return ret;
			}
		}

		public unsafe void** GetVoidPtrRef(int key)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				void** ret = ImGui.GetVoidPtrRefNative(@this, key, (void*)(default));
				return ret;
			}
		}

		public unsafe void SetAllInt(int val)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				ImGui.SetAllIntNative(@this, val);
			}
		}

		public unsafe void SetBool(int key, bool val)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				ImGui.SetBoolNative(@this, key, val ? (byte)1 : (byte)0);
			}
		}

		public unsafe void SetFloat(int key, float val)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				ImGui.SetFloatNative(@this, key, val);
			}
		}

		public unsafe void SetInt(int key, int val)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				ImGui.SetIntNative(@this, key, val);
			}
		}

		public unsafe void SetVoidPtr(int key, void* val)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				ImGui.SetVoidPtrNative(@this, key, val);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiStoragePtr : IEquatable<ImGuiStoragePtr>
	{
		public ImGuiStoragePtr(ImGuiStorage* handle) { Handle = handle; }

		public ImGuiStorage* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiStoragePtr Null => new ImGuiStoragePtr(null);

		public static implicit operator ImGuiStoragePtr(ImGuiStorage* handle) => new ImGuiStoragePtr(handle);

		public static implicit operator ImGuiStorage*(ImGuiStoragePtr handle) => handle.Handle;

		public static bool operator ==(ImGuiStoragePtr left, ImGuiStoragePtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiStoragePtr left, ImGuiStoragePtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiStoragePtr left, ImGuiStorage* right) => left.Handle == right;

		public static bool operator !=(ImGuiStoragePtr left, ImGuiStorage* right) => left.Handle != right;

		public bool Equals(ImGuiStoragePtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiStoragePtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiStoragePtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref ImVectorImGuiStoragePair Data => ref Unsafe.AsRef<ImVectorImGuiStoragePair>(&Handle->Data);

		public unsafe void BuildSortByKey()
		{
			ImGui.BuildSortByKeyNative(Handle);
		}

		public unsafe void Clear()
		{
			ImGui.ClearNative(Handle);
		}

		public unsafe bool GetBool(int key, bool defaultVal)
		{
			byte ret = ImGui.GetBoolNative(Handle, key, defaultVal ? (byte)1 : (byte)0);
			return ret != 0;
		}

		public unsafe bool GetBool(int key)
		{
			byte ret = ImGui.GetBoolNative(Handle, key, (byte)(0));
			return ret != 0;
		}

		public unsafe byte* GetBoolRef(int key, bool defaultVal)
		{
			byte* ret = ImGui.GetBoolRefNative(Handle, key, defaultVal ? (byte)1 : (byte)0);
			return ret;
		}

		public unsafe byte* GetBoolRef(int key)
		{
			byte* ret = ImGui.GetBoolRefNative(Handle, key, (byte)(0));
			return ret;
		}

		public unsafe float GetFloat(int key, float defaultVal)
		{
			float ret = ImGui.GetFloatNative(Handle, key, defaultVal);
			return ret;
		}

		public unsafe float GetFloat(int key)
		{
			float ret = ImGui.GetFloatNative(Handle, key, (float)(0.0f));
			return ret;
		}

		public unsafe float* GetFloatRef(int key, float defaultVal)
		{
			float* ret = ImGui.GetFloatRefNative(Handle, key, defaultVal);
			return ret;
		}

		public unsafe float* GetFloatRef(int key)
		{
			float* ret = ImGui.GetFloatRefNative(Handle, key, (float)(0.0f));
			return ret;
		}

		public unsafe int GetInt(int key, int defaultVal)
		{
			int ret = ImGui.GetIntNative(Handle, key, defaultVal);
			return ret;
		}

		public unsafe int GetInt(int key)
		{
			int ret = ImGui.GetIntNative(Handle, key, (int)(0));
			return ret;
		}

		public unsafe int* GetIntRef(int key, int defaultVal)
		{
			int* ret = ImGui.GetIntRefNative(Handle, key, defaultVal);
			return ret;
		}

		public unsafe int* GetIntRef(int key)
		{
			int* ret = ImGui.GetIntRefNative(Handle, key, (int)(0));
			return ret;
		}

		/// <summary>		/// default_val is NULL		/// </summary>		public unsafe void* GetVoidPtr(int key)
		{
			void* ret = ImGui.GetVoidPtrNative(Handle, key);
			return ret;
		}

		public unsafe void** GetVoidPtrRef(int key, void* defaultVal)
		{
			void** ret = ImGui.GetVoidPtrRefNative(Handle, key, defaultVal);
			return ret;
		}

		public unsafe void** GetVoidPtrRef(int key)
		{
			void** ret = ImGui.GetVoidPtrRefNative(Handle, key, (void*)(default));
			return ret;
		}

		public unsafe void SetAllInt(int val)
		{
			ImGui.SetAllIntNative(Handle, val);
		}

		public unsafe void SetBool(int key, bool val)
		{
			ImGui.SetBoolNative(Handle, key, val ? (byte)1 : (byte)0);
		}

		public unsafe void SetFloat(int key, float val)
		{
			ImGui.SetFloatNative(Handle, key, val);
		}

		public unsafe void SetInt(int key, int val)
		{
			ImGui.SetIntNative(Handle, key, val);
		}

		public unsafe void SetVoidPtr(int key, void* val)
		{
			ImGui.SetVoidPtrNative(Handle, key, val);
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiStoragePair
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiStoragePair* Data;


	}

	[StructLayout(LayoutKind.Explicit)]
	public partial struct ImGuiStoragePairUnion
	{
		[FieldOffset(0)]
		public int ValI;
		[FieldOffset(0)]
		public float ValF;
		[FieldOffset(0)]
		public unsafe void* ValP;


	}

	/// <summary>
	/// [Internal]<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiStoragePair
	{
		public int Key;
		public ImGuiStoragePairUnion ImGuiStoragePairUnion;




		public unsafe void Destroy()
		{
			fixed (ImGuiStoragePair* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiStoragePairPtr : IEquatable<ImGuiStoragePairPtr>
	{
		public ImGuiStoragePairPtr(ImGuiStoragePair* handle) { Handle = handle; }

		public ImGuiStoragePair* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiStoragePairPtr Null => new ImGuiStoragePairPtr(null);

		public static implicit operator ImGuiStoragePairPtr(ImGuiStoragePair* handle) => new ImGuiStoragePairPtr(handle);

		public static implicit operator ImGuiStoragePair*(ImGuiStoragePairPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiStoragePairPtr left, ImGuiStoragePairPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiStoragePairPtr left, ImGuiStoragePairPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiStoragePairPtr left, ImGuiStoragePair* right) => left.Handle == right;

		public static bool operator !=(ImGuiStoragePairPtr left, ImGuiStoragePair* right) => left.Handle != right;

		public bool Equals(ImGuiStoragePairPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiStoragePairPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiStoragePairPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref int Key => ref Unsafe.AsRef<int>(&Handle->Key);
		public ref ImGuiStoragePairUnion ImGuiStoragePairUnion => ref Unsafe.AsRef<ImGuiStoragePairUnion>(&Handle->ImGuiStoragePairUnion);

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiOldColumns
	{
		public int ID;
		public ImGuiOldColumnFlags Flags;
		public byte IsFirstFrame;
		public byte IsBeingResized;
		public int Current;
		public int Count;
		/// <summary>
		/// Offsets from HostWorkRect.Min.x<br/>
		/// </summary>
		public float OffMinX;

		/// <summary>
		/// Offsets from HostWorkRect.Min.x<br/>
		/// </summary>
		public float OffMaxX;

		public float LineMinY;
		public float LineMaxY;
		/// <summary>
		/// Backup of CursorPos at the time of BeginColumns()<br/>
		/// </summary>
		public float HostCursorPosY;

		/// <summary>
		/// Backup of CursorMaxPos at the time of BeginColumns()<br/>
		/// </summary>
		public float HostCursorMaxPosX;

		/// <summary>
		/// Backup of ClipRect at the time of BeginColumns()<br/>
		/// </summary>
		public ImRect HostInitialClipRect;

		/// <summary>
		/// Backup of ClipRect during PushColumnsBackground()PopColumnsBackground()<br/>
		/// </summary>
		public ImRect HostBackupClipRect;

		/// <summary>
		/// Backup of WorkRect at the time of BeginColumns()<br/>
		/// </summary>
		public ImRect HostBackupParentWorkRect;

		public ImVectorImGuiOldColumnData Columns;
		public ImDrawListSplitter Splitter;




		public unsafe void Destroy()
		{
			fixed (ImGuiOldColumns* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiOldColumnsPtr : IEquatable<ImGuiOldColumnsPtr>
	{
		public ImGuiOldColumnsPtr(ImGuiOldColumns* handle) { Handle = handle; }

		public ImGuiOldColumns* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiOldColumnsPtr Null => new ImGuiOldColumnsPtr(null);

		public static implicit operator ImGuiOldColumnsPtr(ImGuiOldColumns* handle) => new ImGuiOldColumnsPtr(handle);

		public static implicit operator ImGuiOldColumns*(ImGuiOldColumnsPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiOldColumnsPtr left, ImGuiOldColumnsPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiOldColumnsPtr left, ImGuiOldColumnsPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiOldColumnsPtr left, ImGuiOldColumns* right) => left.Handle == right;

		public static bool operator !=(ImGuiOldColumnsPtr left, ImGuiOldColumns* right) => left.Handle != right;

		public bool Equals(ImGuiOldColumnsPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiOldColumnsPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiOldColumnsPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref int ID => ref Unsafe.AsRef<int>(&Handle->ID);
		public ref ImGuiOldColumnFlags Flags => ref Unsafe.AsRef<ImGuiOldColumnFlags>(&Handle->Flags);
		public ref bool IsFirstFrame => ref Unsafe.AsRef<bool>(&Handle->IsFirstFrame);
		public ref bool IsBeingResized => ref Unsafe.AsRef<bool>(&Handle->IsBeingResized);
		public ref int Current => ref Unsafe.AsRef<int>(&Handle->Current);
		public ref int Count => ref Unsafe.AsRef<int>(&Handle->Count);
		/// <summary>
		/// Offsets from HostWorkRect.Min.x<br/>
		/// </summary>
		public ref float OffMinX => ref Unsafe.AsRef<float>(&Handle->OffMinX);
		/// <summary>
		/// Offsets from HostWorkRect.Min.x<br/>
		/// </summary>
		public ref float OffMaxX => ref Unsafe.AsRef<float>(&Handle->OffMaxX);
		public ref float LineMinY => ref Unsafe.AsRef<float>(&Handle->LineMinY);
		public ref float LineMaxY => ref Unsafe.AsRef<float>(&Handle->LineMaxY);
		/// <summary>
		/// Backup of CursorPos at the time of BeginColumns()<br/>
		/// </summary>
		public ref float HostCursorPosY => ref Unsafe.AsRef<float>(&Handle->HostCursorPosY);
		/// <summary>
		/// Backup of CursorMaxPos at the time of BeginColumns()<br/>
		/// </summary>
		public ref float HostCursorMaxPosX => ref Unsafe.AsRef<float>(&Handle->HostCursorMaxPosX);
		/// <summary>
		/// Backup of ClipRect at the time of BeginColumns()<br/>
		/// </summary>
		public ref ImRect HostInitialClipRect => ref Unsafe.AsRef<ImRect>(&Handle->HostInitialClipRect);
		/// <summary>
		/// Backup of ClipRect during PushColumnsBackground()PopColumnsBackground()<br/>
		/// </summary>
		public ref ImRect HostBackupClipRect => ref Unsafe.AsRef<ImRect>(&Handle->HostBackupClipRect);
		/// <summary>
		/// Backup of WorkRect at the time of BeginColumns()<br/>
		/// </summary>
		public ref ImRect HostBackupParentWorkRect => ref Unsafe.AsRef<ImRect>(&Handle->HostBackupParentWorkRect);
		public ref ImVectorImGuiOldColumnData Columns => ref Unsafe.AsRef<ImVectorImGuiOldColumnData>(&Handle->Columns);
		public ref ImDrawListSplitter Splitter => ref Unsafe.AsRef<ImDrawListSplitter>(&Handle->Splitter);

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

	}

	/// <summary>
	/// Helper: ImRect (2D axis aligned bounding-box)<br/>
	/// NB: we can't rely on ImVec2 math operators being available here!<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImRect
	{
		/// <summary>
		/// Upper-left<br/>
		/// </summary>
		public Vector2 Min;

		/// <summary>
		/// Lower-right<br/>
		/// </summary>
		public Vector2 Max;





		public unsafe void Add(Vector2 p)
		{
			fixed (ImRect* @this = &this)
			{
				ImGui.AddNative(@this, p);
			}
		}

		public unsafe void Add(ImRect r)
		{
			fixed (ImRect* @this = &this)
			{
				ImGui.AddNative(@this, r);
			}
		}

		/// <summary>		/// Simple version, may lead to an inverted rectangle, which is fine for ContainsOverlaps test but not for display.		/// </summary>		public unsafe void ClipWith(ImRect r)
		{
			fixed (ImRect* @this = &this)
			{
				ImGui.ClipWithNative(@this, r);
			}
		}

		/// <summary>		/// Full version, ensure both points are fully clipped.		/// </summary>		public unsafe void ClipWithFull(ImRect r)
		{
			fixed (ImRect* @this = &this)
			{
				ImGui.ClipWithFullNative(@this, r);
			}
		}

		public unsafe bool Contains(Vector2 p)
		{
			fixed (ImRect* @this = &this)
			{
				byte ret = ImGui.ContainsNative(@this, p);
				return ret != 0;
			}
		}

		public unsafe bool Contains(ImRect r)
		{
			fixed (ImRect* @this = &this)
			{
				byte ret = ImGui.ContainsNative(@this, r);
				return ret != 0;
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImRect* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe void Expand(float amount)
		{
			fixed (ImRect* @this = &this)
			{
				ImGui.ExpandNative(@this, amount);
			}
		}

		public unsafe void Expand(Vector2 amount)
		{
			fixed (ImRect* @this = &this)
			{
				ImGui.ExpandNative(@this, amount);
			}
		}

		public unsafe void Floor()
		{
			fixed (ImRect* @this = &this)
			{
				ImGui.FloorNative(@this);
			}
		}

		public unsafe float GetArea()
		{
			fixed (ImRect* @this = &this)
			{
				float ret = ImGui.GetAreaNative(@this);
				return ret;
			}
		}

		public unsafe float GetHeight()
		{
			fixed (ImRect* @this = &this)
			{
				float ret = ImGui.GetHeightNative(@this);
				return ret;
			}
		}

		public unsafe float GetWidth()
		{
			fixed (ImRect* @this = &this)
			{
				float ret = ImGui.GetWidthNative(@this);
				return ret;
			}
		}

		public unsafe bool IsInverted()
		{
			fixed (ImRect* @this = &this)
			{
				byte ret = ImGui.IsInvertedNative(@this);
				return ret != 0;
			}
		}

		public unsafe bool Overlaps(ImRect r)
		{
			fixed (ImRect* @this = &this)
			{
				byte ret = ImGui.OverlapsNative(@this, r);
				return ret != 0;
			}
		}

		public unsafe void Translate(Vector2 d)
		{
			fixed (ImRect* @this = &this)
			{
				ImGui.TranslateNative(@this, d);
			}
		}

		public unsafe void TranslateX(float dx)
		{
			fixed (ImRect* @this = &this)
			{
				ImGui.TranslateXNative(@this, dx);
			}
		}

		public unsafe void TranslateY(float dy)
		{
			fixed (ImRect* @this = &this)
			{
				ImGui.TranslateYNative(@this, dy);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImRectPtr : IEquatable<ImRectPtr>
	{
		public ImRectPtr(ImRect* handle) { Handle = handle; }

		public ImRect* Handle;

		public bool IsNull => Handle == null;

		public static ImRectPtr Null => new ImRectPtr(null);

		public static implicit operator ImRectPtr(ImRect* handle) => new ImRectPtr(handle);

		public static implicit operator ImRect*(ImRectPtr handle) => handle.Handle;

		public static bool operator ==(ImRectPtr left, ImRectPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImRectPtr left, ImRectPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImRectPtr left, ImRect* right) => left.Handle == right;

		public static bool operator !=(ImRectPtr left, ImRect* right) => left.Handle != right;

		public bool Equals(ImRectPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImRectPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImRectPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		/// <summary>
		/// Upper-left<br/>
		/// </summary>
		public ref Vector2 Min => ref Unsafe.AsRef<Vector2>(&Handle->Min);
		/// <summary>
		/// Lower-right<br/>
		/// </summary>
		public ref Vector2 Max => ref Unsafe.AsRef<Vector2>(&Handle->Max);

		public unsafe void Add(Vector2 p)
		{
			ImGui.AddNative(Handle, p);
		}

		public unsafe void Add(ImRect r)
		{
			ImGui.AddNative(Handle, r);
		}

		/// <summary>		/// Simple version, may lead to an inverted rectangle, which is fine for ContainsOverlaps test but not for display.		/// </summary>		public unsafe void ClipWith(ImRect r)
		{
			ImGui.ClipWithNative(Handle, r);
		}

		/// <summary>		/// Full version, ensure both points are fully clipped.		/// </summary>		public unsafe void ClipWithFull(ImRect r)
		{
			ImGui.ClipWithFullNative(Handle, r);
		}

		public unsafe bool Contains(Vector2 p)
		{
			byte ret = ImGui.ContainsNative(Handle, p);
			return ret != 0;
		}

		public unsafe bool Contains(ImRect r)
		{
			byte ret = ImGui.ContainsNative(Handle, r);
			return ret != 0;
		}

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

		public unsafe void Expand(float amount)
		{
			ImGui.ExpandNative(Handle, amount);
		}

		public unsafe void Expand(Vector2 amount)
		{
			ImGui.ExpandNative(Handle, amount);
		}

		public unsafe void Floor()
		{
			ImGui.FloorNative(Handle);
		}

		public unsafe float GetArea()
		{
			float ret = ImGui.GetAreaNative(Handle);
			return ret;
		}

		public unsafe float GetHeight()
		{
			float ret = ImGui.GetHeightNative(Handle);
			return ret;
		}

		public unsafe float GetWidth()
		{
			float ret = ImGui.GetWidthNative(Handle);
			return ret;
		}

		public unsafe bool IsInverted()
		{
			byte ret = ImGui.IsInvertedNative(Handle);
			return ret != 0;
		}

		public unsafe bool Overlaps(ImRect r)
		{
			byte ret = ImGui.OverlapsNative(Handle, r);
			return ret != 0;
		}

		public unsafe void Translate(Vector2 d)
		{
			ImGui.TranslateNative(Handle, d);
		}

		public unsafe void TranslateX(float dx)
		{
			ImGui.TranslateXNative(Handle, dx);
		}

		public unsafe void TranslateY(float dy)
		{
			ImGui.TranslateYNative(Handle, dy);
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiOldColumnData
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiOldColumnData* Data;


	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiOldColumnData
	{
		/// <summary>
		/// Column start offset, normalized 0.0 (far left) -&gt; 1.0 (far right)<br/>
		/// </summary>
		public float OffsetNorm;

		public float OffsetNormBeforeResize;
		/// <summary>
		/// Not exposed<br/>
		/// </summary>
		public ImGuiOldColumnFlags Flags;

		public ImRect ClipRect;




		public unsafe void Destroy()
		{
			fixed (ImGuiOldColumnData* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiOldColumnDataPtr : IEquatable<ImGuiOldColumnDataPtr>
	{
		public ImGuiOldColumnDataPtr(ImGuiOldColumnData* handle) { Handle = handle; }

		public ImGuiOldColumnData* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiOldColumnDataPtr Null => new ImGuiOldColumnDataPtr(null);

		public static implicit operator ImGuiOldColumnDataPtr(ImGuiOldColumnData* handle) => new ImGuiOldColumnDataPtr(handle);

		public static implicit operator ImGuiOldColumnData*(ImGuiOldColumnDataPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiOldColumnDataPtr left, ImGuiOldColumnDataPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiOldColumnDataPtr left, ImGuiOldColumnDataPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiOldColumnDataPtr left, ImGuiOldColumnData* right) => left.Handle == right;

		public static bool operator !=(ImGuiOldColumnDataPtr left, ImGuiOldColumnData* right) => left.Handle != right;

		public bool Equals(ImGuiOldColumnDataPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiOldColumnDataPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiOldColumnDataPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		/// <summary>
		/// Column start offset, normalized 0.0 (far left) -&gt; 1.0 (far right)<br/>
		/// </summary>
		public ref float OffsetNorm => ref Unsafe.AsRef<float>(&Handle->OffsetNorm);
		public ref float OffsetNormBeforeResize => ref Unsafe.AsRef<float>(&Handle->OffsetNormBeforeResize);
		/// <summary>
		/// Not exposed<br/>
		/// </summary>
		public ref ImGuiOldColumnFlags Flags => ref Unsafe.AsRef<ImGuiOldColumnFlags>(&Handle->Flags);
		public ref ImRect ClipRect => ref Unsafe.AsRef<ImRect>(&Handle->ClipRect);

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

	}

	/// <summary>
	/// Helper: ImVec2ih (2D vector, half-size integer, for long-term packed storage)<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVec2Ih
	{
		public short X;
		public short Y;




		public unsafe void Destroy()
		{
			fixed (ImVec2Ih* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImVec2IhPtr : IEquatable<ImVec2IhPtr>
	{
		public ImVec2IhPtr(ImVec2Ih* handle) { Handle = handle; }

		public ImVec2Ih* Handle;

		public bool IsNull => Handle == null;

		public static ImVec2IhPtr Null => new ImVec2IhPtr(null);

		public static implicit operator ImVec2IhPtr(ImVec2Ih* handle) => new ImVec2IhPtr(handle);

		public static implicit operator ImVec2Ih*(ImVec2IhPtr handle) => handle.Handle;

		public static bool operator ==(ImVec2IhPtr left, ImVec2IhPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImVec2IhPtr left, ImVec2IhPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImVec2IhPtr left, ImVec2Ih* right) => left.Handle == right;

		public static bool operator !=(ImVec2IhPtr left, ImVec2Ih* right) => left.Handle != right;

		public bool Equals(ImVec2IhPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImVec2IhPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImVec2IhPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref short X => ref Unsafe.AsRef<short>(&Handle->X);
		public ref short Y => ref Unsafe.AsRef<short>(&Handle->Y);

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiOldColumns
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiOldColumns* Data;


	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiWindowDockStyle
	{
		public uint Colors_0;
		public uint Colors_1;
		public uint Colors_2;
		public uint Colors_3;
		public uint Colors_4;
		public uint Colors_5;


	}

	/// <summary>
	/// sizeof() 156~192<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiDockNode
	{
		public int ID;
		/// <summary>
		/// (Write) Flags shared by all nodes of a same dockspace hierarchy (inherited from the root node)<br/>
		/// </summary>
		public ImGuiDockNodeFlags SharedFlags;

		/// <summary>
		/// (Write) Flags specific to this node<br/>
		/// </summary>
		public ImGuiDockNodeFlags LocalFlags;

		/// <summary>
		/// (Write) Flags specific to this node, applied from windows<br/>
		/// </summary>
		public ImGuiDockNodeFlags LocalFlagsInWindows;

		/// <summary>
		/// (Read)  Effective flags (== SharedFlags | LocalFlagsInNode | LocalFlagsInWindows)<br/>
		/// </summary>
		public ImGuiDockNodeFlags MergedFlags;

		public ImGuiDockNodeState State;
		public unsafe ImGuiDockNode* ParentNode;
		/// <summary>
		/// [Split node only] Child nodes (leftright or topbottom). Consider switching to an array.<br/>
		/// </summary>
		public unsafe ImGuiDockNode* ChildNodes_0;
		public unsafe ImGuiDockNode* ChildNodes_1;

		/// <summary>
		/// Note: unordered list! Iterate TabBar-&gt;Tabs for user-order.<br/>
		/// </summary>
		public ImVectorImGuiWindowPtr Windows;

		public unsafe ImGuiTabBar* TabBar;
		/// <summary>
		/// Current position<br/>
		/// </summary>
		public Vector2 Pos;

		/// <summary>
		/// Current size<br/>
		/// </summary>
		public Vector2 Size;

		/// <summary>
		/// [Split node only] Last explicitly written-to size (overridden when using a splitter affecting the node), used to calculate Size.<br/>
		/// </summary>
		public Vector2 SizeRef;

		/// <summary>
		/// [Split node only] Split axis (X or Y)<br/>
		/// </summary>
		public ImGuiAxis SplitAxis;

		/// <summary>
		/// [Root node only]<br/>
		/// </summary>
		public ImGuiWindowClass WindowClass;

		public uint LastBgColor;
		public unsafe ImGuiWindow* HostWindow;
		/// <summary>
		/// Generally point to window which is ID is == SelectedTabID, but when CTRL+Tabbing this can be a different window.<br/>
		/// </summary>
		public unsafe ImGuiWindow* VisibleWindow;

		/// <summary>
		/// [Root node only] Pointer to central node.<br/>
		/// </summary>
		public unsafe ImGuiDockNode* CentralNode;

		/// <summary>
		/// [Root node only] Set when there is a single visible node within the hierarchy.<br/>
		/// </summary>
		public unsafe ImGuiDockNode* OnlyNodeWithWindows;

		/// <summary>
		/// [Root node only]<br/>
		/// </summary>
		public int CountNodeWithWindows;

		/// <summary>
		/// Last frame number the node was updated or kept alive explicitly with DockSpace() + ImGuiDockNodeFlags_KeepAliveOnly<br/>
		/// </summary>
		public int LastFrameAlive;

		/// <summary>
		/// Last frame number the node was updated.<br/>
		/// </summary>
		public int LastFrameActive;

		/// <summary>
		/// Last frame number the node was focused.<br/>
		/// </summary>
		public int LastFrameFocused;

		/// <summary>
		/// [Root node only] Which of our child docking node (any ancestor in the hierarchy) was last focused.<br/>
		/// </summary>
		public int LastFocusedNodeId;

		/// <summary>
		/// [Leaf node only] Which of our tabwindow is selected.<br/>
		/// </summary>
		public int SelectedTabId;

		/// <summary>
		/// [Leaf node only] Set when closing a specific tabwindow.<br/>
		/// </summary>
		public int WantCloseTabId;

		/// <summary>
		/// Reference viewport ID from visible window when HostWindow == NULL.<br/>
		/// </summary>
		public int RefViewportId;

		public ImGuiDataAuthority AuthorityForPos;
		public ImGuiDataAuthority AuthorityForSize;
		public ImGuiDataAuthority AuthorityForViewport;
		/// <summary>
		/// Set to false when the node is hidden (usually disabled as it has no active window)<br/>
		/// </summary>
		public byte IsVisible;

		public byte IsFocused;
		public byte IsBgDrawnThisFrame;
		/// <summary>
		/// Provide space for a close button (if any of the docked window has one). Note that button may be hidden on window without one.<br/>
		/// </summary>
		public byte HasCloseButton;

		public byte HasWindowMenuButton;
		public byte HasCentralNodeChild;
		/// <summary>
		/// Set when closing all tabs at once.<br/>
		/// </summary>
		public byte WantCloseAll;

		public byte WantLockSizeOnce;
		/// <summary>
		/// After a node extraction we need to transition toward moving the newly created host window<br/>
		/// </summary>
		public byte WantMouseMove;

		public byte WantHiddenTabBarUpdate;
		public byte WantHiddenTabBarToggle;




		public unsafe void Destroy()
		{
			fixed (ImGuiDockNode* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe bool IsCentralNode()
		{
			fixed (ImGuiDockNode* @this = &this)
			{
				byte ret = ImGui.IsCentralNodeNative(@this);
				return ret != 0;
			}
		}

		public unsafe bool IsDockSpace()
		{
			fixed (ImGuiDockNode* @this = &this)
			{
				byte ret = ImGui.IsDockSpaceNative(@this);
				return ret != 0;
			}
		}

		public unsafe bool IsEmpty()
		{
			fixed (ImGuiDockNode* @this = &this)
			{
				byte ret = ImGui.IsEmptyNative(@this);
				return ret != 0;
			}
		}

		public unsafe bool IsFloatingNode()
		{
			fixed (ImGuiDockNode* @this = &this)
			{
				byte ret = ImGui.IsFloatingNodeNative(@this);
				return ret != 0;
			}
		}

		/// <summary>		/// Hidden tab bar can be shown back by clicking the small triangle		/// </summary>		public unsafe bool IsHiddenTabBar()
		{
			fixed (ImGuiDockNode* @this = &this)
			{
				byte ret = ImGui.IsHiddenTabBarNative(@this);
				return ret != 0;
			}
		}

		public unsafe bool IsLeafNode()
		{
			fixed (ImGuiDockNode* @this = &this)
			{
				byte ret = ImGui.IsLeafNodeNative(@this);
				return ret != 0;
			}
		}

		/// <summary>		/// Never show a tab bar		/// </summary>		public unsafe bool IsNoTabBar()
		{
			fixed (ImGuiDockNode* @this = &this)
			{
				byte ret = ImGui.IsNoTabBarNative(@this);
				return ret != 0;
			}
		}

		public unsafe bool IsRootNode()
		{
			fixed (ImGuiDockNode* @this = &this)
			{
				byte ret = ImGui.IsRootNodeNative(@this);
				return ret != 0;
			}
		}

		public unsafe bool IsSplitNode()
		{
			fixed (ImGuiDockNode* @this = &this)
			{
				byte ret = ImGui.IsSplitNodeNative(@this);
				return ret != 0;
			}
		}

		public unsafe void SetLocalFlags(ImGuiDockNodeFlags flags)
		{
			fixed (ImGuiDockNode* @this = &this)
			{
				ImGui.SetLocalFlagsNative(@this, flags);
			}
		}

		public unsafe void UpdateMergedFlags()
		{
			fixed (ImGuiDockNode* @this = &this)
			{
				ImGui.UpdateMergedFlagsNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiDockNodePtr : IEquatable<ImGuiDockNodePtr>
	{
		public ImGuiDockNodePtr(ImGuiDockNode* handle) { Handle = handle; }

		public ImGuiDockNode* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiDockNodePtr Null => new ImGuiDockNodePtr(null);

		public static implicit operator ImGuiDockNodePtr(ImGuiDockNode* handle) => new ImGuiDockNodePtr(handle);

		public static implicit operator ImGuiDockNode*(ImGuiDockNodePtr handle) => handle.Handle;

		public static bool operator ==(ImGuiDockNodePtr left, ImGuiDockNodePtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiDockNodePtr left, ImGuiDockNodePtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiDockNodePtr left, ImGuiDockNode* right) => left.Handle == right;

		public static bool operator !=(ImGuiDockNodePtr left, ImGuiDockNode* right) => left.Handle != right;

		public bool Equals(ImGuiDockNodePtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiDockNodePtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiDockNodePtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref int ID => ref Unsafe.AsRef<int>(&Handle->ID);
		/// <summary>
		/// (Write) Flags shared by all nodes of a same dockspace hierarchy (inherited from the root node)<br/>
		/// </summary>
		public ref ImGuiDockNodeFlags SharedFlags => ref Unsafe.AsRef<ImGuiDockNodeFlags>(&Handle->SharedFlags);
		/// <summary>
		/// (Write) Flags specific to this node<br/>
		/// </summary>
		public ref ImGuiDockNodeFlags LocalFlags => ref Unsafe.AsRef<ImGuiDockNodeFlags>(&Handle->LocalFlags);
		/// <summary>
		/// (Write) Flags specific to this node, applied from windows<br/>
		/// </summary>
		public ref ImGuiDockNodeFlags LocalFlagsInWindows => ref Unsafe.AsRef<ImGuiDockNodeFlags>(&Handle->LocalFlagsInWindows);
		/// <summary>
		/// (Read)  Effective flags (== SharedFlags | LocalFlagsInNode | LocalFlagsInWindows)<br/>
		/// </summary>
		public ref ImGuiDockNodeFlags MergedFlags => ref Unsafe.AsRef<ImGuiDockNodeFlags>(&Handle->MergedFlags);
		public ref ImGuiDockNodeState State => ref Unsafe.AsRef<ImGuiDockNodeState>(&Handle->State);
		public ref ImGuiDockNodePtr ParentNode => ref Unsafe.AsRef<ImGuiDockNodePtr>(&Handle->ParentNode);
		/// <summary>
		/// [Split node only] Child nodes (leftright or topbottom). Consider switching to an array.<br/>
		/// </summary>
		/// <summary>
		/// Note: unordered list! Iterate TabBar-&gt;Tabs for user-order.<br/>
		/// </summary>
		public ref ImVectorImGuiWindowPtr Windows => ref Unsafe.AsRef<ImVectorImGuiWindowPtr>(&Handle->Windows);
		public ref ImGuiTabBarPtr TabBar => ref Unsafe.AsRef<ImGuiTabBarPtr>(&Handle->TabBar);
		/// <summary>
		/// Current position<br/>
		/// </summary>
		public ref Vector2 Pos => ref Unsafe.AsRef<Vector2>(&Handle->Pos);
		/// <summary>
		/// Current size<br/>
		/// </summary>
		public ref Vector2 Size => ref Unsafe.AsRef<Vector2>(&Handle->Size);
		/// <summary>
		/// [Split node only] Last explicitly written-to size (overridden when using a splitter affecting the node), used to calculate Size.<br/>
		/// </summary>
		public ref Vector2 SizeRef => ref Unsafe.AsRef<Vector2>(&Handle->SizeRef);
		/// <summary>
		/// [Split node only] Split axis (X or Y)<br/>
		/// </summary>
		public ref ImGuiAxis SplitAxis => ref Unsafe.AsRef<ImGuiAxis>(&Handle->SplitAxis);
		/// <summary>
		/// [Root node only]<br/>
		/// </summary>
		public ref ImGuiWindowClass WindowClass => ref Unsafe.AsRef<ImGuiWindowClass>(&Handle->WindowClass);
		public ref uint LastBgColor => ref Unsafe.AsRef<uint>(&Handle->LastBgColor);
		public ref ImGuiWindowPtr HostWindow => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->HostWindow);
		/// <summary>
		/// Generally point to window which is ID is == SelectedTabID, but when CTRL+Tabbing this can be a different window.<br/>
		/// </summary>
		public ref ImGuiWindowPtr VisibleWindow => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->VisibleWindow);
		/// <summary>
		/// [Root node only] Pointer to central node.<br/>
		/// </summary>
		public ref ImGuiDockNodePtr CentralNode => ref Unsafe.AsRef<ImGuiDockNodePtr>(&Handle->CentralNode);
		/// <summary>
		/// [Root node only] Set when there is a single visible node within the hierarchy.<br/>
		/// </summary>
		public ref ImGuiDockNodePtr OnlyNodeWithWindows => ref Unsafe.AsRef<ImGuiDockNodePtr>(&Handle->OnlyNodeWithWindows);
		/// <summary>
		/// [Root node only]<br/>
		/// </summary>
		public ref int CountNodeWithWindows => ref Unsafe.AsRef<int>(&Handle->CountNodeWithWindows);
		/// <summary>
		/// Last frame number the node was updated or kept alive explicitly with DockSpace() + ImGuiDockNodeFlags_KeepAliveOnly<br/>
		/// </summary>
		public ref int LastFrameAlive => ref Unsafe.AsRef<int>(&Handle->LastFrameAlive);
		/// <summary>
		/// Last frame number the node was updated.<br/>
		/// </summary>
		public ref int LastFrameActive => ref Unsafe.AsRef<int>(&Handle->LastFrameActive);
		/// <summary>
		/// Last frame number the node was focused.<br/>
		/// </summary>
		public ref int LastFrameFocused => ref Unsafe.AsRef<int>(&Handle->LastFrameFocused);
		/// <summary>
		/// [Root node only] Which of our child docking node (any ancestor in the hierarchy) was last focused.<br/>
		/// </summary>
		public ref int LastFocusedNodeId => ref Unsafe.AsRef<int>(&Handle->LastFocusedNodeId);
		/// <summary>
		/// [Leaf node only] Which of our tabwindow is selected.<br/>
		/// </summary>
		public ref int SelectedTabId => ref Unsafe.AsRef<int>(&Handle->SelectedTabId);
		/// <summary>
		/// [Leaf node only] Set when closing a specific tabwindow.<br/>
		/// </summary>
		public ref int WantCloseTabId => ref Unsafe.AsRef<int>(&Handle->WantCloseTabId);
		/// <summary>
		/// Reference viewport ID from visible window when HostWindow == NULL.<br/>
		/// </summary>
		public ref int RefViewportId => ref Unsafe.AsRef<int>(&Handle->RefViewportId);
		public ref ImGuiDataAuthority AuthorityForPos => ref Unsafe.AsRef<ImGuiDataAuthority>(&Handle->AuthorityForPos);
		public ref ImGuiDataAuthority AuthorityForSize => ref Unsafe.AsRef<ImGuiDataAuthority>(&Handle->AuthorityForSize);
		public ref ImGuiDataAuthority AuthorityForViewport => ref Unsafe.AsRef<ImGuiDataAuthority>(&Handle->AuthorityForViewport);
		/// <summary>
		/// Set to false when the node is hidden (usually disabled as it has no active window)<br/>
		/// </summary>
		public ref bool IsVisible => ref Unsafe.AsRef<bool>(&Handle->IsVisible);
		public ref bool IsFocused => ref Unsafe.AsRef<bool>(&Handle->IsFocused);
		public ref bool IsBgDrawnThisFrame => ref Unsafe.AsRef<bool>(&Handle->IsBgDrawnThisFrame);
		/// <summary>
		/// Provide space for a close button (if any of the docked window has one). Note that button may be hidden on window without one.<br/>
		/// </summary>
		public ref bool HasCloseButton => ref Unsafe.AsRef<bool>(&Handle->HasCloseButton);
		public ref bool HasWindowMenuButton => ref Unsafe.AsRef<bool>(&Handle->HasWindowMenuButton);
		public ref bool HasCentralNodeChild => ref Unsafe.AsRef<bool>(&Handle->HasCentralNodeChild);
		/// <summary>
		/// Set when closing all tabs at once.<br/>
		/// </summary>
		public ref bool WantCloseAll => ref Unsafe.AsRef<bool>(&Handle->WantCloseAll);
		public ref bool WantLockSizeOnce => ref Unsafe.AsRef<bool>(&Handle->WantLockSizeOnce);
		/// <summary>
		/// After a node extraction we need to transition toward moving the newly created host window<br/>
		/// </summary>
		public ref bool WantMouseMove => ref Unsafe.AsRef<bool>(&Handle->WantMouseMove);
		public ref bool WantHiddenTabBarUpdate => ref Unsafe.AsRef<bool>(&Handle->WantHiddenTabBarUpdate);
		public ref bool WantHiddenTabBarToggle => ref Unsafe.AsRef<bool>(&Handle->WantHiddenTabBarToggle);

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

		public unsafe bool IsCentralNode()
		{
			byte ret = ImGui.IsCentralNodeNative(Handle);
			return ret != 0;
		}

		public unsafe bool IsDockSpace()
		{
			byte ret = ImGui.IsDockSpaceNative(Handle);
			return ret != 0;
		}

		public unsafe bool IsEmpty()
		{
			byte ret = ImGui.IsEmptyNative(Handle);
			return ret != 0;
		}

		public unsafe bool IsFloatingNode()
		{
			byte ret = ImGui.IsFloatingNodeNative(Handle);
			return ret != 0;
		}

		/// <summary>		/// Hidden tab bar can be shown back by clicking the small triangle		/// </summary>		public unsafe bool IsHiddenTabBar()
		{
			byte ret = ImGui.IsHiddenTabBarNative(Handle);
			return ret != 0;
		}

		public unsafe bool IsLeafNode()
		{
			byte ret = ImGui.IsLeafNodeNative(Handle);
			return ret != 0;
		}

		/// <summary>		/// Never show a tab bar		/// </summary>		public unsafe bool IsNoTabBar()
		{
			byte ret = ImGui.IsNoTabBarNative(Handle);
			return ret != 0;
		}

		public unsafe bool IsRootNode()
		{
			byte ret = ImGui.IsRootNodeNative(Handle);
			return ret != 0;
		}

		public unsafe bool IsSplitNode()
		{
			byte ret = ImGui.IsSplitNodeNative(Handle);
			return ret != 0;
		}

		public unsafe void SetLocalFlags(ImGuiDockNodeFlags flags)
		{
			ImGui.SetLocalFlagsNative(Handle, flags);
		}

		public unsafe void UpdateMergedFlags()
		{
			ImGui.UpdateMergedFlagsNative(Handle);
		}

	}

	/// <summary>
	/// Storage for a tab bar (sizeof() 152 bytes)<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTabBar
	{
		public ImVectorImGuiTabItem Tabs;
		public ImGuiTabBarFlags Flags;
		/// <summary>
		/// Zero for tab-bars used by docking<br/>
		/// </summary>
		public int ID;

		/// <summary>
		/// Selected tabwindow<br/>
		/// </summary>
		public int SelectedTabId;

		/// <summary>
		/// Next selected tabwindow. Will also trigger a scrolling animation<br/>
		/// </summary>
		public int NextSelectedTabId;

		/// <summary>
		/// Can occasionally be != SelectedTabId (e.g. when previewing contents for CTRL+TAB preview)<br/>
		/// </summary>
		public int VisibleTabId;

		public int CurrFrameVisible;
		public int PrevFrameVisible;
		public ImRect BarRect;
		public float CurrTabsContentsHeight;
		/// <summary>
		/// Record the height of contents submitted below the tab bar<br/>
		/// </summary>
		public float PrevTabsContentsHeight;

		/// <summary>
		/// Actual width of all tabs (locked during layout)<br/>
		/// </summary>
		public float WidthAllTabs;

		/// <summary>
		/// Ideal width if all tabs were visible and not clipped<br/>
		/// </summary>
		public float WidthAllTabsIdeal;

		public float ScrollingAnim;
		public float ScrollingTarget;
		public float ScrollingTargetDistToVisibility;
		public float ScrollingSpeed;
		public float ScrollingRectMinX;
		public float ScrollingRectMaxX;
		public int ReorderRequestTabId;
		public short ReorderRequestOffset;
		public sbyte BeginCount;
		public byte WantLayout;
		public byte VisibleTabWasSubmitted;
		/// <summary>
		/// Set to true when a new tab item or button has been added to the tab bar during last frame<br/>
		/// </summary>
		public byte TabsAddedNew;

		/// <summary>
		/// Number of tabs submitted this frame.<br/>
		/// </summary>
		public short TabsActiveCount;

		/// <summary>
		/// Index of last BeginTabItem() tab for use by EndTabItem()<br/>
		/// </summary>
		public short LastTabItemIdx;

		public float ItemSpacingY;
		/// <summary>
		/// style.FramePadding locked at the time of BeginTabBar()<br/>
		/// </summary>
		public Vector2 FramePadding;

		public Vector2 BackupCursorPos;
		/// <summary>
		/// For non-docking tab bar we re-append names in a contiguous buffer.<br/>
		/// </summary>
		public ImGuiTextBuffer TabsNames;





		public unsafe void Destroy()
		{
			fixed (ImGuiTabBar* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiTabBarPtr : IEquatable<ImGuiTabBarPtr>
	{
		public ImGuiTabBarPtr(ImGuiTabBar* handle) { Handle = handle; }

		public ImGuiTabBar* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiTabBarPtr Null => new ImGuiTabBarPtr(null);

		public static implicit operator ImGuiTabBarPtr(ImGuiTabBar* handle) => new ImGuiTabBarPtr(handle);

		public static implicit operator ImGuiTabBar*(ImGuiTabBarPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiTabBarPtr left, ImGuiTabBarPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiTabBarPtr left, ImGuiTabBarPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiTabBarPtr left, ImGuiTabBar* right) => left.Handle == right;

		public static bool operator !=(ImGuiTabBarPtr left, ImGuiTabBar* right) => left.Handle != right;

		public bool Equals(ImGuiTabBarPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiTabBarPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiTabBarPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref ImVectorImGuiTabItem Tabs => ref Unsafe.AsRef<ImVectorImGuiTabItem>(&Handle->Tabs);
		public ref ImGuiTabBarFlags Flags => ref Unsafe.AsRef<ImGuiTabBarFlags>(&Handle->Flags);
		/// <summary>
		/// Zero for tab-bars used by docking<br/>
		/// </summary>
		public ref int ID => ref Unsafe.AsRef<int>(&Handle->ID);
		/// <summary>
		/// Selected tabwindow<br/>
		/// </summary>
		public ref int SelectedTabId => ref Unsafe.AsRef<int>(&Handle->SelectedTabId);
		/// <summary>
		/// Next selected tabwindow. Will also trigger a scrolling animation<br/>
		/// </summary>
		public ref int NextSelectedTabId => ref Unsafe.AsRef<int>(&Handle->NextSelectedTabId);
		/// <summary>
		/// Can occasionally be != SelectedTabId (e.g. when previewing contents for CTRL+TAB preview)<br/>
		/// </summary>
		public ref int VisibleTabId => ref Unsafe.AsRef<int>(&Handle->VisibleTabId);
		public ref int CurrFrameVisible => ref Unsafe.AsRef<int>(&Handle->CurrFrameVisible);
		public ref int PrevFrameVisible => ref Unsafe.AsRef<int>(&Handle->PrevFrameVisible);
		public ref ImRect BarRect => ref Unsafe.AsRef<ImRect>(&Handle->BarRect);
		public ref float CurrTabsContentsHeight => ref Unsafe.AsRef<float>(&Handle->CurrTabsContentsHeight);
		/// <summary>
		/// Record the height of contents submitted below the tab bar<br/>
		/// </summary>
		public ref float PrevTabsContentsHeight => ref Unsafe.AsRef<float>(&Handle->PrevTabsContentsHeight);
		/// <summary>
		/// Actual width of all tabs (locked during layout)<br/>
		/// </summary>
		public ref float WidthAllTabs => ref Unsafe.AsRef<float>(&Handle->WidthAllTabs);
		/// <summary>
		/// Ideal width if all tabs were visible and not clipped<br/>
		/// </summary>
		public ref float WidthAllTabsIdeal => ref Unsafe.AsRef<float>(&Handle->WidthAllTabsIdeal);
		public ref float ScrollingAnim => ref Unsafe.AsRef<float>(&Handle->ScrollingAnim);
		public ref float ScrollingTarget => ref Unsafe.AsRef<float>(&Handle->ScrollingTarget);
		public ref float ScrollingTargetDistToVisibility => ref Unsafe.AsRef<float>(&Handle->ScrollingTargetDistToVisibility);
		public ref float ScrollingSpeed => ref Unsafe.AsRef<float>(&Handle->ScrollingSpeed);
		public ref float ScrollingRectMinX => ref Unsafe.AsRef<float>(&Handle->ScrollingRectMinX);
		public ref float ScrollingRectMaxX => ref Unsafe.AsRef<float>(&Handle->ScrollingRectMaxX);
		public ref int ReorderRequestTabId => ref Unsafe.AsRef<int>(&Handle->ReorderRequestTabId);
		public ref short ReorderRequestOffset => ref Unsafe.AsRef<short>(&Handle->ReorderRequestOffset);
		public ref sbyte BeginCount => ref Unsafe.AsRef<sbyte>(&Handle->BeginCount);
		public ref bool WantLayout => ref Unsafe.AsRef<bool>(&Handle->WantLayout);
		public ref bool VisibleTabWasSubmitted => ref Unsafe.AsRef<bool>(&Handle->VisibleTabWasSubmitted);
		/// <summary>
		/// Set to true when a new tab item or button has been added to the tab bar during last frame<br/>
		/// </summary>
		public ref bool TabsAddedNew => ref Unsafe.AsRef<bool>(&Handle->TabsAddedNew);
		/// <summary>
		/// Number of tabs submitted this frame.<br/>
		/// </summary>
		public ref short TabsActiveCount => ref Unsafe.AsRef<short>(&Handle->TabsActiveCount);
		/// <summary>
		/// Index of last BeginTabItem() tab for use by EndTabItem()<br/>
		/// </summary>
		public ref short LastTabItemIdx => ref Unsafe.AsRef<short>(&Handle->LastTabItemIdx);
		public ref float ItemSpacingY => ref Unsafe.AsRef<float>(&Handle->ItemSpacingY);
		/// <summary>
		/// style.FramePadding locked at the time of BeginTabBar()<br/>
		/// </summary>
		public ref Vector2 FramePadding => ref Unsafe.AsRef<Vector2>(&Handle->FramePadding);
		public ref Vector2 BackupCursorPos => ref Unsafe.AsRef<Vector2>(&Handle->BackupCursorPos);
		/// <summary>
		/// For non-docking tab bar we re-append names in a contiguous buffer.<br/>
		/// </summary>
		public ref ImGuiTextBuffer TabsNames => ref Unsafe.AsRef<ImGuiTextBuffer>(&Handle->TabsNames);

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiTabItem
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiTabItem* Data;


	}

	/// <summary>
	/// Storage for one active tab item (sizeof() 48 bytes)<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTabItem
	{
		public int ID;
		public ImGuiTabItemFlags Flags;
		/// <summary>
		/// When TabItem is part of a DockNode's TabBar, we hold on to a window.<br/>
		/// </summary>
		public unsafe ImGuiWindow* Window;

		public int LastFrameVisible;
		/// <summary>
		/// This allows us to infer an ordered list of the last activated tabs with little maintenance<br/>
		/// </summary>
		public int LastFrameSelected;

		/// <summary>
		/// Position relative to beginning of tab<br/>
		/// </summary>
		public float Offset;

		/// <summary>
		/// Width currently displayed<br/>
		/// </summary>
		public float Width;

		/// <summary>
		/// Width of label, stored during BeginTabItem() call<br/>
		/// </summary>
		public float ContentWidth;

		/// <summary>
		/// Width optionally requested by caller, -1.0f is unused<br/>
		/// </summary>
		public float RequestedWidth;

		/// <summary>
		/// When Window==NULL, offset to name within parent ImGuiTabBar::TabsNames<br/>
		/// </summary>
		public int NameOffset;

		/// <summary>
		/// BeginTabItem() order, used to re-order tabs after toggling ImGuiTabBarFlags_Reorderable<br/>
		/// </summary>
		public short BeginOrder;

		/// <summary>
		/// Index only used during TabBarLayout(). Tabs gets reordered so 'Tabs[n].IndexDuringLayout == n' but may mismatch during additions.<br/>
		/// </summary>
		public short IndexDuringLayout;

		/// <summary>
		/// Marked as closed by SetTabItemClosed()<br/>
		/// </summary>
		public byte WantClose;





		public unsafe void Destroy()
		{
			fixed (ImGuiTabItem* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiTabItemPtr : IEquatable<ImGuiTabItemPtr>
	{
		public ImGuiTabItemPtr(ImGuiTabItem* handle) { Handle = handle; }

		public ImGuiTabItem* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiTabItemPtr Null => new ImGuiTabItemPtr(null);

		public static implicit operator ImGuiTabItemPtr(ImGuiTabItem* handle) => new ImGuiTabItemPtr(handle);

		public static implicit operator ImGuiTabItem*(ImGuiTabItemPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiTabItemPtr left, ImGuiTabItemPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiTabItemPtr left, ImGuiTabItemPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiTabItemPtr left, ImGuiTabItem* right) => left.Handle == right;

		public static bool operator !=(ImGuiTabItemPtr left, ImGuiTabItem* right) => left.Handle != right;

		public bool Equals(ImGuiTabItemPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiTabItemPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiTabItemPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref int ID => ref Unsafe.AsRef<int>(&Handle->ID);
		public ref ImGuiTabItemFlags Flags => ref Unsafe.AsRef<ImGuiTabItemFlags>(&Handle->Flags);
		/// <summary>
		/// When TabItem is part of a DockNode's TabBar, we hold on to a window.<br/>
		/// </summary>
		public ref ImGuiWindowPtr Window => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->Window);
		public ref int LastFrameVisible => ref Unsafe.AsRef<int>(&Handle->LastFrameVisible);
		/// <summary>
		/// This allows us to infer an ordered list of the last activated tabs with little maintenance<br/>
		/// </summary>
		public ref int LastFrameSelected => ref Unsafe.AsRef<int>(&Handle->LastFrameSelected);
		/// <summary>
		/// Position relative to beginning of tab<br/>
		/// </summary>
		public ref float Offset => ref Unsafe.AsRef<float>(&Handle->Offset);
		/// <summary>
		/// Width currently displayed<br/>
		/// </summary>
		public ref float Width => ref Unsafe.AsRef<float>(&Handle->Width);
		/// <summary>
		/// Width of label, stored during BeginTabItem() call<br/>
		/// </summary>
		public ref float ContentWidth => ref Unsafe.AsRef<float>(&Handle->ContentWidth);
		/// <summary>
		/// Width optionally requested by caller, -1.0f is unused<br/>
		/// </summary>
		public ref float RequestedWidth => ref Unsafe.AsRef<float>(&Handle->RequestedWidth);
		/// <summary>
		/// When Window==NULL, offset to name within parent ImGuiTabBar::TabsNames<br/>
		/// </summary>
		public ref int NameOffset => ref Unsafe.AsRef<int>(&Handle->NameOffset);
		/// <summary>
		/// BeginTabItem() order, used to re-order tabs after toggling ImGuiTabBarFlags_Reorderable<br/>
		/// </summary>
		public ref short BeginOrder => ref Unsafe.AsRef<short>(&Handle->BeginOrder);
		/// <summary>
		/// Index only used during TabBarLayout(). Tabs gets reordered so 'Tabs[n].IndexDuringLayout == n' but may mismatch during additions.<br/>
		/// </summary>
		public ref short IndexDuringLayout => ref Unsafe.AsRef<short>(&Handle->IndexDuringLayout);
		/// <summary>
		/// Marked as closed by SetTabItemClosed()<br/>
		/// </summary>
		public ref bool WantClose => ref Unsafe.AsRef<bool>(&Handle->WantClose);

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

	}

	/// <summary>
	/// Helper: Growable text buffer for loggingaccumulating text<br/>
	/// (this could be called 'ImGuiTextBuilder'  'ImGuiStringBuilder')<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTextBuffer
	{
		public ImVectorChar Buf;




		public unsafe void append(byte* str, byte* strEnd)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				ImGui.appendNative(@this, str, strEnd);
			}
		}

		public unsafe void append(byte* str)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				ImGui.appendNative(@this, str, (byte*)(default));
			}
		}

		public unsafe void append(ref byte str, byte* strEnd)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				fixed (byte* pstr = &str)
				{
					ImGui.appendNative(@this, (byte*)pstr, strEnd);
				}
			}
		}

		public unsafe void append(ref byte str)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				fixed (byte* pstr = &str)
				{
					ImGui.appendNative(@this, (byte*)pstr, (byte*)(default));
				}
			}
		}

		public unsafe void append(string str, byte* strEnd)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.appendNative(@this, pStr0, strEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void append(string str)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.appendNative(@this, pStr0, (byte*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void append(byte* str, ref byte strEnd)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				fixed (byte* pstrEnd = &strEnd)
				{
					ImGui.appendNative(@this, str, (byte*)pstrEnd);
				}
			}
		}

		public unsafe void append(byte* str, string strEnd)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (strEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(strEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(strEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.appendNative(@this, str, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void append(ref byte str, ref byte strEnd)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				fixed (byte* pstr = &str)
				{
					fixed (byte* pstrEnd = &strEnd)
					{
						ImGui.appendNative(@this, (byte*)pstr, (byte*)pstrEnd);
					}
				}
			}
		}

		public unsafe void append(string str, string strEnd)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (strEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(strEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(strEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.appendNative(@this, pStr0, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void appendf(byte* fmt)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				ImGui.appendfNative(@this, fmt);
			}
		}

		public unsafe void appendf(ref byte fmt)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				fixed (byte* pfmt = &fmt)
				{
					ImGui.appendfNative(@this, (byte*)pfmt);
				}
			}
		}

		public unsafe void appendf(string fmt)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (fmt != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(fmt);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.appendfNative(@this, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void appendfv(byte* fmt, nuint args)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				ImGui.appendfvNative(@this, fmt, args);
			}
		}

		public unsafe void appendfv(ref byte fmt, nuint args)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				fixed (byte* pfmt = &fmt)
				{
					ImGui.appendfvNative(@this, (byte*)pfmt, args);
				}
			}
		}

		public unsafe void appendfv(string fmt, nuint args)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (fmt != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(fmt);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.appendfvNative(@this, pStr0, args);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe byte* begin()
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				byte* ret = ImGui.beginNative(@this);
				return ret;
			}
		}

		public unsafe string beginS()
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				string ret = Utils.DecodeStringUTF8(ImGui.beginNative(@this));
				return ret;
			}
		}

		public unsafe byte* c_str()
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				byte* ret = ImGui.c_strNative(@this);
				return ret;
			}
		}

		public unsafe string c_strS()
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				string ret = Utils.DecodeStringUTF8(ImGui.c_strNative(@this));
				return ret;
			}
		}

		public unsafe void clear()
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				ImGui.clearNative(@this);
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe bool empty()
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				byte ret = ImGui.emptyNative(@this);
				return ret != 0;
			}
		}

		/// <summary>		/// Buf is zero-terminated, so end() will point on the zero-terminator		/// </summary>		public unsafe byte* end()
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				byte* ret = ImGui.endNative(@this);
				return ret;
			}
		}

		/// <summary>		/// Buf is zero-terminated, so end() will point on the zero-terminator		/// </summary>		public unsafe string endS()
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				string ret = Utils.DecodeStringUTF8(ImGui.endNative(@this));
				return ret;
			}
		}

		public unsafe void reserve(int capacity)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				ImGui.reserveNative(@this, capacity);
			}
		}

		public unsafe int size()
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				int ret = ImGui.sizeNative(@this);
				return ret;
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiTextBufferPtr : IEquatable<ImGuiTextBufferPtr>
	{
		public ImGuiTextBufferPtr(ImGuiTextBuffer* handle) { Handle = handle; }

		public ImGuiTextBuffer* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiTextBufferPtr Null => new ImGuiTextBufferPtr(null);

		public static implicit operator ImGuiTextBufferPtr(ImGuiTextBuffer* handle) => new ImGuiTextBufferPtr(handle);

		public static implicit operator ImGuiTextBuffer*(ImGuiTextBufferPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiTextBufferPtr left, ImGuiTextBufferPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiTextBufferPtr left, ImGuiTextBufferPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiTextBufferPtr left, ImGuiTextBuffer* right) => left.Handle == right;

		public static bool operator !=(ImGuiTextBufferPtr left, ImGuiTextBuffer* right) => left.Handle != right;

		public bool Equals(ImGuiTextBufferPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiTextBufferPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiTextBufferPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref ImVectorChar Buf => ref Unsafe.AsRef<ImVectorChar>(&Handle->Buf);

		public unsafe void append(byte* str, byte* strEnd)
		{
			ImGui.appendNative(Handle, str, strEnd);
		}

		public unsafe void append(byte* str)
		{
			ImGui.appendNative(Handle, str, (byte*)(default));
		}

		public unsafe void append(ref byte str, byte* strEnd)
		{
			fixed (byte* pstr = &str)
			{
				ImGui.appendNative(Handle, (byte*)pstr, strEnd);
			}
		}

		public unsafe void append(ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				ImGui.appendNative(Handle, (byte*)pstr, (byte*)(default));
			}
		}

		public unsafe void append(string str, byte* strEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.appendNative(Handle, pStr0, strEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void append(string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.appendNative(Handle, pStr0, (byte*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void append(byte* str, ref byte strEnd)
		{
			fixed (byte* pstrEnd = &strEnd)
			{
				ImGui.appendNative(Handle, str, (byte*)pstrEnd);
			}
		}

		public unsafe void append(byte* str, string strEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.appendNative(Handle, str, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void append(ref byte str, ref byte strEnd)
		{
			fixed (byte* pstr = &str)
			{
				fixed (byte* pstrEnd = &strEnd)
				{
					ImGui.appendNative(Handle, (byte*)pstr, (byte*)pstrEnd);
				}
			}
		}

		public unsafe void append(string str, string strEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (strEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(strEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(strEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ImGui.appendNative(Handle, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void appendf(byte* fmt)
		{
			ImGui.appendfNative(Handle, fmt);
		}

		public unsafe void appendf(ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				ImGui.appendfNative(Handle, (byte*)pfmt);
			}
		}

		public unsafe void appendf(string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.appendfNative(Handle, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void appendfv(byte* fmt, nuint args)
		{
			ImGui.appendfvNative(Handle, fmt, args);
		}

		public unsafe void appendfv(ref byte fmt, nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				ImGui.appendfvNative(Handle, (byte*)pfmt, args);
			}
		}

		public unsafe void appendfv(string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.appendfvNative(Handle, pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe byte* begin()
		{
			byte* ret = ImGui.beginNative(Handle);
			return ret;
		}

		public unsafe string beginS()
		{
			string ret = Utils.DecodeStringUTF8(ImGui.beginNative(Handle));
			return ret;
		}

		public unsafe byte* c_str()
		{
			byte* ret = ImGui.c_strNative(Handle);
			return ret;
		}

		public unsafe string c_strS()
		{
			string ret = Utils.DecodeStringUTF8(ImGui.c_strNative(Handle));
			return ret;
		}

		public unsafe void clear()
		{
			ImGui.clearNative(Handle);
		}

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

		public unsafe bool empty()
		{
			byte ret = ImGui.emptyNative(Handle);
			return ret != 0;
		}

		/// <summary>		/// Buf is zero-terminated, so end() will point on the zero-terminator		/// </summary>		public unsafe byte* end()
		{
			byte* ret = ImGui.endNative(Handle);
			return ret;
		}

		/// <summary>		/// Buf is zero-terminated, so end() will point on the zero-terminator		/// </summary>		public unsafe string endS()
		{
			string ret = Utils.DecodeStringUTF8(ImGui.endNative(Handle));
			return ret;
		}

		public unsafe void reserve(int capacity)
		{
			ImGui.reserveNative(Handle, capacity);
		}

		public unsafe int size()
		{
			int ret = ImGui.sizeNative(Handle);
			return ret;
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorChar
	{
		public int Size;
		public int Capacity;
		public unsafe byte* Data;


	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiWindowStackData
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiWindowStackData* Data;


	}

	/// <summary>
	/// Data saved for each window pushed into the stack<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiWindowStackData
	{
		public unsafe ImGuiWindow* Window;
		public ImGuiLastItemData ParentLastItemDataBackup;
		/// <summary>
		/// Store size of various stacks for asserting<br/>
		/// </summary>
		public ImGuiStackSizes StackSizesOnBegin;



	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiWindowStackDataPtr : IEquatable<ImGuiWindowStackDataPtr>
	{
		public ImGuiWindowStackDataPtr(ImGuiWindowStackData* handle) { Handle = handle; }

		public ImGuiWindowStackData* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiWindowStackDataPtr Null => new ImGuiWindowStackDataPtr(null);

		public static implicit operator ImGuiWindowStackDataPtr(ImGuiWindowStackData* handle) => new ImGuiWindowStackDataPtr(handle);

		public static implicit operator ImGuiWindowStackData*(ImGuiWindowStackDataPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiWindowStackDataPtr left, ImGuiWindowStackDataPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiWindowStackDataPtr left, ImGuiWindowStackDataPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiWindowStackDataPtr left, ImGuiWindowStackData* right) => left.Handle == right;

		public static bool operator !=(ImGuiWindowStackDataPtr left, ImGuiWindowStackData* right) => left.Handle != right;

		public bool Equals(ImGuiWindowStackDataPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiWindowStackDataPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiWindowStackDataPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref ImGuiWindowPtr Window => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->Window);
		public ref ImGuiLastItemData ParentLastItemDataBackup => ref Unsafe.AsRef<ImGuiLastItemData>(&Handle->ParentLastItemDataBackup);
		/// <summary>
		/// Store size of various stacks for asserting<br/>
		/// </summary>
		public ref ImGuiStackSizes StackSizesOnBegin => ref Unsafe.AsRef<ImGuiStackSizes>(&Handle->StackSizesOnBegin);
	}

	/// <summary>
	/// Status storage for the last submitted item<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiLastItemData
	{
		public int ID;
		/// <summary>
		/// See ImGuiItemFlags_<br/>
		/// </summary>
		public ImGuiItemFlags InFlags;

		/// <summary>
		/// See ImGuiItemStatusFlags_<br/>
		/// </summary>
		public ImGuiItemStatusFlags StatusFlags;

		/// <summary>
		/// Full rectangle<br/>
		/// </summary>
		public ImRect Rect;

		/// <summary>
		/// Navigation scoring rectangle (not displayed)<br/>
		/// </summary>
		public ImRect NavRect;

		/// <summary>
		/// Display rectangle (only if ImGuiItemStatusFlags_HasDisplayRect is set)<br/>
		/// </summary>
		public ImRect DisplayRect;





		public unsafe void Destroy()
		{
			fixed (ImGuiLastItemData* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiLastItemDataPtr : IEquatable<ImGuiLastItemDataPtr>
	{
		public ImGuiLastItemDataPtr(ImGuiLastItemData* handle) { Handle = handle; }

		public ImGuiLastItemData* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiLastItemDataPtr Null => new ImGuiLastItemDataPtr(null);

		public static implicit operator ImGuiLastItemDataPtr(ImGuiLastItemData* handle) => new ImGuiLastItemDataPtr(handle);

		public static implicit operator ImGuiLastItemData*(ImGuiLastItemDataPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiLastItemDataPtr left, ImGuiLastItemDataPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiLastItemDataPtr left, ImGuiLastItemDataPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiLastItemDataPtr left, ImGuiLastItemData* right) => left.Handle == right;

		public static bool operator !=(ImGuiLastItemDataPtr left, ImGuiLastItemData* right) => left.Handle != right;

		public bool Equals(ImGuiLastItemDataPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiLastItemDataPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiLastItemDataPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref int ID => ref Unsafe.AsRef<int>(&Handle->ID);
		/// <summary>
		/// See ImGuiItemFlags_<br/>
		/// </summary>
		public ref ImGuiItemFlags InFlags => ref Unsafe.AsRef<ImGuiItemFlags>(&Handle->InFlags);
		/// <summary>
		/// See ImGuiItemStatusFlags_<br/>
		/// </summary>
		public ref ImGuiItemStatusFlags StatusFlags => ref Unsafe.AsRef<ImGuiItemStatusFlags>(&Handle->StatusFlags);
		/// <summary>
		/// Full rectangle<br/>
		/// </summary>
		public ref ImRect Rect => ref Unsafe.AsRef<ImRect>(&Handle->Rect);
		/// <summary>
		/// Navigation scoring rectangle (not displayed)<br/>
		/// </summary>
		public ref ImRect NavRect => ref Unsafe.AsRef<ImRect>(&Handle->NavRect);
		/// <summary>
		/// Display rectangle (only if ImGuiItemStatusFlags_HasDisplayRect is set)<br/>
		/// </summary>
		public ref ImRect DisplayRect => ref Unsafe.AsRef<ImRect>(&Handle->DisplayRect);

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiStackSizes
	{
		public short SizeOfIDStack;
		public short SizeOfColorStack;
		public short SizeOfStyleVarStack;
		public short SizeOfFontStack;
		public short SizeOfFocusScopeStack;
		public short SizeOfGroupStack;
		public short SizeOfItemFlagsStack;
		public short SizeOfBeginPopupStack;
		public short SizeOfDisabledStack;




		public unsafe void CompareWithContextState(ImGuiContextPtr ctx)
		{
			fixed (ImGuiStackSizes* @this = &this)
			{
				ImGui.CompareWithContextStateNative(@this, ctx);
			}
		}

		public unsafe void CompareWithContextState(ref ImGuiContext ctx)
		{
			fixed (ImGuiStackSizes* @this = &this)
			{
				fixed (ImGuiContext* pctx = &ctx)
				{
					ImGui.CompareWithContextStateNative(@this, (ImGuiContext*)pctx);
				}
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImGuiStackSizes* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe void SetToContextState(ImGuiContextPtr ctx)
		{
			fixed (ImGuiStackSizes* @this = &this)
			{
				ImGui.SetToContextStateNative(@this, ctx);
			}
		}

		public unsafe void SetToContextState(ref ImGuiContext ctx)
		{
			fixed (ImGuiStackSizes* @this = &this)
			{
				fixed (ImGuiContext* pctx = &ctx)
				{
					ImGui.SetToContextStateNative(@this, (ImGuiContext*)pctx);
				}
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiStackSizesPtr : IEquatable<ImGuiStackSizesPtr>
	{
		public ImGuiStackSizesPtr(ImGuiStackSizes* handle) { Handle = handle; }

		public ImGuiStackSizes* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiStackSizesPtr Null => new ImGuiStackSizesPtr(null);

		public static implicit operator ImGuiStackSizesPtr(ImGuiStackSizes* handle) => new ImGuiStackSizesPtr(handle);

		public static implicit operator ImGuiStackSizes*(ImGuiStackSizesPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiStackSizesPtr left, ImGuiStackSizesPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiStackSizesPtr left, ImGuiStackSizesPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiStackSizesPtr left, ImGuiStackSizes* right) => left.Handle == right;

		public static bool operator !=(ImGuiStackSizesPtr left, ImGuiStackSizes* right) => left.Handle != right;

		public bool Equals(ImGuiStackSizesPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiStackSizesPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiStackSizesPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref short SizeOfIDStack => ref Unsafe.AsRef<short>(&Handle->SizeOfIDStack);
		public ref short SizeOfColorStack => ref Unsafe.AsRef<short>(&Handle->SizeOfColorStack);
		public ref short SizeOfStyleVarStack => ref Unsafe.AsRef<short>(&Handle->SizeOfStyleVarStack);
		public ref short SizeOfFontStack => ref Unsafe.AsRef<short>(&Handle->SizeOfFontStack);
		public ref short SizeOfFocusScopeStack => ref Unsafe.AsRef<short>(&Handle->SizeOfFocusScopeStack);
		public ref short SizeOfGroupStack => ref Unsafe.AsRef<short>(&Handle->SizeOfGroupStack);
		public ref short SizeOfItemFlagsStack => ref Unsafe.AsRef<short>(&Handle->SizeOfItemFlagsStack);
		public ref short SizeOfBeginPopupStack => ref Unsafe.AsRef<short>(&Handle->SizeOfBeginPopupStack);
		public ref short SizeOfDisabledStack => ref Unsafe.AsRef<short>(&Handle->SizeOfDisabledStack);

		public unsafe void CompareWithContextState(ImGuiContextPtr ctx)
		{
			ImGui.CompareWithContextStateNative(Handle, ctx);
		}

		public unsafe void CompareWithContextState(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				ImGui.CompareWithContextStateNative(Handle, (ImGuiContext*)pctx);
			}
		}

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

		public unsafe void SetToContextState(ImGuiContextPtr ctx)
		{
			ImGui.SetToContextStateNative(Handle, ctx);
		}

		public unsafe void SetToContextState(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				ImGui.SetToContextStateNative(Handle, (ImGuiContext*)pctx);
			}
		}

	}

	/// <summary>
	/// This extends ImGuiKeyData but only for named keys (legacy keys don't support the new features)<br/>
	/// Stored in main context (1 per named key). In the future it might be merged into ImGuiKeyData.<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiKeyOwnerData
	{
		public int OwnerCurr;
		public int OwnerNext;
		/// <summary>
		/// Reading this key requires explicit owner id (until end of frame). Set by ImGuiInputFlags_LockThisFrame.<br/>
		/// </summary>
		public byte LockThisFrame;

		/// <summary>
		/// Reading this key requires explicit owner id (until key is released). Set by ImGuiInputFlags_LockUntilRelease. When this is true LockThisFrame is always true as well.<br/>
		/// </summary>
		public byte LockUntilRelease;





		public unsafe void Destroy()
		{
			fixed (ImGuiKeyOwnerData* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiKeyOwnerDataPtr : IEquatable<ImGuiKeyOwnerDataPtr>
	{
		public ImGuiKeyOwnerDataPtr(ImGuiKeyOwnerData* handle) { Handle = handle; }

		public ImGuiKeyOwnerData* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiKeyOwnerDataPtr Null => new ImGuiKeyOwnerDataPtr(null);

		public static implicit operator ImGuiKeyOwnerDataPtr(ImGuiKeyOwnerData* handle) => new ImGuiKeyOwnerDataPtr(handle);

		public static implicit operator ImGuiKeyOwnerData*(ImGuiKeyOwnerDataPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiKeyOwnerDataPtr left, ImGuiKeyOwnerDataPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiKeyOwnerDataPtr left, ImGuiKeyOwnerDataPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiKeyOwnerDataPtr left, ImGuiKeyOwnerData* right) => left.Handle == right;

		public static bool operator !=(ImGuiKeyOwnerDataPtr left, ImGuiKeyOwnerData* right) => left.Handle != right;

		public bool Equals(ImGuiKeyOwnerDataPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiKeyOwnerDataPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiKeyOwnerDataPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref int OwnerCurr => ref Unsafe.AsRef<int>(&Handle->OwnerCurr);
		public ref int OwnerNext => ref Unsafe.AsRef<int>(&Handle->OwnerNext);
		/// <summary>
		/// Reading this key requires explicit owner id (until end of frame). Set by ImGuiInputFlags_LockThisFrame.<br/>
		/// </summary>
		public ref bool LockThisFrame => ref Unsafe.AsRef<bool>(&Handle->LockThisFrame);
		/// <summary>
		/// Reading this key requires explicit owner id (until key is released). Set by ImGuiInputFlags_LockUntilRelease. When this is true LockThisFrame is always true as well.<br/>
		/// </summary>
		public ref bool LockUntilRelease => ref Unsafe.AsRef<bool>(&Handle->LockUntilRelease);

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

	}

	/// <summary>
	/// Routing table: maintain a desired owner for each possible key-chord (key + mods), and setup owner in NewFrame() when mods are matching.<br/>
	/// Stored in main context (1 instance)<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiKeyRoutingTable
	{
		/// <summary>
		/// Index of first entry in Entries[]<br/>
		/// </summary>
		public short Index_0;
		public short Index_1;
		public short Index_2;
		public short Index_3;
		public short Index_4;
		public short Index_5;
		public short Index_6;
		public short Index_7;
		public short Index_8;
		public short Index_9;
		public short Index_10;
		public short Index_11;
		public short Index_12;
		public short Index_13;
		public short Index_14;
		public short Index_15;
		public short Index_16;
		public short Index_17;
		public short Index_18;
		public short Index_19;
		public short Index_20;
		public short Index_21;
		public short Index_22;
		public short Index_23;
		public short Index_24;
		public short Index_25;
		public short Index_26;
		public short Index_27;
		public short Index_28;
		public short Index_29;
		public short Index_30;
		public short Index_31;
		public short Index_32;
		public short Index_33;
		public short Index_34;
		public short Index_35;
		public short Index_36;
		public short Index_37;
		public short Index_38;
		public short Index_39;
		public short Index_40;
		public short Index_41;
		public short Index_42;
		public short Index_43;
		public short Index_44;
		public short Index_45;
		public short Index_46;
		public short Index_47;
		public short Index_48;
		public short Index_49;
		public short Index_50;
		public short Index_51;
		public short Index_52;
		public short Index_53;
		public short Index_54;
		public short Index_55;
		public short Index_56;
		public short Index_57;
		public short Index_58;
		public short Index_59;
		public short Index_60;
		public short Index_61;
		public short Index_62;
		public short Index_63;
		public short Index_64;
		public short Index_65;
		public short Index_66;
		public short Index_67;
		public short Index_68;
		public short Index_69;
		public short Index_70;
		public short Index_71;
		public short Index_72;
		public short Index_73;
		public short Index_74;
		public short Index_75;
		public short Index_76;
		public short Index_77;
		public short Index_78;
		public short Index_79;
		public short Index_80;
		public short Index_81;
		public short Index_82;
		public short Index_83;
		public short Index_84;
		public short Index_85;
		public short Index_86;
		public short Index_87;
		public short Index_88;
		public short Index_89;
		public short Index_90;
		public short Index_91;
		public short Index_92;
		public short Index_93;
		public short Index_94;
		public short Index_95;
		public short Index_96;
		public short Index_97;
		public short Index_98;
		public short Index_99;
		public short Index_100;
		public short Index_101;
		public short Index_102;
		public short Index_103;
		public short Index_104;
		public short Index_105;
		public short Index_106;
		public short Index_107;
		public short Index_108;
		public short Index_109;
		public short Index_110;
		public short Index_111;
		public short Index_112;
		public short Index_113;
		public short Index_114;
		public short Index_115;
		public short Index_116;
		public short Index_117;
		public short Index_118;
		public short Index_119;
		public short Index_120;
		public short Index_121;
		public short Index_122;
		public short Index_123;
		public short Index_124;
		public short Index_125;
		public short Index_126;
		public short Index_127;
		public short Index_128;
		public short Index_129;
		public short Index_130;
		public short Index_131;
		public short Index_132;
		public short Index_133;
		public short Index_134;
		public short Index_135;
		public short Index_136;
		public short Index_137;
		public short Index_138;
		public short Index_139;

		public ImVectorImGuiKeyRoutingData Entries;
		/// <summary>
		/// Double-buffer to avoid reallocation (could use a shared buffer)<br/>
		/// </summary>
		public ImVectorImGuiKeyRoutingData EntriesNext;





		public unsafe void Clear()
		{
			fixed (ImGuiKeyRoutingTable* @this = &this)
			{
				ImGui.ClearNative(@this);
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImGuiKeyRoutingTable* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiKeyRoutingTablePtr : IEquatable<ImGuiKeyRoutingTablePtr>
	{
		public ImGuiKeyRoutingTablePtr(ImGuiKeyRoutingTable* handle) { Handle = handle; }

		public ImGuiKeyRoutingTable* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiKeyRoutingTablePtr Null => new ImGuiKeyRoutingTablePtr(null);

		public static implicit operator ImGuiKeyRoutingTablePtr(ImGuiKeyRoutingTable* handle) => new ImGuiKeyRoutingTablePtr(handle);

		public static implicit operator ImGuiKeyRoutingTable*(ImGuiKeyRoutingTablePtr handle) => handle.Handle;

		public static bool operator ==(ImGuiKeyRoutingTablePtr left, ImGuiKeyRoutingTablePtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiKeyRoutingTablePtr left, ImGuiKeyRoutingTablePtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiKeyRoutingTablePtr left, ImGuiKeyRoutingTable* right) => left.Handle == right;

		public static bool operator !=(ImGuiKeyRoutingTablePtr left, ImGuiKeyRoutingTable* right) => left.Handle != right;

		public bool Equals(ImGuiKeyRoutingTablePtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiKeyRoutingTablePtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiKeyRoutingTablePtr [0x{0}]", ((nuint)Handle).ToString("X"));
		/// <summary>
		/// Index of first entry in Entries[]<br/>
		/// </summary>
		public unsafe Span<short> Index
		
		{
			get
			{
				return new Span<short>(&Handle->Index_0, 140);
			}
		}
		public ref ImVectorImGuiKeyRoutingData Entries => ref Unsafe.AsRef<ImVectorImGuiKeyRoutingData>(&Handle->Entries);
		/// <summary>
		/// Double-buffer to avoid reallocation (could use a shared buffer)<br/>
		/// </summary>
		public ref ImVectorImGuiKeyRoutingData EntriesNext => ref Unsafe.AsRef<ImVectorImGuiKeyRoutingData>(&Handle->EntriesNext);

		public unsafe void Clear()
		{
			ImGui.ClearNative(Handle);
		}

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiKeyRoutingData
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiKeyRoutingData* Data;


	}

	/// <summary>
	/// Routing table entry (sizeof() == 16 bytes)<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiKeyRoutingData
	{
		public short NextEntryIndex;
		/// <summary>
		/// Technically we'd only need 4-bits but for simplify we store ImGuiMod_ values which need 16-bits. ImGuiMod_Shortcut is already translated to CtrlSuper.<br/>
		/// </summary>
		public ushort Mods;

		/// <summary>
		/// Lower is better (0: perfect score)<br/>
		/// </summary>
		public byte RoutingNextScore;

		public int RoutingCurr;
		public int RoutingNext;




		public unsafe void Destroy()
		{
			fixed (ImGuiKeyRoutingData* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiKeyRoutingDataPtr : IEquatable<ImGuiKeyRoutingDataPtr>
	{
		public ImGuiKeyRoutingDataPtr(ImGuiKeyRoutingData* handle) { Handle = handle; }

		public ImGuiKeyRoutingData* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiKeyRoutingDataPtr Null => new ImGuiKeyRoutingDataPtr(null);

		public static implicit operator ImGuiKeyRoutingDataPtr(ImGuiKeyRoutingData* handle) => new ImGuiKeyRoutingDataPtr(handle);

		public static implicit operator ImGuiKeyRoutingData*(ImGuiKeyRoutingDataPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiKeyRoutingDataPtr left, ImGuiKeyRoutingDataPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiKeyRoutingDataPtr left, ImGuiKeyRoutingDataPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiKeyRoutingDataPtr left, ImGuiKeyRoutingData* right) => left.Handle == right;

		public static bool operator !=(ImGuiKeyRoutingDataPtr left, ImGuiKeyRoutingData* right) => left.Handle != right;

		public bool Equals(ImGuiKeyRoutingDataPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiKeyRoutingDataPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiKeyRoutingDataPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref short NextEntryIndex => ref Unsafe.AsRef<short>(&Handle->NextEntryIndex);
		/// <summary>
		/// Technically we'd only need 4-bits but for simplify we store ImGuiMod_ values which need 16-bits. ImGuiMod_Shortcut is already translated to CtrlSuper.<br/>
		/// </summary>
		public ref ushort Mods => ref Unsafe.AsRef<ushort>(&Handle->Mods);
		/// <summary>
		/// Lower is better (0: perfect score)<br/>
		/// </summary>
		public ref byte RoutingNextScore => ref Unsafe.AsRef<byte>(&Handle->RoutingNextScore);
		public ref int RoutingCurr => ref Unsafe.AsRef<int>(&Handle->RoutingCurr);
		public ref int RoutingNext => ref Unsafe.AsRef<int>(&Handle->RoutingNext);

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiNextItemData
	{
		public ImGuiNextItemDataFlags Flags;
		/// <summary>
		/// Currently only testedused for ImGuiItemflags_AllowOverlap.<br/>
		/// </summary>
		public ImGuiItemFlags ItemFlags;

		/// <summary>
		/// Set by SetNextItemWidth()<br/>
		/// </summary>
		public float Width;

		/// <summary>
		/// Set by SetNextItemMultiSelectData() (!= 0 signify value has been set, so it's an alternate version of HasSelectionData, we don't use Flags for this because they are cleared too early. This is mostly used for debugging)<br/>
		/// </summary>
		public int FocusScopeId;

		public ImGuiCond OpenCond;
		/// <summary>
		/// Set by SetNextItemOpen()<br/>
		/// </summary>
		public byte OpenVal;





		/// <summary>		/// Also cleared manually by ItemAdd()!		/// </summary>		public unsafe void ClearFlags()
		{
			fixed (ImGuiNextItemData* @this = &this)
			{
				ImGui.ClearFlagsNative(@this);
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImGuiNextItemData* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiNextItemDataPtr : IEquatable<ImGuiNextItemDataPtr>
	{
		public ImGuiNextItemDataPtr(ImGuiNextItemData* handle) { Handle = handle; }

		public ImGuiNextItemData* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiNextItemDataPtr Null => new ImGuiNextItemDataPtr(null);

		public static implicit operator ImGuiNextItemDataPtr(ImGuiNextItemData* handle) => new ImGuiNextItemDataPtr(handle);

		public static implicit operator ImGuiNextItemData*(ImGuiNextItemDataPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiNextItemDataPtr left, ImGuiNextItemDataPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiNextItemDataPtr left, ImGuiNextItemDataPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiNextItemDataPtr left, ImGuiNextItemData* right) => left.Handle == right;

		public static bool operator !=(ImGuiNextItemDataPtr left, ImGuiNextItemData* right) => left.Handle != right;

		public bool Equals(ImGuiNextItemDataPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiNextItemDataPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiNextItemDataPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref ImGuiNextItemDataFlags Flags => ref Unsafe.AsRef<ImGuiNextItemDataFlags>(&Handle->Flags);
		/// <summary>
		/// Currently only testedused for ImGuiItemflags_AllowOverlap.<br/>
		/// </summary>
		public ref ImGuiItemFlags ItemFlags => ref Unsafe.AsRef<ImGuiItemFlags>(&Handle->ItemFlags);
		/// <summary>
		/// Set by SetNextItemWidth()<br/>
		/// </summary>
		public ref float Width => ref Unsafe.AsRef<float>(&Handle->Width);
		/// <summary>
		/// Set by SetNextItemMultiSelectData() (!= 0 signify value has been set, so it's an alternate version of HasSelectionData, we don't use Flags for this because they are cleared too early. This is mostly used for debugging)<br/>
		/// </summary>
		public ref int FocusScopeId => ref Unsafe.AsRef<int>(&Handle->FocusScopeId);
		public ref ImGuiCond OpenCond => ref Unsafe.AsRef<ImGuiCond>(&Handle->OpenCond);
		/// <summary>
		/// Set by SetNextItemOpen()<br/>
		/// </summary>
		public ref bool OpenVal => ref Unsafe.AsRef<bool>(&Handle->OpenVal);

		/// <summary>		/// Also cleared manually by ItemAdd()!		/// </summary>		public unsafe void ClearFlags()
		{
			ImGui.ClearFlagsNative(Handle);
		}

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

	}

	/// <summary>
	/// Storage for SetNexWindow** functions<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiNextWindowData
	{
		public ImGuiNextWindowDataFlags Flags;
		public ImGuiCond PosCond;
		public ImGuiCond SizeCond;
		public ImGuiCond CollapsedCond;
		public ImGuiCond DockCond;
		public Vector2 PosVal;
		public Vector2 PosPivotVal;
		public Vector2 SizeVal;
		public Vector2 ContentSizeVal;
		public Vector2 ScrollVal;
		public byte PosUndock;
		public byte CollapsedVal;
		public ImRect SizeConstraintRect;
		public unsafe void* SizeCallback;
		public unsafe void* SizeCallbackUserData;
		/// <summary>
		/// Override background alpha<br/>
		/// </summary>
		public float BgAlphaVal;

		public int ViewportId;
		public int DockId;
		public ImGuiWindowClass WindowClass;
		/// <summary>
		/// (Always on) This is not exposed publicly, so we don't clear it and it doesn't have a corresponding flag (could we? for consistency?)<br/>
		/// </summary>
		public Vector2 MenuBarOffsetMinVal;





		public unsafe void ClearFlags()
		{
			fixed (ImGuiNextWindowData* @this = &this)
			{
				ImGui.ClearFlagsNative(@this);
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImGuiNextWindowData* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiNextWindowDataPtr : IEquatable<ImGuiNextWindowDataPtr>
	{
		public ImGuiNextWindowDataPtr(ImGuiNextWindowData* handle) { Handle = handle; }

		public ImGuiNextWindowData* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiNextWindowDataPtr Null => new ImGuiNextWindowDataPtr(null);

		public static implicit operator ImGuiNextWindowDataPtr(ImGuiNextWindowData* handle) => new ImGuiNextWindowDataPtr(handle);

		public static implicit operator ImGuiNextWindowData*(ImGuiNextWindowDataPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiNextWindowDataPtr left, ImGuiNextWindowDataPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiNextWindowDataPtr left, ImGuiNextWindowDataPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiNextWindowDataPtr left, ImGuiNextWindowData* right) => left.Handle == right;

		public static bool operator !=(ImGuiNextWindowDataPtr left, ImGuiNextWindowData* right) => left.Handle != right;

		public bool Equals(ImGuiNextWindowDataPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiNextWindowDataPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiNextWindowDataPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref ImGuiNextWindowDataFlags Flags => ref Unsafe.AsRef<ImGuiNextWindowDataFlags>(&Handle->Flags);
		public ref ImGuiCond PosCond => ref Unsafe.AsRef<ImGuiCond>(&Handle->PosCond);
		public ref ImGuiCond SizeCond => ref Unsafe.AsRef<ImGuiCond>(&Handle->SizeCond);
		public ref ImGuiCond CollapsedCond => ref Unsafe.AsRef<ImGuiCond>(&Handle->CollapsedCond);
		public ref ImGuiCond DockCond => ref Unsafe.AsRef<ImGuiCond>(&Handle->DockCond);
		public ref Vector2 PosVal => ref Unsafe.AsRef<Vector2>(&Handle->PosVal);
		public ref Vector2 PosPivotVal => ref Unsafe.AsRef<Vector2>(&Handle->PosPivotVal);
		public ref Vector2 SizeVal => ref Unsafe.AsRef<Vector2>(&Handle->SizeVal);
		public ref Vector2 ContentSizeVal => ref Unsafe.AsRef<Vector2>(&Handle->ContentSizeVal);
		public ref Vector2 ScrollVal => ref Unsafe.AsRef<Vector2>(&Handle->ScrollVal);
		public ref bool PosUndock => ref Unsafe.AsRef<bool>(&Handle->PosUndock);
		public ref bool CollapsedVal => ref Unsafe.AsRef<bool>(&Handle->CollapsedVal);
		public ref ImRect SizeConstraintRect => ref Unsafe.AsRef<ImRect>(&Handle->SizeConstraintRect);
		public void* SizeCallback { get => Handle->SizeCallback; set => Handle->SizeCallback = value; }
		public void* SizeCallbackUserData { get => Handle->SizeCallbackUserData; set => Handle->SizeCallbackUserData = value; }
		/// <summary>
		/// Override background alpha<br/>
		/// </summary>
		public ref float BgAlphaVal => ref Unsafe.AsRef<float>(&Handle->BgAlphaVal);
		public ref int ViewportId => ref Unsafe.AsRef<int>(&Handle->ViewportId);
		public ref int DockId => ref Unsafe.AsRef<int>(&Handle->DockId);
		public ref ImGuiWindowClass WindowClass => ref Unsafe.AsRef<ImGuiWindowClass>(&Handle->WindowClass);
		/// <summary>
		/// (Always on) This is not exposed publicly, so we don't clear it and it doesn't have a corresponding flag (could we? for consistency?)<br/>
		/// </summary>
		public ref Vector2 MenuBarOffsetMinVal => ref Unsafe.AsRef<Vector2>(&Handle->MenuBarOffsetMinVal);

		public unsafe void ClearFlags()
		{
			ImGui.ClearFlagsNative(Handle);
		}

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

	}

	/// <summary>
	/// Resizing callback data to apply custom constraint. As enabled by SetNextWindowSizeConstraints(). Callback is called during the next Begin().<br/>
	/// NB: For basic minmax size constraint on each axis you don't need to use the callback! The SetNextWindowSizeConstraints() parameters are enough.<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiSizeCallbackData
	{
		/// <summary>
		/// Read-only.   What user passed to SetNextWindowSizeConstraints(). Generally store an integer or float in here (need reinterpret_cast&lt;&gt;).<br/>
		/// </summary>
		public unsafe void* UserData;

		/// <summary>
		/// Read-only.   Window position, for reference.<br/>
		/// </summary>
		public Vector2 Pos;

		/// <summary>
		/// Read-only.   Current window size.<br/>
		/// </summary>
		public Vector2 CurrentSize;

		/// <summary>
		/// Read-write.  Desired size, based on user's mouse position. Write to this field to restrain resizing.<br/>
		/// </summary>
		public Vector2 DesiredSize;



	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiColorMod
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiColorMod* Data;


	}

	/// <summary>
	/// Stacked color modifier, backup of modified data so we can restore it<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiColorMod
	{
		public ImGuiCol Col;
		public Vector4 BackupValue;


	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiColorModPtr : IEquatable<ImGuiColorModPtr>
	{
		public ImGuiColorModPtr(ImGuiColorMod* handle) { Handle = handle; }

		public ImGuiColorMod* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiColorModPtr Null => new ImGuiColorModPtr(null);

		public static implicit operator ImGuiColorModPtr(ImGuiColorMod* handle) => new ImGuiColorModPtr(handle);

		public static implicit operator ImGuiColorMod*(ImGuiColorModPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiColorModPtr left, ImGuiColorModPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiColorModPtr left, ImGuiColorModPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiColorModPtr left, ImGuiColorMod* right) => left.Handle == right;

		public static bool operator !=(ImGuiColorModPtr left, ImGuiColorMod* right) => left.Handle != right;

		public bool Equals(ImGuiColorModPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiColorModPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiColorModPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref ImGuiCol Col => ref Unsafe.AsRef<ImGuiCol>(&Handle->Col);
		public ref Vector4 BackupValue => ref Unsafe.AsRef<Vector4>(&Handle->BackupValue);
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiStyleMod
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiStyleMod* Data;


	}

	[StructLayout(LayoutKind.Explicit)]
	public partial struct ImGuiStyleModUnion
	{
		[FieldOffset(0)]
		public int BackupInt_0;
		[FieldOffset(8)]
		public int BackupInt_1;
		[FieldOffset(0)]
		public float BackupFloat_0;
		[FieldOffset(8)]
		public float BackupFloat_1;


	}

	/// <summary>
	/// Stacked style modifier, backup of modified data so we can restore it. Data type inferred from the variable.<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiStyleMod
	{
		public ImGuiStyleVar VarIdx;
		public ImGuiStyleModUnion ImGuiStyleModUnion;




		public unsafe void Destroy()
		{
			fixed (ImGuiStyleMod* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiStyleModPtr : IEquatable<ImGuiStyleModPtr>
	{
		public ImGuiStyleModPtr(ImGuiStyleMod* handle) { Handle = handle; }

		public ImGuiStyleMod* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiStyleModPtr Null => new ImGuiStyleModPtr(null);

		public static implicit operator ImGuiStyleModPtr(ImGuiStyleMod* handle) => new ImGuiStyleModPtr(handle);

		public static implicit operator ImGuiStyleMod*(ImGuiStyleModPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiStyleModPtr left, ImGuiStyleModPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiStyleModPtr left, ImGuiStyleModPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiStyleModPtr left, ImGuiStyleMod* right) => left.Handle == right;

		public static bool operator !=(ImGuiStyleModPtr left, ImGuiStyleMod* right) => left.Handle != right;

		public bool Equals(ImGuiStyleModPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiStyleModPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiStyleModPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref ImGuiStyleVar VarIdx => ref Unsafe.AsRef<ImGuiStyleVar>(&Handle->VarIdx);
		public ref ImGuiStyleModUnion ImGuiStyleModUnion => ref Unsafe.AsRef<ImGuiStyleModUnion>(&Handle->ImGuiStyleModUnion);

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiItemFlags
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiItemFlags* Data;


	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiGroupData
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiGroupData* Data;


	}

	/// <summary>
	/// Stacked storage data for BeginGroup()EndGroup()<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiGroupData
	{
		public int WindowID;
		public Vector2 BackupCursorPos;
		public Vector2 BackupCursorMaxPos;
		public ImVec1 BackupIndent;
		public ImVec1 BackupGroupOffset;
		public Vector2 BackupCurrLineSize;
		public float BackupCurrLineTextBaseOffset;
		public int BackupActiveIdIsAlive;
		public byte BackupActiveIdPreviousFrameIsAlive;
		public byte BackupHoveredIdIsAlive;
		public byte EmitItem;


	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiGroupDataPtr : IEquatable<ImGuiGroupDataPtr>
	{
		public ImGuiGroupDataPtr(ImGuiGroupData* handle) { Handle = handle; }

		public ImGuiGroupData* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiGroupDataPtr Null => new ImGuiGroupDataPtr(null);

		public static implicit operator ImGuiGroupDataPtr(ImGuiGroupData* handle) => new ImGuiGroupDataPtr(handle);

		public static implicit operator ImGuiGroupData*(ImGuiGroupDataPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiGroupDataPtr left, ImGuiGroupDataPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiGroupDataPtr left, ImGuiGroupDataPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiGroupDataPtr left, ImGuiGroupData* right) => left.Handle == right;

		public static bool operator !=(ImGuiGroupDataPtr left, ImGuiGroupData* right) => left.Handle != right;

		public bool Equals(ImGuiGroupDataPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiGroupDataPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiGroupDataPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref int WindowID => ref Unsafe.AsRef<int>(&Handle->WindowID);
		public ref Vector2 BackupCursorPos => ref Unsafe.AsRef<Vector2>(&Handle->BackupCursorPos);
		public ref Vector2 BackupCursorMaxPos => ref Unsafe.AsRef<Vector2>(&Handle->BackupCursorMaxPos);
		public ref ImVec1 BackupIndent => ref Unsafe.AsRef<ImVec1>(&Handle->BackupIndent);
		public ref ImVec1 BackupGroupOffset => ref Unsafe.AsRef<ImVec1>(&Handle->BackupGroupOffset);
		public ref Vector2 BackupCurrLineSize => ref Unsafe.AsRef<Vector2>(&Handle->BackupCurrLineSize);
		public ref float BackupCurrLineTextBaseOffset => ref Unsafe.AsRef<float>(&Handle->BackupCurrLineTextBaseOffset);
		public ref int BackupActiveIdIsAlive => ref Unsafe.AsRef<int>(&Handle->BackupActiveIdIsAlive);
		public ref bool BackupActiveIdPreviousFrameIsAlive => ref Unsafe.AsRef<bool>(&Handle->BackupActiveIdPreviousFrameIsAlive);
		public ref bool BackupHoveredIdIsAlive => ref Unsafe.AsRef<bool>(&Handle->BackupHoveredIdIsAlive);
		public ref bool EmitItem => ref Unsafe.AsRef<bool>(&Handle->EmitItem);
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiPopupData
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiPopupData* Data;


	}

	/// <summary>
	/// Storage for current popup stack<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiPopupData
	{
		/// <summary>
		/// Set on OpenPopup()<br/>
		/// </summary>
		public int PopupId;

		/// <summary>
		/// Resolved on BeginPopup() - may stay unresolved if user never calls OpenPopup()<br/>
		/// </summary>
		public unsafe ImGuiWindow* Window;

		/// <summary>
		/// Set on OpenPopup(), a NavWindow that will be restored on popup close<br/>
		/// </summary>
		public unsafe ImGuiWindow* BackupNavWindow;

		/// <summary>
		/// Resolved on BeginPopup(). Actually a ImGuiNavLayer type (declared down below), initialized to -1 which is not part of an enum, but serves well-enough as "not any of layers" value<br/>
		/// </summary>
		public int ParentNavLayer;

		/// <summary>
		/// Set on OpenPopup()<br/>
		/// </summary>
		public int OpenFrameCount;

		/// <summary>
		/// Set on OpenPopup(), we need this to differentiate multiple menu sets from each others (e.g. inside menu bar vs loose menu items)<br/>
		/// </summary>
		public int OpenParentId;

		/// <summary>
		/// Set on OpenPopup(), preferred popup position (typically == OpenMousePos when using mouse)<br/>
		/// </summary>
		public Vector2 OpenPopupPos;

		/// <summary>
		/// Set on OpenPopup(), copy of mouse position at the time of opening popup<br/>
		/// </summary>
		public Vector2 OpenMousePos;





		public unsafe void Destroy()
		{
			fixed (ImGuiPopupData* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiPopupDataPtr : IEquatable<ImGuiPopupDataPtr>
	{
		public ImGuiPopupDataPtr(ImGuiPopupData* handle) { Handle = handle; }

		public ImGuiPopupData* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiPopupDataPtr Null => new ImGuiPopupDataPtr(null);

		public static implicit operator ImGuiPopupDataPtr(ImGuiPopupData* handle) => new ImGuiPopupDataPtr(handle);

		public static implicit operator ImGuiPopupData*(ImGuiPopupDataPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiPopupDataPtr left, ImGuiPopupDataPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiPopupDataPtr left, ImGuiPopupDataPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiPopupDataPtr left, ImGuiPopupData* right) => left.Handle == right;

		public static bool operator !=(ImGuiPopupDataPtr left, ImGuiPopupData* right) => left.Handle != right;

		public bool Equals(ImGuiPopupDataPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiPopupDataPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiPopupDataPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		/// <summary>
		/// Set on OpenPopup()<br/>
		/// </summary>
		public ref int PopupId => ref Unsafe.AsRef<int>(&Handle->PopupId);
		/// <summary>
		/// Resolved on BeginPopup() - may stay unresolved if user never calls OpenPopup()<br/>
		/// </summary>
		public ref ImGuiWindowPtr Window => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->Window);
		/// <summary>
		/// Set on OpenPopup(), a NavWindow that will be restored on popup close<br/>
		/// </summary>
		public ref ImGuiWindowPtr BackupNavWindow => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->BackupNavWindow);
		/// <summary>
		/// Resolved on BeginPopup(). Actually a ImGuiNavLayer type (declared down below), initialized to -1 which is not part of an enum, but serves well-enough as "not any of layers" value<br/>
		/// </summary>
		public ref int ParentNavLayer => ref Unsafe.AsRef<int>(&Handle->ParentNavLayer);
		/// <summary>
		/// Set on OpenPopup()<br/>
		/// </summary>
		public ref int OpenFrameCount => ref Unsafe.AsRef<int>(&Handle->OpenFrameCount);
		/// <summary>
		/// Set on OpenPopup(), we need this to differentiate multiple menu sets from each others (e.g. inside menu bar vs loose menu items)<br/>
		/// </summary>
		public ref int OpenParentId => ref Unsafe.AsRef<int>(&Handle->OpenParentId);
		/// <summary>
		/// Set on OpenPopup(), preferred popup position (typically == OpenMousePos when using mouse)<br/>
		/// </summary>
		public ref Vector2 OpenPopupPos => ref Unsafe.AsRef<Vector2>(&Handle->OpenPopupPos);
		/// <summary>
		/// Set on OpenPopup(), copy of mouse position at the time of opening popup<br/>
		/// </summary>
		public ref Vector2 OpenMousePos => ref Unsafe.AsRef<Vector2>(&Handle->OpenMousePos);

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiViewportPPtr
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiViewportP** Data;


	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiNavItemData
	{
		/// <summary>
		/// Init,Move     Best candidate window (result-&gt;ItemWindow-&gt;RootWindowForNav == request-&gt;Window)<br/>
		/// </summary>
		public unsafe ImGuiWindow* Window;

		/// <summary>
		/// Init,Move     Best candidate item ID<br/>
		/// </summary>
		public int ID;

		/// <summary>
		/// Init,Move     Best candidate focus scope ID<br/>
		/// </summary>
		public int FocusScopeId;

		/// <summary>
		/// Init,Move     Best candidate bounding box in window relative space<br/>
		/// </summary>
		public ImRect RectRel;

		/// <summary>
		/// ????,Move     Best candidate item flags<br/>
		/// </summary>
		public ImGuiItemFlags InFlags;

		/// <summary>
		/// Move     Best candidate box distance to current NavId<br/>
		/// </summary>
		public float DistBox;

		/// <summary>
		/// Move     Best candidate center distance to current NavId<br/>
		/// </summary>
		public float DistCenter;

		/// <summary>
		/// Move     Best candidate axial distance to current NavId<br/>
		/// </summary>
		public float DistAxial;





		public unsafe void Clear()
		{
			fixed (ImGuiNavItemData* @this = &this)
			{
				ImGui.ClearNative(@this);
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImGuiNavItemData* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiNavItemDataPtr : IEquatable<ImGuiNavItemDataPtr>
	{
		public ImGuiNavItemDataPtr(ImGuiNavItemData* handle) { Handle = handle; }

		public ImGuiNavItemData* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiNavItemDataPtr Null => new ImGuiNavItemDataPtr(null);

		public static implicit operator ImGuiNavItemDataPtr(ImGuiNavItemData* handle) => new ImGuiNavItemDataPtr(handle);

		public static implicit operator ImGuiNavItemData*(ImGuiNavItemDataPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiNavItemDataPtr left, ImGuiNavItemDataPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiNavItemDataPtr left, ImGuiNavItemDataPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiNavItemDataPtr left, ImGuiNavItemData* right) => left.Handle == right;

		public static bool operator !=(ImGuiNavItemDataPtr left, ImGuiNavItemData* right) => left.Handle != right;

		public bool Equals(ImGuiNavItemDataPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiNavItemDataPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiNavItemDataPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		/// <summary>
		/// Init,Move     Best candidate window (result-&gt;ItemWindow-&gt;RootWindowForNav == request-&gt;Window)<br/>
		/// </summary>
		public ref ImGuiWindowPtr Window => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->Window);
		/// <summary>
		/// Init,Move     Best candidate item ID<br/>
		/// </summary>
		public ref int ID => ref Unsafe.AsRef<int>(&Handle->ID);
		/// <summary>
		/// Init,Move     Best candidate focus scope ID<br/>
		/// </summary>
		public ref int FocusScopeId => ref Unsafe.AsRef<int>(&Handle->FocusScopeId);
		/// <summary>
		/// Init,Move     Best candidate bounding box in window relative space<br/>
		/// </summary>
		public ref ImRect RectRel => ref Unsafe.AsRef<ImRect>(&Handle->RectRel);
		/// <summary>
		/// ????,Move     Best candidate item flags<br/>
		/// </summary>
		public ref ImGuiItemFlags InFlags => ref Unsafe.AsRef<ImGuiItemFlags>(&Handle->InFlags);
		/// <summary>
		/// Move     Best candidate box distance to current NavId<br/>
		/// </summary>
		public ref float DistBox => ref Unsafe.AsRef<float>(&Handle->DistBox);
		/// <summary>
		/// Move     Best candidate center distance to current NavId<br/>
		/// </summary>
		public ref float DistCenter => ref Unsafe.AsRef<float>(&Handle->DistCenter);
		/// <summary>
		/// Move     Best candidate axial distance to current NavId<br/>
		/// </summary>
		public ref float DistAxial => ref Unsafe.AsRef<float>(&Handle->DistAxial);

		public unsafe void Clear()
		{
			ImGui.ClearNative(Handle);
		}

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

	}

	/// <summary>
	/// Data payload for Drag and Drop operations: AcceptDragDropPayload(), GetDragDropPayload()<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiPayload
	{
		/// <summary>
		/// Members Data (copied and owned by dear imgui)<br/>
		/// </summary>
		public unsafe void* Data;

		/// <summary>
		/// Data size<br/>
		/// </summary>
		public int DataSize;

		/// <summary>
		/// [Internal] Source item id<br/>
		/// </summary>
		public int SourceId;

		/// <summary>
		/// Source parent id (if available)<br/>
		/// </summary>
		public int SourceParentId;

		/// <summary>
		/// Data timestamp<br/>
		/// </summary>
		public int DataFrameCount;

		/// <summary>
		/// Data type tag (short user-supplied string, 32 characters max)<br/>
		/// </summary>
		public byte DataType_0;
		public byte DataType_1;
		public byte DataType_2;
		public byte DataType_3;
		public byte DataType_4;
		public byte DataType_5;
		public byte DataType_6;
		public byte DataType_7;
		public byte DataType_8;
		public byte DataType_9;
		public byte DataType_10;
		public byte DataType_11;
		public byte DataType_12;
		public byte DataType_13;
		public byte DataType_14;
		public byte DataType_15;
		public byte DataType_16;
		public byte DataType_17;
		public byte DataType_18;
		public byte DataType_19;
		public byte DataType_20;
		public byte DataType_21;
		public byte DataType_22;
		public byte DataType_23;
		public byte DataType_24;
		public byte DataType_25;
		public byte DataType_26;
		public byte DataType_27;
		public byte DataType_28;
		public byte DataType_29;
		public byte DataType_30;
		public byte DataType_31;
		public byte DataType_32;

		/// <summary>
		/// Set when AcceptDragDropPayload() was called and mouse has been hovering the target item (nb: handle overlapping drag targets)<br/>
		/// </summary>
		public byte Preview;

		/// <summary>
		/// Set when AcceptDragDropPayload() was called and mouse button is released over the target item.<br/>
		/// </summary>
		public byte Delivery;





		public unsafe void Clear()
		{
			fixed (ImGuiPayload* @this = &this)
			{
				ImGui.ClearNative(@this);
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImGuiPayload* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe bool IsDataType(byte* type)
		{
			fixed (ImGuiPayload* @this = &this)
			{
				byte ret = ImGui.IsDataTypeNative(@this, type);
				return ret != 0;
			}
		}

		public unsafe bool IsDataType(ref byte type)
		{
			fixed (ImGuiPayload* @this = &this)
			{
				fixed (byte* ptype = &type)
				{
					byte ret = ImGui.IsDataTypeNative(@this, (byte*)ptype);
					return ret != 0;
				}
			}
		}

		public unsafe bool IsDataType(string type)
		{
			fixed (ImGuiPayload* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (type != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(type);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGui.IsDataTypeNative(@this, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public unsafe bool IsDelivery()
		{
			fixed (ImGuiPayload* @this = &this)
			{
				byte ret = ImGui.IsDeliveryNative(@this);
				return ret != 0;
			}
		}

		public unsafe bool IsPreview()
		{
			fixed (ImGuiPayload* @this = &this)
			{
				byte ret = ImGui.IsPreviewNative(@this);
				return ret != 0;
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiPayloadPtr : IEquatable<ImGuiPayloadPtr>
	{
		public ImGuiPayloadPtr(ImGuiPayload* handle) { Handle = handle; }

		public ImGuiPayload* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiPayloadPtr Null => new ImGuiPayloadPtr(null);

		public static implicit operator ImGuiPayloadPtr(ImGuiPayload* handle) => new ImGuiPayloadPtr(handle);

		public static implicit operator ImGuiPayload*(ImGuiPayloadPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiPayloadPtr left, ImGuiPayloadPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiPayloadPtr left, ImGuiPayloadPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiPayloadPtr left, ImGuiPayload* right) => left.Handle == right;

		public static bool operator !=(ImGuiPayloadPtr left, ImGuiPayload* right) => left.Handle != right;

		public bool Equals(ImGuiPayloadPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiPayloadPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiPayloadPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		/// <summary>
		/// Members Data (copied and owned by dear imgui)<br/>
		/// </summary>
		public void* Data { get => Handle->Data; set => Handle->Data = value; }
		/// <summary>
		/// Data size<br/>
		/// </summary>
		public ref int DataSize => ref Unsafe.AsRef<int>(&Handle->DataSize);
		/// <summary>
		/// [Internal] Source item id<br/>
		/// </summary>
		public ref int SourceId => ref Unsafe.AsRef<int>(&Handle->SourceId);
		/// <summary>
		/// Source parent id (if available)<br/>
		/// </summary>
		public ref int SourceParentId => ref Unsafe.AsRef<int>(&Handle->SourceParentId);
		/// <summary>
		/// Data timestamp<br/>
		/// </summary>
		public ref int DataFrameCount => ref Unsafe.AsRef<int>(&Handle->DataFrameCount);
		/// <summary>
		/// Data type tag (short user-supplied string, 32 characters max)<br/>
		/// </summary>
		public unsafe Span<byte> DataType
		
		{
			get
			{
				return new Span<byte>(&Handle->DataType_0, 33);
			}
		}
		/// <summary>
		/// Set when AcceptDragDropPayload() was called and mouse has been hovering the target item (nb: handle overlapping drag targets)<br/>
		/// </summary>
		public ref bool Preview => ref Unsafe.AsRef<bool>(&Handle->Preview);
		/// <summary>
		/// Set when AcceptDragDropPayload() was called and mouse button is released over the target item.<br/>
		/// </summary>
		public ref bool Delivery => ref Unsafe.AsRef<bool>(&Handle->Delivery);

		public unsafe void Clear()
		{
			ImGui.ClearNative(Handle);
		}

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

		public unsafe bool IsDataType(byte* type)
		{
			byte ret = ImGui.IsDataTypeNative(Handle, type);
			return ret != 0;
		}

		public unsafe bool IsDataType(ref byte type)
		{
			fixed (byte* ptype = &type)
			{
				byte ret = ImGui.IsDataTypeNative(Handle, (byte*)ptype);
				return ret != 0;
			}
		}

		public unsafe bool IsDataType(string type)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (type != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(type);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGui.IsDataTypeNative(Handle, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public unsafe bool IsDelivery()
		{
			byte ret = ImGui.IsDeliveryNative(Handle);
			return ret != 0;
		}

		public unsafe bool IsPreview()
		{
			byte ret = ImGui.IsPreviewNative(Handle);
			return ret != 0;
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorUnsignedChar
	{
		public int Size;
		public int Capacity;
		public unsafe byte* Data;


	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiListClipperData
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiListClipperData* Data;


	}

	/// <summary>
	/// Temporary clipper data, buffers sharedreused between instances<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiListClipperData
	{
		public unsafe ImGuiListClipper* ListClipper;
		public float LossynessOffset;
		public int StepNo;
		public int ItemsFrozen;
		public ImVectorImGuiListClipperRange Ranges;




		public unsafe void Destroy()
		{
			fixed (ImGuiListClipperData* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe void Reset(ImGuiListClipper* clipper)
		{
			fixed (ImGuiListClipperData* @this = &this)
			{
				ImGui.ResetNative(@this, clipper);
			}
		}

		public unsafe void Reset(ref ImGuiListClipper clipper)
		{
			fixed (ImGuiListClipperData* @this = &this)
			{
				fixed (ImGuiListClipper* pclipper = &clipper)
				{
					ImGui.ResetNative(@this, (ImGuiListClipper*)pclipper);
				}
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiListClipperDataPtr : IEquatable<ImGuiListClipperDataPtr>
	{
		public ImGuiListClipperDataPtr(ImGuiListClipperData* handle) { Handle = handle; }

		public ImGuiListClipperData* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiListClipperDataPtr Null => new ImGuiListClipperDataPtr(null);

		public static implicit operator ImGuiListClipperDataPtr(ImGuiListClipperData* handle) => new ImGuiListClipperDataPtr(handle);

		public static implicit operator ImGuiListClipperData*(ImGuiListClipperDataPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiListClipperDataPtr left, ImGuiListClipperDataPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiListClipperDataPtr left, ImGuiListClipperDataPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiListClipperDataPtr left, ImGuiListClipperData* right) => left.Handle == right;

		public static bool operator !=(ImGuiListClipperDataPtr left, ImGuiListClipperData* right) => left.Handle != right;

		public bool Equals(ImGuiListClipperDataPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiListClipperDataPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiListClipperDataPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref ImGuiListClipperPtr ListClipper => ref Unsafe.AsRef<ImGuiListClipperPtr>(&Handle->ListClipper);
		public ref float LossynessOffset => ref Unsafe.AsRef<float>(&Handle->LossynessOffset);
		public ref int StepNo => ref Unsafe.AsRef<int>(&Handle->StepNo);
		public ref int ItemsFrozen => ref Unsafe.AsRef<int>(&Handle->ItemsFrozen);
		public ref ImVectorImGuiListClipperRange Ranges => ref Unsafe.AsRef<ImVectorImGuiListClipperRange>(&Handle->Ranges);

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

		public unsafe void Reset(ImGuiListClipper* clipper)
		{
			ImGui.ResetNative(Handle, clipper);
		}

		public unsafe void Reset(ref ImGuiListClipper clipper)
		{
			fixed (ImGuiListClipper* pclipper = &clipper)
			{
				ImGui.ResetNative(Handle, (ImGuiListClipper*)pclipper);
			}
		}

	}

	/// <summary>
	/// Helper: Manually clip large list of items.<br/>
	/// If you have lots evenly spaced items and you have random access to the list, you can perform coarse<br/>
	/// clipping based on visibility to only submit items that are in view.<br/>
	/// The clipper calculates the range of visible items and advance the cursor to compensate for the non-visible items we have skipped.<br/>
	/// (Dear ImGui already clip items based on their bounds but: it needs to first layout the item to do so, and generally<br/>
	/// fetchingsubmitting your own data incurs additional cost. Coarse clipping using ImGuiListClipper allows you to easily<br/>
	/// scale using lists with tens of thousands of items without a problem)<br/>
	/// Usage:<br/>
	/// ImGuiListClipper clipper;<br/>
	/// clipper.Begin(1000);          We have 1000 elements, evenly spaced.<br/>
	/// while (clipper.Step())<br/>
	/// for (int i = clipper.DisplayStart; i &lt; clipper.DisplayEnd; i++)<br/>
	/// ImGui::Text("line number %d", i);<br/>
	/// Generally what happens is:<br/>
	/// - Clipper lets you process the first element (DisplayStart = 0, DisplayEnd = 1) regardless of it being visible or not.<br/>
	/// - User code submit that one element.<br/>
	/// - Clipper can measure the height of the first element<br/>
	/// - Clipper calculate the actual range of elements to display based on the current clipping rectangle, position the cursor before the first visible element.<br/>
	/// - User code submit visible elements.<br/>
	/// - The clipper also handles various subtleties related to keyboardgamepad navigation, wrapping etc.<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiListClipper
	{
		/// <summary>
		/// Parent UI context<br/>
		/// </summary>
		public unsafe ImGuiContext* Ctx;

		/// <summary>
		/// First item to display, updated by each call to Step()<br/>
		/// </summary>
		public int DisplayStart;

		/// <summary>
		/// End of items to display (exclusive)<br/>
		/// </summary>
		public int DisplayEnd;

		/// <summary>
		/// [Internal] Number of items<br/>
		/// </summary>
		public int ItemsCount;

		/// <summary>
		/// [Internal] Height of item after a first step and item submission can calculate it<br/>
		/// </summary>
		public float ItemsHeight;

		/// <summary>
		/// [Internal] Cursor position at the time of Begin() or after table frozen rows are all processed<br/>
		/// </summary>
		public float StartPosY;

		/// <summary>
		/// [Internal] Internal data<br/>
		/// </summary>
		public unsafe void* TempData;





		public unsafe void Begin(int itemsCount, float itemsHeight)
		{
			fixed (ImGuiListClipper* @this = &this)
			{
				ImGui.BeginNative(@this, itemsCount, itemsHeight);
			}
		}

		public unsafe void Begin(int itemsCount)
		{
			fixed (ImGuiListClipper* @this = &this)
			{
				ImGui.BeginNative(@this, itemsCount, (float)(-1.0f));
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImGuiListClipper* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		/// <summary>		/// Automatically called on the last call of Step() that returns false.		/// </summary>		public unsafe void End()
		{
			fixed (ImGuiListClipper* @this = &this)
			{
				ImGui.EndNative(@this);
			}
		}

		/// <summary>		/// item_end is exclusive e.g. use (42, 42+1) to make item 42 never clipped.		/// </summary>		public unsafe void IncludeRangeByIndices(int itemBegin, int itemEnd)
		{
			fixed (ImGuiListClipper* @this = &this)
			{
				ImGui.IncludeRangeByIndicesNative(@this, itemBegin, itemEnd);
			}
		}

		/// <summary>		/// Call until it returns false. The DisplayStartDisplayEnd fields will be set and you can processdraw those items.		/// </summary>		public unsafe bool Step()
		{
			fixed (ImGuiListClipper* @this = &this)
			{
				byte ret = ImGui.StepNative(@this);
				return ret != 0;
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiListClipperPtr : IEquatable<ImGuiListClipperPtr>
	{
		public ImGuiListClipperPtr(ImGuiListClipper* handle) { Handle = handle; }

		public ImGuiListClipper* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiListClipperPtr Null => new ImGuiListClipperPtr(null);

		public static implicit operator ImGuiListClipperPtr(ImGuiListClipper* handle) => new ImGuiListClipperPtr(handle);

		public static implicit operator ImGuiListClipper*(ImGuiListClipperPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiListClipperPtr left, ImGuiListClipperPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiListClipperPtr left, ImGuiListClipperPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiListClipperPtr left, ImGuiListClipper* right) => left.Handle == right;

		public static bool operator !=(ImGuiListClipperPtr left, ImGuiListClipper* right) => left.Handle != right;

		public bool Equals(ImGuiListClipperPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiListClipperPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiListClipperPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		/// <summary>
		/// Parent UI context<br/>
		/// </summary>
		public ref ImGuiContextPtr Ctx => ref Unsafe.AsRef<ImGuiContextPtr>(&Handle->Ctx);
		/// <summary>
		/// First item to display, updated by each call to Step()<br/>
		/// </summary>
		public ref int DisplayStart => ref Unsafe.AsRef<int>(&Handle->DisplayStart);
		/// <summary>
		/// End of items to display (exclusive)<br/>
		/// </summary>
		public ref int DisplayEnd => ref Unsafe.AsRef<int>(&Handle->DisplayEnd);
		/// <summary>
		/// [Internal] Number of items<br/>
		/// </summary>
		public ref int ItemsCount => ref Unsafe.AsRef<int>(&Handle->ItemsCount);
		/// <summary>
		/// [Internal] Height of item after a first step and item submission can calculate it<br/>
		/// </summary>
		public ref float ItemsHeight => ref Unsafe.AsRef<float>(&Handle->ItemsHeight);
		/// <summary>
		/// [Internal] Cursor position at the time of Begin() or after table frozen rows are all processed<br/>
		/// </summary>
		public ref float StartPosY => ref Unsafe.AsRef<float>(&Handle->StartPosY);
		/// <summary>
		/// [Internal] Internal data<br/>
		/// </summary>
		public void* TempData { get => Handle->TempData; set => Handle->TempData = value; }

		public unsafe void Begin(int itemsCount, float itemsHeight)
		{
			ImGui.BeginNative(Handle, itemsCount, itemsHeight);
		}

		public unsafe void Begin(int itemsCount)
		{
			ImGui.BeginNative(Handle, itemsCount, (float)(-1.0f));
		}

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

		/// <summary>		/// Automatically called on the last call of Step() that returns false.		/// </summary>		public unsafe void End()
		{
			ImGui.EndNative(Handle);
		}

		/// <summary>		/// item_end is exclusive e.g. use (42, 42+1) to make item 42 never clipped.		/// </summary>		public unsafe void IncludeRangeByIndices(int itemBegin, int itemEnd)
		{
			ImGui.IncludeRangeByIndicesNative(Handle, itemBegin, itemEnd);
		}

		/// <summary>		/// Call until it returns false. The DisplayStartDisplayEnd fields will be set and you can processdraw those items.		/// </summary>		public unsafe bool Step()
		{
			byte ret = ImGui.StepNative(Handle);
			return ret != 0;
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiListClipperRange
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiListClipperRange* Data;


	}

	/// <summary>
	/// Note that Max is exclusive, so perhaps should be using a BeginEnd convention.<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiListClipperRange
	{
		public int Min;
		public int Max;
		/// <summary>
		/// BeginEnd are absolute position (will be converted to indices later)<br/>
		/// </summary>
		public byte PosToIndexConvert;

		/// <summary>
		/// Add to Min after converting to indices<br/>
		/// </summary>
		public sbyte PosToIndexOffsetMin;

		/// <summary>
		/// Add to Min after converting to indices<br/>
		/// </summary>
		public sbyte PosToIndexOffsetMax;




	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiListClipperRangePtr : IEquatable<ImGuiListClipperRangePtr>
	{
		public ImGuiListClipperRangePtr(ImGuiListClipperRange* handle) { Handle = handle; }

		public ImGuiListClipperRange* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiListClipperRangePtr Null => new ImGuiListClipperRangePtr(null);

		public static implicit operator ImGuiListClipperRangePtr(ImGuiListClipperRange* handle) => new ImGuiListClipperRangePtr(handle);

		public static implicit operator ImGuiListClipperRange*(ImGuiListClipperRangePtr handle) => handle.Handle;

		public static bool operator ==(ImGuiListClipperRangePtr left, ImGuiListClipperRangePtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiListClipperRangePtr left, ImGuiListClipperRangePtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiListClipperRangePtr left, ImGuiListClipperRange* right) => left.Handle == right;

		public static bool operator !=(ImGuiListClipperRangePtr left, ImGuiListClipperRange* right) => left.Handle != right;

		public bool Equals(ImGuiListClipperRangePtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiListClipperRangePtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiListClipperRangePtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref int Min => ref Unsafe.AsRef<int>(&Handle->Min);
		public ref int Max => ref Unsafe.AsRef<int>(&Handle->Max);
		/// <summary>
		/// BeginEnd are absolute position (will be converted to indices later)<br/>
		/// </summary>
		public ref bool PosToIndexConvert => ref Unsafe.AsRef<bool>(&Handle->PosToIndexConvert);
		/// <summary>
		/// Add to Min after converting to indices<br/>
		/// </summary>
		public ref sbyte PosToIndexOffsetMin => ref Unsafe.AsRef<sbyte>(&Handle->PosToIndexOffsetMin);
		/// <summary>
		/// Add to Min after converting to indices<br/>
		/// </summary>
		public ref sbyte PosToIndexOffsetMax => ref Unsafe.AsRef<sbyte>(&Handle->PosToIndexOffsetMax);

	}

	/// <summary>
	/// FIXME-TABLE: more transient data could be stored in a stacked ImGuiTableTempData: e.g. SortSpecs, incoming RowData<br/>
	/// sizeof() ~ 580 bytes + heap allocs described in TableBeginInitMemory()<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTable
	{
		public int ID;
		public ImGuiTableFlags Flags;
		/// <summary>
		/// Single allocation to hold Columns[], DisplayOrderToIndex[] and RowCellData[]<br/>
		/// </summary>
		public unsafe void* RawData;

		/// <summary>
		/// Transient data while table is active. Point within g.CurrentTableStack[]<br/>
		/// </summary>
		public unsafe ImGuiTableTempData* TempData;

		/// <summary>
		/// Point within RawData[]<br/>
		/// </summary>
		public ImSpanImGuiTableColumn Columns;

		/// <summary>
		/// Point within RawData[]. Store display order of columns (when not reordered, the values are 0...Count-1)<br/>
		/// </summary>
		public ImSpanImGuiTableColumnIdx DisplayOrderToIndex;

		/// <summary>
		/// Point within RawData[]. Store cells background requests for current row.<br/>
		/// </summary>
		public ImSpanImGuiTableCellData RowCellData;

		/// <summary>
		/// Column DisplayOrder -&gt; IsEnabled map<br/>
		/// </summary>
		public ImBitArrayPtr EnabledMaskByDisplayOrder;

		/// <summary>
		/// Column Index -&gt; IsEnabled map (== not hidden by userapi) in a format adequate for iterating column without touching cold data<br/>
		/// </summary>
		public ImBitArrayPtr EnabledMaskByIndex;

		/// <summary>
		/// Column Index -&gt; IsVisibleX|IsVisibleY map (== not hidden by userapi &amp;&amp; not hidden by scrollingcliprect)<br/>
		/// </summary>
		public ImBitArrayPtr VisibleMaskByIndex;

		/// <summary>
		/// Which data were loaded from the .ini file (e.g. when order is not altered we won't save order)<br/>
		/// </summary>
		public ImGuiTableFlags SettingsLoadedFlags;

		/// <summary>
		/// Offset in g.SettingsTables<br/>
		/// </summary>
		public int SettingsOffset;

		public int LastFrameActive;
		/// <summary>
		/// Number of columns declared in BeginTable()<br/>
		/// </summary>
		public int ColumnsCount;

		public int CurrentRow;
		public int CurrentColumn;
		/// <summary>
		/// Count of BeginTable() calls with same ID in the same frame (generally 0). This is a little bit similar to BeginCount for a window, but multiple table with same ID look are multiple tables, they are just synched.<br/>
		/// </summary>
		public short InstanceCurrent;

		/// <summary>
		/// Mark which instance (generally 0) of the same ID is being interacted with<br/>
		/// </summary>
		public short InstanceInteracted;

		public float RowPosY1;
		public float RowPosY2;
		/// <summary>
		/// Height submitted to TableNextRow()<br/>
		/// </summary>
		public float RowMinHeight;

		public float RowTextBaseline;
		public float RowIndentOffsetX;
		/// <summary>
		/// Current row flags, see ImGuiTableRowFlags_<br/>
		/// </summary>
		public ImGuiTableRowFlags RowFlags;

		public ImGuiTableRowFlags LastRowFlags;
		/// <summary>
		/// Counter for alternating background colors (can be fast-forwarded by e.g clipper), not same as CurrentRow because header rows typically don't increase this.<br/>
		/// </summary>
		public int RowBgColorCounter;

		/// <summary>
		/// Background color override for current row.<br/>
		/// </summary>
		public uint RowBgColor_0;
		public uint RowBgColor_1;

		public uint BorderColorStrong;
		public uint BorderColorLight;
		public float BorderX1;
		public float BorderX2;
		public float HostIndentX;
		public float MinColumnWidth;
		public float OuterPaddingX;
		/// <summary>
		/// Padding from each borders<br/>
		/// </summary>
		public float CellPaddingX;

		public float CellPaddingY;
		/// <summary>
		/// Spacing between non-bordered cells<br/>
		/// </summary>
		public float CellSpacingX1;

		public float CellSpacingX2;
		/// <summary>
		/// User value passed to BeginTable(), see comments at the top of BeginTable() for details.<br/>
		/// </summary>
		public float InnerWidth;

		/// <summary>
		/// Sum of current column width<br/>
		/// </summary>
		public float ColumnsGivenWidth;

		/// <summary>
		/// Sum of ideal column width in order nothing to be clipped, used for auto-fitting and content width submission in outer window<br/>
		/// </summary>
		public float ColumnsAutoFitWidth;

		/// <summary>
		/// Sum of weight of all enabled stretching columns<br/>
		/// </summary>
		public float ColumnsStretchSumWeights;

		public float ResizedColumnNextWidth;
		/// <summary>
		/// Lock minimum contents width while resizing down in order to not create feedback loops. But we allow growing the table.<br/>
		/// </summary>
		public float ResizeLockMinContentsX2;

		/// <summary>
		/// Reference scale to be able to rescale columns on fontdpi changes.<br/>
		/// </summary>
		public float RefScale;

		/// <summary>
		/// Note: for non-scrolling table, OuterRect.Max.y is often FLT_MAX until EndTable(), unless a height has been specified in BeginTable().<br/>
		/// </summary>
		public ImRect OuterRect;

		/// <summary>
		/// InnerRect but without decoration. As with OuterRect, for non-scrolling tables, InnerRect.Max.y is<br/>
		/// </summary>
		public ImRect InnerRect;

		public ImRect WorkRect;
		public ImRect InnerClipRect;
		/// <summary>
		/// We use this to cpu-clip cell background color fill, evolve during the frame as we cross frozen rows boundaries<br/>
		/// </summary>
		public ImRect BgClipRect;

		/// <summary>
		/// Actual ImDrawCmd clip rect for BG01 channel. This tends to be == OuterWindow-&gt;ClipRect at BeginTable() because output in BG0BG1 is cpu-clipped<br/>
		/// </summary>
		public ImRect Bg0ClipRectForDrawCmd;

		/// <summary>
		/// Actual ImDrawCmd clip rect for BG2 channel. This tends to be a correct, tight-fit, because output to BG2 are done by widgets relying on regular ClipRect.<br/>
		/// </summary>
		public ImRect Bg2ClipRectForDrawCmd;

		/// <summary>
		/// This is used to check if we can eventually merge our columns draw calls into the current draw call of the current window.<br/>
		/// </summary>
		public ImRect HostClipRect;

		/// <summary>
		/// Backup of InnerWindow-&gt;ClipRect during PushTableBackground()PopTableBackground()<br/>
		/// </summary>
		public ImRect HostBackupInnerClipRect;

		/// <summary>
		/// Parent window for the table<br/>
		/// </summary>
		public unsafe ImGuiWindow* OuterWindow;

		/// <summary>
		/// Window holding the table data (== OuterWindow or a child window)<br/>
		/// </summary>
		public unsafe ImGuiWindow* InnerWindow;

		/// <summary>
		/// Contiguous buffer holding columns names<br/>
		/// </summary>
		public ImGuiTextBuffer ColumnsNames;

		/// <summary>
		/// Shortcut to TempData-&gt;DrawSplitter while in table. Isolate draw commands per columns to avoid switching clip rect constantly<br/>
		/// </summary>
		public unsafe ImDrawListSplitter* DrawSplitter;

		public ImGuiTableInstanceData InstanceDataFirst;
		/// <summary>
		/// FIXME-OPT: Using a small-vector pattern would be good.<br/>
		/// </summary>
		public ImVectorImGuiTableInstanceData InstanceDataExtra;

		public ImGuiTableColumnSortSpecs SortSpecsSingle;
		/// <summary>
		/// FIXME-OPT: Using a small-vector pattern would be good.<br/>
		/// </summary>
		public ImVectorImGuiTableColumnSortSpecs SortSpecsMulti;

		/// <summary>
		/// Public facing sorts specs, this is what we return in TableGetSortSpecs()<br/>
		/// </summary>
		public ImGuiTableSortSpecs SortSpecs;

		public sbyte SortSpecsCount;
		/// <summary>
		/// Number of enabled columns (&lt;= ColumnsCount)<br/>
		/// </summary>
		public sbyte ColumnsEnabledCount;

		/// <summary>
		/// Number of enabled columns (&lt;= ColumnsCount)<br/>
		/// </summary>
		public sbyte ColumnsEnabledFixedCount;

		/// <summary>
		/// Count calls to TableSetupColumn()<br/>
		/// </summary>
		public sbyte DeclColumnsCount;

		/// <summary>
		/// Index of column whose visible region is being hovered. Important: == ColumnsCount when hovering empty region after the right-most column!<br/>
		/// </summary>
		public sbyte HoveredColumnBody;

		/// <summary>
		/// Index of column whose right-border is being hovered (for resizing).<br/>
		/// </summary>
		public sbyte HoveredColumnBorder;

		/// <summary>
		/// Index of single column requesting auto-fit.<br/>
		/// </summary>
		public sbyte AutoFitSingleColumn;

		/// <summary>
		/// Index of column being resized. Reset when InstanceCurrent==0.<br/>
		/// </summary>
		public sbyte ResizedColumn;

		/// <summary>
		/// Index of column being resized from previous frame.<br/>
		/// </summary>
		public sbyte LastResizedColumn;

		/// <summary>
		/// Index of column header being held.<br/>
		/// </summary>
		public sbyte HeldHeaderColumn;

		/// <summary>
		/// Index of column being reordered. (not cleared)<br/>
		/// </summary>
		public sbyte ReorderColumn;

		/// <summary>
		/// -1 or +1<br/>
		/// </summary>
		public sbyte ReorderColumnDir;

		/// <summary>
		/// Index of left-most non-hidden column.<br/>
		/// </summary>
		public sbyte LeftMostEnabledColumn;

		/// <summary>
		/// Index of right-most non-hidden column.<br/>
		/// </summary>
		public sbyte RightMostEnabledColumn;

		/// <summary>
		/// Index of left-most stretched column.<br/>
		/// </summary>
		public sbyte LeftMostStretchedColumn;

		/// <summary>
		/// Index of right-most stretched column.<br/>
		/// </summary>
		public sbyte RightMostStretchedColumn;

		/// <summary>
		/// Column right-clicked on, of -1 if opening context menu from a neutralempty spot<br/>
		/// </summary>
		public sbyte ContextPopupColumn;

		/// <summary>
		/// Requested frozen rows count<br/>
		/// </summary>
		public sbyte FreezeRowsRequest;

		/// <summary>
		/// Actual frozen row count (== FreezeRowsRequest, or == 0 when no scrolling offset)<br/>
		/// </summary>
		public sbyte FreezeRowsCount;

		/// <summary>
		/// Requested frozen columns count<br/>
		/// </summary>
		public sbyte FreezeColumnsRequest;

		/// <summary>
		/// Actual frozen columns count (== FreezeColumnsRequest, or == 0 when no scrolling offset)<br/>
		/// </summary>
		public sbyte FreezeColumnsCount;

		/// <summary>
		/// Index of current RowCellData[] entry in current row<br/>
		/// </summary>
		public sbyte RowCellDataCurrent;

		/// <summary>
		/// Redirect non-visible columns here.<br/>
		/// </summary>
		public byte DummyDrawChannel;

		/// <summary>
		/// For Selectable() and other widgets drawing across columns after the freezing line. Index within DrawSplitter.Channels[]<br/>
		/// </summary>
		public byte Bg2DrawChannelCurrent;

		public byte Bg2DrawChannelUnfrozen;
		/// <summary>
		/// Set by TableUpdateLayout() which is called when beginning the first row.<br/>
		/// </summary>
		public byte IsLayoutLocked;

		/// <summary>
		/// Set when inside TableBeginRow()TableEndRow().<br/>
		/// </summary>
		public byte IsInsideRow;

		public byte IsInitializing;
		public byte IsSortSpecsDirty;
		/// <summary>
		/// Set when the first row had the ImGuiTableRowFlags_Headers flag.<br/>
		/// </summary>
		public byte IsUsingHeaders;

		/// <summary>
		/// Set when default context menu is open (also see: ContextPopupColumn, InstanceInteracted).<br/>
		/// </summary>
		public byte IsContextPopupOpen;

		public byte IsSettingsRequestLoad;
		/// <summary>
		/// Set when table settings have changed and needs to be reported into ImGuiTableSetttings data.<br/>
		/// </summary>
		public byte IsSettingsDirty;

		/// <summary>
		/// Set when display order is unchanged from default (DisplayOrder contains 0...Count-1)<br/>
		/// </summary>
		public byte IsDefaultDisplayOrder;

		public byte IsResetAllRequest;
		public byte IsResetDisplayOrderRequest;
		/// <summary>
		/// Set when we got past the frozen row.<br/>
		/// </summary>
		public byte IsUnfrozenRows;

		/// <summary>
		/// Set if user didn't explicitly set a sizing policy in BeginTable()<br/>
		/// </summary>
		public byte IsDefaultSizingPolicy;

		/// <summary>
		/// Whether ANY instance of this table had a vertical scrollbar during the current frame.<br/>
		/// </summary>
		public byte HasScrollbarYCurr;

		/// <summary>
		/// Whether ANY instance of this table had a vertical scrollbar during the previous.<br/>
		/// </summary>
		public byte HasScrollbarYPrev;

		public byte MemoryCompacted;
		/// <summary>
		/// Backup of InnerWindow-&gt;SkipItem at the end of BeginTable(), because we will overwrite InnerWindow-&gt;SkipItem on a per-column basis<br/>
		/// </summary>
		public byte HostSkipItems;





		public unsafe void Destroy()
		{
			fixed (ImGuiTable* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiTablePtr : IEquatable<ImGuiTablePtr>
	{
		public ImGuiTablePtr(ImGuiTable* handle) { Handle = handle; }

		public ImGuiTable* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiTablePtr Null => new ImGuiTablePtr(null);

		public static implicit operator ImGuiTablePtr(ImGuiTable* handle) => new ImGuiTablePtr(handle);

		public static implicit operator ImGuiTable*(ImGuiTablePtr handle) => handle.Handle;

		public static bool operator ==(ImGuiTablePtr left, ImGuiTablePtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiTablePtr left, ImGuiTablePtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiTablePtr left, ImGuiTable* right) => left.Handle == right;

		public static bool operator !=(ImGuiTablePtr left, ImGuiTable* right) => left.Handle != right;

		public bool Equals(ImGuiTablePtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiTablePtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiTablePtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref int ID => ref Unsafe.AsRef<int>(&Handle->ID);
		public ref ImGuiTableFlags Flags => ref Unsafe.AsRef<ImGuiTableFlags>(&Handle->Flags);
		/// <summary>
		/// Single allocation to hold Columns[], DisplayOrderToIndex[] and RowCellData[]<br/>
		/// </summary>
		public void* RawData { get => Handle->RawData; set => Handle->RawData = value; }
		/// <summary>
		/// Transient data while table is active. Point within g.CurrentTableStack[]<br/>
		/// </summary>
		public ref ImGuiTableTempDataPtr TempData => ref Unsafe.AsRef<ImGuiTableTempDataPtr>(&Handle->TempData);
		/// <summary>
		/// Point within RawData[]<br/>
		/// </summary>
		public ref ImSpanImGuiTableColumn Columns => ref Unsafe.AsRef<ImSpanImGuiTableColumn>(&Handle->Columns);
		/// <summary>
		/// Point within RawData[]. Store display order of columns (when not reordered, the values are 0...Count-1)<br/>
		/// </summary>
		public ref ImSpanImGuiTableColumnIdx DisplayOrderToIndex => ref Unsafe.AsRef<ImSpanImGuiTableColumnIdx>(&Handle->DisplayOrderToIndex);
		/// <summary>
		/// Point within RawData[]. Store cells background requests for current row.<br/>
		/// </summary>
		public ref ImSpanImGuiTableCellData RowCellData => ref Unsafe.AsRef<ImSpanImGuiTableCellData>(&Handle->RowCellData);
		/// <summary>
		/// Column DisplayOrder -&gt; IsEnabled map<br/>
		/// </summary>
		public ref ImBitArrayPtr EnabledMaskByDisplayOrder => ref Unsafe.AsRef<ImBitArrayPtr>(&Handle->EnabledMaskByDisplayOrder);
		/// <summary>
		/// Column Index -&gt; IsEnabled map (== not hidden by userapi) in a format adequate for iterating column without touching cold data<br/>
		/// </summary>
		public ref ImBitArrayPtr EnabledMaskByIndex => ref Unsafe.AsRef<ImBitArrayPtr>(&Handle->EnabledMaskByIndex);
		/// <summary>
		/// Column Index -&gt; IsVisibleX|IsVisibleY map (== not hidden by userapi &amp;&amp; not hidden by scrollingcliprect)<br/>
		/// </summary>
		public ref ImBitArrayPtr VisibleMaskByIndex => ref Unsafe.AsRef<ImBitArrayPtr>(&Handle->VisibleMaskByIndex);
		/// <summary>
		/// Which data were loaded from the .ini file (e.g. when order is not altered we won't save order)<br/>
		/// </summary>
		public ref ImGuiTableFlags SettingsLoadedFlags => ref Unsafe.AsRef<ImGuiTableFlags>(&Handle->SettingsLoadedFlags);
		/// <summary>
		/// Offset in g.SettingsTables<br/>
		/// </summary>
		public ref int SettingsOffset => ref Unsafe.AsRef<int>(&Handle->SettingsOffset);
		public ref int LastFrameActive => ref Unsafe.AsRef<int>(&Handle->LastFrameActive);
		/// <summary>
		/// Number of columns declared in BeginTable()<br/>
		/// </summary>
		public ref int ColumnsCount => ref Unsafe.AsRef<int>(&Handle->ColumnsCount);
		public ref int CurrentRow => ref Unsafe.AsRef<int>(&Handle->CurrentRow);
		public ref int CurrentColumn => ref Unsafe.AsRef<int>(&Handle->CurrentColumn);
		/// <summary>
		/// Count of BeginTable() calls with same ID in the same frame (generally 0). This is a little bit similar to BeginCount for a window, but multiple table with same ID look are multiple tables, they are just synched.<br/>
		/// </summary>
		public ref short InstanceCurrent => ref Unsafe.AsRef<short>(&Handle->InstanceCurrent);
		/// <summary>
		/// Mark which instance (generally 0) of the same ID is being interacted with<br/>
		/// </summary>
		public ref short InstanceInteracted => ref Unsafe.AsRef<short>(&Handle->InstanceInteracted);
		public ref float RowPosY1 => ref Unsafe.AsRef<float>(&Handle->RowPosY1);
		public ref float RowPosY2 => ref Unsafe.AsRef<float>(&Handle->RowPosY2);
		/// <summary>
		/// Height submitted to TableNextRow()<br/>
		/// </summary>
		public ref float RowMinHeight => ref Unsafe.AsRef<float>(&Handle->RowMinHeight);
		public ref float RowTextBaseline => ref Unsafe.AsRef<float>(&Handle->RowTextBaseline);
		public ref float RowIndentOffsetX => ref Unsafe.AsRef<float>(&Handle->RowIndentOffsetX);
		/// <summary>
		/// Current row flags, see ImGuiTableRowFlags_<br/>
		/// </summary>
		public ref ImGuiTableRowFlags RowFlags => ref Unsafe.AsRef<ImGuiTableRowFlags>(&Handle->RowFlags);
		public ref ImGuiTableRowFlags LastRowFlags => ref Unsafe.AsRef<ImGuiTableRowFlags>(&Handle->LastRowFlags);
		/// <summary>
		/// Counter for alternating background colors (can be fast-forwarded by e.g clipper), not same as CurrentRow because header rows typically don't increase this.<br/>
		/// </summary>
		public ref int RowBgColorCounter => ref Unsafe.AsRef<int>(&Handle->RowBgColorCounter);
		/// <summary>
		/// Background color override for current row.<br/>
		/// </summary>
		public unsafe Span<uint> RowBgColor
		
		{
			get
			{
				return new Span<uint>(&Handle->RowBgColor_0, 2);
			}
		}
		public ref uint BorderColorStrong => ref Unsafe.AsRef<uint>(&Handle->BorderColorStrong);
		public ref uint BorderColorLight => ref Unsafe.AsRef<uint>(&Handle->BorderColorLight);
		public ref float BorderX1 => ref Unsafe.AsRef<float>(&Handle->BorderX1);
		public ref float BorderX2 => ref Unsafe.AsRef<float>(&Handle->BorderX2);
		public ref float HostIndentX => ref Unsafe.AsRef<float>(&Handle->HostIndentX);
		public ref float MinColumnWidth => ref Unsafe.AsRef<float>(&Handle->MinColumnWidth);
		public ref float OuterPaddingX => ref Unsafe.AsRef<float>(&Handle->OuterPaddingX);
		/// <summary>
		/// Padding from each borders<br/>
		/// </summary>
		public ref float CellPaddingX => ref Unsafe.AsRef<float>(&Handle->CellPaddingX);
		public ref float CellPaddingY => ref Unsafe.AsRef<float>(&Handle->CellPaddingY);
		/// <summary>
		/// Spacing between non-bordered cells<br/>
		/// </summary>
		public ref float CellSpacingX1 => ref Unsafe.AsRef<float>(&Handle->CellSpacingX1);
		public ref float CellSpacingX2 => ref Unsafe.AsRef<float>(&Handle->CellSpacingX2);
		/// <summary>
		/// User value passed to BeginTable(), see comments at the top of BeginTable() for details.<br/>
		/// </summary>
		public ref float InnerWidth => ref Unsafe.AsRef<float>(&Handle->InnerWidth);
		/// <summary>
		/// Sum of current column width<br/>
		/// </summary>
		public ref float ColumnsGivenWidth => ref Unsafe.AsRef<float>(&Handle->ColumnsGivenWidth);
		/// <summary>
		/// Sum of ideal column width in order nothing to be clipped, used for auto-fitting and content width submission in outer window<br/>
		/// </summary>
		public ref float ColumnsAutoFitWidth => ref Unsafe.AsRef<float>(&Handle->ColumnsAutoFitWidth);
		/// <summary>
		/// Sum of weight of all enabled stretching columns<br/>
		/// </summary>
		public ref float ColumnsStretchSumWeights => ref Unsafe.AsRef<float>(&Handle->ColumnsStretchSumWeights);
		public ref float ResizedColumnNextWidth => ref Unsafe.AsRef<float>(&Handle->ResizedColumnNextWidth);
		/// <summary>
		/// Lock minimum contents width while resizing down in order to not create feedback loops. But we allow growing the table.<br/>
		/// </summary>
		public ref float ResizeLockMinContentsX2 => ref Unsafe.AsRef<float>(&Handle->ResizeLockMinContentsX2);
		/// <summary>
		/// Reference scale to be able to rescale columns on fontdpi changes.<br/>
		/// </summary>
		public ref float RefScale => ref Unsafe.AsRef<float>(&Handle->RefScale);
		/// <summary>
		/// Note: for non-scrolling table, OuterRect.Max.y is often FLT_MAX until EndTable(), unless a height has been specified in BeginTable().<br/>
		/// </summary>
		public ref ImRect OuterRect => ref Unsafe.AsRef<ImRect>(&Handle->OuterRect);
		/// <summary>
		/// InnerRect but without decoration. As with OuterRect, for non-scrolling tables, InnerRect.Max.y is<br/>
		/// </summary>
		public ref ImRect InnerRect => ref Unsafe.AsRef<ImRect>(&Handle->InnerRect);
		public ref ImRect WorkRect => ref Unsafe.AsRef<ImRect>(&Handle->WorkRect);
		public ref ImRect InnerClipRect => ref Unsafe.AsRef<ImRect>(&Handle->InnerClipRect);
		/// <summary>
		/// We use this to cpu-clip cell background color fill, evolve during the frame as we cross frozen rows boundaries<br/>
		/// </summary>
		public ref ImRect BgClipRect => ref Unsafe.AsRef<ImRect>(&Handle->BgClipRect);
		/// <summary>
		/// Actual ImDrawCmd clip rect for BG01 channel. This tends to be == OuterWindow-&gt;ClipRect at BeginTable() because output in BG0BG1 is cpu-clipped<br/>
		/// </summary>
		public ref ImRect Bg0ClipRectForDrawCmd => ref Unsafe.AsRef<ImRect>(&Handle->Bg0ClipRectForDrawCmd);
		/// <summary>
		/// Actual ImDrawCmd clip rect for BG2 channel. This tends to be a correct, tight-fit, because output to BG2 are done by widgets relying on regular ClipRect.<br/>
		/// </summary>
		public ref ImRect Bg2ClipRectForDrawCmd => ref Unsafe.AsRef<ImRect>(&Handle->Bg2ClipRectForDrawCmd);
		/// <summary>
		/// This is used to check if we can eventually merge our columns draw calls into the current draw call of the current window.<br/>
		/// </summary>
		public ref ImRect HostClipRect => ref Unsafe.AsRef<ImRect>(&Handle->HostClipRect);
		/// <summary>
		/// Backup of InnerWindow-&gt;ClipRect during PushTableBackground()PopTableBackground()<br/>
		/// </summary>
		public ref ImRect HostBackupInnerClipRect => ref Unsafe.AsRef<ImRect>(&Handle->HostBackupInnerClipRect);
		/// <summary>
		/// Parent window for the table<br/>
		/// </summary>
		public ref ImGuiWindowPtr OuterWindow => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->OuterWindow);
		/// <summary>
		/// Window holding the table data (== OuterWindow or a child window)<br/>
		/// </summary>
		public ref ImGuiWindowPtr InnerWindow => ref Unsafe.AsRef<ImGuiWindowPtr>(&Handle->InnerWindow);
		/// <summary>
		/// Contiguous buffer holding columns names<br/>
		/// </summary>
		public ref ImGuiTextBuffer ColumnsNames => ref Unsafe.AsRef<ImGuiTextBuffer>(&Handle->ColumnsNames);
		/// <summary>
		/// Shortcut to TempData-&gt;DrawSplitter while in table. Isolate draw commands per columns to avoid switching clip rect constantly<br/>
		/// </summary>
		public ref ImDrawListSplitterPtr DrawSplitter => ref Unsafe.AsRef<ImDrawListSplitterPtr>(&Handle->DrawSplitter);
		public ref ImGuiTableInstanceData InstanceDataFirst => ref Unsafe.AsRef<ImGuiTableInstanceData>(&Handle->InstanceDataFirst);
		/// <summary>
		/// FIXME-OPT: Using a small-vector pattern would be good.<br/>
		/// </summary>
		public ref ImVectorImGuiTableInstanceData InstanceDataExtra => ref Unsafe.AsRef<ImVectorImGuiTableInstanceData>(&Handle->InstanceDataExtra);
		public ref ImGuiTableColumnSortSpecs SortSpecsSingle => ref Unsafe.AsRef<ImGuiTableColumnSortSpecs>(&Handle->SortSpecsSingle);
		/// <summary>
		/// FIXME-OPT: Using a small-vector pattern would be good.<br/>
		/// </summary>
		public ref ImVectorImGuiTableColumnSortSpecs SortSpecsMulti => ref Unsafe.AsRef<ImVectorImGuiTableColumnSortSpecs>(&Handle->SortSpecsMulti);
		/// <summary>
		/// Public facing sorts specs, this is what we return in TableGetSortSpecs()<br/>
		/// </summary>
		public ref ImGuiTableSortSpecs SortSpecs => ref Unsafe.AsRef<ImGuiTableSortSpecs>(&Handle->SortSpecs);
		public ref sbyte SortSpecsCount => ref Unsafe.AsRef<sbyte>(&Handle->SortSpecsCount);
		/// <summary>
		/// Number of enabled columns (&lt;= ColumnsCount)<br/>
		/// </summary>
		public ref sbyte ColumnsEnabledCount => ref Unsafe.AsRef<sbyte>(&Handle->ColumnsEnabledCount);
		/// <summary>
		/// Number of enabled columns (&lt;= ColumnsCount)<br/>
		/// </summary>
		public ref sbyte ColumnsEnabledFixedCount => ref Unsafe.AsRef<sbyte>(&Handle->ColumnsEnabledFixedCount);
		/// <summary>
		/// Count calls to TableSetupColumn()<br/>
		/// </summary>
		public ref sbyte DeclColumnsCount => ref Unsafe.AsRef<sbyte>(&Handle->DeclColumnsCount);
		/// <summary>
		/// Index of column whose visible region is being hovered. Important: == ColumnsCount when hovering empty region after the right-most column!<br/>
		/// </summary>
		public ref sbyte HoveredColumnBody => ref Unsafe.AsRef<sbyte>(&Handle->HoveredColumnBody);
		/// <summary>
		/// Index of column whose right-border is being hovered (for resizing).<br/>
		/// </summary>
		public ref sbyte HoveredColumnBorder => ref Unsafe.AsRef<sbyte>(&Handle->HoveredColumnBorder);
		/// <summary>
		/// Index of single column requesting auto-fit.<br/>
		/// </summary>
		public ref sbyte AutoFitSingleColumn => ref Unsafe.AsRef<sbyte>(&Handle->AutoFitSingleColumn);
		/// <summary>
		/// Index of column being resized. Reset when InstanceCurrent==0.<br/>
		/// </summary>
		public ref sbyte ResizedColumn => ref Unsafe.AsRef<sbyte>(&Handle->ResizedColumn);
		/// <summary>
		/// Index of column being resized from previous frame.<br/>
		/// </summary>
		public ref sbyte LastResizedColumn => ref Unsafe.AsRef<sbyte>(&Handle->LastResizedColumn);
		/// <summary>
		/// Index of column header being held.<br/>
		/// </summary>
		public ref sbyte HeldHeaderColumn => ref Unsafe.AsRef<sbyte>(&Handle->HeldHeaderColumn);
		/// <summary>
		/// Index of column being reordered. (not cleared)<br/>
		/// </summary>
		public ref sbyte ReorderColumn => ref Unsafe.AsRef<sbyte>(&Handle->ReorderColumn);
		/// <summary>
		/// -1 or +1<br/>
		/// </summary>
		public ref sbyte ReorderColumnDir => ref Unsafe.AsRef<sbyte>(&Handle->ReorderColumnDir);
		/// <summary>
		/// Index of left-most non-hidden column.<br/>
		/// </summary>
		public ref sbyte LeftMostEnabledColumn => ref Unsafe.AsRef<sbyte>(&Handle->LeftMostEnabledColumn);
		/// <summary>
		/// Index of right-most non-hidden column.<br/>
		/// </summary>
		public ref sbyte RightMostEnabledColumn => ref Unsafe.AsRef<sbyte>(&Handle->RightMostEnabledColumn);
		/// <summary>
		/// Index of left-most stretched column.<br/>
		/// </summary>
		public ref sbyte LeftMostStretchedColumn => ref Unsafe.AsRef<sbyte>(&Handle->LeftMostStretchedColumn);
		/// <summary>
		/// Index of right-most stretched column.<br/>
		/// </summary>
		public ref sbyte RightMostStretchedColumn => ref Unsafe.AsRef<sbyte>(&Handle->RightMostStretchedColumn);
		/// <summary>
		/// Column right-clicked on, of -1 if opening context menu from a neutralempty spot<br/>
		/// </summary>
		public ref sbyte ContextPopupColumn => ref Unsafe.AsRef<sbyte>(&Handle->ContextPopupColumn);
		/// <summary>
		/// Requested frozen rows count<br/>
		/// </summary>
		public ref sbyte FreezeRowsRequest => ref Unsafe.AsRef<sbyte>(&Handle->FreezeRowsRequest);
		/// <summary>
		/// Actual frozen row count (== FreezeRowsRequest, or == 0 when no scrolling offset)<br/>
		/// </summary>
		public ref sbyte FreezeRowsCount => ref Unsafe.AsRef<sbyte>(&Handle->FreezeRowsCount);
		/// <summary>
		/// Requested frozen columns count<br/>
		/// </summary>
		public ref sbyte FreezeColumnsRequest => ref Unsafe.AsRef<sbyte>(&Handle->FreezeColumnsRequest);
		/// <summary>
		/// Actual frozen columns count (== FreezeColumnsRequest, or == 0 when no scrolling offset)<br/>
		/// </summary>
		public ref sbyte FreezeColumnsCount => ref Unsafe.AsRef<sbyte>(&Handle->FreezeColumnsCount);
		/// <summary>
		/// Index of current RowCellData[] entry in current row<br/>
		/// </summary>
		public ref sbyte RowCellDataCurrent => ref Unsafe.AsRef<sbyte>(&Handle->RowCellDataCurrent);
		/// <summary>
		/// Redirect non-visible columns here.<br/>
		/// </summary>
		public ref byte DummyDrawChannel => ref Unsafe.AsRef<byte>(&Handle->DummyDrawChannel);
		/// <summary>
		/// For Selectable() and other widgets drawing across columns after the freezing line. Index within DrawSplitter.Channels[]<br/>
		/// </summary>
		public ref byte Bg2DrawChannelCurrent => ref Unsafe.AsRef<byte>(&Handle->Bg2DrawChannelCurrent);
		public ref byte Bg2DrawChannelUnfrozen => ref Unsafe.AsRef<byte>(&Handle->Bg2DrawChannelUnfrozen);
		/// <summary>
		/// Set by TableUpdateLayout() which is called when beginning the first row.<br/>
		/// </summary>
		public ref bool IsLayoutLocked => ref Unsafe.AsRef<bool>(&Handle->IsLayoutLocked);
		/// <summary>
		/// Set when inside TableBeginRow()TableEndRow().<br/>
		/// </summary>
		public ref bool IsInsideRow => ref Unsafe.AsRef<bool>(&Handle->IsInsideRow);
		public ref bool IsInitializing => ref Unsafe.AsRef<bool>(&Handle->IsInitializing);
		public ref bool IsSortSpecsDirty => ref Unsafe.AsRef<bool>(&Handle->IsSortSpecsDirty);
		/// <summary>
		/// Set when the first row had the ImGuiTableRowFlags_Headers flag.<br/>
		/// </summary>
		public ref bool IsUsingHeaders => ref Unsafe.AsRef<bool>(&Handle->IsUsingHeaders);
		/// <summary>
		/// Set when default context menu is open (also see: ContextPopupColumn, InstanceInteracted).<br/>
		/// </summary>
		public ref bool IsContextPopupOpen => ref Unsafe.AsRef<bool>(&Handle->IsContextPopupOpen);
		public ref bool IsSettingsRequestLoad => ref Unsafe.AsRef<bool>(&Handle->IsSettingsRequestLoad);
		/// <summary>
		/// Set when table settings have changed and needs to be reported into ImGuiTableSetttings data.<br/>
		/// </summary>
		public ref bool IsSettingsDirty => ref Unsafe.AsRef<bool>(&Handle->IsSettingsDirty);
		/// <summary>
		/// Set when display order is unchanged from default (DisplayOrder contains 0...Count-1)<br/>
		/// </summary>
		public ref bool IsDefaultDisplayOrder => ref Unsafe.AsRef<bool>(&Handle->IsDefaultDisplayOrder);
		public ref bool IsResetAllRequest => ref Unsafe.AsRef<bool>(&Handle->IsResetAllRequest);
		public ref bool IsResetDisplayOrderRequest => ref Unsafe.AsRef<bool>(&Handle->IsResetDisplayOrderRequest);
		/// <summary>
		/// Set when we got past the frozen row.<br/>
		/// </summary>
		public ref bool IsUnfrozenRows => ref Unsafe.AsRef<bool>(&Handle->IsUnfrozenRows);
		/// <summary>
		/// Set if user didn't explicitly set a sizing policy in BeginTable()<br/>
		/// </summary>
		public ref bool IsDefaultSizingPolicy => ref Unsafe.AsRef<bool>(&Handle->IsDefaultSizingPolicy);
		/// <summary>
		/// Whether ANY instance of this table had a vertical scrollbar during the current frame.<br/>
		/// </summary>
		public ref bool HasScrollbarYCurr => ref Unsafe.AsRef<bool>(&Handle->HasScrollbarYCurr);
		/// <summary>
		/// Whether ANY instance of this table had a vertical scrollbar during the previous.<br/>
		/// </summary>
		public ref bool HasScrollbarYPrev => ref Unsafe.AsRef<bool>(&Handle->HasScrollbarYPrev);
		public ref bool MemoryCompacted => ref Unsafe.AsRef<bool>(&Handle->MemoryCompacted);
		/// <summary>
		/// Backup of InnerWindow-&gt;SkipItem at the end of BeginTable(), because we will overwrite InnerWindow-&gt;SkipItem on a per-column basis<br/>
		/// </summary>
		public ref bool HostSkipItems => ref Unsafe.AsRef<bool>(&Handle->HostSkipItems);

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

	}

	/// <summary>
	/// Transient data that are only needed between BeginTable() and EndTable(), those buffers are shared (1 per level of stacked table).<br/>
	/// - Accessing those requires chasing an extra pointer so for very frequently used data we leave them in the main table structure.<br/>
	/// - We also leave out of this structure data that tend to be particularly useful for debuggingmetrics.<br/>
	/// sizeof() ~ 112 bytes.<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTableTempData
	{
		/// <summary>
		/// Index in g.Tables.Buf[] pool<br/>
		/// </summary>
		public int TableIndex;

		/// <summary>
		/// Last timestamp this structure was used<br/>
		/// </summary>
		public float LastTimeActive;

		/// <summary>
		/// outer_size.x passed to BeginTable()<br/>
		/// </summary>
		public Vector2 UserOuterSize;

		public ImDrawListSplitter DrawSplitter;
		/// <summary>
		/// Backup of InnerWindow-&gt;WorkRect at the end of BeginTable()<br/>
		/// </summary>
		public ImRect HostBackupWorkRect;

		/// <summary>
		/// Backup of InnerWindow-&gt;ParentWorkRect at the end of BeginTable()<br/>
		/// </summary>
		public ImRect HostBackupParentWorkRect;

		/// <summary>
		/// Backup of InnerWindow-&gt;DC.PrevLineSize at the end of BeginTable()<br/>
		/// </summary>
		public Vector2 HostBackupPrevLineSize;

		/// <summary>
		/// Backup of InnerWindow-&gt;DC.CurrLineSize at the end of BeginTable()<br/>
		/// </summary>
		public Vector2 HostBackupCurrLineSize;

		/// <summary>
		/// Backup of InnerWindow-&gt;DC.CursorMaxPos at the end of BeginTable()<br/>
		/// </summary>
		public Vector2 HostBackupCursorMaxPos;

		/// <summary>
		/// Backup of OuterWindow-&gt;DC.ColumnsOffset at the end of BeginTable()<br/>
		/// </summary>
		public ImVec1 HostBackupColumnsOffset;

		/// <summary>
		/// Backup of OuterWindow-&gt;DC.ItemWidth at the end of BeginTable()<br/>
		/// </summary>
		public float HostBackupItemWidth;

		/// <summary>
		/// Backup of OuterWindow-&gt;DC.ItemWidthStack.Size at the end of BeginTable()<br/>
		/// </summary>
		public int HostBackupItemWidthStackSize;





		public unsafe void Destroy()
		{
			fixed (ImGuiTableTempData* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiTableTempDataPtr : IEquatable<ImGuiTableTempDataPtr>
	{
		public ImGuiTableTempDataPtr(ImGuiTableTempData* handle) { Handle = handle; }

		public ImGuiTableTempData* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiTableTempDataPtr Null => new ImGuiTableTempDataPtr(null);

		public static implicit operator ImGuiTableTempDataPtr(ImGuiTableTempData* handle) => new ImGuiTableTempDataPtr(handle);

		public static implicit operator ImGuiTableTempData*(ImGuiTableTempDataPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiTableTempDataPtr left, ImGuiTableTempDataPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiTableTempDataPtr left, ImGuiTableTempDataPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiTableTempDataPtr left, ImGuiTableTempData* right) => left.Handle == right;

		public static bool operator !=(ImGuiTableTempDataPtr left, ImGuiTableTempData* right) => left.Handle != right;

		public bool Equals(ImGuiTableTempDataPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiTableTempDataPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiTableTempDataPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		/// <summary>
		/// Index in g.Tables.Buf[] pool<br/>
		/// </summary>
		public ref int TableIndex => ref Unsafe.AsRef<int>(&Handle->TableIndex);
		/// <summary>
		/// Last timestamp this structure was used<br/>
		/// </summary>
		public ref float LastTimeActive => ref Unsafe.AsRef<float>(&Handle->LastTimeActive);
		/// <summary>
		/// outer_size.x passed to BeginTable()<br/>
		/// </summary>
		public ref Vector2 UserOuterSize => ref Unsafe.AsRef<Vector2>(&Handle->UserOuterSize);
		public ref ImDrawListSplitter DrawSplitter => ref Unsafe.AsRef<ImDrawListSplitter>(&Handle->DrawSplitter);
		/// <summary>
		/// Backup of InnerWindow-&gt;WorkRect at the end of BeginTable()<br/>
		/// </summary>
		public ref ImRect HostBackupWorkRect => ref Unsafe.AsRef<ImRect>(&Handle->HostBackupWorkRect);
		/// <summary>
		/// Backup of InnerWindow-&gt;ParentWorkRect at the end of BeginTable()<br/>
		/// </summary>
		public ref ImRect HostBackupParentWorkRect => ref Unsafe.AsRef<ImRect>(&Handle->HostBackupParentWorkRect);
		/// <summary>
		/// Backup of InnerWindow-&gt;DC.PrevLineSize at the end of BeginTable()<br/>
		/// </summary>
		public ref Vector2 HostBackupPrevLineSize => ref Unsafe.AsRef<Vector2>(&Handle->HostBackupPrevLineSize);
		/// <summary>
		/// Backup of InnerWindow-&gt;DC.CurrLineSize at the end of BeginTable()<br/>
		/// </summary>
		public ref Vector2 HostBackupCurrLineSize => ref Unsafe.AsRef<Vector2>(&Handle->HostBackupCurrLineSize);
		/// <summary>
		/// Backup of InnerWindow-&gt;DC.CursorMaxPos at the end of BeginTable()<br/>
		/// </summary>
		public ref Vector2 HostBackupCursorMaxPos => ref Unsafe.AsRef<Vector2>(&Handle->HostBackupCursorMaxPos);
		/// <summary>
		/// Backup of OuterWindow-&gt;DC.ColumnsOffset at the end of BeginTable()<br/>
		/// </summary>
		public ref ImVec1 HostBackupColumnsOffset => ref Unsafe.AsRef<ImVec1>(&Handle->HostBackupColumnsOffset);
		/// <summary>
		/// Backup of OuterWindow-&gt;DC.ItemWidth at the end of BeginTable()<br/>
		/// </summary>
		public ref float HostBackupItemWidth => ref Unsafe.AsRef<float>(&Handle->HostBackupItemWidth);
		/// <summary>
		/// Backup of OuterWindow-&gt;DC.ItemWidthStack.Size at the end of BeginTable()<br/>
		/// </summary>
		public ref int HostBackupItemWidthStackSize => ref Unsafe.AsRef<int>(&Handle->HostBackupItemWidthStackSize);

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImSpanImGuiTableColumn
	{
		public unsafe ImGuiTableColumn* Data;
		public unsafe ImGuiTableColumn* DataEnd;


	}

	/// <summary>
	/// [Internal] sizeof() ~ 112<br/>
	/// We use the terminology "Enabled" to refer to a column that is not Hidden by userapi.<br/>
	/// We use the terminology "Clipped" to refer to a column that is out of sight because of scrollingclipping.<br/>
	/// This is in contrast with some user-facing api such as IsItemVisible()  IsRectVisible() which use "Visible" to mean "not clipped".<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTableColumn
	{
		/// <summary>
		/// Flags after some patching (not directly same as provided by user). See ImGuiTableColumnFlags_<br/>
		/// </summary>
		public ImGuiTableColumnFlags Flags;

		/// <summary>
		/// Finalactual width visible == (MaxX - MinX), locked in TableUpdateLayout(). May be &gt; WidthRequest to honor minimum width, may be &lt; WidthRequest to honor shrinking columns down in tight space.<br/>
		/// </summary>
		public float WidthGiven;

		/// <summary>
		/// Absolute positions<br/>
		/// </summary>
		public float MinX;

		public float MaxX;
		/// <summary>
		/// Master width absolute value when !(Flags &amp; _WidthStretch). When Stretch this is derived every frame from StretchWeight in TableUpdateLayout()<br/>
		/// </summary>
		public float WidthRequest;

		/// <summary>
		/// Automatic width<br/>
		/// </summary>
		public float WidthAuto;

		/// <summary>
		/// Master width weight when (Flags &amp; _WidthStretch). Often around ~1.0f initially.<br/>
		/// </summary>
		public float StretchWeight;

		/// <summary>
		/// Value passed to TableSetupColumn(). For Width it is a content width (_without padding_).<br/>
		/// </summary>
		public float InitStretchWeightOrWidth;

		/// <summary>
		/// Clipping rectangle for the column<br/>
		/// </summary>
		public ImRect ClipRect;

		/// <summary>
		/// Optional, value passed to TableSetupColumn()<br/>
		/// </summary>
		public int UserID;

		/// <summary>
		/// Contents region min ~(MinX + CellPaddingX + CellSpacingX1) == cursor start position when entering column<br/>
		/// </summary>
		public float WorkMinX;

		/// <summary>
		/// Contents region max ~(MaxX - CellPaddingX - CellSpacingX2)<br/>
		/// </summary>
		public float WorkMaxX;

		/// <summary>
		/// Current item width for the column, preserved across rows<br/>
		/// </summary>
		public float ItemWidth;

		/// <summary>
		/// Contents maximum position for frozen rows (apart from headers), from which we can infer content width.<br/>
		/// </summary>
		public float ContentMaxXFrozen;

		public float ContentMaxXUnfrozen;
		/// <summary>
		/// Contents maximum position for headers rows (regardless of freezing). TableHeader() automatically softclip itself + report ideal desired size, to avoid creating extraneous draw calls<br/>
		/// </summary>
		public float ContentMaxXHeadersUsed;

		public float ContentMaxXHeadersIdeal;
		/// <summary>
		/// Offset into parent ColumnsNames[]<br/>
		/// </summary>
		public short NameOffset;

		/// <summary>
		/// Index within Table's IndexToDisplayOrder[] (column may be reordered by users)<br/>
		/// </summary>
		public sbyte DisplayOrder;

		/// <summary>
		/// Index within enabledvisible set (&lt;= IndexToDisplayOrder)<br/>
		/// </summary>
		public sbyte IndexWithinEnabledSet;

		/// <summary>
		/// Index of prev enabledvisible column within Columns[], -1 if first enabledvisible column<br/>
		/// </summary>
		public sbyte PrevEnabledColumn;

		/// <summary>
		/// Index of next enabledvisible column within Columns[], -1 if last enabledvisible column<br/>
		/// </summary>
		public sbyte NextEnabledColumn;

		/// <summary>
		/// Index of this column within sort specs, -1 if not sorting on this column, 0 for single-sort, may be &gt;0 on multi-sort<br/>
		/// </summary>
		public sbyte SortOrder;

		/// <summary>
		/// Index within DrawSplitter.Channels[]<br/>
		/// </summary>
		public byte DrawChannelCurrent;

		/// <summary>
		/// Draw channels for frozen rows (often headers)<br/>
		/// </summary>
		public byte DrawChannelFrozen;

		/// <summary>
		/// Draw channels for unfrozen rows<br/>
		/// </summary>
		public byte DrawChannelUnfrozen;

		/// <summary>
		/// IsUserEnabled &amp;&amp; (Flags &amp; ImGuiTableColumnFlags_Disabled) == 0<br/>
		/// </summary>
		public byte IsEnabled;

		/// <summary>
		/// Is the column not marked Hidden by the user? (unrelated to being off view, e.g. clipped by scrolling).<br/>
		/// </summary>
		public byte IsUserEnabled;

		public byte IsUserEnabledNextFrame;
		/// <summary>
		/// Is actually in view (e.g. overlapping the host window clipping rectangle, not scrolled).<br/>
		/// </summary>
		public byte IsVisibleX;

		public byte IsVisibleY;
		/// <summary>
		/// Return value for TableSetColumnIndex()  TableNextColumn(): whether we request user to output contents or not.<br/>
		/// </summary>
		public byte IsRequestOutput;

		/// <summary>
		/// Do we want item submissions to this column to be completely ignored (no layout will happen).<br/>
		/// </summary>
		public byte IsSkipItems;

		public byte IsPreserveWidthAuto;
		/// <summary>
		/// ImGuiNavLayer in 1 byte<br/>
		/// </summary>
		public sbyte NavLayerCurrent;

		/// <summary>
		/// Queue of 8 values for the next 8 frames to request auto-fit<br/>
		/// </summary>
		public byte AutoFitQueue;

		/// <summary>
		/// Queue of 8 values for the next 8 frames to disable ClippedSkipItem<br/>
		/// </summary>
		public byte CannotSkipItemsQueue;

		/// <summary>
		/// ImGuiSortDirection_Ascending or ImGuiSortDirection_Descending<br/>
		/// </summary>
		public byte SortDirection;

		/// <summary>
		/// Number of available sort directions (0 to 3)<br/>
		/// </summary>
		public byte SortDirectionsAvailCount;

		/// <summary>
		/// Mask of available sort directions (1-bit each)<br/>
		/// </summary>
		public byte SortDirectionsAvailMask;

		/// <summary>
		/// Ordered list of available sort directions (2-bits each, total 8-bits)<br/>
		/// </summary>
		public byte SortDirectionsAvailList;





		public unsafe void Destroy()
		{
			fixed (ImGuiTableColumn* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiTableColumnPtr : IEquatable<ImGuiTableColumnPtr>
	{
		public ImGuiTableColumnPtr(ImGuiTableColumn* handle) { Handle = handle; }

		public ImGuiTableColumn* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiTableColumnPtr Null => new ImGuiTableColumnPtr(null);

		public static implicit operator ImGuiTableColumnPtr(ImGuiTableColumn* handle) => new ImGuiTableColumnPtr(handle);

		public static implicit operator ImGuiTableColumn*(ImGuiTableColumnPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiTableColumnPtr left, ImGuiTableColumnPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiTableColumnPtr left, ImGuiTableColumnPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiTableColumnPtr left, ImGuiTableColumn* right) => left.Handle == right;

		public static bool operator !=(ImGuiTableColumnPtr left, ImGuiTableColumn* right) => left.Handle != right;

		public bool Equals(ImGuiTableColumnPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiTableColumnPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiTableColumnPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		/// <summary>
		/// Flags after some patching (not directly same as provided by user). See ImGuiTableColumnFlags_<br/>
		/// </summary>
		public ref ImGuiTableColumnFlags Flags => ref Unsafe.AsRef<ImGuiTableColumnFlags>(&Handle->Flags);
		/// <summary>
		/// Finalactual width visible == (MaxX - MinX), locked in TableUpdateLayout(). May be &gt; WidthRequest to honor minimum width, may be &lt; WidthRequest to honor shrinking columns down in tight space.<br/>
		/// </summary>
		public ref float WidthGiven => ref Unsafe.AsRef<float>(&Handle->WidthGiven);
		/// <summary>
		/// Absolute positions<br/>
		/// </summary>
		public ref float MinX => ref Unsafe.AsRef<float>(&Handle->MinX);
		public ref float MaxX => ref Unsafe.AsRef<float>(&Handle->MaxX);
		/// <summary>
		/// Master width absolute value when !(Flags &amp; _WidthStretch). When Stretch this is derived every frame from StretchWeight in TableUpdateLayout()<br/>
		/// </summary>
		public ref float WidthRequest => ref Unsafe.AsRef<float>(&Handle->WidthRequest);
		/// <summary>
		/// Automatic width<br/>
		/// </summary>
		public ref float WidthAuto => ref Unsafe.AsRef<float>(&Handle->WidthAuto);
		/// <summary>
		/// Master width weight when (Flags &amp; _WidthStretch). Often around ~1.0f initially.<br/>
		/// </summary>
		public ref float StretchWeight => ref Unsafe.AsRef<float>(&Handle->StretchWeight);
		/// <summary>
		/// Value passed to TableSetupColumn(). For Width it is a content width (_without padding_).<br/>
		/// </summary>
		public ref float InitStretchWeightOrWidth => ref Unsafe.AsRef<float>(&Handle->InitStretchWeightOrWidth);
		/// <summary>
		/// Clipping rectangle for the column<br/>
		/// </summary>
		public ref ImRect ClipRect => ref Unsafe.AsRef<ImRect>(&Handle->ClipRect);
		/// <summary>
		/// Optional, value passed to TableSetupColumn()<br/>
		/// </summary>
		public ref int UserID => ref Unsafe.AsRef<int>(&Handle->UserID);
		/// <summary>
		/// Contents region min ~(MinX + CellPaddingX + CellSpacingX1) == cursor start position when entering column<br/>
		/// </summary>
		public ref float WorkMinX => ref Unsafe.AsRef<float>(&Handle->WorkMinX);
		/// <summary>
		/// Contents region max ~(MaxX - CellPaddingX - CellSpacingX2)<br/>
		/// </summary>
		public ref float WorkMaxX => ref Unsafe.AsRef<float>(&Handle->WorkMaxX);
		/// <summary>
		/// Current item width for the column, preserved across rows<br/>
		/// </summary>
		public ref float ItemWidth => ref Unsafe.AsRef<float>(&Handle->ItemWidth);
		/// <summary>
		/// Contents maximum position for frozen rows (apart from headers), from which we can infer content width.<br/>
		/// </summary>
		public ref float ContentMaxXFrozen => ref Unsafe.AsRef<float>(&Handle->ContentMaxXFrozen);
		public ref float ContentMaxXUnfrozen => ref Unsafe.AsRef<float>(&Handle->ContentMaxXUnfrozen);
		/// <summary>
		/// Contents maximum position for headers rows (regardless of freezing). TableHeader() automatically softclip itself + report ideal desired size, to avoid creating extraneous draw calls<br/>
		/// </summary>
		public ref float ContentMaxXHeadersUsed => ref Unsafe.AsRef<float>(&Handle->ContentMaxXHeadersUsed);
		public ref float ContentMaxXHeadersIdeal => ref Unsafe.AsRef<float>(&Handle->ContentMaxXHeadersIdeal);
		/// <summary>
		/// Offset into parent ColumnsNames[]<br/>
		/// </summary>
		public ref short NameOffset => ref Unsafe.AsRef<short>(&Handle->NameOffset);
		/// <summary>
		/// Index within Table's IndexToDisplayOrder[] (column may be reordered by users)<br/>
		/// </summary>
		public ref sbyte DisplayOrder => ref Unsafe.AsRef<sbyte>(&Handle->DisplayOrder);
		/// <summary>
		/// Index within enabledvisible set (&lt;= IndexToDisplayOrder)<br/>
		/// </summary>
		public ref sbyte IndexWithinEnabledSet => ref Unsafe.AsRef<sbyte>(&Handle->IndexWithinEnabledSet);
		/// <summary>
		/// Index of prev enabledvisible column within Columns[], -1 if first enabledvisible column<br/>
		/// </summary>
		public ref sbyte PrevEnabledColumn => ref Unsafe.AsRef<sbyte>(&Handle->PrevEnabledColumn);
		/// <summary>
		/// Index of next enabledvisible column within Columns[], -1 if last enabledvisible column<br/>
		/// </summary>
		public ref sbyte NextEnabledColumn => ref Unsafe.AsRef<sbyte>(&Handle->NextEnabledColumn);
		/// <summary>
		/// Index of this column within sort specs, -1 if not sorting on this column, 0 for single-sort, may be &gt;0 on multi-sort<br/>
		/// </summary>
		public ref sbyte SortOrder => ref Unsafe.AsRef<sbyte>(&Handle->SortOrder);
		/// <summary>
		/// Index within DrawSplitter.Channels[]<br/>
		/// </summary>
		public ref byte DrawChannelCurrent => ref Unsafe.AsRef<byte>(&Handle->DrawChannelCurrent);
		/// <summary>
		/// Draw channels for frozen rows (often headers)<br/>
		/// </summary>
		public ref byte DrawChannelFrozen => ref Unsafe.AsRef<byte>(&Handle->DrawChannelFrozen);
		/// <summary>
		/// Draw channels for unfrozen rows<br/>
		/// </summary>
		public ref byte DrawChannelUnfrozen => ref Unsafe.AsRef<byte>(&Handle->DrawChannelUnfrozen);
		/// <summary>
		/// IsUserEnabled &amp;&amp; (Flags &amp; ImGuiTableColumnFlags_Disabled) == 0<br/>
		/// </summary>
		public ref bool IsEnabled => ref Unsafe.AsRef<bool>(&Handle->IsEnabled);
		/// <summary>
		/// Is the column not marked Hidden by the user? (unrelated to being off view, e.g. clipped by scrolling).<br/>
		/// </summary>
		public ref bool IsUserEnabled => ref Unsafe.AsRef<bool>(&Handle->IsUserEnabled);
		public ref bool IsUserEnabledNextFrame => ref Unsafe.AsRef<bool>(&Handle->IsUserEnabledNextFrame);
		/// <summary>
		/// Is actually in view (e.g. overlapping the host window clipping rectangle, not scrolled).<br/>
		/// </summary>
		public ref bool IsVisibleX => ref Unsafe.AsRef<bool>(&Handle->IsVisibleX);
		public ref bool IsVisibleY => ref Unsafe.AsRef<bool>(&Handle->IsVisibleY);
		/// <summary>
		/// Return value for TableSetColumnIndex()  TableNextColumn(): whether we request user to output contents or not.<br/>
		/// </summary>
		public ref bool IsRequestOutput => ref Unsafe.AsRef<bool>(&Handle->IsRequestOutput);
		/// <summary>
		/// Do we want item submissions to this column to be completely ignored (no layout will happen).<br/>
		/// </summary>
		public ref bool IsSkipItems => ref Unsafe.AsRef<bool>(&Handle->IsSkipItems);
		public ref bool IsPreserveWidthAuto => ref Unsafe.AsRef<bool>(&Handle->IsPreserveWidthAuto);
		/// <summary>
		/// ImGuiNavLayer in 1 byte<br/>
		/// </summary>
		public ref sbyte NavLayerCurrent => ref Unsafe.AsRef<sbyte>(&Handle->NavLayerCurrent);
		/// <summary>
		/// Queue of 8 values for the next 8 frames to request auto-fit<br/>
		/// </summary>
		public ref byte AutoFitQueue => ref Unsafe.AsRef<byte>(&Handle->AutoFitQueue);
		/// <summary>
		/// Queue of 8 values for the next 8 frames to disable ClippedSkipItem<br/>
		/// </summary>
		public ref byte CannotSkipItemsQueue => ref Unsafe.AsRef<byte>(&Handle->CannotSkipItemsQueue);
		/// <summary>
		/// ImGuiSortDirection_Ascending or ImGuiSortDirection_Descending<br/>
		/// </summary>
		public ref byte SortDirection => ref Unsafe.AsRef<byte>(&Handle->SortDirection);
		/// <summary>
		/// Number of available sort directions (0 to 3)<br/>
		/// </summary>
		public ref byte SortDirectionsAvailCount => ref Unsafe.AsRef<byte>(&Handle->SortDirectionsAvailCount);
		/// <summary>
		/// Mask of available sort directions (1-bit each)<br/>
		/// </summary>
		public ref byte SortDirectionsAvailMask => ref Unsafe.AsRef<byte>(&Handle->SortDirectionsAvailMask);
		/// <summary>
		/// Ordered list of available sort directions (2-bits each, total 8-bits)<br/>
		/// </summary>
		public ref byte SortDirectionsAvailList => ref Unsafe.AsRef<byte>(&Handle->SortDirectionsAvailList);

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImSpanImGuiTableColumnIdx
	{
		public unsafe sbyte* Data;
		public unsafe sbyte* DataEnd;


	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImSpanImGuiTableCellData
	{
		public unsafe ImGuiTableCellData* Data;
		public unsafe ImGuiTableCellData* DataEnd;


	}

	/// <summary>
	/// Transient cell data stored per row.<br/>
	/// sizeof() ~ 6<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTableCellData
	{
		/// <summary>
		/// Actual color<br/>
		/// </summary>
		public uint BgColor;

		/// <summary>
		/// Column number<br/>
		/// </summary>
		public sbyte Column;



	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiTableCellDataPtr : IEquatable<ImGuiTableCellDataPtr>
	{
		public ImGuiTableCellDataPtr(ImGuiTableCellData* handle) { Handle = handle; }

		public ImGuiTableCellData* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiTableCellDataPtr Null => new ImGuiTableCellDataPtr(null);

		public static implicit operator ImGuiTableCellDataPtr(ImGuiTableCellData* handle) => new ImGuiTableCellDataPtr(handle);

		public static implicit operator ImGuiTableCellData*(ImGuiTableCellDataPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiTableCellDataPtr left, ImGuiTableCellDataPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiTableCellDataPtr left, ImGuiTableCellDataPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiTableCellDataPtr left, ImGuiTableCellData* right) => left.Handle == right;

		public static bool operator !=(ImGuiTableCellDataPtr left, ImGuiTableCellData* right) => left.Handle != right;

		public bool Equals(ImGuiTableCellDataPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiTableCellDataPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiTableCellDataPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		/// <summary>
		/// Actual color<br/>
		/// </summary>
		public ref uint BgColor => ref Unsafe.AsRef<uint>(&Handle->BgColor);
		/// <summary>
		/// Column number<br/>
		/// </summary>
		public ref sbyte Column => ref Unsafe.AsRef<sbyte>(&Handle->Column);
	}

	/// <summary>
	/// Per-instance data that needs preserving across frames (seemingly most others do not need to be preserved aside from debug needs. Does that means they could be moved to ImGuiTableTempData?)<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTableInstanceData
	{
		public int TableInstanceID;
		/// <summary>
		/// Outer height from last frame<br/>
		/// </summary>
		public float LastOuterHeight;

		/// <summary>
		/// Height of first row from last frame (FIXME: this is used as "header height" and may be reworked)<br/>
		/// </summary>
		public float LastFirstRowHeight;

		/// <summary>
		/// Height of frozen section from last frame<br/>
		/// </summary>
		public float LastFrozenHeight;





		public unsafe void Destroy()
		{
			fixed (ImGuiTableInstanceData* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiTableInstanceDataPtr : IEquatable<ImGuiTableInstanceDataPtr>
	{
		public ImGuiTableInstanceDataPtr(ImGuiTableInstanceData* handle) { Handle = handle; }

		public ImGuiTableInstanceData* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiTableInstanceDataPtr Null => new ImGuiTableInstanceDataPtr(null);

		public static implicit operator ImGuiTableInstanceDataPtr(ImGuiTableInstanceData* handle) => new ImGuiTableInstanceDataPtr(handle);

		public static implicit operator ImGuiTableInstanceData*(ImGuiTableInstanceDataPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiTableInstanceDataPtr left, ImGuiTableInstanceDataPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiTableInstanceDataPtr left, ImGuiTableInstanceDataPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiTableInstanceDataPtr left, ImGuiTableInstanceData* right) => left.Handle == right;

		public static bool operator !=(ImGuiTableInstanceDataPtr left, ImGuiTableInstanceData* right) => left.Handle != right;

		public bool Equals(ImGuiTableInstanceDataPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiTableInstanceDataPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiTableInstanceDataPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref int TableInstanceID => ref Unsafe.AsRef<int>(&Handle->TableInstanceID);
		/// <summary>
		/// Outer height from last frame<br/>
		/// </summary>
		public ref float LastOuterHeight => ref Unsafe.AsRef<float>(&Handle->LastOuterHeight);
		/// <summary>
		/// Height of first row from last frame (FIXME: this is used as "header height" and may be reworked)<br/>
		/// </summary>
		public ref float LastFirstRowHeight => ref Unsafe.AsRef<float>(&Handle->LastFirstRowHeight);
		/// <summary>
		/// Height of frozen section from last frame<br/>
		/// </summary>
		public ref float LastFrozenHeight => ref Unsafe.AsRef<float>(&Handle->LastFrozenHeight);

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiTableInstanceData
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiTableInstanceData* Data;


	}

	/// <summary>
	/// Sorting specification for one column of a table (sizeof == 12 bytes)<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTableColumnSortSpecs
	{
		/// <summary>
		/// User id of the column (if specified by a TableSetupColumn() call)<br/>
		/// </summary>
		public int ColumnUserID;

		/// <summary>
		/// Index of the column<br/>
		/// </summary>
		public short ColumnIndex;

		/// <summary>
		/// Index within parent ImGuiTableSortSpecs (always stored in order starting from 0, tables sorted on a single criteria will always have a 0 here)<br/>
		/// </summary>
		public short SortOrder;

		/// <summary>
		/// ImGuiSortDirection_Ascending or ImGuiSortDirection_Descending (you can use this or SortSign, whichever is more convenient for your sort function)<br/>
		/// </summary>
		public ImGuiSortDirection SortDirection;





		public unsafe void Destroy()
		{
			fixed (ImGuiTableColumnSortSpecs* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiTableColumnSortSpecsPtr : IEquatable<ImGuiTableColumnSortSpecsPtr>
	{
		public ImGuiTableColumnSortSpecsPtr(ImGuiTableColumnSortSpecs* handle) { Handle = handle; }

		public ImGuiTableColumnSortSpecs* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiTableColumnSortSpecsPtr Null => new ImGuiTableColumnSortSpecsPtr(null);

		public static implicit operator ImGuiTableColumnSortSpecsPtr(ImGuiTableColumnSortSpecs* handle) => new ImGuiTableColumnSortSpecsPtr(handle);

		public static implicit operator ImGuiTableColumnSortSpecs*(ImGuiTableColumnSortSpecsPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiTableColumnSortSpecsPtr left, ImGuiTableColumnSortSpecsPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiTableColumnSortSpecsPtr left, ImGuiTableColumnSortSpecsPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiTableColumnSortSpecsPtr left, ImGuiTableColumnSortSpecs* right) => left.Handle == right;

		public static bool operator !=(ImGuiTableColumnSortSpecsPtr left, ImGuiTableColumnSortSpecs* right) => left.Handle != right;

		public bool Equals(ImGuiTableColumnSortSpecsPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiTableColumnSortSpecsPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiTableColumnSortSpecsPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		/// <summary>
		/// User id of the column (if specified by a TableSetupColumn() call)<br/>
		/// </summary>
		public ref int ColumnUserID => ref Unsafe.AsRef<int>(&Handle->ColumnUserID);
		/// <summary>
		/// Index of the column<br/>
		/// </summary>
		public ref short ColumnIndex => ref Unsafe.AsRef<short>(&Handle->ColumnIndex);
		/// <summary>
		/// Index within parent ImGuiTableSortSpecs (always stored in order starting from 0, tables sorted on a single criteria will always have a 0 here)<br/>
		/// </summary>
		public ref short SortOrder => ref Unsafe.AsRef<short>(&Handle->SortOrder);
		/// <summary>
		/// ImGuiSortDirection_Ascending or ImGuiSortDirection_Descending (you can use this or SortSign, whichever is more convenient for your sort function)<br/>
		/// </summary>
		public ref ImGuiSortDirection SortDirection => ref Unsafe.AsRef<ImGuiSortDirection>(&Handle->SortDirection);

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiTableColumnSortSpecs
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiTableColumnSortSpecs* Data;


	}

	/// <summary>
	/// Sorting specifications for a table (often handling sort specs for a single column, occasionally more)<br/>
	/// Obtained by calling TableGetSortSpecs().<br/>
	/// When 'SpecsDirty == true' you can sort your data. It will be true with sorting specs have changed since last call, or the first time.<br/>
	/// Make sure to set 'SpecsDirty = false' after sorting, else you may wastefully sort your data every frame!<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTableSortSpecs
	{
		/// <summary>
		/// Pointer to sort spec array.<br/>
		/// </summary>
		public unsafe ImGuiTableColumnSortSpecs* Specs;

		/// <summary>
		/// Sort spec count. Most often 1. May be &gt; 1 when ImGuiTableFlags_SortMulti is enabled. May be == 0 when ImGuiTableFlags_SortTristate is enabled.<br/>
		/// </summary>
		public int SpecsCount;

		/// <summary>
		/// Set to true when specs have changed since last time! Use this to sort again, then clear the flag.<br/>
		/// </summary>
		public byte SpecsDirty;





		public unsafe void Destroy()
		{
			fixed (ImGuiTableSortSpecs* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiTableSortSpecsPtr : IEquatable<ImGuiTableSortSpecsPtr>
	{
		public ImGuiTableSortSpecsPtr(ImGuiTableSortSpecs* handle) { Handle = handle; }

		public ImGuiTableSortSpecs* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiTableSortSpecsPtr Null => new ImGuiTableSortSpecsPtr(null);

		public static implicit operator ImGuiTableSortSpecsPtr(ImGuiTableSortSpecs* handle) => new ImGuiTableSortSpecsPtr(handle);

		public static implicit operator ImGuiTableSortSpecs*(ImGuiTableSortSpecsPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiTableSortSpecsPtr left, ImGuiTableSortSpecsPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiTableSortSpecsPtr left, ImGuiTableSortSpecsPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiTableSortSpecsPtr left, ImGuiTableSortSpecs* right) => left.Handle == right;

		public static bool operator !=(ImGuiTableSortSpecsPtr left, ImGuiTableSortSpecs* right) => left.Handle != right;

		public bool Equals(ImGuiTableSortSpecsPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiTableSortSpecsPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiTableSortSpecsPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		/// <summary>
		/// Pointer to sort spec array.<br/>
		/// </summary>
		public ref ImGuiTableColumnSortSpecsPtr Specs => ref Unsafe.AsRef<ImGuiTableColumnSortSpecsPtr>(&Handle->Specs);
		/// <summary>
		/// Sort spec count. Most often 1. May be &gt; 1 when ImGuiTableFlags_SortMulti is enabled. May be == 0 when ImGuiTableFlags_SortTristate is enabled.<br/>
		/// </summary>
		public ref int SpecsCount => ref Unsafe.AsRef<int>(&Handle->SpecsCount);
		/// <summary>
		/// Set to true when specs have changed since last time! Use this to sort again, then clear the flag.<br/>
		/// </summary>
		public ref bool SpecsDirty => ref Unsafe.AsRef<bool>(&Handle->SpecsDirty);

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiTableTempData
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiTableTempData* Data;


	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImPoolImGuiTable
	{
		public ImVectorImGuiTable Buf;
		public ImGuiStorage Map;
		public int FreeIdx;
		public int AliveCount;


	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiTable
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiTable* Data;


	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImPoolImGuiTabBar
	{
		public ImVectorImGuiTabBar Buf;
		public ImGuiStorage Map;
		public int FreeIdx;
		public int AliveCount;


	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiTabBar
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiTabBar* Data;


	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiPtrOrIndex
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiPtrOrIndex* Data;


	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiPtrOrIndex
	{
		/// <summary>
		/// Either field can be set, not both. e.g. Dock node tab bars are loose while BeginTabBar() ones are in a pool.<br/>
		/// </summary>
		public unsafe void* Ptr;

		/// <summary>
		/// Usually index in a main pool.<br/>
		/// </summary>
		public int Index;





		public unsafe void Destroy()
		{
			fixed (ImGuiPtrOrIndex* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiPtrOrIndexPtr : IEquatable<ImGuiPtrOrIndexPtr>
	{
		public ImGuiPtrOrIndexPtr(ImGuiPtrOrIndex* handle) { Handle = handle; }

		public ImGuiPtrOrIndex* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiPtrOrIndexPtr Null => new ImGuiPtrOrIndexPtr(null);

		public static implicit operator ImGuiPtrOrIndexPtr(ImGuiPtrOrIndex* handle) => new ImGuiPtrOrIndexPtr(handle);

		public static implicit operator ImGuiPtrOrIndex*(ImGuiPtrOrIndexPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiPtrOrIndexPtr left, ImGuiPtrOrIndexPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiPtrOrIndexPtr left, ImGuiPtrOrIndexPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiPtrOrIndexPtr left, ImGuiPtrOrIndex* right) => left.Handle == right;

		public static bool operator !=(ImGuiPtrOrIndexPtr left, ImGuiPtrOrIndex* right) => left.Handle != right;

		public bool Equals(ImGuiPtrOrIndexPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiPtrOrIndexPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiPtrOrIndexPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		/// <summary>
		/// Either field can be set, not both. e.g. Dock node tab bars are loose while BeginTabBar() ones are in a pool.<br/>
		/// </summary>
		public void* Ptr { get => Handle->Ptr; set => Handle->Ptr = value; }
		/// <summary>
		/// Usually index in a main pool.<br/>
		/// </summary>
		public ref int Index => ref Unsafe.AsRef<int>(&Handle->Index);

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiShrinkWidthItem
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiShrinkWidthItem* Data;


	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiShrinkWidthItem
	{
		public int Index;
		public float Width;
		public float InitialWidth;


	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiShrinkWidthItemPtr : IEquatable<ImGuiShrinkWidthItemPtr>
	{
		public ImGuiShrinkWidthItemPtr(ImGuiShrinkWidthItem* handle) { Handle = handle; }

		public ImGuiShrinkWidthItem* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiShrinkWidthItemPtr Null => new ImGuiShrinkWidthItemPtr(null);

		public static implicit operator ImGuiShrinkWidthItemPtr(ImGuiShrinkWidthItem* handle) => new ImGuiShrinkWidthItemPtr(handle);

		public static implicit operator ImGuiShrinkWidthItem*(ImGuiShrinkWidthItemPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiShrinkWidthItemPtr left, ImGuiShrinkWidthItemPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiShrinkWidthItemPtr left, ImGuiShrinkWidthItemPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiShrinkWidthItemPtr left, ImGuiShrinkWidthItem* right) => left.Handle == right;

		public static bool operator !=(ImGuiShrinkWidthItemPtr left, ImGuiShrinkWidthItem* right) => left.Handle != right;

		public bool Equals(ImGuiShrinkWidthItemPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiShrinkWidthItemPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiShrinkWidthItemPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref int Index => ref Unsafe.AsRef<int>(&Handle->Index);
		public ref float Width => ref Unsafe.AsRef<float>(&Handle->Width);
		public ref float InitialWidth => ref Unsafe.AsRef<float>(&Handle->InitialWidth);
	}

	/// <summary>
	/// Internal state of the currently focusededited text input box<br/>
	/// For a given item ID, access with ImGui::GetInputTextState()<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiInputTextState
	{
		/// <summary>
		/// parent UI context (needs to be set explicitly by parent).<br/>
		/// </summary>
		public unsafe ImGuiContext* Ctx;

		/// <summary>
		/// widget id owning the text state<br/>
		/// </summary>
		public int ID;

		/// <summary>
		/// we need to maintain our buffer length in both UTF-8 and wchar format. UTF-8 length is valid even if TextA is not.<br/>
		/// </summary>
		public int CurLenW;

		/// <summary>
		/// we need to maintain our buffer length in both UTF-8 and wchar format. UTF-8 length is valid even if TextA is not.<br/>
		/// </summary>
		public int CurLenA;

		/// <summary>
		/// edit buffer, we need to persist but can't guarantee the persistence of the user-provided buffer. so we copy into own buffer.<br/>
		/// </summary>
		public ImVectorImWchar TextW;

		/// <summary>
		/// temporary UTF8 buffer for callbacks and other operations. this is not updated in every code-path! size=capacity.<br/>
		/// </summary>
		public ImVectorChar TextA;

		/// <summary>
		/// backup of end-user buffer at the time of focus (in UTF-8, unaltered)<br/>
		/// </summary>
		public ImVectorChar InitialTextA;

		/// <summary>
		/// temporary UTF8 buffer is not initially valid before we make the widget active (until then we pull the data from user argument)<br/>
		/// </summary>
		public byte TextAIsValid;

		/// <summary>
		/// end-user buffer capacity<br/>
		/// </summary>
		public int BufCapacityA;

		/// <summary>
		/// horizontal scrollingoffset<br/>
		/// </summary>
		public float ScrollX;

		/// <summary>
		/// state for stb_textedit.h<br/>
		/// </summary>
		public STBTexteditState Stb;

		/// <summary>
		/// timer for cursor blink, reset on every user action so the cursor reappears immediately<br/>
		/// </summary>
		public float CursorAnim;

		/// <summary>
		/// set when we want scrolling to follow the current cursor position (not always!)<br/>
		/// </summary>
		public byte CursorFollow;

		/// <summary>
		/// after a double-click to select all, we ignore further mouse drags to update selection<br/>
		/// </summary>
		public byte SelectedAllMouseLock;

		/// <summary>
		/// edited this frame<br/>
		/// </summary>
		public byte Edited;

		/// <summary>
		/// copy of InputText() flags. may be used to check if e.g. ImGuiInputTextFlags_Password is set.<br/>
		/// </summary>
		public ImGuiInputTextFlags Flags;





		public unsafe void ClearFreeMemory()
		{
			fixed (ImGuiInputTextState* @this = &this)
			{
				ImGui.ClearFreeMemoryNative(@this);
			}
		}

		public unsafe void ClearSelection()
		{
			fixed (ImGuiInputTextState* @this = &this)
			{
				ImGui.ClearSelectionNative(@this);
			}
		}

		public unsafe void ClearText()
		{
			fixed (ImGuiInputTextState* @this = &this)
			{
				ImGui.ClearTextNative(@this);
			}
		}

		/// <summary>		/// After a user-input the cursor stays on for a while without blinking		/// </summary>		public unsafe void CursorAnimReset()
		{
			fixed (ImGuiInputTextState* @this = &this)
			{
				ImGui.CursorAnimResetNative(@this);
			}
		}

		public unsafe void CursorClamp()
		{
			fixed (ImGuiInputTextState* @this = &this)
			{
				ImGui.CursorClampNative(@this);
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImGuiInputTextState* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe int GetCursorPos()
		{
			fixed (ImGuiInputTextState* @this = &this)
			{
				int ret = ImGui.GetCursorPosNative(@this);
				return ret;
			}
		}

		public unsafe int GetRedoAvailCount()
		{
			fixed (ImGuiInputTextState* @this = &this)
			{
				int ret = ImGui.GetRedoAvailCountNative(@this);
				return ret;
			}
		}

		public unsafe int GetSelectionEnd()
		{
			fixed (ImGuiInputTextState* @this = &this)
			{
				int ret = ImGui.GetSelectionEndNative(@this);
				return ret;
			}
		}

		public unsafe int GetSelectionStart()
		{
			fixed (ImGuiInputTextState* @this = &this)
			{
				int ret = ImGui.GetSelectionStartNative(@this);
				return ret;
			}
		}

		public unsafe int GetUndoAvailCount()
		{
			fixed (ImGuiInputTextState* @this = &this)
			{
				int ret = ImGui.GetUndoAvailCountNative(@this);
				return ret;
			}
		}

		public unsafe bool HasSelection()
		{
			fixed (ImGuiInputTextState* @this = &this)
			{
				byte ret = ImGui.HasSelectionNative(@this);
				return ret != 0;
			}
		}

		/// <summary>		/// Cannot be inline because we call in code in stb_textedit.h implementation		/// </summary>		public unsafe void OnKeyPressed(int key)
		{
			fixed (ImGuiInputTextState* @this = &this)
			{
				ImGui.OnKeyPressedNative(@this, key);
			}
		}

		public unsafe void SelectAll()
		{
			fixed (ImGuiInputTextState* @this = &this)
			{
				ImGui.SelectAllNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiInputTextStatePtr : IEquatable<ImGuiInputTextStatePtr>
	{
		public ImGuiInputTextStatePtr(ImGuiInputTextState* handle) { Handle = handle; }

		public ImGuiInputTextState* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiInputTextStatePtr Null => new ImGuiInputTextStatePtr(null);

		public static implicit operator ImGuiInputTextStatePtr(ImGuiInputTextState* handle) => new ImGuiInputTextStatePtr(handle);

		public static implicit operator ImGuiInputTextState*(ImGuiInputTextStatePtr handle) => handle.Handle;

		public static bool operator ==(ImGuiInputTextStatePtr left, ImGuiInputTextStatePtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiInputTextStatePtr left, ImGuiInputTextStatePtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiInputTextStatePtr left, ImGuiInputTextState* right) => left.Handle == right;

		public static bool operator !=(ImGuiInputTextStatePtr left, ImGuiInputTextState* right) => left.Handle != right;

		public bool Equals(ImGuiInputTextStatePtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiInputTextStatePtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiInputTextStatePtr [0x{0}]", ((nuint)Handle).ToString("X"));
		/// <summary>
		/// parent UI context (needs to be set explicitly by parent).<br/>
		/// </summary>
		public ref ImGuiContextPtr Ctx => ref Unsafe.AsRef<ImGuiContextPtr>(&Handle->Ctx);
		/// <summary>
		/// widget id owning the text state<br/>
		/// </summary>
		public ref int ID => ref Unsafe.AsRef<int>(&Handle->ID);
		/// <summary>
		/// we need to maintain our buffer length in both UTF-8 and wchar format. UTF-8 length is valid even if TextA is not.<br/>
		/// </summary>
		public ref int CurLenW => ref Unsafe.AsRef<int>(&Handle->CurLenW);
		/// <summary>
		/// we need to maintain our buffer length in both UTF-8 and wchar format. UTF-8 length is valid even if TextA is not.<br/>
		/// </summary>
		public ref int CurLenA => ref Unsafe.AsRef<int>(&Handle->CurLenA);
		/// <summary>
		/// edit buffer, we need to persist but can't guarantee the persistence of the user-provided buffer. so we copy into own buffer.<br/>
		/// </summary>
		public ref ImVectorImWchar TextW => ref Unsafe.AsRef<ImVectorImWchar>(&Handle->TextW);
		/// <summary>
		/// temporary UTF8 buffer for callbacks and other operations. this is not updated in every code-path! size=capacity.<br/>
		/// </summary>
		public ref ImVectorChar TextA => ref Unsafe.AsRef<ImVectorChar>(&Handle->TextA);
		/// <summary>
		/// backup of end-user buffer at the time of focus (in UTF-8, unaltered)<br/>
		/// </summary>
		public ref ImVectorChar InitialTextA => ref Unsafe.AsRef<ImVectorChar>(&Handle->InitialTextA);
		/// <summary>
		/// temporary UTF8 buffer is not initially valid before we make the widget active (until then we pull the data from user argument)<br/>
		/// </summary>
		public ref bool TextAIsValid => ref Unsafe.AsRef<bool>(&Handle->TextAIsValid);
		/// <summary>
		/// end-user buffer capacity<br/>
		/// </summary>
		public ref int BufCapacityA => ref Unsafe.AsRef<int>(&Handle->BufCapacityA);
		/// <summary>
		/// horizontal scrollingoffset<br/>
		/// </summary>
		public ref float ScrollX => ref Unsafe.AsRef<float>(&Handle->ScrollX);
		/// <summary>
		/// state for stb_textedit.h<br/>
		/// </summary>
		public ref STBTexteditState Stb => ref Unsafe.AsRef<STBTexteditState>(&Handle->Stb);
		/// <summary>
		/// timer for cursor blink, reset on every user action so the cursor reappears immediately<br/>
		/// </summary>
		public ref float CursorAnim => ref Unsafe.AsRef<float>(&Handle->CursorAnim);
		/// <summary>
		/// set when we want scrolling to follow the current cursor position (not always!)<br/>
		/// </summary>
		public ref bool CursorFollow => ref Unsafe.AsRef<bool>(&Handle->CursorFollow);
		/// <summary>
		/// after a double-click to select all, we ignore further mouse drags to update selection<br/>
		/// </summary>
		public ref bool SelectedAllMouseLock => ref Unsafe.AsRef<bool>(&Handle->SelectedAllMouseLock);
		/// <summary>
		/// edited this frame<br/>
		/// </summary>
		public ref bool Edited => ref Unsafe.AsRef<bool>(&Handle->Edited);
		/// <summary>
		/// copy of InputText() flags. may be used to check if e.g. ImGuiInputTextFlags_Password is set.<br/>
		/// </summary>
		public ref ImGuiInputTextFlags Flags => ref Unsafe.AsRef<ImGuiInputTextFlags>(&Handle->Flags);

		public unsafe void ClearFreeMemory()
		{
			ImGui.ClearFreeMemoryNative(Handle);
		}

		public unsafe void ClearSelection()
		{
			ImGui.ClearSelectionNative(Handle);
		}

		public unsafe void ClearText()
		{
			ImGui.ClearTextNative(Handle);
		}

		/// <summary>		/// After a user-input the cursor stays on for a while without blinking		/// </summary>		public unsafe void CursorAnimReset()
		{
			ImGui.CursorAnimResetNative(Handle);
		}

		public unsafe void CursorClamp()
		{
			ImGui.CursorClampNative(Handle);
		}

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

		public unsafe int GetCursorPos()
		{
			int ret = ImGui.GetCursorPosNative(Handle);
			return ret;
		}

		public unsafe int GetRedoAvailCount()
		{
			int ret = ImGui.GetRedoAvailCountNative(Handle);
			return ret;
		}

		public unsafe int GetSelectionEnd()
		{
			int ret = ImGui.GetSelectionEndNative(Handle);
			return ret;
		}

		public unsafe int GetSelectionStart()
		{
			int ret = ImGui.GetSelectionStartNative(Handle);
			return ret;
		}

		public unsafe int GetUndoAvailCount()
		{
			int ret = ImGui.GetUndoAvailCountNative(Handle);
			return ret;
		}

		public unsafe bool HasSelection()
		{
			byte ret = ImGui.HasSelectionNative(Handle);
			return ret != 0;
		}

		/// <summary>		/// Cannot be inline because we call in code in stb_textedit.h implementation		/// </summary>		public unsafe void OnKeyPressed(int key)
		{
			ImGui.OnKeyPressedNative(Handle, key);
		}

		public unsafe void SelectAll()
		{
			ImGui.SelectAllNative(Handle);
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct STBTexteditState
	{
		public int Cursor;
		/// <summary>
		/// selection start point<br/>
		/// </summary>
		public int SelectStart;

		public int SelectEnd;
		public byte InsertMode;
		public int RowCountPerPage;
		/// <summary>
		/// private data<br/>
		/// not implemented yet<br/>
		/// </summary>
		public byte CursorAtEndOfLine;

		public byte Initialized;
		public byte HasPreferredX;
		public byte SingleLine;
		public byte Padding1;
		public byte Padding2;
		public byte Padding3;
		/// <summary>
		/// this determines where the cursor updown tries to seek to along x<br/>
		/// </summary>
		public float PreferredX;

		public StbUndoState Undostate;


	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct StbUndoState
	{
		public StbUndoRecord UndoRec_0;
		public StbUndoRecord UndoRec_1;
		public StbUndoRecord UndoRec_2;
		public StbUndoRecord UndoRec_3;
		public StbUndoRecord UndoRec_4;
		public StbUndoRecord UndoRec_5;
		public StbUndoRecord UndoRec_6;
		public StbUndoRecord UndoRec_7;
		public StbUndoRecord UndoRec_8;
		public StbUndoRecord UndoRec_9;
		public StbUndoRecord UndoRec_10;
		public StbUndoRecord UndoRec_11;
		public StbUndoRecord UndoRec_12;
		public StbUndoRecord UndoRec_13;
		public StbUndoRecord UndoRec_14;
		public StbUndoRecord UndoRec_15;
		public StbUndoRecord UndoRec_16;
		public StbUndoRecord UndoRec_17;
		public StbUndoRecord UndoRec_18;
		public StbUndoRecord UndoRec_19;
		public StbUndoRecord UndoRec_20;
		public StbUndoRecord UndoRec_21;
		public StbUndoRecord UndoRec_22;
		public StbUndoRecord UndoRec_23;
		public StbUndoRecord UndoRec_24;
		public StbUndoRecord UndoRec_25;
		public StbUndoRecord UndoRec_26;
		public StbUndoRecord UndoRec_27;
		public StbUndoRecord UndoRec_28;
		public StbUndoRecord UndoRec_29;
		public StbUndoRecord UndoRec_30;
		public StbUndoRecord UndoRec_31;
		public StbUndoRecord UndoRec_32;
		public StbUndoRecord UndoRec_33;
		public StbUndoRecord UndoRec_34;
		public StbUndoRecord UndoRec_35;
		public StbUndoRecord UndoRec_36;
		public StbUndoRecord UndoRec_37;
		public StbUndoRecord UndoRec_38;
		public StbUndoRecord UndoRec_39;
		public StbUndoRecord UndoRec_40;
		public StbUndoRecord UndoRec_41;
		public StbUndoRecord UndoRec_42;
		public StbUndoRecord UndoRec_43;
		public StbUndoRecord UndoRec_44;
		public StbUndoRecord UndoRec_45;
		public StbUndoRecord UndoRec_46;
		public StbUndoRecord UndoRec_47;
		public StbUndoRecord UndoRec_48;
		public StbUndoRecord UndoRec_49;
		public StbUndoRecord UndoRec_50;
		public StbUndoRecord UndoRec_51;
		public StbUndoRecord UndoRec_52;
		public StbUndoRecord UndoRec_53;
		public StbUndoRecord UndoRec_54;
		public StbUndoRecord UndoRec_55;
		public StbUndoRecord UndoRec_56;
		public StbUndoRecord UndoRec_57;
		public StbUndoRecord UndoRec_58;
		public StbUndoRecord UndoRec_59;
		public StbUndoRecord UndoRec_60;
		public StbUndoRecord UndoRec_61;
		public StbUndoRecord UndoRec_62;
		public StbUndoRecord UndoRec_63;
		public StbUndoRecord UndoRec_64;
		public StbUndoRecord UndoRec_65;
		public StbUndoRecord UndoRec_66;
		public StbUndoRecord UndoRec_67;
		public StbUndoRecord UndoRec_68;
		public StbUndoRecord UndoRec_69;
		public StbUndoRecord UndoRec_70;
		public StbUndoRecord UndoRec_71;
		public StbUndoRecord UndoRec_72;
		public StbUndoRecord UndoRec_73;
		public StbUndoRecord UndoRec_74;
		public StbUndoRecord UndoRec_75;
		public StbUndoRecord UndoRec_76;
		public StbUndoRecord UndoRec_77;
		public StbUndoRecord UndoRec_78;
		public StbUndoRecord UndoRec_79;
		public StbUndoRecord UndoRec_80;
		public StbUndoRecord UndoRec_81;
		public StbUndoRecord UndoRec_82;
		public StbUndoRecord UndoRec_83;
		public StbUndoRecord UndoRec_84;
		public StbUndoRecord UndoRec_85;
		public StbUndoRecord UndoRec_86;
		public StbUndoRecord UndoRec_87;
		public StbUndoRecord UndoRec_88;
		public StbUndoRecord UndoRec_89;
		public StbUndoRecord UndoRec_90;
		public StbUndoRecord UndoRec_91;
		public StbUndoRecord UndoRec_92;
		public StbUndoRecord UndoRec_93;
		public StbUndoRecord UndoRec_94;
		public StbUndoRecord UndoRec_95;
		public StbUndoRecord UndoRec_96;
		public StbUndoRecord UndoRec_97;
		public StbUndoRecord UndoRec_98;
		public ushort UndoChar_0;
		public ushort UndoChar_1;
		public ushort UndoChar_2;
		public ushort UndoChar_3;
		public ushort UndoChar_4;
		public ushort UndoChar_5;
		public ushort UndoChar_6;
		public ushort UndoChar_7;
		public ushort UndoChar_8;
		public ushort UndoChar_9;
		public ushort UndoChar_10;
		public ushort UndoChar_11;
		public ushort UndoChar_12;
		public ushort UndoChar_13;
		public ushort UndoChar_14;
		public ushort UndoChar_15;
		public ushort UndoChar_16;
		public ushort UndoChar_17;
		public ushort UndoChar_18;
		public ushort UndoChar_19;
		public ushort UndoChar_20;
		public ushort UndoChar_21;
		public ushort UndoChar_22;
		public ushort UndoChar_23;
		public ushort UndoChar_24;
		public ushort UndoChar_25;
		public ushort UndoChar_26;
		public ushort UndoChar_27;
		public ushort UndoChar_28;
		public ushort UndoChar_29;
		public ushort UndoChar_30;
		public ushort UndoChar_31;
		public ushort UndoChar_32;
		public ushort UndoChar_33;
		public ushort UndoChar_34;
		public ushort UndoChar_35;
		public ushort UndoChar_36;
		public ushort UndoChar_37;
		public ushort UndoChar_38;
		public ushort UndoChar_39;
		public ushort UndoChar_40;
		public ushort UndoChar_41;
		public ushort UndoChar_42;
		public ushort UndoChar_43;
		public ushort UndoChar_44;
		public ushort UndoChar_45;
		public ushort UndoChar_46;
		public ushort UndoChar_47;
		public ushort UndoChar_48;
		public ushort UndoChar_49;
		public ushort UndoChar_50;
		public ushort UndoChar_51;
		public ushort UndoChar_52;
		public ushort UndoChar_53;
		public ushort UndoChar_54;
		public ushort UndoChar_55;
		public ushort UndoChar_56;
		public ushort UndoChar_57;
		public ushort UndoChar_58;
		public ushort UndoChar_59;
		public ushort UndoChar_60;
		public ushort UndoChar_61;
		public ushort UndoChar_62;
		public ushort UndoChar_63;
		public ushort UndoChar_64;
		public ushort UndoChar_65;
		public ushort UndoChar_66;
		public ushort UndoChar_67;
		public ushort UndoChar_68;
		public ushort UndoChar_69;
		public ushort UndoChar_70;
		public ushort UndoChar_71;
		public ushort UndoChar_72;
		public ushort UndoChar_73;
		public ushort UndoChar_74;
		public ushort UndoChar_75;
		public ushort UndoChar_76;
		public ushort UndoChar_77;
		public ushort UndoChar_78;
		public ushort UndoChar_79;
		public ushort UndoChar_80;
		public ushort UndoChar_81;
		public ushort UndoChar_82;
		public ushort UndoChar_83;
		public ushort UndoChar_84;
		public ushort UndoChar_85;
		public ushort UndoChar_86;
		public ushort UndoChar_87;
		public ushort UndoChar_88;
		public ushort UndoChar_89;
		public ushort UndoChar_90;
		public ushort UndoChar_91;
		public ushort UndoChar_92;
		public ushort UndoChar_93;
		public ushort UndoChar_94;
		public ushort UndoChar_95;
		public ushort UndoChar_96;
		public ushort UndoChar_97;
		public ushort UndoChar_98;
		public ushort UndoChar_99;
		public ushort UndoChar_100;
		public ushort UndoChar_101;
		public ushort UndoChar_102;
		public ushort UndoChar_103;
		public ushort UndoChar_104;
		public ushort UndoChar_105;
		public ushort UndoChar_106;
		public ushort UndoChar_107;
		public ushort UndoChar_108;
		public ushort UndoChar_109;
		public ushort UndoChar_110;
		public ushort UndoChar_111;
		public ushort UndoChar_112;
		public ushort UndoChar_113;
		public ushort UndoChar_114;
		public ushort UndoChar_115;
		public ushort UndoChar_116;
		public ushort UndoChar_117;
		public ushort UndoChar_118;
		public ushort UndoChar_119;
		public ushort UndoChar_120;
		public ushort UndoChar_121;
		public ushort UndoChar_122;
		public ushort UndoChar_123;
		public ushort UndoChar_124;
		public ushort UndoChar_125;
		public ushort UndoChar_126;
		public ushort UndoChar_127;
		public ushort UndoChar_128;
		public ushort UndoChar_129;
		public ushort UndoChar_130;
		public ushort UndoChar_131;
		public ushort UndoChar_132;
		public ushort UndoChar_133;
		public ushort UndoChar_134;
		public ushort UndoChar_135;
		public ushort UndoChar_136;
		public ushort UndoChar_137;
		public ushort UndoChar_138;
		public ushort UndoChar_139;
		public ushort UndoChar_140;
		public ushort UndoChar_141;
		public ushort UndoChar_142;
		public ushort UndoChar_143;
		public ushort UndoChar_144;
		public ushort UndoChar_145;
		public ushort UndoChar_146;
		public ushort UndoChar_147;
		public ushort UndoChar_148;
		public ushort UndoChar_149;
		public ushort UndoChar_150;
		public ushort UndoChar_151;
		public ushort UndoChar_152;
		public ushort UndoChar_153;
		public ushort UndoChar_154;
		public ushort UndoChar_155;
		public ushort UndoChar_156;
		public ushort UndoChar_157;
		public ushort UndoChar_158;
		public ushort UndoChar_159;
		public ushort UndoChar_160;
		public ushort UndoChar_161;
		public ushort UndoChar_162;
		public ushort UndoChar_163;
		public ushort UndoChar_164;
		public ushort UndoChar_165;
		public ushort UndoChar_166;
		public ushort UndoChar_167;
		public ushort UndoChar_168;
		public ushort UndoChar_169;
		public ushort UndoChar_170;
		public ushort UndoChar_171;
		public ushort UndoChar_172;
		public ushort UndoChar_173;
		public ushort UndoChar_174;
		public ushort UndoChar_175;
		public ushort UndoChar_176;
		public ushort UndoChar_177;
		public ushort UndoChar_178;
		public ushort UndoChar_179;
		public ushort UndoChar_180;
		public ushort UndoChar_181;
		public ushort UndoChar_182;
		public ushort UndoChar_183;
		public ushort UndoChar_184;
		public ushort UndoChar_185;
		public ushort UndoChar_186;
		public ushort UndoChar_187;
		public ushort UndoChar_188;
		public ushort UndoChar_189;
		public ushort UndoChar_190;
		public ushort UndoChar_191;
		public ushort UndoChar_192;
		public ushort UndoChar_193;
		public ushort UndoChar_194;
		public ushort UndoChar_195;
		public ushort UndoChar_196;
		public ushort UndoChar_197;
		public ushort UndoChar_198;
		public ushort UndoChar_199;
		public ushort UndoChar_200;
		public ushort UndoChar_201;
		public ushort UndoChar_202;
		public ushort UndoChar_203;
		public ushort UndoChar_204;
		public ushort UndoChar_205;
		public ushort UndoChar_206;
		public ushort UndoChar_207;
		public ushort UndoChar_208;
		public ushort UndoChar_209;
		public ushort UndoChar_210;
		public ushort UndoChar_211;
		public ushort UndoChar_212;
		public ushort UndoChar_213;
		public ushort UndoChar_214;
		public ushort UndoChar_215;
		public ushort UndoChar_216;
		public ushort UndoChar_217;
		public ushort UndoChar_218;
		public ushort UndoChar_219;
		public ushort UndoChar_220;
		public ushort UndoChar_221;
		public ushort UndoChar_222;
		public ushort UndoChar_223;
		public ushort UndoChar_224;
		public ushort UndoChar_225;
		public ushort UndoChar_226;
		public ushort UndoChar_227;
		public ushort UndoChar_228;
		public ushort UndoChar_229;
		public ushort UndoChar_230;
		public ushort UndoChar_231;
		public ushort UndoChar_232;
		public ushort UndoChar_233;
		public ushort UndoChar_234;
		public ushort UndoChar_235;
		public ushort UndoChar_236;
		public ushort UndoChar_237;
		public ushort UndoChar_238;
		public ushort UndoChar_239;
		public ushort UndoChar_240;
		public ushort UndoChar_241;
		public ushort UndoChar_242;
		public ushort UndoChar_243;
		public ushort UndoChar_244;
		public ushort UndoChar_245;
		public ushort UndoChar_246;
		public ushort UndoChar_247;
		public ushort UndoChar_248;
		public ushort UndoChar_249;
		public ushort UndoChar_250;
		public ushort UndoChar_251;
		public ushort UndoChar_252;
		public ushort UndoChar_253;
		public ushort UndoChar_254;
		public ushort UndoChar_255;
		public ushort UndoChar_256;
		public ushort UndoChar_257;
		public ushort UndoChar_258;
		public ushort UndoChar_259;
		public ushort UndoChar_260;
		public ushort UndoChar_261;
		public ushort UndoChar_262;
		public ushort UndoChar_263;
		public ushort UndoChar_264;
		public ushort UndoChar_265;
		public ushort UndoChar_266;
		public ushort UndoChar_267;
		public ushort UndoChar_268;
		public ushort UndoChar_269;
		public ushort UndoChar_270;
		public ushort UndoChar_271;
		public ushort UndoChar_272;
		public ushort UndoChar_273;
		public ushort UndoChar_274;
		public ushort UndoChar_275;
		public ushort UndoChar_276;
		public ushort UndoChar_277;
		public ushort UndoChar_278;
		public ushort UndoChar_279;
		public ushort UndoChar_280;
		public ushort UndoChar_281;
		public ushort UndoChar_282;
		public ushort UndoChar_283;
		public ushort UndoChar_284;
		public ushort UndoChar_285;
		public ushort UndoChar_286;
		public ushort UndoChar_287;
		public ushort UndoChar_288;
		public ushort UndoChar_289;
		public ushort UndoChar_290;
		public ushort UndoChar_291;
		public ushort UndoChar_292;
		public ushort UndoChar_293;
		public ushort UndoChar_294;
		public ushort UndoChar_295;
		public ushort UndoChar_296;
		public ushort UndoChar_297;
		public ushort UndoChar_298;
		public ushort UndoChar_299;
		public ushort UndoChar_300;
		public ushort UndoChar_301;
		public ushort UndoChar_302;
		public ushort UndoChar_303;
		public ushort UndoChar_304;
		public ushort UndoChar_305;
		public ushort UndoChar_306;
		public ushort UndoChar_307;
		public ushort UndoChar_308;
		public ushort UndoChar_309;
		public ushort UndoChar_310;
		public ushort UndoChar_311;
		public ushort UndoChar_312;
		public ushort UndoChar_313;
		public ushort UndoChar_314;
		public ushort UndoChar_315;
		public ushort UndoChar_316;
		public ushort UndoChar_317;
		public ushort UndoChar_318;
		public ushort UndoChar_319;
		public ushort UndoChar_320;
		public ushort UndoChar_321;
		public ushort UndoChar_322;
		public ushort UndoChar_323;
		public ushort UndoChar_324;
		public ushort UndoChar_325;
		public ushort UndoChar_326;
		public ushort UndoChar_327;
		public ushort UndoChar_328;
		public ushort UndoChar_329;
		public ushort UndoChar_330;
		public ushort UndoChar_331;
		public ushort UndoChar_332;
		public ushort UndoChar_333;
		public ushort UndoChar_334;
		public ushort UndoChar_335;
		public ushort UndoChar_336;
		public ushort UndoChar_337;
		public ushort UndoChar_338;
		public ushort UndoChar_339;
		public ushort UndoChar_340;
		public ushort UndoChar_341;
		public ushort UndoChar_342;
		public ushort UndoChar_343;
		public ushort UndoChar_344;
		public ushort UndoChar_345;
		public ushort UndoChar_346;
		public ushort UndoChar_347;
		public ushort UndoChar_348;
		public ushort UndoChar_349;
		public ushort UndoChar_350;
		public ushort UndoChar_351;
		public ushort UndoChar_352;
		public ushort UndoChar_353;
		public ushort UndoChar_354;
		public ushort UndoChar_355;
		public ushort UndoChar_356;
		public ushort UndoChar_357;
		public ushort UndoChar_358;
		public ushort UndoChar_359;
		public ushort UndoChar_360;
		public ushort UndoChar_361;
		public ushort UndoChar_362;
		public ushort UndoChar_363;
		public ushort UndoChar_364;
		public ushort UndoChar_365;
		public ushort UndoChar_366;
		public ushort UndoChar_367;
		public ushort UndoChar_368;
		public ushort UndoChar_369;
		public ushort UndoChar_370;
		public ushort UndoChar_371;
		public ushort UndoChar_372;
		public ushort UndoChar_373;
		public ushort UndoChar_374;
		public ushort UndoChar_375;
		public ushort UndoChar_376;
		public ushort UndoChar_377;
		public ushort UndoChar_378;
		public ushort UndoChar_379;
		public ushort UndoChar_380;
		public ushort UndoChar_381;
		public ushort UndoChar_382;
		public ushort UndoChar_383;
		public ushort UndoChar_384;
		public ushort UndoChar_385;
		public ushort UndoChar_386;
		public ushort UndoChar_387;
		public ushort UndoChar_388;
		public ushort UndoChar_389;
		public ushort UndoChar_390;
		public ushort UndoChar_391;
		public ushort UndoChar_392;
		public ushort UndoChar_393;
		public ushort UndoChar_394;
		public ushort UndoChar_395;
		public ushort UndoChar_396;
		public ushort UndoChar_397;
		public ushort UndoChar_398;
		public ushort UndoChar_399;
		public ushort UndoChar_400;
		public ushort UndoChar_401;
		public ushort UndoChar_402;
		public ushort UndoChar_403;
		public ushort UndoChar_404;
		public ushort UndoChar_405;
		public ushort UndoChar_406;
		public ushort UndoChar_407;
		public ushort UndoChar_408;
		public ushort UndoChar_409;
		public ushort UndoChar_410;
		public ushort UndoChar_411;
		public ushort UndoChar_412;
		public ushort UndoChar_413;
		public ushort UndoChar_414;
		public ushort UndoChar_415;
		public ushort UndoChar_416;
		public ushort UndoChar_417;
		public ushort UndoChar_418;
		public ushort UndoChar_419;
		public ushort UndoChar_420;
		public ushort UndoChar_421;
		public ushort UndoChar_422;
		public ushort UndoChar_423;
		public ushort UndoChar_424;
		public ushort UndoChar_425;
		public ushort UndoChar_426;
		public ushort UndoChar_427;
		public ushort UndoChar_428;
		public ushort UndoChar_429;
		public ushort UndoChar_430;
		public ushort UndoChar_431;
		public ushort UndoChar_432;
		public ushort UndoChar_433;
		public ushort UndoChar_434;
		public ushort UndoChar_435;
		public ushort UndoChar_436;
		public ushort UndoChar_437;
		public ushort UndoChar_438;
		public ushort UndoChar_439;
		public ushort UndoChar_440;
		public ushort UndoChar_441;
		public ushort UndoChar_442;
		public ushort UndoChar_443;
		public ushort UndoChar_444;
		public ushort UndoChar_445;
		public ushort UndoChar_446;
		public ushort UndoChar_447;
		public ushort UndoChar_448;
		public ushort UndoChar_449;
		public ushort UndoChar_450;
		public ushort UndoChar_451;
		public ushort UndoChar_452;
		public ushort UndoChar_453;
		public ushort UndoChar_454;
		public ushort UndoChar_455;
		public ushort UndoChar_456;
		public ushort UndoChar_457;
		public ushort UndoChar_458;
		public ushort UndoChar_459;
		public ushort UndoChar_460;
		public ushort UndoChar_461;
		public ushort UndoChar_462;
		public ushort UndoChar_463;
		public ushort UndoChar_464;
		public ushort UndoChar_465;
		public ushort UndoChar_466;
		public ushort UndoChar_467;
		public ushort UndoChar_468;
		public ushort UndoChar_469;
		public ushort UndoChar_470;
		public ushort UndoChar_471;
		public ushort UndoChar_472;
		public ushort UndoChar_473;
		public ushort UndoChar_474;
		public ushort UndoChar_475;
		public ushort UndoChar_476;
		public ushort UndoChar_477;
		public ushort UndoChar_478;
		public ushort UndoChar_479;
		public ushort UndoChar_480;
		public ushort UndoChar_481;
		public ushort UndoChar_482;
		public ushort UndoChar_483;
		public ushort UndoChar_484;
		public ushort UndoChar_485;
		public ushort UndoChar_486;
		public ushort UndoChar_487;
		public ushort UndoChar_488;
		public ushort UndoChar_489;
		public ushort UndoChar_490;
		public ushort UndoChar_491;
		public ushort UndoChar_492;
		public ushort UndoChar_493;
		public ushort UndoChar_494;
		public ushort UndoChar_495;
		public ushort UndoChar_496;
		public ushort UndoChar_497;
		public ushort UndoChar_498;
		public ushort UndoChar_499;
		public ushort UndoChar_500;
		public ushort UndoChar_501;
		public ushort UndoChar_502;
		public ushort UndoChar_503;
		public ushort UndoChar_504;
		public ushort UndoChar_505;
		public ushort UndoChar_506;
		public ushort UndoChar_507;
		public ushort UndoChar_508;
		public ushort UndoChar_509;
		public ushort UndoChar_510;
		public ushort UndoChar_511;
		public ushort UndoChar_512;
		public ushort UndoChar_513;
		public ushort UndoChar_514;
		public ushort UndoChar_515;
		public ushort UndoChar_516;
		public ushort UndoChar_517;
		public ushort UndoChar_518;
		public ushort UndoChar_519;
		public ushort UndoChar_520;
		public ushort UndoChar_521;
		public ushort UndoChar_522;
		public ushort UndoChar_523;
		public ushort UndoChar_524;
		public ushort UndoChar_525;
		public ushort UndoChar_526;
		public ushort UndoChar_527;
		public ushort UndoChar_528;
		public ushort UndoChar_529;
		public ushort UndoChar_530;
		public ushort UndoChar_531;
		public ushort UndoChar_532;
		public ushort UndoChar_533;
		public ushort UndoChar_534;
		public ushort UndoChar_535;
		public ushort UndoChar_536;
		public ushort UndoChar_537;
		public ushort UndoChar_538;
		public ushort UndoChar_539;
		public ushort UndoChar_540;
		public ushort UndoChar_541;
		public ushort UndoChar_542;
		public ushort UndoChar_543;
		public ushort UndoChar_544;
		public ushort UndoChar_545;
		public ushort UndoChar_546;
		public ushort UndoChar_547;
		public ushort UndoChar_548;
		public ushort UndoChar_549;
		public ushort UndoChar_550;
		public ushort UndoChar_551;
		public ushort UndoChar_552;
		public ushort UndoChar_553;
		public ushort UndoChar_554;
		public ushort UndoChar_555;
		public ushort UndoChar_556;
		public ushort UndoChar_557;
		public ushort UndoChar_558;
		public ushort UndoChar_559;
		public ushort UndoChar_560;
		public ushort UndoChar_561;
		public ushort UndoChar_562;
		public ushort UndoChar_563;
		public ushort UndoChar_564;
		public ushort UndoChar_565;
		public ushort UndoChar_566;
		public ushort UndoChar_567;
		public ushort UndoChar_568;
		public ushort UndoChar_569;
		public ushort UndoChar_570;
		public ushort UndoChar_571;
		public ushort UndoChar_572;
		public ushort UndoChar_573;
		public ushort UndoChar_574;
		public ushort UndoChar_575;
		public ushort UndoChar_576;
		public ushort UndoChar_577;
		public ushort UndoChar_578;
		public ushort UndoChar_579;
		public ushort UndoChar_580;
		public ushort UndoChar_581;
		public ushort UndoChar_582;
		public ushort UndoChar_583;
		public ushort UndoChar_584;
		public ushort UndoChar_585;
		public ushort UndoChar_586;
		public ushort UndoChar_587;
		public ushort UndoChar_588;
		public ushort UndoChar_589;
		public ushort UndoChar_590;
		public ushort UndoChar_591;
		public ushort UndoChar_592;
		public ushort UndoChar_593;
		public ushort UndoChar_594;
		public ushort UndoChar_595;
		public ushort UndoChar_596;
		public ushort UndoChar_597;
		public ushort UndoChar_598;
		public ushort UndoChar_599;
		public ushort UndoChar_600;
		public ushort UndoChar_601;
		public ushort UndoChar_602;
		public ushort UndoChar_603;
		public ushort UndoChar_604;
		public ushort UndoChar_605;
		public ushort UndoChar_606;
		public ushort UndoChar_607;
		public ushort UndoChar_608;
		public ushort UndoChar_609;
		public ushort UndoChar_610;
		public ushort UndoChar_611;
		public ushort UndoChar_612;
		public ushort UndoChar_613;
		public ushort UndoChar_614;
		public ushort UndoChar_615;
		public ushort UndoChar_616;
		public ushort UndoChar_617;
		public ushort UndoChar_618;
		public ushort UndoChar_619;
		public ushort UndoChar_620;
		public ushort UndoChar_621;
		public ushort UndoChar_622;
		public ushort UndoChar_623;
		public ushort UndoChar_624;
		public ushort UndoChar_625;
		public ushort UndoChar_626;
		public ushort UndoChar_627;
		public ushort UndoChar_628;
		public ushort UndoChar_629;
		public ushort UndoChar_630;
		public ushort UndoChar_631;
		public ushort UndoChar_632;
		public ushort UndoChar_633;
		public ushort UndoChar_634;
		public ushort UndoChar_635;
		public ushort UndoChar_636;
		public ushort UndoChar_637;
		public ushort UndoChar_638;
		public ushort UndoChar_639;
		public ushort UndoChar_640;
		public ushort UndoChar_641;
		public ushort UndoChar_642;
		public ushort UndoChar_643;
		public ushort UndoChar_644;
		public ushort UndoChar_645;
		public ushort UndoChar_646;
		public ushort UndoChar_647;
		public ushort UndoChar_648;
		public ushort UndoChar_649;
		public ushort UndoChar_650;
		public ushort UndoChar_651;
		public ushort UndoChar_652;
		public ushort UndoChar_653;
		public ushort UndoChar_654;
		public ushort UndoChar_655;
		public ushort UndoChar_656;
		public ushort UndoChar_657;
		public ushort UndoChar_658;
		public ushort UndoChar_659;
		public ushort UndoChar_660;
		public ushort UndoChar_661;
		public ushort UndoChar_662;
		public ushort UndoChar_663;
		public ushort UndoChar_664;
		public ushort UndoChar_665;
		public ushort UndoChar_666;
		public ushort UndoChar_667;
		public ushort UndoChar_668;
		public ushort UndoChar_669;
		public ushort UndoChar_670;
		public ushort UndoChar_671;
		public ushort UndoChar_672;
		public ushort UndoChar_673;
		public ushort UndoChar_674;
		public ushort UndoChar_675;
		public ushort UndoChar_676;
		public ushort UndoChar_677;
		public ushort UndoChar_678;
		public ushort UndoChar_679;
		public ushort UndoChar_680;
		public ushort UndoChar_681;
		public ushort UndoChar_682;
		public ushort UndoChar_683;
		public ushort UndoChar_684;
		public ushort UndoChar_685;
		public ushort UndoChar_686;
		public ushort UndoChar_687;
		public ushort UndoChar_688;
		public ushort UndoChar_689;
		public ushort UndoChar_690;
		public ushort UndoChar_691;
		public ushort UndoChar_692;
		public ushort UndoChar_693;
		public ushort UndoChar_694;
		public ushort UndoChar_695;
		public ushort UndoChar_696;
		public ushort UndoChar_697;
		public ushort UndoChar_698;
		public ushort UndoChar_699;
		public ushort UndoChar_700;
		public ushort UndoChar_701;
		public ushort UndoChar_702;
		public ushort UndoChar_703;
		public ushort UndoChar_704;
		public ushort UndoChar_705;
		public ushort UndoChar_706;
		public ushort UndoChar_707;
		public ushort UndoChar_708;
		public ushort UndoChar_709;
		public ushort UndoChar_710;
		public ushort UndoChar_711;
		public ushort UndoChar_712;
		public ushort UndoChar_713;
		public ushort UndoChar_714;
		public ushort UndoChar_715;
		public ushort UndoChar_716;
		public ushort UndoChar_717;
		public ushort UndoChar_718;
		public ushort UndoChar_719;
		public ushort UndoChar_720;
		public ushort UndoChar_721;
		public ushort UndoChar_722;
		public ushort UndoChar_723;
		public ushort UndoChar_724;
		public ushort UndoChar_725;
		public ushort UndoChar_726;
		public ushort UndoChar_727;
		public ushort UndoChar_728;
		public ushort UndoChar_729;
		public ushort UndoChar_730;
		public ushort UndoChar_731;
		public ushort UndoChar_732;
		public ushort UndoChar_733;
		public ushort UndoChar_734;
		public ushort UndoChar_735;
		public ushort UndoChar_736;
		public ushort UndoChar_737;
		public ushort UndoChar_738;
		public ushort UndoChar_739;
		public ushort UndoChar_740;
		public ushort UndoChar_741;
		public ushort UndoChar_742;
		public ushort UndoChar_743;
		public ushort UndoChar_744;
		public ushort UndoChar_745;
		public ushort UndoChar_746;
		public ushort UndoChar_747;
		public ushort UndoChar_748;
		public ushort UndoChar_749;
		public ushort UndoChar_750;
		public ushort UndoChar_751;
		public ushort UndoChar_752;
		public ushort UndoChar_753;
		public ushort UndoChar_754;
		public ushort UndoChar_755;
		public ushort UndoChar_756;
		public ushort UndoChar_757;
		public ushort UndoChar_758;
		public ushort UndoChar_759;
		public ushort UndoChar_760;
		public ushort UndoChar_761;
		public ushort UndoChar_762;
		public ushort UndoChar_763;
		public ushort UndoChar_764;
		public ushort UndoChar_765;
		public ushort UndoChar_766;
		public ushort UndoChar_767;
		public ushort UndoChar_768;
		public ushort UndoChar_769;
		public ushort UndoChar_770;
		public ushort UndoChar_771;
		public ushort UndoChar_772;
		public ushort UndoChar_773;
		public ushort UndoChar_774;
		public ushort UndoChar_775;
		public ushort UndoChar_776;
		public ushort UndoChar_777;
		public ushort UndoChar_778;
		public ushort UndoChar_779;
		public ushort UndoChar_780;
		public ushort UndoChar_781;
		public ushort UndoChar_782;
		public ushort UndoChar_783;
		public ushort UndoChar_784;
		public ushort UndoChar_785;
		public ushort UndoChar_786;
		public ushort UndoChar_787;
		public ushort UndoChar_788;
		public ushort UndoChar_789;
		public ushort UndoChar_790;
		public ushort UndoChar_791;
		public ushort UndoChar_792;
		public ushort UndoChar_793;
		public ushort UndoChar_794;
		public ushort UndoChar_795;
		public ushort UndoChar_796;
		public ushort UndoChar_797;
		public ushort UndoChar_798;
		public ushort UndoChar_799;
		public ushort UndoChar_800;
		public ushort UndoChar_801;
		public ushort UndoChar_802;
		public ushort UndoChar_803;
		public ushort UndoChar_804;
		public ushort UndoChar_805;
		public ushort UndoChar_806;
		public ushort UndoChar_807;
		public ushort UndoChar_808;
		public ushort UndoChar_809;
		public ushort UndoChar_810;
		public ushort UndoChar_811;
		public ushort UndoChar_812;
		public ushort UndoChar_813;
		public ushort UndoChar_814;
		public ushort UndoChar_815;
		public ushort UndoChar_816;
		public ushort UndoChar_817;
		public ushort UndoChar_818;
		public ushort UndoChar_819;
		public ushort UndoChar_820;
		public ushort UndoChar_821;
		public ushort UndoChar_822;
		public ushort UndoChar_823;
		public ushort UndoChar_824;
		public ushort UndoChar_825;
		public ushort UndoChar_826;
		public ushort UndoChar_827;
		public ushort UndoChar_828;
		public ushort UndoChar_829;
		public ushort UndoChar_830;
		public ushort UndoChar_831;
		public ushort UndoChar_832;
		public ushort UndoChar_833;
		public ushort UndoChar_834;
		public ushort UndoChar_835;
		public ushort UndoChar_836;
		public ushort UndoChar_837;
		public ushort UndoChar_838;
		public ushort UndoChar_839;
		public ushort UndoChar_840;
		public ushort UndoChar_841;
		public ushort UndoChar_842;
		public ushort UndoChar_843;
		public ushort UndoChar_844;
		public ushort UndoChar_845;
		public ushort UndoChar_846;
		public ushort UndoChar_847;
		public ushort UndoChar_848;
		public ushort UndoChar_849;
		public ushort UndoChar_850;
		public ushort UndoChar_851;
		public ushort UndoChar_852;
		public ushort UndoChar_853;
		public ushort UndoChar_854;
		public ushort UndoChar_855;
		public ushort UndoChar_856;
		public ushort UndoChar_857;
		public ushort UndoChar_858;
		public ushort UndoChar_859;
		public ushort UndoChar_860;
		public ushort UndoChar_861;
		public ushort UndoChar_862;
		public ushort UndoChar_863;
		public ushort UndoChar_864;
		public ushort UndoChar_865;
		public ushort UndoChar_866;
		public ushort UndoChar_867;
		public ushort UndoChar_868;
		public ushort UndoChar_869;
		public ushort UndoChar_870;
		public ushort UndoChar_871;
		public ushort UndoChar_872;
		public ushort UndoChar_873;
		public ushort UndoChar_874;
		public ushort UndoChar_875;
		public ushort UndoChar_876;
		public ushort UndoChar_877;
		public ushort UndoChar_878;
		public ushort UndoChar_879;
		public ushort UndoChar_880;
		public ushort UndoChar_881;
		public ushort UndoChar_882;
		public ushort UndoChar_883;
		public ushort UndoChar_884;
		public ushort UndoChar_885;
		public ushort UndoChar_886;
		public ushort UndoChar_887;
		public ushort UndoChar_888;
		public ushort UndoChar_889;
		public ushort UndoChar_890;
		public ushort UndoChar_891;
		public ushort UndoChar_892;
		public ushort UndoChar_893;
		public ushort UndoChar_894;
		public ushort UndoChar_895;
		public ushort UndoChar_896;
		public ushort UndoChar_897;
		public ushort UndoChar_898;
		public ushort UndoChar_899;
		public ushort UndoChar_900;
		public ushort UndoChar_901;
		public ushort UndoChar_902;
		public ushort UndoChar_903;
		public ushort UndoChar_904;
		public ushort UndoChar_905;
		public ushort UndoChar_906;
		public ushort UndoChar_907;
		public ushort UndoChar_908;
		public ushort UndoChar_909;
		public ushort UndoChar_910;
		public ushort UndoChar_911;
		public ushort UndoChar_912;
		public ushort UndoChar_913;
		public ushort UndoChar_914;
		public ushort UndoChar_915;
		public ushort UndoChar_916;
		public ushort UndoChar_917;
		public ushort UndoChar_918;
		public ushort UndoChar_919;
		public ushort UndoChar_920;
		public ushort UndoChar_921;
		public ushort UndoChar_922;
		public ushort UndoChar_923;
		public ushort UndoChar_924;
		public ushort UndoChar_925;
		public ushort UndoChar_926;
		public ushort UndoChar_927;
		public ushort UndoChar_928;
		public ushort UndoChar_929;
		public ushort UndoChar_930;
		public ushort UndoChar_931;
		public ushort UndoChar_932;
		public ushort UndoChar_933;
		public ushort UndoChar_934;
		public ushort UndoChar_935;
		public ushort UndoChar_936;
		public ushort UndoChar_937;
		public ushort UndoChar_938;
		public ushort UndoChar_939;
		public ushort UndoChar_940;
		public ushort UndoChar_941;
		public ushort UndoChar_942;
		public ushort UndoChar_943;
		public ushort UndoChar_944;
		public ushort UndoChar_945;
		public ushort UndoChar_946;
		public ushort UndoChar_947;
		public ushort UndoChar_948;
		public ushort UndoChar_949;
		public ushort UndoChar_950;
		public ushort UndoChar_951;
		public ushort UndoChar_952;
		public ushort UndoChar_953;
		public ushort UndoChar_954;
		public ushort UndoChar_955;
		public ushort UndoChar_956;
		public ushort UndoChar_957;
		public ushort UndoChar_958;
		public ushort UndoChar_959;
		public ushort UndoChar_960;
		public ushort UndoChar_961;
		public ushort UndoChar_962;
		public ushort UndoChar_963;
		public ushort UndoChar_964;
		public ushort UndoChar_965;
		public ushort UndoChar_966;
		public ushort UndoChar_967;
		public ushort UndoChar_968;
		public ushort UndoChar_969;
		public ushort UndoChar_970;
		public ushort UndoChar_971;
		public ushort UndoChar_972;
		public ushort UndoChar_973;
		public ushort UndoChar_974;
		public ushort UndoChar_975;
		public ushort UndoChar_976;
		public ushort UndoChar_977;
		public ushort UndoChar_978;
		public ushort UndoChar_979;
		public ushort UndoChar_980;
		public ushort UndoChar_981;
		public ushort UndoChar_982;
		public ushort UndoChar_983;
		public ushort UndoChar_984;
		public ushort UndoChar_985;
		public ushort UndoChar_986;
		public ushort UndoChar_987;
		public ushort UndoChar_988;
		public ushort UndoChar_989;
		public ushort UndoChar_990;
		public ushort UndoChar_991;
		public ushort UndoChar_992;
		public ushort UndoChar_993;
		public ushort UndoChar_994;
		public ushort UndoChar_995;
		public ushort UndoChar_996;
		public ushort UndoChar_997;
		public ushort UndoChar_998;
		public short UndoPoint;
		public short RedoPoint;
		public int UndoCharPoint;
		public int RedoCharPoint;


		public unsafe Span<StbUndoRecord> UndoRec
		
		{
			get
			{
				fixed (StbUndoRecord* p = &this.UndoRec_0)
				{
					return new Span<StbUndoRecord>(p, 99);
				}
			}
		}
	}

	/// <summary>
	/// STB_TexteditState<br/>
	/// Definition of STB_TexteditState which you should store<br/>
	/// per-textfield; it includes cursor position, selection state,<br/>
	/// and undo state.<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct StbUndoRecord
	{
		public int Where;
		public int InsertLength;
		public int DeleteLength;
		public int CharStorage;


	}

	/// <summary>
	/// Internal temporary state for deactivating InputText() instances.<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiInputTextDeactivatedState
	{
		/// <summary>
		/// widget id owning the text state (which just got deactivated)<br/>
		/// </summary>
		public int ID;

		/// <summary>
		/// text buffer<br/>
		/// </summary>
		public ImVectorChar TextA;





		public unsafe void ClearFreeMemory()
		{
			fixed (ImGuiInputTextDeactivatedState* @this = &this)
			{
				ImGui.ClearFreeMemoryNative(@this);
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImGuiInputTextDeactivatedState* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiInputTextDeactivatedStatePtr : IEquatable<ImGuiInputTextDeactivatedStatePtr>
	{
		public ImGuiInputTextDeactivatedStatePtr(ImGuiInputTextDeactivatedState* handle) { Handle = handle; }

		public ImGuiInputTextDeactivatedState* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiInputTextDeactivatedStatePtr Null => new ImGuiInputTextDeactivatedStatePtr(null);

		public static implicit operator ImGuiInputTextDeactivatedStatePtr(ImGuiInputTextDeactivatedState* handle) => new ImGuiInputTextDeactivatedStatePtr(handle);

		public static implicit operator ImGuiInputTextDeactivatedState*(ImGuiInputTextDeactivatedStatePtr handle) => handle.Handle;

		public static bool operator ==(ImGuiInputTextDeactivatedStatePtr left, ImGuiInputTextDeactivatedStatePtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiInputTextDeactivatedStatePtr left, ImGuiInputTextDeactivatedStatePtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiInputTextDeactivatedStatePtr left, ImGuiInputTextDeactivatedState* right) => left.Handle == right;

		public static bool operator !=(ImGuiInputTextDeactivatedStatePtr left, ImGuiInputTextDeactivatedState* right) => left.Handle != right;

		public bool Equals(ImGuiInputTextDeactivatedStatePtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiInputTextDeactivatedStatePtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiInputTextDeactivatedStatePtr [0x{0}]", ((nuint)Handle).ToString("X"));
		/// <summary>
		/// widget id owning the text state (which just got deactivated)<br/>
		/// </summary>
		public ref int ID => ref Unsafe.AsRef<int>(&Handle->ID);
		/// <summary>
		/// text buffer<br/>
		/// </summary>
		public ref ImVectorChar TextA => ref Unsafe.AsRef<ImVectorChar>(&Handle->TextA);

		public unsafe void ClearFreeMemory()
		{
			ImGui.ClearFreeMemoryNative(Handle);
		}

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

	}

	/// <summary>
	/// Storage data for BeginComboPreview()EndComboPreview()<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiComboPreviewData
	{
		public ImRect PreviewRect;
		public Vector2 BackupCursorPos;
		public Vector2 BackupCursorMaxPos;
		public Vector2 BackupCursorPosPrevLine;
		public float BackupPrevLineTextBaseOffset;
		public ImGuiLayoutType BackupLayout;




		public unsafe void Destroy()
		{
			fixed (ImGuiComboPreviewData* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiComboPreviewDataPtr : IEquatable<ImGuiComboPreviewDataPtr>
	{
		public ImGuiComboPreviewDataPtr(ImGuiComboPreviewData* handle) { Handle = handle; }

		public ImGuiComboPreviewData* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiComboPreviewDataPtr Null => new ImGuiComboPreviewDataPtr(null);

		public static implicit operator ImGuiComboPreviewDataPtr(ImGuiComboPreviewData* handle) => new ImGuiComboPreviewDataPtr(handle);

		public static implicit operator ImGuiComboPreviewData*(ImGuiComboPreviewDataPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiComboPreviewDataPtr left, ImGuiComboPreviewDataPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiComboPreviewDataPtr left, ImGuiComboPreviewDataPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiComboPreviewDataPtr left, ImGuiComboPreviewData* right) => left.Handle == right;

		public static bool operator !=(ImGuiComboPreviewDataPtr left, ImGuiComboPreviewData* right) => left.Handle != right;

		public bool Equals(ImGuiComboPreviewDataPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiComboPreviewDataPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiComboPreviewDataPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref ImRect PreviewRect => ref Unsafe.AsRef<ImRect>(&Handle->PreviewRect);
		public ref Vector2 BackupCursorPos => ref Unsafe.AsRef<Vector2>(&Handle->BackupCursorPos);
		public ref Vector2 BackupCursorMaxPos => ref Unsafe.AsRef<Vector2>(&Handle->BackupCursorMaxPos);
		public ref Vector2 BackupCursorPosPrevLine => ref Unsafe.AsRef<Vector2>(&Handle->BackupCursorPosPrevLine);
		public ref float BackupPrevLineTextBaseOffset => ref Unsafe.AsRef<float>(&Handle->BackupPrevLineTextBaseOffset);
		public ref ImGuiLayoutType BackupLayout => ref Unsafe.AsRef<ImGuiLayoutType>(&Handle->BackupLayout);

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiDockContext
	{
		/// <summary>
		/// Map ID -&gt; ImGuiDockNode*: Active nodes<br/>
		/// </summary>
		public ImGuiStorage Nodes;

		public ImVectorImGuiDockRequest Requests;
		public ImVectorImGuiDockNodeSettings NodesSettings;
		public byte WantFullRebuild;




		public unsafe void Destroy()
		{
			fixed (ImGuiDockContext* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiDockContextPtr : IEquatable<ImGuiDockContextPtr>
	{
		public ImGuiDockContextPtr(ImGuiDockContext* handle) { Handle = handle; }

		public ImGuiDockContext* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiDockContextPtr Null => new ImGuiDockContextPtr(null);

		public static implicit operator ImGuiDockContextPtr(ImGuiDockContext* handle) => new ImGuiDockContextPtr(handle);

		public static implicit operator ImGuiDockContext*(ImGuiDockContextPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiDockContextPtr left, ImGuiDockContextPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiDockContextPtr left, ImGuiDockContextPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiDockContextPtr left, ImGuiDockContext* right) => left.Handle == right;

		public static bool operator !=(ImGuiDockContextPtr left, ImGuiDockContext* right) => left.Handle != right;

		public bool Equals(ImGuiDockContextPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiDockContextPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiDockContextPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		/// <summary>
		/// Map ID -&gt; ImGuiDockNode*: Active nodes<br/>
		/// </summary>
		public ref ImGuiStorage Nodes => ref Unsafe.AsRef<ImGuiStorage>(&Handle->Nodes);
		public ref ImVectorImGuiDockRequest Requests => ref Unsafe.AsRef<ImVectorImGuiDockRequest>(&Handle->Requests);
		public ref ImVectorImGuiDockNodeSettings NodesSettings => ref Unsafe.AsRef<ImVectorImGuiDockNodeSettings>(&Handle->NodesSettings);
		public ref bool WantFullRebuild => ref Unsafe.AsRef<bool>(&Handle->WantFullRebuild);

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiDockRequest
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiDockRequest* Data;


	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiDockRequest
	{


	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiDockRequestPtr : IEquatable<ImGuiDockRequestPtr>
	{
		public ImGuiDockRequestPtr(ImGuiDockRequest* handle) { Handle = handle; }

		public ImGuiDockRequest* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiDockRequestPtr Null => new ImGuiDockRequestPtr(null);

		public static implicit operator ImGuiDockRequestPtr(ImGuiDockRequest* handle) => new ImGuiDockRequestPtr(handle);

		public static implicit operator ImGuiDockRequest*(ImGuiDockRequestPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiDockRequestPtr left, ImGuiDockRequestPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiDockRequestPtr left, ImGuiDockRequestPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiDockRequestPtr left, ImGuiDockRequest* right) => left.Handle == right;

		public static bool operator !=(ImGuiDockRequestPtr left, ImGuiDockRequest* right) => left.Handle != right;

		public bool Equals(ImGuiDockRequestPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiDockRequestPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiDockRequestPtr [0x{0}]", ((nuint)Handle).ToString("X"));
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiDockNodeSettings
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiDockNodeSettings* Data;


	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiDockNodeSettings
	{


	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiDockNodeSettingsPtr : IEquatable<ImGuiDockNodeSettingsPtr>
	{
		public ImGuiDockNodeSettingsPtr(ImGuiDockNodeSettings* handle) { Handle = handle; }

		public ImGuiDockNodeSettings* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiDockNodeSettingsPtr Null => new ImGuiDockNodeSettingsPtr(null);

		public static implicit operator ImGuiDockNodeSettingsPtr(ImGuiDockNodeSettings* handle) => new ImGuiDockNodeSettingsPtr(handle);

		public static implicit operator ImGuiDockNodeSettings*(ImGuiDockNodeSettingsPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiDockNodeSettingsPtr left, ImGuiDockNodeSettingsPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiDockNodeSettingsPtr left, ImGuiDockNodeSettingsPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiDockNodeSettingsPtr left, ImGuiDockNodeSettings* right) => left.Handle == right;

		public static bool operator !=(ImGuiDockNodeSettingsPtr left, ImGuiDockNodeSettings* right) => left.Handle != right;

		public bool Equals(ImGuiDockNodeSettingsPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiDockNodeSettingsPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiDockNodeSettingsPtr [0x{0}]", ((nuint)Handle).ToString("X"));
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiSettingsHandler
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiSettingsHandler* Data;


	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiSettingsHandler
	{
		/// <summary>
		/// Short description stored in .ini file. Disallowed characters: '[' ']'<br/>
		/// </summary>
		public unsafe byte* TypeName;

		/// <summary>
		/// == ImHashStr(TypeName)<br/>
		/// </summary>
		public int TypeHash;

		/// <summary>
		/// Clear all settings data<br/>
		/// </summary>
		public unsafe void* ClearAllFn;

		/// <summary>
		/// Read: Called before reading (in registration order)<br/>
		/// </summary>
		public unsafe void* ReadInitFn;

		/// <summary>
		/// Read: Called when entering into a new ini entry e.g. "[Window][Name]"<br/>
		/// </summary>
		public unsafe void* ReadOpenFn;

		/// <summary>
		/// Read: Called for every line of text within an ini entry<br/>
		/// </summary>
		public unsafe void* ReadLineFn;

		/// <summary>
		/// Read: Called after reading (in registration order)<br/>
		/// </summary>
		public unsafe void* ApplyAllFn;

		/// <summary>
		/// Write: Output every entries into 'out_buf'<br/>
		/// </summary>
		public unsafe void* WriteAllFn;

		public unsafe void* UserData;




		public unsafe void Destroy()
		{
			fixed (ImGuiSettingsHandler* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiSettingsHandlerPtr : IEquatable<ImGuiSettingsHandlerPtr>
	{
		public ImGuiSettingsHandlerPtr(ImGuiSettingsHandler* handle) { Handle = handle; }

		public ImGuiSettingsHandler* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiSettingsHandlerPtr Null => new ImGuiSettingsHandlerPtr(null);

		public static implicit operator ImGuiSettingsHandlerPtr(ImGuiSettingsHandler* handle) => new ImGuiSettingsHandlerPtr(handle);

		public static implicit operator ImGuiSettingsHandler*(ImGuiSettingsHandlerPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiSettingsHandlerPtr left, ImGuiSettingsHandlerPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiSettingsHandlerPtr left, ImGuiSettingsHandlerPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiSettingsHandlerPtr left, ImGuiSettingsHandler* right) => left.Handle == right;

		public static bool operator !=(ImGuiSettingsHandlerPtr left, ImGuiSettingsHandler* right) => left.Handle != right;

		public bool Equals(ImGuiSettingsHandlerPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiSettingsHandlerPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiSettingsHandlerPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		/// <summary>
		/// Short description stored in .ini file. Disallowed characters: '[' ']'<br/>
		/// </summary>
		public byte* TypeName { get => Handle->TypeName; set => Handle->TypeName = value; }
		/// <summary>
		/// == ImHashStr(TypeName)<br/>
		/// </summary>
		public ref int TypeHash => ref Unsafe.AsRef<int>(&Handle->TypeHash);
		/// <summary>
		/// Clear all settings data<br/>
		/// </summary>
		public void* ClearAllFn { get => Handle->ClearAllFn; set => Handle->ClearAllFn = value; }
		/// <summary>
		/// Read: Called before reading (in registration order)<br/>
		/// </summary>
		public void* ReadInitFn { get => Handle->ReadInitFn; set => Handle->ReadInitFn = value; }
		/// <summary>
		/// Read: Called when entering into a new ini entry e.g. "[Window][Name]"<br/>
		/// </summary>
		public void* ReadOpenFn { get => Handle->ReadOpenFn; set => Handle->ReadOpenFn = value; }
		/// <summary>
		/// Read: Called for every line of text within an ini entry<br/>
		/// </summary>
		public void* ReadLineFn { get => Handle->ReadLineFn; set => Handle->ReadLineFn = value; }
		/// <summary>
		/// Read: Called after reading (in registration order)<br/>
		/// </summary>
		public void* ApplyAllFn { get => Handle->ApplyAllFn; set => Handle->ApplyAllFn = value; }
		/// <summary>
		/// Write: Output every entries into 'out_buf'<br/>
		/// </summary>
		public void* WriteAllFn { get => Handle->WriteAllFn; set => Handle->WriteAllFn = value; }
		public void* UserData { get => Handle->UserData; set => Handle->UserData = value; }

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImChunkStreamImGuiWindowSettings
	{
		public ImVectorChar Buf;


	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImChunkStreamImGuiTableSettings
	{
		public ImVectorChar Buf;


	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiContextHook
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiContextHook* Data;


	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiContextHook
	{
		/// <summary>
		/// A unique ID assigned by AddContextHook()<br/>
		/// </summary>
		public int HookId;

		public ImGuiContextHookType Type;
		public int Owner;
		public unsafe void* Callback;
		public unsafe void* UserData;




		public unsafe void Destroy()
		{
			fixed (ImGuiContextHook* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiContextHookPtr : IEquatable<ImGuiContextHookPtr>
	{
		public ImGuiContextHookPtr(ImGuiContextHook* handle) { Handle = handle; }

		public ImGuiContextHook* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiContextHookPtr Null => new ImGuiContextHookPtr(null);

		public static implicit operator ImGuiContextHookPtr(ImGuiContextHook* handle) => new ImGuiContextHookPtr(handle);

		public static implicit operator ImGuiContextHook*(ImGuiContextHookPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiContextHookPtr left, ImGuiContextHookPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiContextHookPtr left, ImGuiContextHookPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiContextHookPtr left, ImGuiContextHook* right) => left.Handle == right;

		public static bool operator !=(ImGuiContextHookPtr left, ImGuiContextHook* right) => left.Handle != right;

		public bool Equals(ImGuiContextHookPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiContextHookPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiContextHookPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		/// <summary>
		/// A unique ID assigned by AddContextHook()<br/>
		/// </summary>
		public ref int HookId => ref Unsafe.AsRef<int>(&Handle->HookId);
		public ref ImGuiContextHookType Type => ref Unsafe.AsRef<ImGuiContextHookType>(&Handle->Type);
		public ref int Owner => ref Unsafe.AsRef<int>(&Handle->Owner);
		public void* Callback { get => Handle->Callback; set => Handle->Callback = value; }
		public void* UserData { get => Handle->UserData; set => Handle->UserData = value; }

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

	}

	/// <summary>
	/// Helper: ImGuiTextIndex&lt;&gt;<br/>
	/// Maintain a line index for a text buffer. This is a strong candidate to be moved into the public API.<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTextIndex
	{
		public ImVectorInt LineOffsets;
		/// <summary>
		/// Because we don't own text buffer we need to maintain EndOffset (may bake in LineOffsets?)<br/>
		/// </summary>
		public int EndOffset;




		public unsafe void append(byte* baseValue, int oldSize, int newSize)
		{
			fixed (ImGuiTextIndex* @this = &this)
			{
				ImGui.appendNative(@this, baseValue, oldSize, newSize);
			}
		}

		public unsafe void append(ref byte baseValue, int oldSize, int newSize)
		{
			fixed (ImGuiTextIndex* @this = &this)
			{
				fixed (byte* pbaseValue = &baseValue)
				{
					ImGui.appendNative(@this, (byte*)pbaseValue, oldSize, newSize);
				}
			}
		}

		public unsafe void append(string baseValue, int oldSize, int newSize)
		{
			fixed (ImGuiTextIndex* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (baseValue != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(baseValue);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.appendNative(@this, pStr0, oldSize, newSize);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void clear()
		{
			fixed (ImGuiTextIndex* @this = &this)
			{
				ImGui.clearNative(@this);
			}
		}

		public unsafe byte* get_line_begin(byte* baseValue, int n)
		{
			fixed (ImGuiTextIndex* @this = &this)
			{
				byte* ret = ImGui.get_line_beginNative(@this, baseValue, n);
				return ret;
			}
		}

		public unsafe string get_line_beginS(byte* baseValue, int n)
		{
			fixed (ImGuiTextIndex* @this = &this)
			{
				string ret = Utils.DecodeStringUTF8(ImGui.get_line_beginNative(@this, baseValue, n));
				return ret;
			}
		}

		public unsafe byte* get_line_begin(ref byte baseValue, int n)
		{
			fixed (ImGuiTextIndex* @this = &this)
			{
				fixed (byte* pbaseValue = &baseValue)
				{
					byte* ret = ImGui.get_line_beginNative(@this, (byte*)pbaseValue, n);
					return ret;
				}
			}
		}

		public unsafe string get_line_beginS(ref byte baseValue, int n)
		{
			fixed (ImGuiTextIndex* @this = &this)
			{
				fixed (byte* pbaseValue = &baseValue)
				{
					string ret = Utils.DecodeStringUTF8(ImGui.get_line_beginNative(@this, (byte*)pbaseValue, n));
					return ret;
				}
			}
		}

		public unsafe byte* get_line_begin(string baseValue, int n)
		{
			fixed (ImGuiTextIndex* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (baseValue != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(baseValue);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* ret = ImGui.get_line_beginNative(@this, pStr0, n);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe string get_line_beginS(string baseValue, int n)
		{
			fixed (ImGuiTextIndex* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (baseValue != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(baseValue);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImGui.get_line_beginNative(@this, pStr0, n));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe byte* get_line_end(byte* baseValue, int n)
		{
			fixed (ImGuiTextIndex* @this = &this)
			{
				byte* ret = ImGui.get_line_endNative(@this, baseValue, n);
				return ret;
			}
		}

		public unsafe string get_line_endS(byte* baseValue, int n)
		{
			fixed (ImGuiTextIndex* @this = &this)
			{
				string ret = Utils.DecodeStringUTF8(ImGui.get_line_endNative(@this, baseValue, n));
				return ret;
			}
		}

		public unsafe byte* get_line_end(ref byte baseValue, int n)
		{
			fixed (ImGuiTextIndex* @this = &this)
			{
				fixed (byte* pbaseValue = &baseValue)
				{
					byte* ret = ImGui.get_line_endNative(@this, (byte*)pbaseValue, n);
					return ret;
				}
			}
		}

		public unsafe string get_line_endS(ref byte baseValue, int n)
		{
			fixed (ImGuiTextIndex* @this = &this)
			{
				fixed (byte* pbaseValue = &baseValue)
				{
					string ret = Utils.DecodeStringUTF8(ImGui.get_line_endNative(@this, (byte*)pbaseValue, n));
					return ret;
				}
			}
		}

		public unsafe byte* get_line_end(string baseValue, int n)
		{
			fixed (ImGuiTextIndex* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (baseValue != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(baseValue);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* ret = ImGui.get_line_endNative(@this, pStr0, n);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe string get_line_endS(string baseValue, int n)
		{
			fixed (ImGuiTextIndex* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (baseValue != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(baseValue);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImGui.get_line_endNative(@this, pStr0, n));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe int size()
		{
			fixed (ImGuiTextIndex* @this = &this)
			{
				int ret = ImGui.sizeNative(@this);
				return ret;
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiTextIndexPtr : IEquatable<ImGuiTextIndexPtr>
	{
		public ImGuiTextIndexPtr(ImGuiTextIndex* handle) { Handle = handle; }

		public ImGuiTextIndex* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiTextIndexPtr Null => new ImGuiTextIndexPtr(null);

		public static implicit operator ImGuiTextIndexPtr(ImGuiTextIndex* handle) => new ImGuiTextIndexPtr(handle);

		public static implicit operator ImGuiTextIndex*(ImGuiTextIndexPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiTextIndexPtr left, ImGuiTextIndexPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiTextIndexPtr left, ImGuiTextIndexPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiTextIndexPtr left, ImGuiTextIndex* right) => left.Handle == right;

		public static bool operator !=(ImGuiTextIndexPtr left, ImGuiTextIndex* right) => left.Handle != right;

		public bool Equals(ImGuiTextIndexPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiTextIndexPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiTextIndexPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref ImVectorInt LineOffsets => ref Unsafe.AsRef<ImVectorInt>(&Handle->LineOffsets);
		/// <summary>
		/// Because we don't own text buffer we need to maintain EndOffset (may bake in LineOffsets?)<br/>
		/// </summary>
		public ref int EndOffset => ref Unsafe.AsRef<int>(&Handle->EndOffset);

		public unsafe void append(byte* baseValue, int oldSize, int newSize)
		{
			ImGui.appendNative(Handle, baseValue, oldSize, newSize);
		}

		public unsafe void append(ref byte baseValue, int oldSize, int newSize)
		{
			fixed (byte* pbaseValue = &baseValue)
			{
				ImGui.appendNative(Handle, (byte*)pbaseValue, oldSize, newSize);
			}
		}

		public unsafe void append(string baseValue, int oldSize, int newSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (baseValue != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(baseValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.appendNative(Handle, pStr0, oldSize, newSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void clear()
		{
			ImGui.clearNative(Handle);
		}

		public unsafe byte* get_line_begin(byte* baseValue, int n)
		{
			byte* ret = ImGui.get_line_beginNative(Handle, baseValue, n);
			return ret;
		}

		public unsafe string get_line_beginS(byte* baseValue, int n)
		{
			string ret = Utils.DecodeStringUTF8(ImGui.get_line_beginNative(Handle, baseValue, n));
			return ret;
		}

		public unsafe byte* get_line_begin(ref byte baseValue, int n)
		{
			fixed (byte* pbaseValue = &baseValue)
			{
				byte* ret = ImGui.get_line_beginNative(Handle, (byte*)pbaseValue, n);
				return ret;
			}
		}

		public unsafe string get_line_beginS(ref byte baseValue, int n)
		{
			fixed (byte* pbaseValue = &baseValue)
			{
				string ret = Utils.DecodeStringUTF8(ImGui.get_line_beginNative(Handle, (byte*)pbaseValue, n));
				return ret;
			}
		}

		public unsafe byte* get_line_begin(string baseValue, int n)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (baseValue != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(baseValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImGui.get_line_beginNative(Handle, pStr0, n);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public unsafe string get_line_beginS(string baseValue, int n)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (baseValue != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(baseValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImGui.get_line_beginNative(Handle, pStr0, n));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public unsafe byte* get_line_end(byte* baseValue, int n)
		{
			byte* ret = ImGui.get_line_endNative(Handle, baseValue, n);
			return ret;
		}

		public unsafe string get_line_endS(byte* baseValue, int n)
		{
			string ret = Utils.DecodeStringUTF8(ImGui.get_line_endNative(Handle, baseValue, n));
			return ret;
		}

		public unsafe byte* get_line_end(ref byte baseValue, int n)
		{
			fixed (byte* pbaseValue = &baseValue)
			{
				byte* ret = ImGui.get_line_endNative(Handle, (byte*)pbaseValue, n);
				return ret;
			}
		}

		public unsafe string get_line_endS(ref byte baseValue, int n)
		{
			fixed (byte* pbaseValue = &baseValue)
			{
				string ret = Utils.DecodeStringUTF8(ImGui.get_line_endNative(Handle, (byte*)pbaseValue, n));
				return ret;
			}
		}

		public unsafe byte* get_line_end(string baseValue, int n)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (baseValue != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(baseValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImGui.get_line_endNative(Handle, pStr0, n);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public unsafe string get_line_endS(string baseValue, int n)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (baseValue != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(baseValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImGui.get_line_endNative(Handle, pStr0, n));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public unsafe int size()
		{
			int ret = ImGui.sizeNative(Handle);
			return ret;
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorInt
	{
		public int Size;
		public int Capacity;
		public unsafe int* Data;


	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiMetricsConfig
	{
		public byte ShowDebugLog;
		public byte ShowStackTool;
		public byte ShowWindowsRects;
		public byte ShowWindowsBeginOrder;
		public byte ShowTablesRects;
		public byte ShowDrawCmdMesh;
		public byte ShowDrawCmdBoundingBoxes;
		public byte ShowAtlasTintedWithTextColor;
		public byte ShowDockingNodes;
		public int ShowWindowsRectsType;
		public int ShowTablesRectsType;


	}

	/// <summary>
	/// State for Stack tool queries<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiStackTool
	{
		public int LastActiveFrame;
		/// <summary>
		/// -1: query stack and resize Results, &gt;= 0: individual stack level<br/>
		/// </summary>
		public int StackLevel;

		/// <summary>
		/// ID to query details for<br/>
		/// </summary>
		public int QueryId;

		public ImVectorImGuiStackLevelInfo Results;
		public byte CopyToClipboardOnCtrlC;
		public float CopyToClipboardLastTime;




		public unsafe void Destroy()
		{
			fixed (ImGuiStackTool* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiStackToolPtr : IEquatable<ImGuiStackToolPtr>
	{
		public ImGuiStackToolPtr(ImGuiStackTool* handle) { Handle = handle; }

		public ImGuiStackTool* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiStackToolPtr Null => new ImGuiStackToolPtr(null);

		public static implicit operator ImGuiStackToolPtr(ImGuiStackTool* handle) => new ImGuiStackToolPtr(handle);

		public static implicit operator ImGuiStackTool*(ImGuiStackToolPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiStackToolPtr left, ImGuiStackToolPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiStackToolPtr left, ImGuiStackToolPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiStackToolPtr left, ImGuiStackTool* right) => left.Handle == right;

		public static bool operator !=(ImGuiStackToolPtr left, ImGuiStackTool* right) => left.Handle != right;

		public bool Equals(ImGuiStackToolPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiStackToolPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiStackToolPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref int LastActiveFrame => ref Unsafe.AsRef<int>(&Handle->LastActiveFrame);
		/// <summary>
		/// -1: query stack and resize Results, &gt;= 0: individual stack level<br/>
		/// </summary>
		public ref int StackLevel => ref Unsafe.AsRef<int>(&Handle->StackLevel);
		/// <summary>
		/// ID to query details for<br/>
		/// </summary>
		public ref int QueryId => ref Unsafe.AsRef<int>(&Handle->QueryId);
		public ref ImVectorImGuiStackLevelInfo Results => ref Unsafe.AsRef<ImVectorImGuiStackLevelInfo>(&Handle->Results);
		public ref bool CopyToClipboardOnCtrlC => ref Unsafe.AsRef<bool>(&Handle->CopyToClipboardOnCtrlC);
		public ref float CopyToClipboardLastTime => ref Unsafe.AsRef<float>(&Handle->CopyToClipboardLastTime);

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiStackLevelInfo
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiStackLevelInfo* Data;


	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiStackLevelInfo
	{
		public int ID;
		/// <summary>
		/// &gt;= 1: Query in progress<br/>
		/// </summary>
		public sbyte QueryFrameCount;

		/// <summary>
		/// Obtained result from DebugHookIdInfo()<br/>
		/// </summary>
		public byte QuerySuccess;

		public ImGuiDataType DataType;
		/// <summary>
		/// Arbitrarily sized buffer to hold a result (FIXME: could replace Results[] with a chunk stream?) FIXME: Now that we added CTRL+C this should be fixed.<br/>
		/// </summary>
		public byte Desc_0;
		public byte Desc_1;
		public byte Desc_2;
		public byte Desc_3;
		public byte Desc_4;
		public byte Desc_5;
		public byte Desc_6;
		public byte Desc_7;
		public byte Desc_8;
		public byte Desc_9;
		public byte Desc_10;
		public byte Desc_11;
		public byte Desc_12;
		public byte Desc_13;
		public byte Desc_14;
		public byte Desc_15;
		public byte Desc_16;
		public byte Desc_17;
		public byte Desc_18;
		public byte Desc_19;
		public byte Desc_20;
		public byte Desc_21;
		public byte Desc_22;
		public byte Desc_23;
		public byte Desc_24;
		public byte Desc_25;
		public byte Desc_26;
		public byte Desc_27;
		public byte Desc_28;
		public byte Desc_29;
		public byte Desc_30;
		public byte Desc_31;
		public byte Desc_32;
		public byte Desc_33;
		public byte Desc_34;
		public byte Desc_35;
		public byte Desc_36;
		public byte Desc_37;
		public byte Desc_38;
		public byte Desc_39;
		public byte Desc_40;
		public byte Desc_41;
		public byte Desc_42;
		public byte Desc_43;
		public byte Desc_44;
		public byte Desc_45;
		public byte Desc_46;
		public byte Desc_47;
		public byte Desc_48;
		public byte Desc_49;
		public byte Desc_50;
		public byte Desc_51;
		public byte Desc_52;
		public byte Desc_53;
		public byte Desc_54;
		public byte Desc_55;
		public byte Desc_56;





		public unsafe void Destroy()
		{
			fixed (ImGuiStackLevelInfo* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiStackLevelInfoPtr : IEquatable<ImGuiStackLevelInfoPtr>
	{
		public ImGuiStackLevelInfoPtr(ImGuiStackLevelInfo* handle) { Handle = handle; }

		public ImGuiStackLevelInfo* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiStackLevelInfoPtr Null => new ImGuiStackLevelInfoPtr(null);

		public static implicit operator ImGuiStackLevelInfoPtr(ImGuiStackLevelInfo* handle) => new ImGuiStackLevelInfoPtr(handle);

		public static implicit operator ImGuiStackLevelInfo*(ImGuiStackLevelInfoPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiStackLevelInfoPtr left, ImGuiStackLevelInfoPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiStackLevelInfoPtr left, ImGuiStackLevelInfoPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiStackLevelInfoPtr left, ImGuiStackLevelInfo* right) => left.Handle == right;

		public static bool operator !=(ImGuiStackLevelInfoPtr left, ImGuiStackLevelInfo* right) => left.Handle != right;

		public bool Equals(ImGuiStackLevelInfoPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiStackLevelInfoPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiStackLevelInfoPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref int ID => ref Unsafe.AsRef<int>(&Handle->ID);
		/// <summary>
		/// &gt;= 1: Query in progress<br/>
		/// </summary>
		public ref sbyte QueryFrameCount => ref Unsafe.AsRef<sbyte>(&Handle->QueryFrameCount);
		/// <summary>
		/// Obtained result from DebugHookIdInfo()<br/>
		/// </summary>
		public ref bool QuerySuccess => ref Unsafe.AsRef<bool>(&Handle->QuerySuccess);
		public ref ImGuiDataType DataType => ref Unsafe.AsRef<ImGuiDataType>(&Handle->DataType);
		/// <summary>
		/// Arbitrarily sized buffer to hold a result (FIXME: could replace Results[] with a chunk stream?) FIXME: Now that we added CTRL+C this should be fixed.<br/>
		/// </summary>
		public unsafe Span<byte> Desc
		
		{
			get
			{
				return new Span<byte>(&Handle->Desc_0, 57);
			}
		}

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

	}

	/// <summary>
	/// Shared state of InputText(), passed as an argument to your callback when a ImGuiInputTextFlags_Callback* flag is used.<br/>
	/// The callback function should return 0 by default.<br/>
	/// Callbacks (follow a flag name and see comments in ImGuiInputTextFlags_ declarations for more details)<br/>
	/// - ImGuiInputTextFlags_CallbackEdit:        Callback on buffer edit (note that InputText() already returns true on edit, the callback is useful mainly to manipulate the underlying buffer while focus is active)<br/>
	/// - ImGuiInputTextFlags_CallbackAlways:      Callback on each iteration<br/>
	/// - ImGuiInputTextFlags_CallbackCompletion:  Callback on pressing TAB<br/>
	/// - ImGuiInputTextFlags_CallbackHistory:     Callback on pressing UpDown arrows<br/>
	/// - ImGuiInputTextFlags_CallbackCharFilter:  Callback on character inputs to replace or discard them. Modify 'EventChar' to replace or discard, or return 1 in callback to discard.<br/>
	/// - ImGuiInputTextFlags_CallbackResize:      Callback on buffer capacity changes request (beyond 'buf_size' parameter value), allowing the string to grow.<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiInputTextCallbackData
	{
		/// <summary>
		/// Parent UI context<br/>
		/// </summary>
		public unsafe ImGuiContext* Ctx;

		/// <summary>
		/// One ImGuiInputTextFlags_Callback*     Read-only<br/>
		/// </summary>
		public ImGuiInputTextFlags EventFlag;

		/// <summary>
		/// What user passed to InputText()       Read-only<br/>
		/// </summary>
		public ImGuiInputTextFlags Flags;

		/// <summary>
		/// What user passed to InputText()       Read-only<br/>
		/// </summary>
		public unsafe void* UserData;

		/// <summary>
		/// Arguments for the different callback events<br/>
		/// - To modify the text buffer in a callback, prefer using the InsertChars()  DeleteChars() function. InsertChars() will take care of calling the resize callback if necessary.<br/>
		/// - If you know your edits are not going to resize the underlying buffer allocation, you may modify the contents of 'Buf[]' directly. You need to update 'BufTextLen' accordingly (0 &lt;= BufTextLen &lt; BufSize) and set 'BufDirty'' to true so InputText can update its internal state. Character input                       Read-write    [CharFilter] Replace character with another one, or set to zero to drop. return 1 is equivalent to setting EventChar=0;<br/>
		/// </summary>
		public char EventChar;

		/// <summary>
		/// Key pressed (UpDownTAB)             Read-only     [Completion,History]<br/>
		/// </summary>
		public ImGuiKey EventKey;

		/// <summary>
		/// Text buffer                           Read-write    [Resize] Can replace pointer  [Completion,History,Always] Only write to pointed data, don't replace the actual pointer!<br/>
		/// </summary>
		public unsafe byte* Buf;

		/// <summary>
		/// Text length (in bytes)                Read-write    [Resize,Completion,History,Always] Exclude zero-terminator storage. In C land: == strlen(some_text), in C++ land: string.length()<br/>
		/// </summary>
		public int BufTextLen;

		/// <summary>
		/// Buffer size (in bytes) = capacity+1   Read-only     [Resize,Completion,History,Always] Include zero-terminator storage. In C land == ARRAYSIZE(my_char_array), in C++ land: string.capacity()+1<br/>
		/// </summary>
		public int BufSize;

		/// <summary>
		/// Set if you modify BufBufTextLen!     Write         [Completion,History,Always]<br/>
		/// </summary>
		public byte BufDirty;

		/// <summary>
		/// Read-write    [Completion,History,Always]<br/>
		/// </summary>
		public int CursorPos;

		/// <summary>
		/// Read-write    [Completion,History,Always] == to SelectionEnd when no selection)<br/>
		/// </summary>
		public int SelectionStart;

		/// <summary>
		/// Read-write    [Completion,History,Always]<br/>
		/// </summary>
		public int SelectionEnd;





		public unsafe void ClearSelection()
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				ImGui.ClearSelectionNative(@this);
			}
		}

		public unsafe void DeleteChars(int pos, int bytesCount)
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				ImGui.DeleteCharsNative(@this, pos, bytesCount);
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe bool HasSelection()
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				byte ret = ImGui.HasSelectionNative(@this);
				return ret != 0;
			}
		}

		public unsafe void InsertChars(int pos, byte* text, byte* textEnd)
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				ImGui.InsertCharsNative(@this, pos, text, textEnd);
			}
		}

		public unsafe void InsertChars(int pos, byte* text)
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				ImGui.InsertCharsNative(@this, pos, text, (byte*)(default));
			}
		}

		public unsafe void InsertChars(int pos, ref byte text, byte* textEnd)
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					ImGui.InsertCharsNative(@this, pos, (byte*)ptext, textEnd);
				}
			}
		}

		public unsafe void InsertChars(int pos, ref byte text)
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					ImGui.InsertCharsNative(@this, pos, (byte*)ptext, (byte*)(default));
				}
			}
		}

		public unsafe void InsertChars(int pos, string text, byte* textEnd)
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.InsertCharsNative(@this, pos, pStr0, textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void InsertChars(int pos, string text)
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.InsertCharsNative(@this, pos, pStr0, (byte*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void InsertChars(int pos, byte* text, ref byte textEnd)
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.InsertCharsNative(@this, pos, text, (byte*)ptextEnd);
				}
			}
		}

		public unsafe void InsertChars(int pos, byte* text, string textEnd)
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.InsertCharsNative(@this, pos, text, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void InsertChars(int pos, ref byte text, ref byte textEnd)
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.InsertCharsNative(@this, pos, (byte*)ptext, (byte*)ptextEnd);
					}
				}
			}
		}

		public unsafe void InsertChars(int pos, string text, string textEnd)
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.InsertCharsNative(@this, pos, pStr0, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void SelectAll()
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				ImGui.SelectAllNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiInputTextCallbackDataPtr : IEquatable<ImGuiInputTextCallbackDataPtr>
	{
		public ImGuiInputTextCallbackDataPtr(ImGuiInputTextCallbackData* handle) { Handle = handle; }

		public ImGuiInputTextCallbackData* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiInputTextCallbackDataPtr Null => new ImGuiInputTextCallbackDataPtr(null);

		public static implicit operator ImGuiInputTextCallbackDataPtr(ImGuiInputTextCallbackData* handle) => new ImGuiInputTextCallbackDataPtr(handle);

		public static implicit operator ImGuiInputTextCallbackData*(ImGuiInputTextCallbackDataPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiInputTextCallbackDataPtr left, ImGuiInputTextCallbackDataPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiInputTextCallbackDataPtr left, ImGuiInputTextCallbackDataPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiInputTextCallbackDataPtr left, ImGuiInputTextCallbackData* right) => left.Handle == right;

		public static bool operator !=(ImGuiInputTextCallbackDataPtr left, ImGuiInputTextCallbackData* right) => left.Handle != right;

		public bool Equals(ImGuiInputTextCallbackDataPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiInputTextCallbackDataPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiInputTextCallbackDataPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		/// <summary>
		/// Parent UI context<br/>
		/// </summary>
		public ref ImGuiContextPtr Ctx => ref Unsafe.AsRef<ImGuiContextPtr>(&Handle->Ctx);
		/// <summary>
		/// One ImGuiInputTextFlags_Callback*     Read-only<br/>
		/// </summary>
		public ref ImGuiInputTextFlags EventFlag => ref Unsafe.AsRef<ImGuiInputTextFlags>(&Handle->EventFlag);
		/// <summary>
		/// What user passed to InputText()       Read-only<br/>
		/// </summary>
		public ref ImGuiInputTextFlags Flags => ref Unsafe.AsRef<ImGuiInputTextFlags>(&Handle->Flags);
		/// <summary>
		/// What user passed to InputText()       Read-only<br/>
		/// </summary>
		public void* UserData { get => Handle->UserData; set => Handle->UserData = value; }
		/// <summary>
		/// Arguments for the different callback events<br/>
		/// - To modify the text buffer in a callback, prefer using the InsertChars()  DeleteChars() function. InsertChars() will take care of calling the resize callback if necessary.<br/>
		/// - If you know your edits are not going to resize the underlying buffer allocation, you may modify the contents of 'Buf[]' directly. You need to update 'BufTextLen' accordingly (0 &lt;= BufTextLen &lt; BufSize) and set 'BufDirty'' to true so InputText can update its internal state. Character input                       Read-write    [CharFilter] Replace character with another one, or set to zero to drop. return 1 is equivalent to setting EventChar=0;<br/>
		/// </summary>
		public ref char EventChar => ref Unsafe.AsRef<char>(&Handle->EventChar);
		/// <summary>
		/// Key pressed (UpDownTAB)             Read-only     [Completion,History]<br/>
		/// </summary>
		public ref ImGuiKey EventKey => ref Unsafe.AsRef<ImGuiKey>(&Handle->EventKey);
		/// <summary>
		/// Text buffer                           Read-write    [Resize] Can replace pointer  [Completion,History,Always] Only write to pointed data, don't replace the actual pointer!<br/>
		/// </summary>
		public byte* Buf { get => Handle->Buf; set => Handle->Buf = value; }
		/// <summary>
		/// Text length (in bytes)                Read-write    [Resize,Completion,History,Always] Exclude zero-terminator storage. In C land: == strlen(some_text), in C++ land: string.length()<br/>
		/// </summary>
		public ref int BufTextLen => ref Unsafe.AsRef<int>(&Handle->BufTextLen);
		/// <summary>
		/// Buffer size (in bytes) = capacity+1   Read-only     [Resize,Completion,History,Always] Include zero-terminator storage. In C land == ARRAYSIZE(my_char_array), in C++ land: string.capacity()+1<br/>
		/// </summary>
		public ref int BufSize => ref Unsafe.AsRef<int>(&Handle->BufSize);
		/// <summary>
		/// Set if you modify BufBufTextLen!     Write         [Completion,History,Always]<br/>
		/// </summary>
		public ref bool BufDirty => ref Unsafe.AsRef<bool>(&Handle->BufDirty);
		/// <summary>
		/// Read-write    [Completion,History,Always]<br/>
		/// </summary>
		public ref int CursorPos => ref Unsafe.AsRef<int>(&Handle->CursorPos);
		/// <summary>
		/// Read-write    [Completion,History,Always] == to SelectionEnd when no selection)<br/>
		/// </summary>
		public ref int SelectionStart => ref Unsafe.AsRef<int>(&Handle->SelectionStart);
		/// <summary>
		/// Read-write    [Completion,History,Always]<br/>
		/// </summary>
		public ref int SelectionEnd => ref Unsafe.AsRef<int>(&Handle->SelectionEnd);

		public unsafe void ClearSelection()
		{
			ImGui.ClearSelectionNative(Handle);
		}

		public unsafe void DeleteChars(int pos, int bytesCount)
		{
			ImGui.DeleteCharsNative(Handle, pos, bytesCount);
		}

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

		public unsafe bool HasSelection()
		{
			byte ret = ImGui.HasSelectionNative(Handle);
			return ret != 0;
		}

		public unsafe void InsertChars(int pos, byte* text, byte* textEnd)
		{
			ImGui.InsertCharsNative(Handle, pos, text, textEnd);
		}

		public unsafe void InsertChars(int pos, byte* text)
		{
			ImGui.InsertCharsNative(Handle, pos, text, (byte*)(default));
		}

		public unsafe void InsertChars(int pos, ref byte text, byte* textEnd)
		{
			fixed (byte* ptext = &text)
			{
				ImGui.InsertCharsNative(Handle, pos, (byte*)ptext, textEnd);
			}
		}

		public unsafe void InsertChars(int pos, ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				ImGui.InsertCharsNative(Handle, pos, (byte*)ptext, (byte*)(default));
			}
		}

		public unsafe void InsertChars(int pos, string text, byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.InsertCharsNative(Handle, pos, pStr0, textEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void InsertChars(int pos, string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.InsertCharsNative(Handle, pos, pStr0, (byte*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void InsertChars(int pos, byte* text, ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				ImGui.InsertCharsNative(Handle, pos, text, (byte*)ptextEnd);
			}
		}

		public unsafe void InsertChars(int pos, byte* text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.InsertCharsNative(Handle, pos, text, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void InsertChars(int pos, ref byte text, ref byte textEnd)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.InsertCharsNative(Handle, pos, (byte*)ptext, (byte*)ptextEnd);
				}
			}
		}

		public unsafe void InsertChars(int pos, string text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ImGui.InsertCharsNative(Handle, pos, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public unsafe void SelectAll()
		{
			ImGui.SelectAllNative(Handle);
		}

	}

	/// <summary>
	/// Helper: Execute a block of code at maximum once a frame. Convenient if you want to quickly create a UI within deep-nested code that runs multiple times every frame.<br/>
	/// Usage: static ImGuiOnceUponAFrame oaf; if (oaf) ImGui::Text("This will be called only once per frame");<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiOnceUponAFrame
	{
		public int RefFrame;




		public unsafe void Destroy()
		{
			fixed (ImGuiOnceUponAFrame* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiOnceUponAFramePtr : IEquatable<ImGuiOnceUponAFramePtr>
	{
		public ImGuiOnceUponAFramePtr(ImGuiOnceUponAFrame* handle) { Handle = handle; }

		public ImGuiOnceUponAFrame* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiOnceUponAFramePtr Null => new ImGuiOnceUponAFramePtr(null);

		public static implicit operator ImGuiOnceUponAFramePtr(ImGuiOnceUponAFrame* handle) => new ImGuiOnceUponAFramePtr(handle);

		public static implicit operator ImGuiOnceUponAFrame*(ImGuiOnceUponAFramePtr handle) => handle.Handle;

		public static bool operator ==(ImGuiOnceUponAFramePtr left, ImGuiOnceUponAFramePtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiOnceUponAFramePtr left, ImGuiOnceUponAFramePtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiOnceUponAFramePtr left, ImGuiOnceUponAFrame* right) => left.Handle == right;

		public static bool operator !=(ImGuiOnceUponAFramePtr left, ImGuiOnceUponAFrame* right) => left.Handle != right;

		public bool Equals(ImGuiOnceUponAFramePtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiOnceUponAFramePtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiOnceUponAFramePtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref int RefFrame => ref Unsafe.AsRef<int>(&Handle->RefFrame);

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

	}

	/// <summary>
	/// Helper: Parse and apply text filters. In format "aaaaa[,bbbb][,ccccc]"<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTextFilter
	{
		public byte InputBuf_0;
		public byte InputBuf_1;
		public byte InputBuf_2;
		public byte InputBuf_3;
		public byte InputBuf_4;
		public byte InputBuf_5;
		public byte InputBuf_6;
		public byte InputBuf_7;
		public byte InputBuf_8;
		public byte InputBuf_9;
		public byte InputBuf_10;
		public byte InputBuf_11;
		public byte InputBuf_12;
		public byte InputBuf_13;
		public byte InputBuf_14;
		public byte InputBuf_15;
		public byte InputBuf_16;
		public byte InputBuf_17;
		public byte InputBuf_18;
		public byte InputBuf_19;
		public byte InputBuf_20;
		public byte InputBuf_21;
		public byte InputBuf_22;
		public byte InputBuf_23;
		public byte InputBuf_24;
		public byte InputBuf_25;
		public byte InputBuf_26;
		public byte InputBuf_27;
		public byte InputBuf_28;
		public byte InputBuf_29;
		public byte InputBuf_30;
		public byte InputBuf_31;
		public byte InputBuf_32;
		public byte InputBuf_33;
		public byte InputBuf_34;
		public byte InputBuf_35;
		public byte InputBuf_36;
		public byte InputBuf_37;
		public byte InputBuf_38;
		public byte InputBuf_39;
		public byte InputBuf_40;
		public byte InputBuf_41;
		public byte InputBuf_42;
		public byte InputBuf_43;
		public byte InputBuf_44;
		public byte InputBuf_45;
		public byte InputBuf_46;
		public byte InputBuf_47;
		public byte InputBuf_48;
		public byte InputBuf_49;
		public byte InputBuf_50;
		public byte InputBuf_51;
		public byte InputBuf_52;
		public byte InputBuf_53;
		public byte InputBuf_54;
		public byte InputBuf_55;
		public byte InputBuf_56;
		public byte InputBuf_57;
		public byte InputBuf_58;
		public byte InputBuf_59;
		public byte InputBuf_60;
		public byte InputBuf_61;
		public byte InputBuf_62;
		public byte InputBuf_63;
		public byte InputBuf_64;
		public byte InputBuf_65;
		public byte InputBuf_66;
		public byte InputBuf_67;
		public byte InputBuf_68;
		public byte InputBuf_69;
		public byte InputBuf_70;
		public byte InputBuf_71;
		public byte InputBuf_72;
		public byte InputBuf_73;
		public byte InputBuf_74;
		public byte InputBuf_75;
		public byte InputBuf_76;
		public byte InputBuf_77;
		public byte InputBuf_78;
		public byte InputBuf_79;
		public byte InputBuf_80;
		public byte InputBuf_81;
		public byte InputBuf_82;
		public byte InputBuf_83;
		public byte InputBuf_84;
		public byte InputBuf_85;
		public byte InputBuf_86;
		public byte InputBuf_87;
		public byte InputBuf_88;
		public byte InputBuf_89;
		public byte InputBuf_90;
		public byte InputBuf_91;
		public byte InputBuf_92;
		public byte InputBuf_93;
		public byte InputBuf_94;
		public byte InputBuf_95;
		public byte InputBuf_96;
		public byte InputBuf_97;
		public byte InputBuf_98;
		public byte InputBuf_99;
		public byte InputBuf_100;
		public byte InputBuf_101;
		public byte InputBuf_102;
		public byte InputBuf_103;
		public byte InputBuf_104;
		public byte InputBuf_105;
		public byte InputBuf_106;
		public byte InputBuf_107;
		public byte InputBuf_108;
		public byte InputBuf_109;
		public byte InputBuf_110;
		public byte InputBuf_111;
		public byte InputBuf_112;
		public byte InputBuf_113;
		public byte InputBuf_114;
		public byte InputBuf_115;
		public byte InputBuf_116;
		public byte InputBuf_117;
		public byte InputBuf_118;
		public byte InputBuf_119;
		public byte InputBuf_120;
		public byte InputBuf_121;
		public byte InputBuf_122;
		public byte InputBuf_123;
		public byte InputBuf_124;
		public byte InputBuf_125;
		public byte InputBuf_126;
		public byte InputBuf_127;
		public byte InputBuf_128;
		public byte InputBuf_129;
		public byte InputBuf_130;
		public byte InputBuf_131;
		public byte InputBuf_132;
		public byte InputBuf_133;
		public byte InputBuf_134;
		public byte InputBuf_135;
		public byte InputBuf_136;
		public byte InputBuf_137;
		public byte InputBuf_138;
		public byte InputBuf_139;
		public byte InputBuf_140;
		public byte InputBuf_141;
		public byte InputBuf_142;
		public byte InputBuf_143;
		public byte InputBuf_144;
		public byte InputBuf_145;
		public byte InputBuf_146;
		public byte InputBuf_147;
		public byte InputBuf_148;
		public byte InputBuf_149;
		public byte InputBuf_150;
		public byte InputBuf_151;
		public byte InputBuf_152;
		public byte InputBuf_153;
		public byte InputBuf_154;
		public byte InputBuf_155;
		public byte InputBuf_156;
		public byte InputBuf_157;
		public byte InputBuf_158;
		public byte InputBuf_159;
		public byte InputBuf_160;
		public byte InputBuf_161;
		public byte InputBuf_162;
		public byte InputBuf_163;
		public byte InputBuf_164;
		public byte InputBuf_165;
		public byte InputBuf_166;
		public byte InputBuf_167;
		public byte InputBuf_168;
		public byte InputBuf_169;
		public byte InputBuf_170;
		public byte InputBuf_171;
		public byte InputBuf_172;
		public byte InputBuf_173;
		public byte InputBuf_174;
		public byte InputBuf_175;
		public byte InputBuf_176;
		public byte InputBuf_177;
		public byte InputBuf_178;
		public byte InputBuf_179;
		public byte InputBuf_180;
		public byte InputBuf_181;
		public byte InputBuf_182;
		public byte InputBuf_183;
		public byte InputBuf_184;
		public byte InputBuf_185;
		public byte InputBuf_186;
		public byte InputBuf_187;
		public byte InputBuf_188;
		public byte InputBuf_189;
		public byte InputBuf_190;
		public byte InputBuf_191;
		public byte InputBuf_192;
		public byte InputBuf_193;
		public byte InputBuf_194;
		public byte InputBuf_195;
		public byte InputBuf_196;
		public byte InputBuf_197;
		public byte InputBuf_198;
		public byte InputBuf_199;
		public byte InputBuf_200;
		public byte InputBuf_201;
		public byte InputBuf_202;
		public byte InputBuf_203;
		public byte InputBuf_204;
		public byte InputBuf_205;
		public byte InputBuf_206;
		public byte InputBuf_207;
		public byte InputBuf_208;
		public byte InputBuf_209;
		public byte InputBuf_210;
		public byte InputBuf_211;
		public byte InputBuf_212;
		public byte InputBuf_213;
		public byte InputBuf_214;
		public byte InputBuf_215;
		public byte InputBuf_216;
		public byte InputBuf_217;
		public byte InputBuf_218;
		public byte InputBuf_219;
		public byte InputBuf_220;
		public byte InputBuf_221;
		public byte InputBuf_222;
		public byte InputBuf_223;
		public byte InputBuf_224;
		public byte InputBuf_225;
		public byte InputBuf_226;
		public byte InputBuf_227;
		public byte InputBuf_228;
		public byte InputBuf_229;
		public byte InputBuf_230;
		public byte InputBuf_231;
		public byte InputBuf_232;
		public byte InputBuf_233;
		public byte InputBuf_234;
		public byte InputBuf_235;
		public byte InputBuf_236;
		public byte InputBuf_237;
		public byte InputBuf_238;
		public byte InputBuf_239;
		public byte InputBuf_240;
		public byte InputBuf_241;
		public byte InputBuf_242;
		public byte InputBuf_243;
		public byte InputBuf_244;
		public byte InputBuf_245;
		public byte InputBuf_246;
		public byte InputBuf_247;
		public byte InputBuf_248;
		public byte InputBuf_249;
		public byte InputBuf_250;
		public byte InputBuf_251;
		public byte InputBuf_252;
		public byte InputBuf_253;
		public byte InputBuf_254;
		public byte InputBuf_255;
		public ImVectorImGuiTextRange Filters;
		public int CountGrep;




		public unsafe void Build()
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				ImGui.BuildNative(@this);
			}
		}

		public unsafe void Clear()
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				ImGui.ClearNative(@this);
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		/// <summary>		/// Helper calling InputText+Build		/// </summary>		public unsafe bool Draw(byte* label, float width)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				byte ret = ImGui.DrawNative(@this, label, width);
				return ret != 0;
			}
		}

		/// <summary>		/// Helper calling InputText+Build		/// </summary>		public unsafe bool Draw(byte* label)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				byte ret = ImGui.DrawNative(@this, label, (float)(0.0f));
				return ret != 0;
			}
		}

		/// <summary>		/// Helper calling InputText+Build		/// </summary>		public unsafe bool Draw()
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				bool ret = ImGui.Draw(@this, (string)"Filter(inc,-exc)", (float)(0.0f));
				return ret;
			}
		}

		/// <summary>		/// Helper calling InputText+Build		/// </summary>		public unsafe bool Draw(float width)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				bool ret = ImGui.Draw(@this, (string)"Filter(inc,-exc)", width);
				return ret;
			}
		}

		/// <summary>		/// Helper calling InputText+Build		/// </summary>		public unsafe bool Draw(ref byte label, float width)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				fixed (byte* plabel = &label)
				{
					byte ret = ImGui.DrawNative(@this, (byte*)plabel, width);
					return ret != 0;
				}
			}
		}

		/// <summary>		/// Helper calling InputText+Build		/// </summary>		public unsafe bool Draw(ref byte label)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				fixed (byte* plabel = &label)
				{
					byte ret = ImGui.DrawNative(@this, (byte*)plabel, (float)(0.0f));
					return ret != 0;
				}
			}
		}

		/// <summary>		/// Helper calling InputText+Build		/// </summary>		public unsafe bool Draw(string label, float width)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGui.DrawNative(@this, pStr0, width);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>		/// Helper calling InputText+Build		/// </summary>		public unsafe bool Draw(string label)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGui.DrawNative(@this, pStr0, (float)(0.0f));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public unsafe bool IsActive()
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				byte ret = ImGui.IsActiveNative(@this);
				return ret != 0;
			}
		}

		public unsafe bool PassFilter(byte* text, byte* textEnd)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				byte ret = ImGui.PassFilterNative(@this, text, textEnd);
				return ret != 0;
			}
		}

		public unsafe bool PassFilter(byte* text)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				byte ret = ImGui.PassFilterNative(@this, text, (byte*)(default));
				return ret != 0;
			}
		}

		public unsafe bool PassFilter(ref byte text, byte* textEnd)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					byte ret = ImGui.PassFilterNative(@this, (byte*)ptext, textEnd);
					return ret != 0;
				}
			}
		}

		public unsafe bool PassFilter(ref byte text)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					byte ret = ImGui.PassFilterNative(@this, (byte*)ptext, (byte*)(default));
					return ret != 0;
				}
			}
		}

		public unsafe bool PassFilter(string text, byte* textEnd)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGui.PassFilterNative(@this, pStr0, textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public unsafe bool PassFilter(string text)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGui.PassFilterNative(@this, pStr0, (byte*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public unsafe bool PassFilter(byte* text, ref byte textEnd)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					byte ret = ImGui.PassFilterNative(@this, text, (byte*)ptextEnd);
					return ret != 0;
				}
			}
		}

		public unsafe bool PassFilter(byte* text, string textEnd)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGui.PassFilterNative(@this, text, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public unsafe bool PassFilter(ref byte text, ref byte textEnd)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						byte ret = ImGui.PassFilterNative(@this, (byte*)ptext, (byte*)ptextEnd);
						return ret != 0;
					}
				}
			}
		}

		public unsafe bool PassFilter(string text, string textEnd)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = ImGui.PassFilterNative(@this, pStr0, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiTextFilterPtr : IEquatable<ImGuiTextFilterPtr>
	{
		public ImGuiTextFilterPtr(ImGuiTextFilter* handle) { Handle = handle; }

		public ImGuiTextFilter* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiTextFilterPtr Null => new ImGuiTextFilterPtr(null);

		public static implicit operator ImGuiTextFilterPtr(ImGuiTextFilter* handle) => new ImGuiTextFilterPtr(handle);

		public static implicit operator ImGuiTextFilter*(ImGuiTextFilterPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiTextFilterPtr left, ImGuiTextFilterPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiTextFilterPtr left, ImGuiTextFilterPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiTextFilterPtr left, ImGuiTextFilter* right) => left.Handle == right;

		public static bool operator !=(ImGuiTextFilterPtr left, ImGuiTextFilter* right) => left.Handle != right;

		public bool Equals(ImGuiTextFilterPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiTextFilterPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiTextFilterPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public unsafe Span<byte> InputBuf
		
		{
			get
			{
				return new Span<byte>(&Handle->InputBuf_0, 256);
			}
		}
		public ref ImVectorImGuiTextRange Filters => ref Unsafe.AsRef<ImVectorImGuiTextRange>(&Handle->Filters);
		public ref int CountGrep => ref Unsafe.AsRef<int>(&Handle->CountGrep);

		public unsafe void Build()
		{
			ImGui.BuildNative(Handle);
		}

		public unsafe void Clear()
		{
			ImGui.ClearNative(Handle);
		}

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

		/// <summary>		/// Helper calling InputText+Build		/// </summary>		public unsafe bool Draw(byte* label, float width)
		{
			byte ret = ImGui.DrawNative(Handle, label, width);
			return ret != 0;
		}

		/// <summary>		/// Helper calling InputText+Build		/// </summary>		public unsafe bool Draw(byte* label)
		{
			byte ret = ImGui.DrawNative(Handle, label, (float)(0.0f));
			return ret != 0;
		}

		/// <summary>		/// Helper calling InputText+Build		/// </summary>		public unsafe bool Draw()
		{
			bool ret = ImGui.Draw(Handle, (string)"Filter(inc,-exc)", (float)(0.0f));
			return ret;
		}

		/// <summary>		/// Helper calling InputText+Build		/// </summary>		public unsafe bool Draw(float width)
		{
			bool ret = ImGui.Draw(Handle, (string)"Filter(inc,-exc)", width);
			return ret;
		}

		/// <summary>		/// Helper calling InputText+Build		/// </summary>		public unsafe bool Draw(ref byte label, float width)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGui.DrawNative(Handle, (byte*)plabel, width);
				return ret != 0;
			}
		}

		/// <summary>		/// Helper calling InputText+Build		/// </summary>		public unsafe bool Draw(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGui.DrawNative(Handle, (byte*)plabel, (float)(0.0f));
				return ret != 0;
			}
		}

		/// <summary>		/// Helper calling InputText+Build		/// </summary>		public unsafe bool Draw(string label, float width)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGui.DrawNative(Handle, pStr0, width);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>		/// Helper calling InputText+Build		/// </summary>		public unsafe bool Draw(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGui.DrawNative(Handle, pStr0, (float)(0.0f));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public unsafe bool IsActive()
		{
			byte ret = ImGui.IsActiveNative(Handle);
			return ret != 0;
		}

		public unsafe bool PassFilter(byte* text, byte* textEnd)
		{
			byte ret = ImGui.PassFilterNative(Handle, text, textEnd);
			return ret != 0;
		}

		public unsafe bool PassFilter(byte* text)
		{
			byte ret = ImGui.PassFilterNative(Handle, text, (byte*)(default));
			return ret != 0;
		}

		public unsafe bool PassFilter(ref byte text, byte* textEnd)
		{
			fixed (byte* ptext = &text)
			{
				byte ret = ImGui.PassFilterNative(Handle, (byte*)ptext, textEnd);
				return ret != 0;
			}
		}

		public unsafe bool PassFilter(ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				byte ret = ImGui.PassFilterNative(Handle, (byte*)ptext, (byte*)(default));
				return ret != 0;
			}
		}

		public unsafe bool PassFilter(string text, byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGui.PassFilterNative(Handle, pStr0, textEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public unsafe bool PassFilter(string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGui.PassFilterNative(Handle, pStr0, (byte*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public unsafe bool PassFilter(byte* text, ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				byte ret = ImGui.PassFilterNative(Handle, text, (byte*)ptextEnd);
				return ret != 0;
			}
		}

		public unsafe bool PassFilter(byte* text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGui.PassFilterNative(Handle, text, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public unsafe bool PassFilter(ref byte text, ref byte textEnd)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					byte ret = ImGui.PassFilterNative(Handle, (byte*)ptext, (byte*)ptextEnd);
					return ret != 0;
				}
			}
		}

		public unsafe bool PassFilter(string text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = ImGui.PassFilterNative(Handle, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiTextRange
	{
		public int Size;
		public int Capacity;
		public unsafe ImGuiTextRange* Data;


	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImVectorImGuiTextRangePtr : IEquatable<ImVectorImGuiTextRangePtr>
	{
		public ImVectorImGuiTextRangePtr(ImVectorImGuiTextRange* handle) { Handle = handle; }

		public ImVectorImGuiTextRange* Handle;

		public bool IsNull => Handle == null;

		public static ImVectorImGuiTextRangePtr Null => new ImVectorImGuiTextRangePtr(null);

		public static implicit operator ImVectorImGuiTextRangePtr(ImVectorImGuiTextRange* handle) => new ImVectorImGuiTextRangePtr(handle);

		public static implicit operator ImVectorImGuiTextRange*(ImVectorImGuiTextRangePtr handle) => handle.Handle;

		public static bool operator ==(ImVectorImGuiTextRangePtr left, ImVectorImGuiTextRangePtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImVectorImGuiTextRangePtr left, ImVectorImGuiTextRangePtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImVectorImGuiTextRangePtr left, ImVectorImGuiTextRange* right) => left.Handle == right;

		public static bool operator !=(ImVectorImGuiTextRangePtr left, ImVectorImGuiTextRange* right) => left.Handle != right;

		public bool Equals(ImVectorImGuiTextRangePtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImVectorImGuiTextRangePtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImVectorImGuiTextRangePtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref int Size => ref Unsafe.AsRef<int>(&Handle->Size);
		public ref int Capacity => ref Unsafe.AsRef<int>(&Handle->Capacity);
		public ref ImGuiTextRangePtr Data => ref Unsafe.AsRef<ImGuiTextRangePtr>(&Handle->Data);
	}

	/// <summary>
	/// [Internal]<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTextRange
	{
		public unsafe byte* B;
		public unsafe byte* E;




		public unsafe void Destroy()
		{
			fixed (ImGuiTextRange* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe bool empty()
		{
			fixed (ImGuiTextRange* @this = &this)
			{
				byte ret = ImGui.emptyNative(@this);
				return ret != 0;
			}
		}

		public unsafe void split(byte separator, ImVectorImGuiTextRangePtr output)
		{
			fixed (ImGuiTextRange* @this = &this)
			{
				ImGui.splitNative(@this, separator, output);
			}
		}

		public unsafe void split(byte separator, ref ImVectorImGuiTextRange output)
		{
			fixed (ImGuiTextRange* @this = &this)
			{
				fixed (ImVectorImGuiTextRange* poutput = &output)
				{
					ImGui.splitNative(@this, separator, (ImVectorImGuiTextRange*)poutput);
				}
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiTextRangePtr : IEquatable<ImGuiTextRangePtr>
	{
		public ImGuiTextRangePtr(ImGuiTextRange* handle) { Handle = handle; }

		public ImGuiTextRange* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiTextRangePtr Null => new ImGuiTextRangePtr(null);

		public static implicit operator ImGuiTextRangePtr(ImGuiTextRange* handle) => new ImGuiTextRangePtr(handle);

		public static implicit operator ImGuiTextRange*(ImGuiTextRangePtr handle) => handle.Handle;

		public static bool operator ==(ImGuiTextRangePtr left, ImGuiTextRangePtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiTextRangePtr left, ImGuiTextRangePtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiTextRangePtr left, ImGuiTextRange* right) => left.Handle == right;

		public static bool operator !=(ImGuiTextRangePtr left, ImGuiTextRange* right) => left.Handle != right;

		public bool Equals(ImGuiTextRangePtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiTextRangePtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiTextRangePtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public byte* B { get => Handle->B; set => Handle->B = value; }
		public byte* E { get => Handle->E; set => Handle->E = value; }

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

		public unsafe bool empty()
		{
			byte ret = ImGui.emptyNative(Handle);
			return ret != 0;
		}

		public unsafe void split(byte separator, ImVectorImGuiTextRangePtr output)
		{
			ImGui.splitNative(Handle, separator, output);
		}

		public unsafe void split(byte separator, ref ImVectorImGuiTextRange output)
		{
			fixed (ImVectorImGuiTextRange* poutput = &output)
			{
				ImGui.splitNative(Handle, separator, (ImVectorImGuiTextRange*)poutput);
			}
		}

	}

	/// <summary>
	/// Helper: ImBitVector<br/>
	/// Store 1-bit per value.<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImBitVector
	{
		public ImVectorImU32 Storage;



		public unsafe void Clear()
		{
			fixed (ImBitVector* @this = &this)
			{
				ImGui.ClearNative(@this);
			}
		}

		public unsafe void ClearBit(int n)
		{
			fixed (ImBitVector* @this = &this)
			{
				ImGui.ClearBitNative(@this, n);
			}
		}

		public unsafe void Create(int sz)
		{
			fixed (ImBitVector* @this = &this)
			{
				ImGui.CreateNative(@this, sz);
			}
		}

		public unsafe void SetBit(int n)
		{
			fixed (ImBitVector* @this = &this)
			{
				ImGui.SetBitNative(@this, n);
			}
		}

		public unsafe bool TestBit(int n)
		{
			fixed (ImBitVector* @this = &this)
			{
				byte ret = ImGui.TestBitNative(@this, n);
				return ret != 0;
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImBitVectorPtr : IEquatable<ImBitVectorPtr>
	{
		public ImBitVectorPtr(ImBitVector* handle) { Handle = handle; }

		public ImBitVector* Handle;

		public bool IsNull => Handle == null;

		public static ImBitVectorPtr Null => new ImBitVectorPtr(null);

		public static implicit operator ImBitVectorPtr(ImBitVector* handle) => new ImBitVectorPtr(handle);

		public static implicit operator ImBitVector*(ImBitVectorPtr handle) => handle.Handle;

		public static bool operator ==(ImBitVectorPtr left, ImBitVectorPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImBitVectorPtr left, ImBitVectorPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImBitVectorPtr left, ImBitVector* right) => left.Handle == right;

		public static bool operator !=(ImBitVectorPtr left, ImBitVector* right) => left.Handle != right;

		public bool Equals(ImBitVectorPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImBitVectorPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImBitVectorPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref ImVectorImU32 Storage => ref Unsafe.AsRef<ImVectorImU32>(&Handle->Storage);

		public unsafe void Clear()
		{
			ImGui.ClearNative(Handle);
		}

		public unsafe void ClearBit(int n)
		{
			ImGui.ClearBitNative(Handle, n);
		}

		public unsafe void Create(int sz)
		{
			ImGui.CreateNative(Handle, sz);
		}

		public unsafe void SetBit(int n)
		{
			ImGui.SetBitNative(Handle, n);
		}

		public unsafe bool TestBit(int n)
		{
			byte ret = ImGui.TestBitNative(Handle, n);
			return ret != 0;
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiDataVarInfo
	{
		public ImGuiDataType Type;
		/// <summary>
		/// 1+<br/>
		/// </summary>
		public uint Count;

		/// <summary>
		/// Offset in parent structure<br/>
		/// </summary>
		public uint Offset;




		public unsafe void* GetVarPtr(void* parent)
		{
			fixed (ImGuiDataVarInfo* @this = &this)
			{
				void* ret = ImGui.GetVarPtrNative(@this, parent);
				return ret;
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiDataVarInfoPtr : IEquatable<ImGuiDataVarInfoPtr>
	{
		public ImGuiDataVarInfoPtr(ImGuiDataVarInfo* handle) { Handle = handle; }

		public ImGuiDataVarInfo* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiDataVarInfoPtr Null => new ImGuiDataVarInfoPtr(null);

		public static implicit operator ImGuiDataVarInfoPtr(ImGuiDataVarInfo* handle) => new ImGuiDataVarInfoPtr(handle);

		public static implicit operator ImGuiDataVarInfo*(ImGuiDataVarInfoPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiDataVarInfoPtr left, ImGuiDataVarInfoPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiDataVarInfoPtr left, ImGuiDataVarInfoPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiDataVarInfoPtr left, ImGuiDataVarInfo* right) => left.Handle == right;

		public static bool operator !=(ImGuiDataVarInfoPtr left, ImGuiDataVarInfo* right) => left.Handle != right;

		public bool Equals(ImGuiDataVarInfoPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiDataVarInfoPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiDataVarInfoPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref ImGuiDataType Type => ref Unsafe.AsRef<ImGuiDataType>(&Handle->Type);
		/// <summary>
		/// 1+<br/>
		/// </summary>
		public ref uint Count => ref Unsafe.AsRef<uint>(&Handle->Count);
		/// <summary>
		/// Offset in parent structure<br/>
		/// </summary>
		public ref uint Offset => ref Unsafe.AsRef<uint>(&Handle->Offset);

		public unsafe void* GetVarPtr(void* parent)
		{
			void* ret = ImGui.GetVarPtrNative(Handle, parent);
			return ret;
		}

	}

	/// <summary>
	/// Type information associated to one ImGuiDataType. Retrieve with DataTypeGetInfo().<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiDataTypeInfo
	{
		/// <summary>
		/// Size in bytes<br/>
		/// </summary>
		public nuint Size;

		/// <summary>
		/// Short descriptive name for the type, for debugging<br/>
		/// </summary>
		public unsafe byte* Name;

		/// <summary>
		/// Default printf format for the type<br/>
		/// </summary>
		public unsafe byte* PrintFmt;

		/// <summary>
		/// Default scanf format for the type<br/>
		/// </summary>
		public unsafe byte* ScanFmt;



	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiDataTypeInfoPtr : IEquatable<ImGuiDataTypeInfoPtr>
	{
		public ImGuiDataTypeInfoPtr(ImGuiDataTypeInfo* handle) { Handle = handle; }

		public ImGuiDataTypeInfo* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiDataTypeInfoPtr Null => new ImGuiDataTypeInfoPtr(null);

		public static implicit operator ImGuiDataTypeInfoPtr(ImGuiDataTypeInfo* handle) => new ImGuiDataTypeInfoPtr(handle);

		public static implicit operator ImGuiDataTypeInfo*(ImGuiDataTypeInfoPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiDataTypeInfoPtr left, ImGuiDataTypeInfoPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiDataTypeInfoPtr left, ImGuiDataTypeInfoPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiDataTypeInfoPtr left, ImGuiDataTypeInfo* right) => left.Handle == right;

		public static bool operator !=(ImGuiDataTypeInfoPtr left, ImGuiDataTypeInfo* right) => left.Handle != right;

		public bool Equals(ImGuiDataTypeInfoPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiDataTypeInfoPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiDataTypeInfoPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		/// <summary>
		/// Size in bytes<br/>
		/// </summary>
		public ref nuint Size => ref Unsafe.AsRef<nuint>(&Handle->Size);
		/// <summary>
		/// Short descriptive name for the type, for debugging<br/>
		/// </summary>
		public byte* Name { get => Handle->Name; set => Handle->Name = value; }
		/// <summary>
		/// Default printf format for the type<br/>
		/// </summary>
		public byte* PrintFmt { get => Handle->PrintFmt; set => Handle->PrintFmt = value; }
		/// <summary>
		/// Default scanf format for the type<br/>
		/// </summary>
		public byte* ScanFmt { get => Handle->ScanFmt; set => Handle->ScanFmt = value; }
	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiInputTextDeactivateData
	{


	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiLocEntry
	{
		public ImGuiLocKey Key;
		public unsafe byte* Text;


	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiLocEntryPtr : IEquatable<ImGuiLocEntryPtr>
	{
		public ImGuiLocEntryPtr(ImGuiLocEntry* handle) { Handle = handle; }

		public ImGuiLocEntry* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiLocEntryPtr Null => new ImGuiLocEntryPtr(null);

		public static implicit operator ImGuiLocEntryPtr(ImGuiLocEntry* handle) => new ImGuiLocEntryPtr(handle);

		public static implicit operator ImGuiLocEntry*(ImGuiLocEntryPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiLocEntryPtr left, ImGuiLocEntryPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiLocEntryPtr left, ImGuiLocEntryPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiLocEntryPtr left, ImGuiLocEntry* right) => left.Handle == right;

		public static bool operator !=(ImGuiLocEntryPtr left, ImGuiLocEntry* right) => left.Handle != right;

		public bool Equals(ImGuiLocEntryPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiLocEntryPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiLocEntryPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref ImGuiLocKey Key => ref Unsafe.AsRef<ImGuiLocKey>(&Handle->Key);
		public byte* Text { get => Handle->Text; set => Handle->Text = value; }
	}

	/// <summary>
	/// This is designed to be stored in a single ImChunkStream (1 header followed by N ImGuiTableColumnSettings, etc.)<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTableSettings
	{
		/// <summary>
		/// Set to 0 to invalidatedelete the setting<br/>
		/// </summary>
		public int ID;

		/// <summary>
		/// Indicate data we want to save using the ResizableReorderableSortableHideable flags (could be using its own flags..)<br/>
		/// </summary>
		public ImGuiTableFlags SaveFlags;

		/// <summary>
		/// Reference scale to be able to rescale columns on fontdpi changes.<br/>
		/// </summary>
		public float RefScale;

		public sbyte ColumnsCount;
		/// <summary>
		/// Maximum number of columns this settings instance can store, we can recycle a settings instance with lower number of columns but not higher<br/>
		/// </summary>
		public sbyte ColumnsCountMax;

		/// <summary>
		/// Set when loaded from .ini data (to enable mergingloading .ini data into an already running context)<br/>
		/// </summary>
		public byte WantApply;





		public unsafe void Destroy()
		{
			fixed (ImGuiTableSettings* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe ImGuiTableColumnSettings* GetColumnSettings()
		{
			fixed (ImGuiTableSettings* @this = &this)
			{
				ImGuiTableColumnSettings* ret = ImGui.GetColumnSettingsNative(@this);
				return ret;
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiTableSettingsPtr : IEquatable<ImGuiTableSettingsPtr>
	{
		public ImGuiTableSettingsPtr(ImGuiTableSettings* handle) { Handle = handle; }

		public ImGuiTableSettings* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiTableSettingsPtr Null => new ImGuiTableSettingsPtr(null);

		public static implicit operator ImGuiTableSettingsPtr(ImGuiTableSettings* handle) => new ImGuiTableSettingsPtr(handle);

		public static implicit operator ImGuiTableSettings*(ImGuiTableSettingsPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiTableSettingsPtr left, ImGuiTableSettingsPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiTableSettingsPtr left, ImGuiTableSettingsPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiTableSettingsPtr left, ImGuiTableSettings* right) => left.Handle == right;

		public static bool operator !=(ImGuiTableSettingsPtr left, ImGuiTableSettings* right) => left.Handle != right;

		public bool Equals(ImGuiTableSettingsPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiTableSettingsPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiTableSettingsPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		/// <summary>
		/// Set to 0 to invalidatedelete the setting<br/>
		/// </summary>
		public ref int ID => ref Unsafe.AsRef<int>(&Handle->ID);
		/// <summary>
		/// Indicate data we want to save using the ResizableReorderableSortableHideable flags (could be using its own flags..)<br/>
		/// </summary>
		public ref ImGuiTableFlags SaveFlags => ref Unsafe.AsRef<ImGuiTableFlags>(&Handle->SaveFlags);
		/// <summary>
		/// Reference scale to be able to rescale columns on fontdpi changes.<br/>
		/// </summary>
		public ref float RefScale => ref Unsafe.AsRef<float>(&Handle->RefScale);
		public ref sbyte ColumnsCount => ref Unsafe.AsRef<sbyte>(&Handle->ColumnsCount);
		/// <summary>
		/// Maximum number of columns this settings instance can store, we can recycle a settings instance with lower number of columns but not higher<br/>
		/// </summary>
		public ref sbyte ColumnsCountMax => ref Unsafe.AsRef<sbyte>(&Handle->ColumnsCountMax);
		/// <summary>
		/// Set when loaded from .ini data (to enable mergingloading .ini data into an already running context)<br/>
		/// </summary>
		public ref bool WantApply => ref Unsafe.AsRef<bool>(&Handle->WantApply);

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

		public unsafe ImGuiTableColumnSettings* GetColumnSettings()
		{
			ImGuiTableColumnSettings* ret = ImGui.GetColumnSettingsNative(Handle);
			return ret;
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTableColumnsSettings
	{


	}

	/// <summary>
	/// Windows data saved in imgui.ini file<br/>
	/// Because we never destroy or rename ImGuiWindowSettings, we can store the names in a separate buffer easily.<br/>
	/// (this is designed to be stored in a ImChunkStream buffer, with the variable-length Name following our structure)<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiWindowSettings
	{
		public int ID;
		/// <summary>
		/// NB: Settings position are stored RELATIVE to the viewport! Whereas runtime ones are absolute positions.<br/>
		/// </summary>
		public ImVec2Ih Pos;

		public ImVec2Ih Size;
		public ImVec2Ih ViewportPos;
		public int ViewportId;
		/// <summary>
		/// ID of last known DockNode (even if the DockNode is invisible because it has only 1 active window), or 0 if none.<br/>
		/// </summary>
		public int DockId;

		/// <summary>
		/// ID of window class if specified<br/>
		/// </summary>
		public int ClassId;

		/// <summary>
		/// Order of the last time the window was visible within its DockNode. This is used to reorder windows that are reappearing on the same frame. Same value between windows that were active and windows that were none are possible.<br/>
		/// </summary>
		public short DockOrder;

		public byte Collapsed;
		/// <summary>
		/// Set when loaded from .ini data (to enable mergingloading .ini data into an already running context)<br/>
		/// </summary>
		public byte WantApply;

		/// <summary>
		/// Set to invalidatedelete the settings entry<br/>
		/// </summary>
		public byte WantDelete;





		public unsafe void Destroy()
		{
			fixed (ImGuiWindowSettings* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe byte* GetName()
		{
			fixed (ImGuiWindowSettings* @this = &this)
			{
				byte* ret = ImGui.GetNameNative(@this);
				return ret;
			}
		}

		public unsafe string GetNameS()
		{
			fixed (ImGuiWindowSettings* @this = &this)
			{
				string ret = Utils.DecodeStringUTF8(ImGui.GetNameNative(@this));
				return ret;
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiWindowSettingsPtr : IEquatable<ImGuiWindowSettingsPtr>
	{
		public ImGuiWindowSettingsPtr(ImGuiWindowSettings* handle) { Handle = handle; }

		public ImGuiWindowSettings* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiWindowSettingsPtr Null => new ImGuiWindowSettingsPtr(null);

		public static implicit operator ImGuiWindowSettingsPtr(ImGuiWindowSettings* handle) => new ImGuiWindowSettingsPtr(handle);

		public static implicit operator ImGuiWindowSettings*(ImGuiWindowSettingsPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiWindowSettingsPtr left, ImGuiWindowSettingsPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiWindowSettingsPtr left, ImGuiWindowSettingsPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiWindowSettingsPtr left, ImGuiWindowSettings* right) => left.Handle == right;

		public static bool operator !=(ImGuiWindowSettingsPtr left, ImGuiWindowSettings* right) => left.Handle != right;

		public bool Equals(ImGuiWindowSettingsPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiWindowSettingsPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiWindowSettingsPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref int ID => ref Unsafe.AsRef<int>(&Handle->ID);
		/// <summary>
		/// NB: Settings position are stored RELATIVE to the viewport! Whereas runtime ones are absolute positions.<br/>
		/// </summary>
		public ref ImVec2Ih Pos => ref Unsafe.AsRef<ImVec2Ih>(&Handle->Pos);
		public ref ImVec2Ih Size => ref Unsafe.AsRef<ImVec2Ih>(&Handle->Size);
		public ref ImVec2Ih ViewportPos => ref Unsafe.AsRef<ImVec2Ih>(&Handle->ViewportPos);
		public ref int ViewportId => ref Unsafe.AsRef<int>(&Handle->ViewportId);
		/// <summary>
		/// ID of last known DockNode (even if the DockNode is invisible because it has only 1 active window), or 0 if none.<br/>
		/// </summary>
		public ref int DockId => ref Unsafe.AsRef<int>(&Handle->DockId);
		/// <summary>
		/// ID of window class if specified<br/>
		/// </summary>
		public ref int ClassId => ref Unsafe.AsRef<int>(&Handle->ClassId);
		/// <summary>
		/// Order of the last time the window was visible within its DockNode. This is used to reorder windows that are reappearing on the same frame. Same value between windows that were active and windows that were none are possible.<br/>
		/// </summary>
		public ref short DockOrder => ref Unsafe.AsRef<short>(&Handle->DockOrder);
		public ref bool Collapsed => ref Unsafe.AsRef<bool>(&Handle->Collapsed);
		/// <summary>
		/// Set when loaded from .ini data (to enable mergingloading .ini data into an already running context)<br/>
		/// </summary>
		public ref bool WantApply => ref Unsafe.AsRef<bool>(&Handle->WantApply);
		/// <summary>
		/// Set to invalidatedelete the settings entry<br/>
		/// </summary>
		public ref bool WantDelete => ref Unsafe.AsRef<bool>(&Handle->WantDelete);

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

		public unsafe byte* GetName()
		{
			byte* ret = ImGui.GetNameNative(Handle);
			return ret;
		}

		public unsafe string GetNameS()
		{
			string ret = Utils.DecodeStringUTF8(ImGui.GetNameNative(Handle));
			return ret;
		}

	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorConstCharPtr
	{
		public int Size;
		public int Capacity;
		public unsafe byte** Data;


	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImVectorConstCharPtrPtr : IEquatable<ImVectorConstCharPtrPtr>
	{
		public ImVectorConstCharPtrPtr(ImVectorConstCharPtr* handle) { Handle = handle; }

		public ImVectorConstCharPtr* Handle;

		public bool IsNull => Handle == null;

		public static ImVectorConstCharPtrPtr Null => new ImVectorConstCharPtrPtr(null);

		public static implicit operator ImVectorConstCharPtrPtr(ImVectorConstCharPtr* handle) => new ImVectorConstCharPtrPtr(handle);

		public static implicit operator ImVectorConstCharPtr*(ImVectorConstCharPtrPtr handle) => handle.Handle;

		public static bool operator ==(ImVectorConstCharPtrPtr left, ImVectorConstCharPtrPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImVectorConstCharPtrPtr left, ImVectorConstCharPtrPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImVectorConstCharPtrPtr left, ImVectorConstCharPtr* right) => left.Handle == right;

		public static bool operator !=(ImVectorConstCharPtrPtr left, ImVectorConstCharPtr* right) => left.Handle != right;

		public bool Equals(ImVectorConstCharPtrPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImVectorConstCharPtrPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImVectorConstCharPtrPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref int Size => ref Unsafe.AsRef<int>(&Handle->Size);
		public ref int Capacity => ref Unsafe.AsRef<int>(&Handle->Capacity);
		public byte** Data { get => Handle->Data; set => Handle->Data = value; }
	}

	/// <summary>
	/// result of layout query<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct StbTexteditRow
	{
		/// <summary>
		/// starting x location, end x location (allows for align=right, etc)<br/>
		/// </summary>
		public float X0;

		/// <summary>
		/// starting x location, end x location (allows for align=right, etc)<br/>
		/// </summary>
		public float X1;

		/// <summary>
		/// position of baseline relative to previous row's baseline<br/>
		/// </summary>
		public float BaselineYDelta;

		/// <summary>
		/// height of row above and below baseline<br/>
		/// </summary>
		public float Ymin;

		/// <summary>
		/// height of row above and below baseline<br/>
		/// </summary>
		public float Ymax;

		public int NumChars;


	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiDataTypeTempStorage
	{
		/// <summary>
		/// Can fit any data up to ImGuiDataType_COUNT<br/>
		/// </summary>
		public byte Data_0;
		public byte Data_1;
		public byte Data_2;
		public byte Data_3;
		public byte Data_4;
		public byte Data_5;
		public byte Data_6;
		public byte Data_7;



	}

	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImBitArrayImGuiKeyNamedKeyCOUNTLessImGuiKeyNamedKeyBEGIN
	{
		public uint Storage_0;
		public uint Storage_1;
		public uint Storage_2;
		public uint Storage_3;
		public uint Storage_4;


	}

	/// <summary>
	/// sizeof() ~ 12<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTableColumnSettings
	{
		public float WidthOrWeight;
		public int UserID;
		public sbyte Index;
		public sbyte DisplayOrder;
		public sbyte SortOrder;
		public byte SortDirection;
		/// <summary>
		/// "Visible" in ini file<br/>
		/// </summary>
		public byte IsEnabled;

		public byte IsStretch;




		public unsafe void Destroy()
		{
			fixed (ImGuiTableColumnSettings* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public unsafe struct ImGuiTableColumnSettingsPtr : IEquatable<ImGuiTableColumnSettingsPtr>
	{
		public ImGuiTableColumnSettingsPtr(ImGuiTableColumnSettings* handle) { Handle = handle; }

		public ImGuiTableColumnSettings* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiTableColumnSettingsPtr Null => new ImGuiTableColumnSettingsPtr(null);

		public static implicit operator ImGuiTableColumnSettingsPtr(ImGuiTableColumnSettings* handle) => new ImGuiTableColumnSettingsPtr(handle);

		public static implicit operator ImGuiTableColumnSettings*(ImGuiTableColumnSettingsPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiTableColumnSettingsPtr left, ImGuiTableColumnSettingsPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiTableColumnSettingsPtr left, ImGuiTableColumnSettingsPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiTableColumnSettingsPtr left, ImGuiTableColumnSettings* right) => left.Handle == right;

		public static bool operator !=(ImGuiTableColumnSettingsPtr left, ImGuiTableColumnSettings* right) => left.Handle != right;

		public bool Equals(ImGuiTableColumnSettingsPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiTableColumnSettingsPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		private string DebuggerDisplay => string.Format("ImGuiTableColumnSettingsPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		public ref float WidthOrWeight => ref Unsafe.AsRef<float>(&Handle->WidthOrWeight);
		public ref int UserID => ref Unsafe.AsRef<int>(&Handle->UserID);
		public ref sbyte Index => ref Unsafe.AsRef<sbyte>(&Handle->Index);
		public ref sbyte DisplayOrder => ref Unsafe.AsRef<sbyte>(&Handle->DisplayOrder);
		public ref sbyte SortOrder => ref Unsafe.AsRef<sbyte>(&Handle->SortOrder);
		public ref byte SortDirection => ref Unsafe.AsRef<byte>(&Handle->SortDirection);
		/// <summary>
		/// "Visible" in ini file<br/>
		/// </summary>
		public ref byte IsEnabled => ref Unsafe.AsRef<byte>(&Handle->IsEnabled);
		public ref byte IsStretch => ref Unsafe.AsRef<byte>(&Handle->IsStretch);

		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

	}

}
