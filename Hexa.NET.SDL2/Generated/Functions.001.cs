// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL2
{
	public unsafe partial class SDL
	{

		/// <summary>/// This function converts a buffer or string between encodings in one pass,<br/>/// returning a string that must be freed with SDL_free() or NULL on error.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLIconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "const char*")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "const char*")] string fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char*")] string inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] ulong inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fromcode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fromcode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fromcode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (inbuf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(inbuf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(inbuf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(SDLIconvStringNative(tocode, pStr0, pStr1, inbytesleft));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// This function converts a buffer or string between encodings in one pass,<br/>/// returning a string that must be freed with SDL_free() or NULL on error.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLIconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "const char*")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "const char*")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char*")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			byte* ret = SDLIconvStringNative(tocode, fromcode, inbuf, inbytesleft);
			return ret;
		}

		/// <summary>/// This function converts a buffer or string between encodings in one pass,<br/>/// returning a string that must be freed with SDL_free() or NULL on error.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLIconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "const char*")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "const char*")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char*")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			string ret = Utils.DecodeStringUTF8(SDLIconvStringNative(tocode, fromcode, inbuf, inbytesleft));
			return ret;
		}

		/// <summary>/// This function converts a buffer or string between encodings in one pass,<br/>/// returning a string that must be freed with SDL_free() or NULL on error.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLIconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "const char*")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "const char*")] ref byte fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char*")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* pfromcode = &fromcode)
			{
				byte* ret = SDLIconvStringNative(tocode, (byte*)pfromcode, inbuf, inbytesleft);
				return ret;
			}
		}

		/// <summary>/// This function converts a buffer or string between encodings in one pass,<br/>/// returning a string that must be freed with SDL_free() or NULL on error.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLIconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "const char*")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "const char*")] ref byte fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char*")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* pfromcode = &fromcode)
			{
				string ret = Utils.DecodeStringUTF8(SDLIconvStringNative(tocode, (byte*)pfromcode, inbuf, inbytesleft));
				return ret;
			}
		}

		/// <summary>/// This function converts a buffer or string between encodings in one pass,<br/>/// returning a string that must be freed with SDL_free() or NULL on error.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLIconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "const char*")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "const char*")] string fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char*")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fromcode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fromcode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fromcode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = SDLIconvStringNative(tocode, pStr0, inbuf, inbytesleft);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// This function converts a buffer or string between encodings in one pass,<br/>/// returning a string that must be freed with SDL_free() or NULL on error.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLIconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "const char*")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "const char*")] string fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char*")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fromcode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fromcode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fromcode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(SDLIconvStringNative(tocode, pStr0, inbuf, inbytesleft));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// This function converts a buffer or string between encodings in one pass,<br/>/// returning a string that must be freed with SDL_free() or NULL on error.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLIconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "const char*")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "const char*")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char*")] ref byte inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* pinbuf = &inbuf)
			{
				byte* ret = SDLIconvStringNative(tocode, fromcode, (byte*)pinbuf, inbytesleft);
				return ret;
			}
		}

		/// <summary>/// This function converts a buffer or string between encodings in one pass,<br/>/// returning a string that must be freed with SDL_free() or NULL on error.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLIconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "const char*")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "const char*")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char*")] ref byte inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* pinbuf = &inbuf)
			{
				string ret = Utils.DecodeStringUTF8(SDLIconvStringNative(tocode, fromcode, (byte*)pinbuf, inbytesleft));
				return ret;
			}
		}

		/// <summary>/// This function converts a buffer or string between encodings in one pass,<br/>/// returning a string that must be freed with SDL_free() or NULL on error.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLIconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "const char*")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "const char*")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char*")] string inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inbuf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inbuf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inbuf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = SDLIconvStringNative(tocode, fromcode, pStr0, inbytesleft);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// This function converts a buffer or string between encodings in one pass,<br/>/// returning a string that must be freed with SDL_free() or NULL on error.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLIconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "const char*")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "const char*")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char*")] string inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inbuf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inbuf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inbuf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(SDLIconvStringNative(tocode, fromcode, pStr0, inbytesleft));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// This function converts a buffer or string between encodings in one pass,<br/>/// returning a string that must be freed with SDL_free() or NULL on error.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLIconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "const char*")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "const char*")] ref byte fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char*")] ref byte inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* pfromcode = &fromcode)
			{
				fixed (byte* pinbuf = &inbuf)
				{
					byte* ret = SDLIconvStringNative(tocode, (byte*)pfromcode, (byte*)pinbuf, inbytesleft);
					return ret;
				}
			}
		}

		/// <summary>/// This function converts a buffer or string between encodings in one pass,<br/>/// returning a string that must be freed with SDL_free() or NULL on error.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLIconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "const char*")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "const char*")] ref byte fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char*")] ref byte inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* pfromcode = &fromcode)
			{
				fixed (byte* pinbuf = &inbuf)
				{
					string ret = Utils.DecodeStringUTF8(SDLIconvStringNative(tocode, (byte*)pfromcode, (byte*)pinbuf, inbytesleft));
					return ret;
				}
			}
		}

		/// <summary>/// This function converts a buffer or string between encodings in one pass,<br/>/// returning a string that must be freed with SDL_free() or NULL on error.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLIconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "const char*")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "const char*")] string fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char*")] string inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fromcode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fromcode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fromcode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (inbuf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(inbuf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(inbuf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = SDLIconvStringNative(tocode, pStr0, pStr1, inbytesleft);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// This function converts a buffer or string between encodings in one pass,<br/>/// returning a string that must be freed with SDL_free() or NULL on error.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLIconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "const char*")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "const char*")] string fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char*")] string inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fromcode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fromcode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fromcode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (inbuf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(inbuf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(inbuf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(SDLIconvStringNative(tocode, pStr0, pStr1, inbytesleft));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_main")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_main")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLMainNative([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char*[-1]")] byte** argv);

		[NativeName(NativeNameType.Func, "SDL_main")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLMain([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char*[-1]")] byte** argv)
		{
			int ret = SDLMainNative(argc, argv);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_main")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLMain([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char*[-1]")] string[] argv)
		{
			byte** pStrArray0 = null;
			int pStrArraySize0 = Utils.GetByteCountArray(argv);
			if (argv != null)
			{
				if (pStrArraySize0 > Utils.MaxStackallocSize)
				{
					pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArraySize0);
				}
				else
				{
					byte* pStrArrayStack0 = stackalloc byte[pStrArraySize0];
					pStrArray0 = (byte**)pStrArrayStack0;
				}
			}
			for (int i = 0; i < argv.Length; i++)
			{
				pStrArray0[i] = (byte*)Utils.StringToUTF8Ptr(argv[i]);
			}
			int ret = SDLMainNative(argc, pStrArray0);
			for (int i = 0; i < argv.Length; i++)
			{
				Utils.Free(pStrArray0[i]);
			}
			if (pStrArraySize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStrArray0);
			}
			return ret;
		}

		/// <summary>
		/// Circumvent failure of SDL_Init() when not using SDL_main() as an entry<br/>
		/// point.<br/>
		/// This function is defined in SDL_main.h, along with the preprocessor rule to<br/>
		/// redefine main() as SDL_main(). Thus to ensure that your main() function<br/>
		/// will not be changed it is necessary to define SDL_MAIN_HANDLED before<br/>
		/// including SDL.h.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetMainReady")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "SDL_SetMainReady")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SDLSetMainReadyNative();

		/// <summary>/// Circumvent failure of SDL_Init() when not using SDL_main() as an entry<br/>/// point.<br/>/// This function is defined in SDL_main.h, along with the preprocessor rule to<br/>/// redefine main() as SDL_main(). Thus to ensure that your main() function<br/>/// will not be changed it is necessary to define SDL_MAIN_HANDLED before<br/>/// including SDL.h.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetMainReady")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLSetMainReady()
		{
			SDLSetMainReadyNative();
		}

		/// <summary>
		/// Register a win32 window class for SDL's use.<br/>
		/// This can be called to set the application window class at startup. It is<br/>
		/// safe to call this multiple times, as long as every call is eventually<br/>
		/// paired with a call to SDL_UnregisterApp, but a second registration attempt<br/>
		/// while a previous registration is still active will be ignored, other than<br/>
		/// to increment a counter.<br/>
		/// Most applications do not need to, and should not, call this directly; SDL<br/>
		/// will call it when initializing the video subsystem.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RegisterApp")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_RegisterApp")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLRegisterAppNative([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name, [NativeName(NativeNameType.Param, "style")] [NativeName(NativeNameType.Type, "Uint32")] uint style, [NativeName(NativeNameType.Param, "hInst")] [NativeName(NativeNameType.Type, "void*")] void* hInst);

		/// <summary>/// Register a win32 window class for SDL's use.<br/>/// This can be called to set the application window class at startup. It is<br/>/// safe to call this multiple times, as long as every call is eventually<br/>/// paired with a call to SDL_UnregisterApp, but a second registration attempt<br/>/// while a previous registration is still active will be ignored, other than<br/>/// to increment a counter.<br/>/// Most applications do not need to, and should not, call this directly; SDL<br/>/// will call it when initializing the video subsystem.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_RegisterApp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRegisterApp([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name, [NativeName(NativeNameType.Param, "style")] [NativeName(NativeNameType.Type, "Uint32")] uint style, [NativeName(NativeNameType.Param, "hInst")] [NativeName(NativeNameType.Type, "void*")] void* hInst)
		{
			int ret = SDLRegisterAppNative(name, style, hInst);
			return ret;
		}

		/// <summary>
		/// Deregister the win32 window class from an SDL_RegisterApp call.<br/>
		/// This can be called to undo the effects of SDL_RegisterApp.<br/>
		/// Most applications do not need to, and should not, call this directly; SDL<br/>
		/// will call it when deinitializing the video subsystem.<br/>
		/// It is safe to call this multiple times, as long as every call is eventually<br/>
		/// paired with a prior call to SDL_RegisterApp. The window class will only be<br/>
		/// deregistered when the registration counter in SDL_RegisterApp decrements to<br/>
		/// zero through calls to this function.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnregisterApp")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "SDL_UnregisterApp")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SDLUnregisterAppNative();

		/// <summary>/// Deregister the win32 window class from an SDL_RegisterApp call.<br/>/// This can be called to undo the effects of SDL_RegisterApp.<br/>/// Most applications do not need to, and should not, call this directly; SDL<br/>/// will call it when deinitializing the video subsystem.<br/>/// It is safe to call this multiple times, as long as every call is eventually<br/>/// paired with a prior call to SDL_RegisterApp. The window class will only be<br/>/// deregistered when the registration counter in SDL_RegisterApp decrements to<br/>/// zero through calls to this function.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_UnregisterApp")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLUnregisterApp()
		{
			SDLUnregisterAppNative();
		}

		/// <summary>
		/// Don't include intrin.h here because it contains C++ code <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "__debugbreak")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "__debugbreak")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DebugbreakNative();

		/// <summary>/// Don't include intrin.h here because it contains C++ code <br/>/// </summary>		[NativeName(NativeNameType.Func, "__debugbreak")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Debugbreak()
		{
			DebugbreakNative();
		}

		/// <summary>
		/// Set an application-defined assertion handler.<br/>
		/// This function allows an application to show its own assertion UI and/or<br/>
		/// force the response to an assertion failure. If the application doesn't<br/>
		/// provide this, SDL will try to do the right thing, popping up a<br/>
		/// system-specific GUI dialog, and probably minimizing any fullscreen windows.<br/>
		/// This callback may fire from any thread, but it runs wrapped in a mutex, so<br/>
		/// it will only fire from one thread at a time.<br/>
		/// This callback is NOT reset to SDL's internal handler upon SDL_Quit()!<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAssertionHandler")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "SDL_SetAssertionHandler")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SDLSetAssertionHandlerNative([NativeName(NativeNameType.Param, "handler")] [NativeName(NativeNameType.Type, "SDL_AssertionHandler")] SdlAssertionhandler handler, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void*")] void* userdata);

		/// <summary>/// Set an application-defined assertion handler.<br/>/// This function allows an application to show its own assertion UI and/or<br/>/// force the response to an assertion failure. If the application doesn't<br/>/// provide this, SDL will try to do the right thing, popping up a<br/>/// system-specific GUI dialog, and probably minimizing any fullscreen windows.<br/>/// This callback may fire from any thread, but it runs wrapped in a mutex, so<br/>/// it will only fire from one thread at a time.<br/>/// This callback is NOT reset to SDL's internal handler upon SDL_Quit()!<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetAssertionHandler")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLSetAssertionHandler([NativeName(NativeNameType.Param, "handler")] [NativeName(NativeNameType.Type, "SDL_AssertionHandler")] SdlAssertionhandler handler, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void*")] void* userdata)
		{
			SDLSetAssertionHandlerNative(handler, userdata);
		}

		/// <summary>
		/// Get the default assertion handler.<br/>
		/// This returns the function pointer that is called by default when an<br/>
		/// assertion is triggered. This is an internal function provided by SDL, that<br/>
		/// is used for assertions when SDL_SetAssertionHandler() hasn't been used to<br/>
		/// provide a different function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetDefaultAssertionHandler")]
		[return: NativeName(NativeNameType.Type, "SDL_AssertionHandler")]
		[LibraryImport(LibName, EntryPoint = "SDL_GetDefaultAssertionHandler")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial SdlAssertionhandler SDLGetDefaultAssertionHandlerNative();

		/// <summary>/// Get the default assertion handler.<br/>/// This returns the function pointer that is called by default when an<br/>/// assertion is triggered. This is an internal function provided by SDL, that<br/>/// is used for assertions when SDL_SetAssertionHandler() hasn't been used to<br/>/// provide a different function.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetDefaultAssertionHandler")]
		[return: NativeName(NativeNameType.Type, "SDL_AssertionHandler")]
		public static SdlAssertionhandler SDLGetDefaultAssertionHandler()
		{
			SdlAssertionhandler ret = SDLGetDefaultAssertionHandlerNative();
			return ret;
		}

		/// <summary>
		/// Get the current assertion handler.<br/>
		/// This returns the function pointer that is called when an assertion is<br/>
		/// triggered. This is either the value last passed to<br/>
		/// SDL_SetAssertionHandler(), or if no application-specified function is set,<br/>
		/// is equivalent to calling SDL_GetDefaultAssertionHandler().<br/>
		/// The parameter `puserdata` is a pointer to a void*, which will store the<br/>
		/// "userdata" pointer that was passed to SDL_SetAssertionHandler(). This value<br/>
		/// will always be NULL for the default handler. If you don't care about this<br/>
		/// data, it is safe to pass a NULL pointer to this function to ignore it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAssertionHandler")]
		[return: NativeName(NativeNameType.Type, "SDL_AssertionHandler")]
		[LibraryImport(LibName, EntryPoint = "SDL_GetAssertionHandler")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial SdlAssertionhandler SDLGetAssertionHandlerNative([NativeName(NativeNameType.Param, "puserdata")] [NativeName(NativeNameType.Type, "void**")] void** puserdata);

		/// <summary>/// Get the current assertion handler.<br/>/// This returns the function pointer that is called when an assertion is<br/>/// triggered. This is either the value last passed to<br/>/// SDL_SetAssertionHandler(), or if no application-specified function is set,<br/>/// is equivalent to calling SDL_GetDefaultAssertionHandler().<br/>/// The parameter `puserdata` is a pointer to a void*, which will store the<br/>/// "userdata" pointer that was passed to SDL_SetAssertionHandler(). This value<br/>/// will always be NULL for the default handler. If you don't care about this<br/>/// data, it is safe to pass a NULL pointer to this function to ignore it.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetAssertionHandler")]
		[return: NativeName(NativeNameType.Type, "SDL_AssertionHandler")]
		public static SdlAssertionhandler SDLGetAssertionHandler([NativeName(NativeNameType.Param, "puserdata")] [NativeName(NativeNameType.Type, "void**")] void** puserdata)
		{
			SdlAssertionhandler ret = SDLGetAssertionHandlerNative(puserdata);
			return ret;
		}

		/// <summary>
		/// Get a list of all assertion failures.<br/>
		/// This function gets all assertions triggered since the last call to<br/>
		/// SDL_ResetAssertionReport(), or the start of the program.<br/>
		/// The proper way to examine this data looks something like this:<br/>
		/// ```c<br/>
		/// const SDL_AssertData *item = SDL_GetAssertionReport();<br/>
		/// while (item) {<br/>
		/// printf("'%s', %s (%s:%d), triggered %u times, always ignore: %s.\\n",<br/>
		/// item->condition, item->function, item->filename,<br/>
		/// item->linenum, item->trigger_count,<br/>
		/// item->always_ignore ? "yes" : "no");<br/>
		/// item = item->next;<br/>
		/// }<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAssertionReport")]
		[return: NativeName(NativeNameType.Type, "const SDL_AssertData*")]
		[LibraryImport(LibName, EntryPoint = "SDL_GetAssertionReport")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial SDLAssertData* SDLGetAssertionReportNative();

		/// <summary>/// Get a list of all assertion failures.<br/>/// This function gets all assertions triggered since the last call to<br/>/// SDL_ResetAssertionReport(), or the start of the program.<br/>/// The proper way to examine this data looks something like this:<br/>/// ```c<br/>/// const SDL_AssertData *item = SDL_GetAssertionReport();<br/>/// while (item) {<br/>/// printf("'%s', %s (%s:%d), triggered %u times, always ignore: %s.\\n",<br/>/// item->condition, item->function, item->filename,<br/>/// item->linenum, item->trigger_count,<br/>/// item->always_ignore ? "yes" : "no");<br/>/// item = item->next;<br/>/// }<br/>/// ```<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetAssertionReport")]
		[return: NativeName(NativeNameType.Type, "const SDL_AssertData*")]
		public static SDLAssertData* SDLGetAssertionReport()
		{
			SDLAssertData* ret = SDLGetAssertionReportNative();
			return ret;
		}

		/// <summary>
		/// Clear the list of all assertion failures.<br/>
		/// This function will clear the list of all assertions triggered up to that<br/>
		/// point. Immediately following this call, SDL_GetAssertionReport will return<br/>
		/// no items. In addition, any previously-triggered assertions will be reset to<br/>
		/// a trigger_count of zero, and their always_ignore state will be false.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ResetAssertionReport")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "SDL_ResetAssertionReport")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SDLResetAssertionReportNative();

		/// <summary>/// Clear the list of all assertion failures.<br/>/// This function will clear the list of all assertions triggered up to that<br/>/// point. Immediately following this call, SDL_GetAssertionReport will return<br/>/// no items. In addition, any previously-triggered assertions will be reset to<br/>/// a trigger_count of zero, and their always_ignore state will be false.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_ResetAssertionReport")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLResetAssertionReport()
		{
			SDLResetAssertionReportNative();
		}

		/// <summary>
		/// Try to lock a spin lock by setting it to a non-zero value.<br/>
		/// ***Please note that spinlocks are dangerous if you don't know what you're<br/>
		/// doing. Please be careful using any sort of spinlock!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AtomicTryLock")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[LibraryImport(LibName, EntryPoint = "SDL_AtomicTryLock")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial SDLBool SDLAtomicTryLockNative([NativeName(NativeNameType.Param, "lock")] [NativeName(NativeNameType.Type, "SDL_SpinLock*")] int* lock0);

		/// <summary>/// Try to lock a spin lock by setting it to a non-zero value.<br/>/// ***Please note that spinlocks are dangerous if you don't know what you're<br/>/// doing. Please be careful using any sort of spinlock!***<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_AtomicTryLock")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLAtomicTryLock([NativeName(NativeNameType.Param, "lock")] [NativeName(NativeNameType.Type, "SDL_SpinLock*")] int* lock0)
		{
			SDLBool ret = SDLAtomicTryLockNative(lock0);
			return ret;
		}

		/// <summary>
		/// Lock a spin lock by setting it to a non-zero value.<br/>
		/// ***Please note that spinlocks are dangerous if you don't know what you're<br/>
		/// doing. Please be careful using any sort of spinlock!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AtomicLock")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "SDL_AtomicLock")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SDLAtomicLockNative([NativeName(NativeNameType.Param, "lock")] [NativeName(NativeNameType.Type, "SDL_SpinLock*")] int* lock0);

		/// <summary>/// Lock a spin lock by setting it to a non-zero value.<br/>/// ***Please note that spinlocks are dangerous if you don't know what you're<br/>/// doing. Please be careful using any sort of spinlock!***<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_AtomicLock")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLAtomicLock([NativeName(NativeNameType.Param, "lock")] [NativeName(NativeNameType.Type, "SDL_SpinLock*")] int* lock0)
		{
			SDLAtomicLockNative(lock0);
		}

		/// <summary>
		/// Unlock a spin lock by setting it to 0.<br/>
		/// Always returns immediately.<br/>
		/// ***Please note that spinlocks are dangerous if you don't know what you're<br/>
		/// doing. Please be careful using any sort of spinlock!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AtomicUnlock")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "SDL_AtomicUnlock")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SDLAtomicUnlockNative([NativeName(NativeNameType.Param, "lock")] [NativeName(NativeNameType.Type, "SDL_SpinLock*")] int* lock0);

		/// <summary>/// Unlock a spin lock by setting it to 0.<br/>/// Always returns immediately.<br/>/// ***Please note that spinlocks are dangerous if you don't know what you're<br/>/// doing. Please be careful using any sort of spinlock!***<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_AtomicUnlock")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLAtomicUnlock([NativeName(NativeNameType.Param, "lock")] [NativeName(NativeNameType.Type, "SDL_SpinLock*")] int* lock0)
		{
			SDLAtomicUnlockNative(lock0);
		}

		/// <summary>
		/// Memory barriers are designed to prevent reads and writes from being<br/>
		/// reordered by the compiler and being seen out of order on multi-core CPUs.<br/>
		/// A typical pattern would be for thread A to write some data and a flag, and<br/>
		/// for thread B to read the flag and get the data. In this case you would<br/>
		/// insert a release barrier between writing the data and the flag,<br/>
		/// guaranteeing that the data write completes no later than the flag is<br/>
		/// written, and you would insert an acquire barrier between reading the flag<br/>
		/// and reading the data, to ensure that all the reads associated with the flag<br/>
		/// have completed.<br/>
		/// In this pattern you should always see a release barrier paired with an<br/>
		/// acquire barrier and you should gate the data reads/writes with a single<br/>
		/// flag variable.<br/>
		/// For more information on these semantics, take a look at the blog post:<br/>
		/// http://preshing.com/20120913/acquire-and-release-semantics<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_MemoryBarrierReleaseFunction")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "SDL_MemoryBarrierReleaseFunction")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SDLMemoryBarrierReleaseFunctionNative();

		/// <summary>/// Memory barriers are designed to prevent reads and writes from being<br/>/// reordered by the compiler and being seen out of order on multi-core CPUs.<br/>/// A typical pattern would be for thread A to write some data and a flag, and<br/>/// for thread B to read the flag and get the data. In this case you would<br/>/// insert a release barrier between writing the data and the flag,<br/>/// guaranteeing that the data write completes no later than the flag is<br/>/// written, and you would insert an acquire barrier between reading the flag<br/>/// and reading the data, to ensure that all the reads associated with the flag<br/>/// have completed.<br/>/// In this pattern you should always see a release barrier paired with an<br/>/// acquire barrier and you should gate the data reads/writes with a single<br/>/// flag variable.<br/>/// For more information on these semantics, take a look at the blog post:<br/>/// http://preshing.com/20120913/acquire-and-release-semantics<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_MemoryBarrierReleaseFunction")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLMemoryBarrierReleaseFunction()
		{
			SDLMemoryBarrierReleaseFunctionNative();
		}

		[NativeName(NativeNameType.Func, "SDL_MemoryBarrierAcquireFunction")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "SDL_MemoryBarrierAcquireFunction")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SDLMemoryBarrierAcquireFunctionNative();

		[NativeName(NativeNameType.Func, "SDL_MemoryBarrierAcquireFunction")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLMemoryBarrierAcquireFunction()
		{
			SDLMemoryBarrierAcquireFunctionNative();
		}

		/// <summary>
		/// Set an atomic variable to a new value if it is currently an old value.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AtomicCAS")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[LibraryImport(LibName, EntryPoint = "SDL_AtomicCAS")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial SDLBool SDLAtomicCASNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_atomic_t*")] SDLAtomic* a, [NativeName(NativeNameType.Param, "oldval")] [NativeName(NativeNameType.Type, "int")] int oldval, [NativeName(NativeNameType.Param, "newval")] [NativeName(NativeNameType.Type, "int")] int newval);

		/// <summary>/// Set an atomic variable to a new value if it is currently an old value.<br/>/// ***Note: If you don't know what this function is for, you shouldn't use<br/>/// it!***<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_AtomicCAS")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLAtomicCAS([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_atomic_t*")] SDLAtomic* a, [NativeName(NativeNameType.Param, "oldval")] [NativeName(NativeNameType.Type, "int")] int oldval, [NativeName(NativeNameType.Param, "newval")] [NativeName(NativeNameType.Type, "int")] int newval)
		{
			SDLBool ret = SDLAtomicCASNative(a, oldval, newval);
			return ret;
		}

		/// <summary>
		/// Set an atomic variable to a value.<br/>
		/// This function also acts as a full memory barrier.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AtomicSet")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_AtomicSet")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLAtomicSetNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_atomic_t*")] SDLAtomic* a, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "int")] int v);

		/// <summary>/// Set an atomic variable to a value.<br/>/// This function also acts as a full memory barrier.<br/>/// ***Note: If you don't know what this function is for, you shouldn't use<br/>/// it!***<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_AtomicSet")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLAtomicSet([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_atomic_t*")] SDLAtomic* a, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "int")] int v)
		{
			int ret = SDLAtomicSetNative(a, v);
			return ret;
		}

		/// <summary>
		/// Get the value of an atomic variable.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AtomicGet")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_AtomicGet")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLAtomicGetNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_atomic_t*")] SDLAtomic* a);

		/// <summary>/// Get the value of an atomic variable.<br/>/// ***Note: If you don't know what this function is for, you shouldn't use<br/>/// it!***<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_AtomicGet")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLAtomicGet([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_atomic_t*")] SDLAtomic* a)
		{
			int ret = SDLAtomicGetNative(a);
			return ret;
		}

		/// <summary>
		/// Add to an atomic variable.<br/>
		/// This function also acts as a full memory barrier.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AtomicAdd")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_AtomicAdd")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLAtomicAddNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_atomic_t*")] SDLAtomic* a, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "int")] int v);

		/// <summary>/// Add to an atomic variable.<br/>/// This function also acts as a full memory barrier.<br/>/// ***Note: If you don't know what this function is for, you shouldn't use<br/>/// it!***<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_AtomicAdd")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLAtomicAdd([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_atomic_t*")] SDLAtomic* a, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "int")] int v)
		{
			int ret = SDLAtomicAddNative(a, v);
			return ret;
		}

		/// <summary>
		/// Set a pointer to a new value if it is currently an old value.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AtomicCASPtr")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[LibraryImport(LibName, EntryPoint = "SDL_AtomicCASPtr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial SDLBool SDLAtomicCASPtrNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "void**")] void** a, [NativeName(NativeNameType.Param, "oldval")] [NativeName(NativeNameType.Type, "void*")] void* oldval, [NativeName(NativeNameType.Param, "newval")] [NativeName(NativeNameType.Type, "void*")] void* newval);

		/// <summary>/// Set a pointer to a new value if it is currently an old value.<br/>/// ***Note: If you don't know what this function is for, you shouldn't use<br/>/// it!***<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_AtomicCASPtr")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLAtomicCASPtr([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "void**")] void** a, [NativeName(NativeNameType.Param, "oldval")] [NativeName(NativeNameType.Type, "void*")] void* oldval, [NativeName(NativeNameType.Param, "newval")] [NativeName(NativeNameType.Type, "void*")] void* newval)
		{
			SDLBool ret = SDLAtomicCASPtrNative(a, oldval, newval);
			return ret;
		}

		/// <summary>
		/// Set a pointer to a value atomically.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AtomicSetPtr")]
		[return: NativeName(NativeNameType.Type, "void*")]
		[LibraryImport(LibName, EntryPoint = "SDL_AtomicSetPtr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void* SDLAtomicSetPtrNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "void**")] void** a, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "void*")] void* v);

		/// <summary>/// Set a pointer to a value atomically.<br/>/// ***Note: If you don't know what this function is for, you shouldn't use<br/>/// it!***<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_AtomicSetPtr")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLAtomicSetPtr([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "void**")] void** a, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "void*")] void* v)
		{
			void* ret = SDLAtomicSetPtrNative(a, v);
			return ret;
		}

		/// <summary>
		/// Get the value of a pointer atomically.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AtomicGetPtr")]
		[return: NativeName(NativeNameType.Type, "void*")]
		[LibraryImport(LibName, EntryPoint = "SDL_AtomicGetPtr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void* SDLAtomicGetPtrNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "void**")] void** a);

		/// <summary>/// Get the value of a pointer atomically.<br/>/// ***Note: If you don't know what this function is for, you shouldn't use<br/>/// it!***<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_AtomicGetPtr")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLAtomicGetPtr([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "void**")] void** a)
		{
			void* ret = SDLAtomicGetPtrNative(a);
			return ret;
		}

		/// <summary>
		/// Set the SDL error message for the current thread.<br/>
		/// Calling this function will replace any previous error message that was set.<br/>
		/// This function always returns -1, since SDL frequently uses -1 to signify an<br/>
		/// failing result, leading to this idiom:<br/>
		/// ```c<br/>
		/// if (error_code) {<br/>
		/// return SDL_SetError("This operation has failed: %d", error_code);<br/>
		/// }<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetError")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_SetError")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLSetErrorNative([NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt);

		/// <summary>/// Set the SDL error message for the current thread.<br/>/// Calling this function will replace any previous error message that was set.<br/>/// This function always returns -1, since SDL frequently uses -1 to signify an<br/>/// failing result, leading to this idiom:<br/>/// ```c<br/>/// if (error_code) {<br/>/// return SDL_SetError("This operation has failed: %d", error_code);<br/>/// }<br/>/// ```<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetError")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetError([NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt)
		{
			int ret = SDLSetErrorNative(fmt);
			return ret;
		}

		/// <summary>
		/// Retrieve a message about the last error that occurred on the current<br/>
		/// thread.<br/>
		/// It is possible for multiple errors to occur before calling SDL_GetError().<br/>
		/// Only the last error is returned.<br/>
		/// The message is only applicable when an SDL function has signaled an error.<br/>
		/// You must check the return values of SDL function calls to determine when to<br/>
		/// appropriately call SDL_GetError(). You should *not* use the results of<br/>
		/// SDL_GetError() to decide if an error has occurred! Sometimes SDL will set<br/>
		/// an error string even when reporting success.<br/>
		/// SDL will *not* clear the error string for successful API calls. You *must*<br/>
		/// check return values for failure cases before you can assume the error<br/>
		/// string applies.<br/>
		/// Error strings are set per-thread, so an error set in a different thread<br/>
		/// will not interfere with the current thread's operation.<br/>
		/// The returned string is internally allocated and must not be freed by the<br/>
		/// application.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetError")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		[LibraryImport(LibName, EntryPoint = "SDL_GetError")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte* SDLGetErrorNative();

		/// <summary>/// Retrieve a message about the last error that occurred on the current<br/>/// thread.<br/>/// It is possible for multiple errors to occur before calling SDL_GetError().<br/>/// Only the last error is returned.<br/>/// The message is only applicable when an SDL function has signaled an error.<br/>/// You must check the return values of SDL function calls to determine when to<br/>/// appropriately call SDL_GetError(). You should *not* use the results of<br/>/// SDL_GetError() to decide if an error has occurred! Sometimes SDL will set<br/>/// an error string even when reporting success.<br/>/// SDL will *not* clear the error string for successful API calls. You *must*<br/>/// check return values for failure cases before you can assume the error<br/>/// string applies.<br/>/// Error strings are set per-thread, so an error set in a different thread<br/>/// will not interfere with the current thread's operation.<br/>/// The returned string is internally allocated and must not be freed by the<br/>/// application.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetError")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGetError()
		{
			byte* ret = SDLGetErrorNative();
			return ret;
		}

		/// <summary>/// Retrieve a message about the last error that occurred on the current<br/>/// thread.<br/>/// It is possible for multiple errors to occur before calling SDL_GetError().<br/>/// Only the last error is returned.<br/>/// The message is only applicable when an SDL function has signaled an error.<br/>/// You must check the return values of SDL function calls to determine when to<br/>/// appropriately call SDL_GetError(). You should *not* use the results of<br/>/// SDL_GetError() to decide if an error has occurred! Sometimes SDL will set<br/>/// an error string even when reporting success.<br/>/// SDL will *not* clear the error string for successful API calls. You *must*<br/>/// check return values for failure cases before you can assume the error<br/>/// string applies.<br/>/// Error strings are set per-thread, so an error set in a different thread<br/>/// will not interfere with the current thread's operation.<br/>/// The returned string is internally allocated and must not be freed by the<br/>/// application.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetError")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGetErrorS()
		{
			string ret = Utils.DecodeStringUTF8(SDLGetErrorNative());
			return ret;
		}

		/// <summary>
		/// Get the last error message that was set for the current thread.<br/>
		/// This allows the caller to copy the error string into a provided buffer, but<br/>
		/// otherwise operates exactly the same as SDL_GetError().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetErrorMsg")]
		[return: NativeName(NativeNameType.Type, "char*")]
		[LibraryImport(LibName, EntryPoint = "SDL_GetErrorMsg")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte* SDLGetErrorMsgNative([NativeName(NativeNameType.Param, "errstr")] [NativeName(NativeNameType.Type, "char*")] byte* errstr, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "int")] int maxlen);

		/// <summary>/// Get the last error message that was set for the current thread.<br/>/// This allows the caller to copy the error string into a provided buffer, but<br/>/// otherwise operates exactly the same as SDL_GetError().<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetErrorMsg")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLGetErrorMsg([NativeName(NativeNameType.Param, "errstr")] [NativeName(NativeNameType.Type, "char*")] byte* errstr, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "int")] int maxlen)
		{
			byte* ret = SDLGetErrorMsgNative(errstr, maxlen);
			return ret;
		}

		/// <summary>/// Get the last error message that was set for the current thread.<br/>/// This allows the caller to copy the error string into a provided buffer, but<br/>/// otherwise operates exactly the same as SDL_GetError().<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetErrorMsg")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLGetErrorMsgS([NativeName(NativeNameType.Param, "errstr")] [NativeName(NativeNameType.Type, "char*")] byte* errstr, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "int")] int maxlen)
		{
			string ret = Utils.DecodeStringUTF8(SDLGetErrorMsgNative(errstr, maxlen));
			return ret;
		}

		/// <summary>
		/// Clear any previous error message for this thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ClearError")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "SDL_ClearError")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SDLClearErrorNative();

		/// <summary>/// Clear any previous error message for this thread.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_ClearError")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLClearError()
		{
			SDLClearErrorNative();
		}

		/// <summary>
		/// SDL_Error() unconditionally returns -1. <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_Error")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_Error")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLErrorNative([NativeName(NativeNameType.Param, "code")] [NativeName(NativeNameType.Type, "SDL_errorcode")] SDLErrorcode code);

		/// <summary>/// SDL_Error() unconditionally returns -1. <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_Error")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLError([NativeName(NativeNameType.Param, "code")] [NativeName(NativeNameType.Type, "SDL_errorcode")] SDLErrorcode code)
		{
			int ret = SDLErrorNative(code);
			return ret;
		}

		/// <summary>
		/// Create a new mutex.<br/>
		/// All newly-created mutexes begin in the _unlocked_ state.<br/>
		/// Calls to SDL_LockMutex() will not return while the mutex is locked by<br/>
		/// another thread. See SDL_TryLockMutex() to attempt to lock without blocking.<br/>
		/// SDL mutexes are reentrant.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateMutex")]
		[return: NativeName(NativeNameType.Type, "SDL_mutex*")]
		[LibraryImport(LibName, EntryPoint = "SDL_CreateMutex")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial SDLMutex* SDLCreateMutexNative();

		/// <summary>/// Create a new mutex.<br/>/// All newly-created mutexes begin in the _unlocked_ state.<br/>/// Calls to SDL_LockMutex() will not return while the mutex is locked by<br/>/// another thread. See SDL_TryLockMutex() to attempt to lock without blocking.<br/>/// SDL mutexes are reentrant.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_CreateMutex")]
		[return: NativeName(NativeNameType.Type, "SDL_mutex*")]
		public static SDLMutex* SDLCreateMutex()
		{
			SDLMutex* ret = SDLCreateMutexNative();
			return ret;
		}

		/// <summary>
		/// Lock the mutex.<br/>
		/// This will block until the mutex is available, which is to say it is in the<br/>
		/// unlocked state and the OS has chosen the caller as the next thread to lock<br/>
		/// it. Of all threads waiting to lock the mutex, only one may do so at a time.<br/>
		/// It is legal for the owning thread to lock an already-locked mutex. It must<br/>
		/// unlock it the same number of times before it is actually made available for<br/>
		/// other threads in the system (this is known as a "recursive mutex").<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockMutex")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_LockMutex")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLLockMutexNative([NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_mutex*")] SDLMutex* mutex);

		/// <summary>/// Lock the mutex.<br/>/// This will block until the mutex is available, which is to say it is in the<br/>/// unlocked state and the OS has chosen the caller as the next thread to lock<br/>/// it. Of all threads waiting to lock the mutex, only one may do so at a time.<br/>/// It is legal for the owning thread to lock an already-locked mutex. It must<br/>/// unlock it the same number of times before it is actually made available for<br/>/// other threads in the system (this is known as a "recursive mutex").<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_LockMutex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLockMutex([NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_mutex*")] SDLMutex* mutex)
		{
			int ret = SDLLockMutexNative(mutex);
			return ret;
		}

		/// <summary>
		/// Try to lock a mutex without blocking.<br/>
		/// This works just like SDL_LockMutex(), but if the mutex is not available,<br/>
		/// this function returns `SDL_MUTEX_TIMEOUT` immediately.<br/>
		/// This technique is useful if you need exclusive access to a resource but<br/>
		/// don't want to wait for it, and will return to it to try again later.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TryLockMutex")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_TryLockMutex")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLTryLockMutexNative([NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_mutex*")] SDLMutex* mutex);

		/// <summary>/// Try to lock a mutex without blocking.<br/>/// This works just like SDL_LockMutex(), but if the mutex is not available,<br/>/// this function returns `SDL_MUTEX_TIMEOUT` immediately.<br/>/// This technique is useful if you need exclusive access to a resource but<br/>/// don't want to wait for it, and will return to it to try again later.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_TryLockMutex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLTryLockMutex([NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_mutex*")] SDLMutex* mutex)
		{
			int ret = SDLTryLockMutexNative(mutex);
			return ret;
		}

		/// <summary>
		/// Unlock the mutex.<br/>
		/// It is legal for the owning thread to lock an already-locked mutex. It must<br/>
		/// unlock it the same number of times before it is actually made available for<br/>
		/// other threads in the system (this is known as a "recursive mutex").<br/>
		/// It is an error to unlock a mutex that has not been locked by the current<br/>
		/// thread, and doing so results in undefined behavior.<br/>
		/// It is also an error to unlock a mutex that isn't locked at all.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnlockMutex")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_UnlockMutex")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLUnlockMutexNative([NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_mutex*")] SDLMutex* mutex);

		/// <summary>/// Unlock the mutex.<br/>/// It is legal for the owning thread to lock an already-locked mutex. It must<br/>/// unlock it the same number of times before it is actually made available for<br/>/// other threads in the system (this is known as a "recursive mutex").<br/>/// It is an error to unlock a mutex that has not been locked by the current<br/>/// thread, and doing so results in undefined behavior.<br/>/// It is also an error to unlock a mutex that isn't locked at all.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_UnlockMutex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUnlockMutex([NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_mutex*")] SDLMutex* mutex)
		{
			int ret = SDLUnlockMutexNative(mutex);
			return ret;
		}

		/// <summary>
		/// Destroy a mutex created with SDL_CreateMutex().<br/>
		/// This function must be called on any mutex that is no longer needed. Failure<br/>
		/// to destroy a mutex will result in a system memory or resource leak. While<br/>
		/// it is safe to destroy a mutex that is _unlocked_, it is not safe to attempt<br/>
		/// to destroy a locked mutex, and may result in undefined behavior depending<br/>
		/// on the platform.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyMutex")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "SDL_DestroyMutex")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SDLDestroyMutexNative([NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_mutex*")] SDLMutex* mutex);

		/// <summary>/// Destroy a mutex created with SDL_CreateMutex().<br/>/// This function must be called on any mutex that is no longer needed. Failure<br/>/// to destroy a mutex will result in a system memory or resource leak. While<br/>/// it is safe to destroy a mutex that is _unlocked_, it is not safe to attempt<br/>/// to destroy a locked mutex, and may result in undefined behavior depending<br/>/// on the platform.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_DestroyMutex")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLDestroyMutex([NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_mutex*")] SDLMutex* mutex)
		{
			SDLDestroyMutexNative(mutex);
		}

		/// <summary>
		/// Create a semaphore.<br/>
		/// This function creates a new semaphore and initializes it with the value<br/>
		/// `initial_value`. Each wait operation on the semaphore will atomically<br/>
		/// decrement the semaphore value and potentially block if the semaphore value<br/>
		/// is 0. Each post operation will atomically increment the semaphore value and<br/>
		/// wake waiting threads and allow them to retry the wait operation.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateSemaphore")]
		[return: NativeName(NativeNameType.Type, "SDL_sem*")]
		[LibraryImport(LibName, EntryPoint = "SDL_CreateSemaphore")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial SDLSemaphore* SDLCreateSemaphoreNative([NativeName(NativeNameType.Param, "initial_value")] [NativeName(NativeNameType.Type, "Uint32")] uint initialValue);

		/// <summary>/// Create a semaphore.<br/>/// This function creates a new semaphore and initializes it with the value<br/>/// `initial_value`. Each wait operation on the semaphore will atomically<br/>/// decrement the semaphore value and potentially block if the semaphore value<br/>/// is 0. Each post operation will atomically increment the semaphore value and<br/>/// wake waiting threads and allow them to retry the wait operation.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_CreateSemaphore")]
		[return: NativeName(NativeNameType.Type, "SDL_sem*")]
		public static SDLSemaphore* SDLCreateSemaphore([NativeName(NativeNameType.Param, "initial_value")] [NativeName(NativeNameType.Type, "Uint32")] uint initialValue)
		{
			SDLSemaphore* ret = SDLCreateSemaphoreNative(initialValue);
			return ret;
		}

		/// <summary>
		/// Destroy a semaphore.<br/>
		/// It is not safe to destroy a semaphore if there are threads currently<br/>
		/// waiting on it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroySemaphore")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "SDL_DestroySemaphore")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SDLDestroySemaphoreNative([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_sem*")] SDLSemaphore* sem);

		/// <summary>/// Destroy a semaphore.<br/>/// It is not safe to destroy a semaphore if there are threads currently<br/>/// waiting on it.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_DestroySemaphore")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLDestroySemaphore([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_sem*")] SDLSemaphore* sem)
		{
			SDLDestroySemaphoreNative(sem);
		}

		/// <summary>
		/// Wait until a semaphore has a positive value and then decrements it.<br/>
		/// This function suspends the calling thread until either the semaphore<br/>
		/// pointed to by `sem` has a positive value or the call is interrupted by a<br/>
		/// signal or error. If the call is successful it will atomically decrement the<br/>
		/// semaphore value.<br/>
		/// This function is the equivalent of calling SDL_SemWaitTimeout() with a time<br/>
		/// length of `SDL_MUTEX_MAXWAIT`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SemWait")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_SemWait")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLSemWaitNative([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_sem*")] SDLSemaphore* sem);

		/// <summary>/// Wait until a semaphore has a positive value and then decrements it.<br/>/// This function suspends the calling thread until either the semaphore<br/>/// pointed to by `sem` has a positive value or the call is interrupted by a<br/>/// signal or error. If the call is successful it will atomically decrement the<br/>/// semaphore value.<br/>/// This function is the equivalent of calling SDL_SemWaitTimeout() with a time<br/>/// length of `SDL_MUTEX_MAXWAIT`.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_SemWait")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSemWait([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_sem*")] SDLSemaphore* sem)
		{
			int ret = SDLSemWaitNative(sem);
			return ret;
		}

		/// <summary>
		/// See if a semaphore has a positive value and decrement it if it does.<br/>
		/// This function checks to see if the semaphore pointed to by `sem` has a<br/>
		/// positive value and atomically decrements the semaphore value if it does. If<br/>
		/// the semaphore doesn't have a positive value, the function immediately<br/>
		/// returns SDL_MUTEX_TIMEDOUT.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SemTryWait")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_SemTryWait")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLSemTryWaitNative([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_sem*")] SDLSemaphore* sem);

		/// <summary>/// See if a semaphore has a positive value and decrement it if it does.<br/>/// This function checks to see if the semaphore pointed to by `sem` has a<br/>/// positive value and atomically decrements the semaphore value if it does. If<br/>/// the semaphore doesn't have a positive value, the function immediately<br/>/// returns SDL_MUTEX_TIMEDOUT.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_SemTryWait")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSemTryWait([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_sem*")] SDLSemaphore* sem)
		{
			int ret = SDLSemTryWaitNative(sem);
			return ret;
		}

		/// <summary>
		/// Wait until a semaphore has a positive value and then decrements it.<br/>
		/// This function suspends the calling thread until either the semaphore<br/>
		/// pointed to by `sem` has a positive value, the call is interrupted by a<br/>
		/// signal or error, or the specified time has elapsed. If the call is<br/>
		/// successful it will atomically decrement the semaphore value.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SemWaitTimeout")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_SemWaitTimeout")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLSemWaitTimeoutNative([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_sem*")] SDLSemaphore* sem, [NativeName(NativeNameType.Param, "timeout")] [NativeName(NativeNameType.Type, "Uint32")] uint timeout);

		/// <summary>/// Wait until a semaphore has a positive value and then decrements it.<br/>/// This function suspends the calling thread until either the semaphore<br/>/// pointed to by `sem` has a positive value, the call is interrupted by a<br/>/// signal or error, or the specified time has elapsed. If the call is<br/>/// successful it will atomically decrement the semaphore value.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_SemWaitTimeout")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSemWaitTimeout([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_sem*")] SDLSemaphore* sem, [NativeName(NativeNameType.Param, "timeout")] [NativeName(NativeNameType.Type, "Uint32")] uint timeout)
		{
			int ret = SDLSemWaitTimeoutNative(sem, timeout);
			return ret;
		}

		/// <summary>
		/// Atomically increment a semaphore's value and wake waiting threads.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SemPost")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_SemPost")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLSemPostNative([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_sem*")] SDLSemaphore* sem);

		/// <summary>/// Atomically increment a semaphore's value and wake waiting threads.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_SemPost")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSemPost([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_sem*")] SDLSemaphore* sem)
		{
			int ret = SDLSemPostNative(sem);
			return ret;
		}

		/// <summary>
		/// Get the current value of a semaphore.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SemValue")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		[LibraryImport(LibName, EntryPoint = "SDL_SemValue")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial uint SDLSemValueNative([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_sem*")] SDLSemaphore* sem);

		/// <summary>/// Get the current value of a semaphore.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_SemValue")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLSemValue([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_sem*")] SDLSemaphore* sem)
		{
			uint ret = SDLSemValueNative(sem);
			return ret;
		}

		/// <summary>
		/// Create a condition variable.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateCond")]
		[return: NativeName(NativeNameType.Type, "SDL_cond*")]
		[LibraryImport(LibName, EntryPoint = "SDL_CreateCond")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial SDLCond* SDLCreateCondNative();

		/// <summary>/// Create a condition variable.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_CreateCond")]
		[return: NativeName(NativeNameType.Type, "SDL_cond*")]
		public static SDLCond* SDLCreateCond()
		{
			SDLCond* ret = SDLCreateCondNative();
			return ret;
		}

		/// <summary>
		/// Destroy a condition variable.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyCond")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "SDL_DestroyCond")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SDLDestroyCondNative([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_cond*")] SDLCond* cond);

		/// <summary>/// Destroy a condition variable.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_DestroyCond")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLDestroyCond([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_cond*")] SDLCond* cond)
		{
			SDLDestroyCondNative(cond);
		}

		/// <summary>
		/// Restart one of the threads that are waiting on the condition variable.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CondSignal")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_CondSignal")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLCondSignalNative([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_cond*")] SDLCond* cond);

		/// <summary>/// Restart one of the threads that are waiting on the condition variable.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_CondSignal")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLCondSignal([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_cond*")] SDLCond* cond)
		{
			int ret = SDLCondSignalNative(cond);
			return ret;
		}

		/// <summary>
		/// Restart all threads that are waiting on the condition variable.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CondBroadcast")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_CondBroadcast")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLCondBroadcastNative([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_cond*")] SDLCond* cond);

		/// <summary>/// Restart all threads that are waiting on the condition variable.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_CondBroadcast")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLCondBroadcast([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_cond*")] SDLCond* cond)
		{
			int ret = SDLCondBroadcastNative(cond);
			return ret;
		}

		/// <summary>
		/// Wait until a condition variable is signaled.<br/>
		/// This function unlocks the specified `mutex` and waits for another thread to<br/>
		/// call SDL_CondSignal() or SDL_CondBroadcast() on the condition variable<br/>
		/// `cond`. Once the condition variable is signaled, the mutex is re-locked and<br/>
		/// the function returns.<br/>
		/// The mutex must be locked before calling this function.<br/>
		/// This function is the equivalent of calling SDL_CondWaitTimeout() with a<br/>
		/// time length of `SDL_MUTEX_MAXWAIT`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CondWait")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_CondWait")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLCondWaitNative([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_cond*")] SDLCond* cond, [NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_mutex*")] SDLMutex* mutex);

		/// <summary>/// Wait until a condition variable is signaled.<br/>/// This function unlocks the specified `mutex` and waits for another thread to<br/>/// call SDL_CondSignal() or SDL_CondBroadcast() on the condition variable<br/>/// `cond`. Once the condition variable is signaled, the mutex is re-locked and<br/>/// the function returns.<br/>/// The mutex must be locked before calling this function.<br/>/// This function is the equivalent of calling SDL_CondWaitTimeout() with a<br/>/// time length of `SDL_MUTEX_MAXWAIT`.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_CondWait")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLCondWait([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_cond*")] SDLCond* cond, [NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_mutex*")] SDLMutex* mutex)
		{
			int ret = SDLCondWaitNative(cond, mutex);
			return ret;
		}

		/// <summary>/// Wait until a condition variable is signaled.<br/>/// This function unlocks the specified `mutex` and waits for another thread to<br/>/// call SDL_CondSignal() or SDL_CondBroadcast() on the condition variable<br/>/// `cond`. Once the condition variable is signaled, the mutex is re-locked and<br/>/// the function returns.<br/>/// The mutex must be locked before calling this function.<br/>/// This function is the equivalent of calling SDL_CondWaitTimeout() with a<br/>/// time length of `SDL_MUTEX_MAXWAIT`.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_CondWait")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLCondWait([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_cond*")] SDLCond* cond, [NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_mutex*")] ref SDLMutex mutex)
		{
			fixed (SDLMutex* pmutex = &mutex)
			{
				int ret = SDLCondWaitNative(cond, (SDLMutex*)pmutex);
				return ret;
			}
		}

		/// <summary>
		/// Wait until a condition variable is signaled or a certain time has passed.<br/>
		/// This function unlocks the specified `mutex` and waits for another thread to<br/>
		/// call SDL_CondSignal() or SDL_CondBroadcast() on the condition variable<br/>
		/// `cond`, or for the specified time to elapse. Once the condition variable is<br/>
		/// signaled or the time elapsed, the mutex is re-locked and the function<br/>
		/// returns.<br/>
		/// The mutex must be locked before calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CondWaitTimeout")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_CondWaitTimeout")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLCondWaitTimeoutNative([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_cond*")] SDLCond* cond, [NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_mutex*")] SDLMutex* mutex, [NativeName(NativeNameType.Param, "ms")] [NativeName(NativeNameType.Type, "Uint32")] uint ms);

		/// <summary>/// Wait until a condition variable is signaled or a certain time has passed.<br/>/// This function unlocks the specified `mutex` and waits for another thread to<br/>/// call SDL_CondSignal() or SDL_CondBroadcast() on the condition variable<br/>/// `cond`, or for the specified time to elapse. Once the condition variable is<br/>/// signaled or the time elapsed, the mutex is re-locked and the function<br/>/// returns.<br/>/// The mutex must be locked before calling this function.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_CondWaitTimeout")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLCondWaitTimeout([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_cond*")] SDLCond* cond, [NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_mutex*")] SDLMutex* mutex, [NativeName(NativeNameType.Param, "ms")] [NativeName(NativeNameType.Type, "Uint32")] uint ms)
		{
			int ret = SDLCondWaitTimeoutNative(cond, mutex, ms);
			return ret;
		}

		/// <summary>/// Wait until a condition variable is signaled or a certain time has passed.<br/>/// This function unlocks the specified `mutex` and waits for another thread to<br/>/// call SDL_CondSignal() or SDL_CondBroadcast() on the condition variable<br/>/// `cond`, or for the specified time to elapse. Once the condition variable is<br/>/// signaled or the time elapsed, the mutex is re-locked and the function<br/>/// returns.<br/>/// The mutex must be locked before calling this function.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_CondWaitTimeout")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLCondWaitTimeout([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_cond*")] SDLCond* cond, [NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_mutex*")] ref SDLMutex mutex, [NativeName(NativeNameType.Param, "ms")] [NativeName(NativeNameType.Type, "Uint32")] uint ms)
		{
			fixed (SDLMutex* pmutex = &mutex)
			{
				int ret = SDLCondWaitTimeoutNative(cond, (SDLMutex*)pmutex, ms);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_CreateThread")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread*")]
		[LibraryImport(LibName, EntryPoint = "SDL_CreateThread")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial SDLThread* SDL_CreateThreadNative([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] SdlThreadfunction fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void*")] void* data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "pfnSDL_CurrentBeginThread")] PfnsdlCurrentbeginthread pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "pfnSDL_CurrentEndThread")] PfnsdlCurrentendthread pfnEndThread);

		[NativeName(NativeNameType.Func, "SDL_CreateThread")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread*")]
		public static SDLThread* SDL_CreateThread([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] SdlThreadfunction fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void*")] void* data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "pfnSDL_CurrentBeginThread")] PfnsdlCurrentbeginthread pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "pfnSDL_CurrentEndThread")] PfnsdlCurrentendthread pfnEndThread)
		{
			SDLThread* ret = SDL_CreateThreadNative(fn, name, data, pfnBeginThread, pfnEndThread);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_CreateThread")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread*")]
		public static SDLThread* SDL_CreateThread([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] SdlThreadfunction fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] ref byte name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void*")] void* data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "pfnSDL_CurrentBeginThread")] PfnsdlCurrentbeginthread pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "pfnSDL_CurrentEndThread")] PfnsdlCurrentendthread pfnEndThread)
		{
			fixed (byte* pname = &name)
			{
				SDLThread* ret = SDL_CreateThreadNative(fn, (byte*)pname, data, pfnBeginThread, pfnEndThread);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_CreateThread")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread*")]
		public static SDLThread* SDL_CreateThread([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] SdlThreadfunction fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] string name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void*")] void* data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "pfnSDL_CurrentBeginThread")] PfnsdlCurrentbeginthread pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "pfnSDL_CurrentEndThread")] PfnsdlCurrentendthread pfnEndThread)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLThread* ret = SDL_CreateThreadNative(fn, pStr0, data, pfnBeginThread, pfnEndThread);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_CreateThreadWithStackSize")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread*")]
		[LibraryImport(LibName, EntryPoint = "SDL_CreateThreadWithStackSize")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial SDLThread* SDL_CreateThreadWithStackSizeNative([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] SdlThreadfunction fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name, [NativeName(NativeNameType.Param, "stacksize")] [NativeName(NativeNameType.Type, "const size_t")] ulong stacksize, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void*")] void* data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "pfnSDL_CurrentBeginThread")] PfnsdlCurrentbeginthread pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "pfnSDL_CurrentEndThread")] PfnsdlCurrentendthread pfnEndThread);

		[NativeName(NativeNameType.Func, "SDL_CreateThreadWithStackSize")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread*")]
		public static SDLThread* SDL_CreateThreadWithStackSize([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] SdlThreadfunction fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name, [NativeName(NativeNameType.Param, "stacksize")] [NativeName(NativeNameType.Type, "const size_t")] ulong stacksize, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void*")] void* data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "pfnSDL_CurrentBeginThread")] PfnsdlCurrentbeginthread pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "pfnSDL_CurrentEndThread")] PfnsdlCurrentendthread pfnEndThread)
		{
			SDLThread* ret = SDL_CreateThreadWithStackSizeNative(fn, name, stacksize, data, pfnBeginThread, pfnEndThread);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_CreateThreadWithStackSize")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread*")]
		public static SDLThread* SDL_CreateThreadWithStackSize([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] SdlThreadfunction fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] ref byte name, [NativeName(NativeNameType.Param, "stacksize")] [NativeName(NativeNameType.Type, "const size_t")] ulong stacksize, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void*")] void* data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "pfnSDL_CurrentBeginThread")] PfnsdlCurrentbeginthread pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "pfnSDL_CurrentEndThread")] PfnsdlCurrentendthread pfnEndThread)
		{
			fixed (byte* pname = &name)
			{
				SDLThread* ret = SDL_CreateThreadWithStackSizeNative(fn, (byte*)pname, stacksize, data, pfnBeginThread, pfnEndThread);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_CreateThreadWithStackSize")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread*")]
		public static SDLThread* SDL_CreateThreadWithStackSize([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] SdlThreadfunction fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] string name, [NativeName(NativeNameType.Param, "stacksize")] [NativeName(NativeNameType.Type, "const size_t")] ulong stacksize, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void*")] void* data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "pfnSDL_CurrentBeginThread")] PfnsdlCurrentbeginthread pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "pfnSDL_CurrentEndThread")] PfnsdlCurrentendthread pfnEndThread)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLThread* ret = SDL_CreateThreadWithStackSizeNative(fn, pStr0, stacksize, data, pfnBeginThread, pfnEndThread);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_CreateThreadWithStackSize")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread*")]
		public static SDLThread* SDL_CreateThreadWithStackSize([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] SdlThreadfunction fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name, [NativeName(NativeNameType.Param, "stacksize")] [NativeName(NativeNameType.Type, "const size_t")] nuint stacksize, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void*")] void* data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "pfnSDL_CurrentBeginThread")] PfnsdlCurrentbeginthread pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "pfnSDL_CurrentEndThread")] PfnsdlCurrentendthread pfnEndThread)
		{
			SDLThread* ret = SDL_CreateThreadWithStackSizeNative(fn, name, stacksize, data, pfnBeginThread, pfnEndThread);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_CreateThreadWithStackSize")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread*")]
		public static SDLThread* SDL_CreateThreadWithStackSize([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] SdlThreadfunction fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] ref byte name, [NativeName(NativeNameType.Param, "stacksize")] [NativeName(NativeNameType.Type, "const size_t")] nuint stacksize, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void*")] void* data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "pfnSDL_CurrentBeginThread")] PfnsdlCurrentbeginthread pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "pfnSDL_CurrentEndThread")] PfnsdlCurrentendthread pfnEndThread)
		{
			fixed (byte* pname = &name)
			{
				SDLThread* ret = SDL_CreateThreadWithStackSizeNative(fn, (byte*)pname, stacksize, data, pfnBeginThread, pfnEndThread);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_CreateThreadWithStackSize")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread*")]
		public static SDLThread* SDL_CreateThreadWithStackSize([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] SdlThreadfunction fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] string name, [NativeName(NativeNameType.Param, "stacksize")] [NativeName(NativeNameType.Type, "const size_t")] nuint stacksize, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void*")] void* data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "pfnSDL_CurrentBeginThread")] PfnsdlCurrentbeginthread pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "pfnSDL_CurrentEndThread")] PfnsdlCurrentendthread pfnEndThread)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLThread* ret = SDL_CreateThreadWithStackSizeNative(fn, pStr0, stacksize, data, pfnBeginThread, pfnEndThread);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get the thread name as it was specified in SDL_CreateThread().<br/>
		/// This is internal memory, not to be freed by the caller, and remains valid<br/>
		/// until the specified thread is cleaned up by SDL_WaitThread().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetThreadName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		[LibraryImport(LibName, EntryPoint = "SDL_GetThreadName")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte* SDLGetThreadNameNative([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread*")] SDLThread* thread);

		/// <summary>/// Get the thread name as it was specified in SDL_CreateThread().<br/>/// This is internal memory, not to be freed by the caller, and remains valid<br/>/// until the specified thread is cleaned up by SDL_WaitThread().<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetThreadName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGetThreadName([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread*")] SDLThread* thread)
		{
			byte* ret = SDLGetThreadNameNative(thread);
			return ret;
		}

		/// <summary>/// Get the thread name as it was specified in SDL_CreateThread().<br/>/// This is internal memory, not to be freed by the caller, and remains valid<br/>/// until the specified thread is cleaned up by SDL_WaitThread().<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetThreadName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGetThreadNameS([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread*")] SDLThread* thread)
		{
			string ret = Utils.DecodeStringUTF8(SDLGetThreadNameNative(thread));
			return ret;
		}

		/// <summary>
		/// Get the thread identifier for the current thread.<br/>
		/// This thread identifier is as reported by the underlying operating system.<br/>
		/// If SDL is running on a platform that does not support threads the return<br/>
		/// value will always be zero.<br/>
		/// This function also returns a valid thread ID when called from the main<br/>
		/// thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ThreadID")]
		[return: NativeName(NativeNameType.Type, "SDL_threadID")]
		[LibraryImport(LibName, EntryPoint = "SDL_ThreadID")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial uint SDLThreadIDNative();

		/// <summary>/// Get the thread identifier for the current thread.<br/>/// This thread identifier is as reported by the underlying operating system.<br/>/// If SDL is running on a platform that does not support threads the return<br/>/// value will always be zero.<br/>/// This function also returns a valid thread ID when called from the main<br/>/// thread.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_ThreadID")]
		[return: NativeName(NativeNameType.Type, "SDL_threadID")]
		public static uint SDLThreadID()
		{
			uint ret = SDLThreadIDNative();
			return ret;
		}

		/// <summary>
		/// Get the thread identifier for the specified thread.<br/>
		/// This thread identifier is as reported by the underlying operating system.<br/>
		/// If SDL is running on a platform that does not support threads the return<br/>
		/// value will always be zero.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetThreadID")]
		[return: NativeName(NativeNameType.Type, "SDL_threadID")]
		[LibraryImport(LibName, EntryPoint = "SDL_GetThreadID")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial uint SDLGetThreadIDNative([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread*")] SDLThread* thread);

		/// <summary>/// Get the thread identifier for the specified thread.<br/>/// This thread identifier is as reported by the underlying operating system.<br/>/// If SDL is running on a platform that does not support threads the return<br/>/// value will always be zero.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetThreadID")]
		[return: NativeName(NativeNameType.Type, "SDL_threadID")]
		public static uint SDLGetThreadID([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread*")] SDLThread* thread)
		{
			uint ret = SDLGetThreadIDNative(thread);
			return ret;
		}

		/// <summary>
		/// Set the priority for the current thread.<br/>
		/// Note that some platforms will not let you alter the priority (or at least,<br/>
		/// promote the thread to a higher priority) at all, and some require you to be<br/>
		/// an administrator account. Be prepared for this to fail.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetThreadPriority")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_SetThreadPriority")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLSetThreadPriorityNative([NativeName(NativeNameType.Param, "priority")] [NativeName(NativeNameType.Type, "SDL_ThreadPriority")] SDLThreadPriority priority);

		/// <summary>/// Set the priority for the current thread.<br/>/// Note that some platforms will not let you alter the priority (or at least,<br/>/// promote the thread to a higher priority) at all, and some require you to be<br/>/// an administrator account. Be prepared for this to fail.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetThreadPriority")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetThreadPriority([NativeName(NativeNameType.Param, "priority")] [NativeName(NativeNameType.Type, "SDL_ThreadPriority")] SDLThreadPriority priority)
		{
			int ret = SDLSetThreadPriorityNative(priority);
			return ret;
		}

		/// <summary>
		/// Wait for a thread to finish.<br/>
		/// Threads that haven't been detached will remain (as a "zombie") until this<br/>
		/// function cleans them up. Not doing so is a resource leak.<br/>
		/// Once a thread has been cleaned up through this function, the SDL_Thread<br/>
		/// that references it becomes invalid and should not be referenced again. As<br/>
		/// such, only one thread may call SDL_WaitThread() on another.<br/>
		/// The return code for the thread function is placed in the area pointed to by<br/>
		/// `status`, if `status` is not NULL.<br/>
		/// You may not wait on a thread that has been used in a call to<br/>
		/// SDL_DetachThread(). Use either that function or this one, but not both, or<br/>
		/// behavior is undefined.<br/>
		/// It is safe to pass a NULL thread to this function; it is a no-op.<br/>
		/// Note that the thread pointer is freed by this function and is not valid<br/>
		/// afterward.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitThread")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "SDL_WaitThread")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SDLWaitThreadNative([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread*")] SDLThread* thread, [NativeName(NativeNameType.Param, "status")] [NativeName(NativeNameType.Type, "int*")] int* status);

		/// <summary>/// Wait for a thread to finish.<br/>/// Threads that haven't been detached will remain (as a "zombie") until this<br/>/// function cleans them up. Not doing so is a resource leak.<br/>/// Once a thread has been cleaned up through this function, the SDL_Thread<br/>/// that references it becomes invalid and should not be referenced again. As<br/>/// such, only one thread may call SDL_WaitThread() on another.<br/>/// The return code for the thread function is placed in the area pointed to by<br/>/// `status`, if `status` is not NULL.<br/>/// You may not wait on a thread that has been used in a call to<br/>/// SDL_DetachThread(). Use either that function or this one, but not both, or<br/>/// behavior is undefined.<br/>/// It is safe to pass a NULL thread to this function; it is a no-op.<br/>/// Note that the thread pointer is freed by this function and is not valid<br/>/// afterward.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_WaitThread")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLWaitThread([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread*")] SDLThread* thread, [NativeName(NativeNameType.Param, "status")] [NativeName(NativeNameType.Type, "int*")] int* status)
		{
			SDLWaitThreadNative(thread, status);
		}

		/// <summary>/// Wait for a thread to finish.<br/>/// Threads that haven't been detached will remain (as a "zombie") until this<br/>/// function cleans them up. Not doing so is a resource leak.<br/>/// Once a thread has been cleaned up through this function, the SDL_Thread<br/>/// that references it becomes invalid and should not be referenced again. As<br/>/// such, only one thread may call SDL_WaitThread() on another.<br/>/// The return code for the thread function is placed in the area pointed to by<br/>/// `status`, if `status` is not NULL.<br/>/// You may not wait on a thread that has been used in a call to<br/>/// SDL_DetachThread(). Use either that function or this one, but not both, or<br/>/// behavior is undefined.<br/>/// It is safe to pass a NULL thread to this function; it is a no-op.<br/>/// Note that the thread pointer is freed by this function and is not valid<br/>/// afterward.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_WaitThread")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLWaitThread([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread*")] SDLThread* thread, [NativeName(NativeNameType.Param, "status")] [NativeName(NativeNameType.Type, "int*")] ref int status)
		{
			fixed (int* pstatus = &status)
			{
				SDLWaitThreadNative(thread, (int*)pstatus);
			}
		}

		/// <summary>
		/// Let a thread clean up on exit without intervention.<br/>
		/// A thread may be "detached" to signify that it should not remain until<br/>
		/// another thread has called SDL_WaitThread() on it. Detaching a thread is<br/>
		/// useful for long-running threads that nothing needs to synchronize with or<br/>
		/// further manage. When a detached thread is done, it simply goes away.<br/>
		/// There is no way to recover the return code of a detached thread. If you<br/>
		/// need this, don't detach the thread and instead use SDL_WaitThread().<br/>
		/// Once a thread is detached, you should usually assume the SDL_Thread isn't<br/>
		/// safe to reference again, as it will become invalid immediately upon the<br/>
		/// detached thread's exit, instead of remaining until someone has called<br/>
		/// SDL_WaitThread() to finally clean it up. As such, don't detach the same<br/>
		/// thread more than once.<br/>
		/// If a thread has already exited when passed to SDL_DetachThread(), it will<br/>
		/// stop waiting for a call to SDL_WaitThread() and clean up immediately. It is<br/>
		/// not safe to detach a thread that might be used with SDL_WaitThread().<br/>
		/// You may not call SDL_WaitThread() on a thread that has been detached. Use<br/>
		/// either that function or this one, but not both, or behavior is undefined.<br/>
		/// It is safe to pass NULL to this function; it is a no-op.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DetachThread")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "SDL_DetachThread")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SDLDetachThreadNative([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread*")] SDLThread* thread);

		/// <summary>/// Let a thread clean up on exit without intervention.<br/>/// A thread may be "detached" to signify that it should not remain until<br/>/// another thread has called SDL_WaitThread() on it. Detaching a thread is<br/>/// useful for long-running threads that nothing needs to synchronize with or<br/>/// further manage. When a detached thread is done, it simply goes away.<br/>/// There is no way to recover the return code of a detached thread. If you<br/>/// need this, don't detach the thread and instead use SDL_WaitThread().<br/>/// Once a thread is detached, you should usually assume the SDL_Thread isn't<br/>/// safe to reference again, as it will become invalid immediately upon the<br/>/// detached thread's exit, instead of remaining until someone has called<br/>/// SDL_WaitThread() to finally clean it up. As such, don't detach the same<br/>/// thread more than once.<br/>/// If a thread has already exited when passed to SDL_DetachThread(), it will<br/>/// stop waiting for a call to SDL_WaitThread() and clean up immediately. It is<br/>/// not safe to detach a thread that might be used with SDL_WaitThread().<br/>/// You may not call SDL_WaitThread() on a thread that has been detached. Use<br/>/// either that function or this one, but not both, or behavior is undefined.<br/>/// It is safe to pass NULL to this function; it is a no-op.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_DetachThread")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLDetachThread([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread*")] SDLThread* thread)
		{
			SDLDetachThreadNative(thread);
		}

		/// <summary>
		/// Create a piece of thread-local storage.<br/>
		/// This creates an identifier that is globally visible to all threads but<br/>
		/// refers to data that is thread-specific.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TLSCreate")]
		[return: NativeName(NativeNameType.Type, "SDL_TLSID")]
		[LibraryImport(LibName, EntryPoint = "SDL_TLSCreate")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial uint SDLTLSCreateNative();

		/// <summary>/// Create a piece of thread-local storage.<br/>/// This creates an identifier that is globally visible to all threads but<br/>/// refers to data that is thread-specific.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_TLSCreate")]
		[return: NativeName(NativeNameType.Type, "SDL_TLSID")]
		public static uint SDLTLSCreate()
		{
			uint ret = SDLTLSCreateNative();
			return ret;
		}

		/// <summary>
		/// Get the current thread's value associated with a thread local storage ID.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TLSGet")]
		[return: NativeName(NativeNameType.Type, "void*")]
		[LibraryImport(LibName, EntryPoint = "SDL_TLSGet")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void* SDLTLSGetNative([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "SDL_TLSID")] uint id);

		/// <summary>/// Get the current thread's value associated with a thread local storage ID.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_TLSGet")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLTLSGet([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "SDL_TLSID")] uint id)
		{
			void* ret = SDLTLSGetNative(id);
			return ret;
		}

		/// <summary>
		/// Set the current thread's value associated with a thread local storage ID.<br/>
		/// The function prototype for `destructor` is:<br/>
		/// ```c<br/>
		/// void destructor(void *value)<br/>
		/// ```<br/>
		/// where its parameter `value` is what was passed as `value` to SDL_TLSSet().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TLSSet")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_TLSSet")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLTLSSetNative([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "SDL_TLSID")] uint id, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const void*")] void* value, [NativeName(NativeNameType.Param, "destructor")] [NativeName(NativeNameType.Type, "void (*)(SDL_TLSID id, const void* value, void (*)(void*)* destructor)*")] delegate*<uint, void*, delegate*<void*, void>, void> destructor);

		/// <summary>/// Set the current thread's value associated with a thread local storage ID.<br/>/// The function prototype for `destructor` is:<br/>/// ```c<br/>/// void destructor(void *value)<br/>/// ```<br/>/// where its parameter `value` is what was passed as `value` to SDL_TLSSet().<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_TLSSet")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLTLSSet([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "SDL_TLSID")] uint id, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const void*")] void* value, [NativeName(NativeNameType.Param, "destructor")] [NativeName(NativeNameType.Type, "void (*)(SDL_TLSID id, const void* value, void (*)(void*)* destructor)*")] delegate*<uint, void*, delegate*<void*, void>, void> destructor)
		{
			int ret = SDLTLSSetNative(id, value, destructor);
			return ret;
		}

		/// <summary>
		/// Cleanup all TLS data for this thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TLSCleanup")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "SDL_TLSCleanup")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SDLTLSCleanupNative();

		/// <summary>/// Cleanup all TLS data for this thread.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_TLSCleanup")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLTLSCleanup()
		{
			SDLTLSCleanupNative();
		}

		/// <summary>
		/// Use this function to create a new SDL_RWops structure for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string is treated roughly the same as in a call to the C<br/>
		/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>
		/// scenes.<br/>
		/// Available `mode` strings:<br/>
		/// - "r": Open a file for reading. The file must exist.<br/>
		/// - "w": Create an empty file for writing. If a file with the same name<br/>
		/// already exists its content is erased and the file is treated as a new<br/>
		/// empty file.<br/>
		/// - "a": Append to a file. Writing operations append data at the end of the<br/>
		/// file. The file is created if it does not exist.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// - "a+": Open a file for reading and appending. All writing operations are<br/>
		/// performed at the end of the file, protecting the previous content to be<br/>
		/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>
		/// anywhere in the file for reading, but writing operations will move it<br/>
		/// back to the end of file. The file is created if it does not exist.<br/>
		/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>
		/// be included in the `mode` string. This additional "b" character can either<br/>
		/// be appended at the end of the string (thus making the following compound<br/>
		/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>
		/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>
		/// Additional characters may follow the sequence, although they should have no<br/>
		/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>
		/// a text file.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// As a fallback, SDL_RWFromFile() will transparently open a matching filename<br/>
		/// in an Android app's `assets`.<br/>
		/// Closing the SDL_RWops will close the file handle SDL is holding internally.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RWFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_RWops*")]
		[LibraryImport(LibName, EntryPoint = "SDL_RWFromFile")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial SDLRWops* SDLRWFromFileNative([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] byte* file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "const char*")] byte* mode);

		/// <summary>/// Use this function to create a new SDL_RWops structure for reading from<br/>/// and/or writing to a named file.<br/>/// The `mode` string is treated roughly the same as in a call to the C<br/>/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>/// scenes.<br/>/// Available `mode` strings:<br/>/// - "r": Open a file for reading. The file must exist.<br/>/// - "w": Create an empty file for writing. If a file with the same name<br/>/// already exists its content is erased and the file is treated as a new<br/>/// empty file.<br/>/// - "a": Append to a file. Writing operations append data at the end of the<br/>/// file. The file is created if it does not exist.<br/>/// - "r+": Open a file for update both reading and writing. The file must<br/>/// exist.<br/>/// - "w+": Create an empty file for both reading and writing. If a file with<br/>/// the same name already exists its content is erased and the file is<br/>/// treated as a new empty file.<br/>/// - "a+": Open a file for reading and appending. All writing operations are<br/>/// performed at the end of the file, protecting the previous content to be<br/>/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>/// anywhere in the file for reading, but writing operations will move it<br/>/// back to the end of file. The file is created if it does not exist.<br/>/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>/// be included in the `mode` string. This additional "b" character can either<br/>/// be appended at the end of the string (thus making the following compound<br/>/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>/// Additional characters may follow the sequence, although they should have no<br/>/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>/// a text file.<br/>/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>/// format, regardless of the underlying operating system.<br/>/// As a fallback, SDL_RWFromFile() will transparently open a matching filename<br/>/// in an Android app's `assets`.<br/>/// Closing the SDL_RWops will close the file handle SDL is holding internally.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_RWops*")]
		public static SDLRWops* SDLRWFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] byte* file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "const char*")] byte* mode)
		{
			SDLRWops* ret = SDLRWFromFileNative(file, mode);
			return ret;
		}

		/// <summary>/// Use this function to create a new SDL_RWops structure for reading from<br/>/// and/or writing to a named file.<br/>/// The `mode` string is treated roughly the same as in a call to the C<br/>/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>/// scenes.<br/>/// Available `mode` strings:<br/>/// - "r": Open a file for reading. The file must exist.<br/>/// - "w": Create an empty file for writing. If a file with the same name<br/>/// already exists its content is erased and the file is treated as a new<br/>/// empty file.<br/>/// - "a": Append to a file. Writing operations append data at the end of the<br/>/// file. The file is created if it does not exist.<br/>/// - "r+": Open a file for update both reading and writing. The file must<br/>/// exist.<br/>/// - "w+": Create an empty file for both reading and writing. If a file with<br/>/// the same name already exists its content is erased and the file is<br/>/// treated as a new empty file.<br/>/// - "a+": Open a file for reading and appending. All writing operations are<br/>/// performed at the end of the file, protecting the previous content to be<br/>/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>/// anywhere in the file for reading, but writing operations will move it<br/>/// back to the end of file. The file is created if it does not exist.<br/>/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>/// be included in the `mode` string. This additional "b" character can either<br/>/// be appended at the end of the string (thus making the following compound<br/>/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>/// Additional characters may follow the sequence, although they should have no<br/>/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>/// a text file.<br/>/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>/// format, regardless of the underlying operating system.<br/>/// As a fallback, SDL_RWFromFile() will transparently open a matching filename<br/>/// in an Android app's `assets`.<br/>/// Closing the SDL_RWops will close the file handle SDL is holding internally.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_RWops*")]
		public static SDLRWops* SDLRWFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] byte* file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "const char*")] ref byte mode)
		{
			fixed (byte* pmode = &mode)
			{
				SDLRWops* ret = SDLRWFromFileNative(file, (byte*)pmode);
				return ret;
			}
		}

		/// <summary>/// Use this function to create a new SDL_RWops structure for reading from<br/>/// and/or writing to a named file.<br/>/// The `mode` string is treated roughly the same as in a call to the C<br/>/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>/// scenes.<br/>/// Available `mode` strings:<br/>/// - "r": Open a file for reading. The file must exist.<br/>/// - "w": Create an empty file for writing. If a file with the same name<br/>/// already exists its content is erased and the file is treated as a new<br/>/// empty file.<br/>/// - "a": Append to a file. Writing operations append data at the end of the<br/>/// file. The file is created if it does not exist.<br/>/// - "r+": Open a file for update both reading and writing. The file must<br/>/// exist.<br/>/// - "w+": Create an empty file for both reading and writing. If a file with<br/>/// the same name already exists its content is erased and the file is<br/>/// treated as a new empty file.<br/>/// - "a+": Open a file for reading and appending. All writing operations are<br/>/// performed at the end of the file, protecting the previous content to be<br/>/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>/// anywhere in the file for reading, but writing operations will move it<br/>/// back to the end of file. The file is created if it does not exist.<br/>/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>/// be included in the `mode` string. This additional "b" character can either<br/>/// be appended at the end of the string (thus making the following compound<br/>/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>/// Additional characters may follow the sequence, although they should have no<br/>/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>/// a text file.<br/>/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>/// format, regardless of the underlying operating system.<br/>/// As a fallback, SDL_RWFromFile() will transparently open a matching filename<br/>/// in an Android app's `assets`.<br/>/// Closing the SDL_RWops will close the file handle SDL is holding internally.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_RWops*")]
		public static SDLRWops* SDLRWFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] byte* file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "const char*")] string mode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (mode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(mode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(mode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLRWops* ret = SDLRWFromFileNative(file, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Use this function to create an SDL_RWops structure from a standard I/O file<br/>
		/// pointer (stdio.h's `FILE*`).<br/>
		/// This function is not available on Windows, since files opened in an<br/>
		/// application on that platform cannot be used by a dynamically linked<br/>
		/// library.<br/>
		/// On some platforms, the first parameter is a `void*`, on others, it's a<br/>
		/// `FILE*`, depending on what system headers are available to SDL. It is<br/>
		/// always intended to be the `FILE*` type from the C runtime's stdio.h.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RWFromFP")]
		[return: NativeName(NativeNameType.Type, "SDL_RWops*")]
		[LibraryImport(LibName, EntryPoint = "SDL_RWFromFP")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial SDLRWops* SDLRWFromFPNative([NativeName(NativeNameType.Param, "fp")] [NativeName(NativeNameType.Type, "void*")] void* fp, [NativeName(NativeNameType.Param, "autoclose")] [NativeName(NativeNameType.Type, "SDL_bool")] SDLBool autoclose);

		/// <summary>/// Use this function to create an SDL_RWops structure from a standard I/O file<br/>/// pointer (stdio.h's `FILE*`).<br/>/// This function is not available on Windows, since files opened in an<br/>/// application on that platform cannot be used by a dynamically linked<br/>/// library.<br/>/// On some platforms, the first parameter is a `void*`, on others, it's a<br/>/// `FILE*`, depending on what system headers are available to SDL. It is<br/>/// always intended to be the `FILE*` type from the C runtime's stdio.h.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWFromFP")]
		[return: NativeName(NativeNameType.Type, "SDL_RWops*")]
		public static SDLRWops* SDLRWFromFP([NativeName(NativeNameType.Param, "fp")] [NativeName(NativeNameType.Type, "void*")] void* fp, [NativeName(NativeNameType.Param, "autoclose")] [NativeName(NativeNameType.Type, "SDL_bool")] SDLBool autoclose)
		{
			SDLRWops* ret = SDLRWFromFPNative(fp, autoclose);
			return ret;
		}

		/// <summary>
		/// Use this function to prepare a read-write memory buffer for use with<br/>
		/// SDL_RWops.<br/>
		/// This function sets up an SDL_RWops struct based on a memory area of a<br/>
		/// certain size, for both read and write access.<br/>
		/// This memory buffer is not copied by the RWops; the pointer you provide must<br/>
		/// remain valid until you close the stream. Closing the stream will not free<br/>
		/// the original buffer.<br/>
		/// If you need to make sure the RWops never writes to the memory buffer, you<br/>
		/// should use SDL_RWFromConstMem() with a read-only buffer of memory instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RWFromMem")]
		[return: NativeName(NativeNameType.Type, "SDL_RWops*")]
		[LibraryImport(LibName, EntryPoint = "SDL_RWFromMem")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial SDLRWops* SDLRWFromMemNative([NativeName(NativeNameType.Param, "mem")] [NativeName(NativeNameType.Type, "void*")] void* mem, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "int")] int size);

		/// <summary>/// Use this function to prepare a read-write memory buffer for use with<br/>/// SDL_RWops.<br/>/// This function sets up an SDL_RWops struct based on a memory area of a<br/>/// certain size, for both read and write access.<br/>/// This memory buffer is not copied by the RWops; the pointer you provide must<br/>/// remain valid until you close the stream. Closing the stream will not free<br/>/// the original buffer.<br/>/// If you need to make sure the RWops never writes to the memory buffer, you<br/>/// should use SDL_RWFromConstMem() with a read-only buffer of memory instead.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWFromMem")]
		[return: NativeName(NativeNameType.Type, "SDL_RWops*")]
		public static SDLRWops* SDLRWFromMem([NativeName(NativeNameType.Param, "mem")] [NativeName(NativeNameType.Type, "void*")] void* mem, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "int")] int size)
		{
			SDLRWops* ret = SDLRWFromMemNative(mem, size);
			return ret;
		}

		/// <summary>
		/// Use this function to prepare a read-only memory buffer for use with RWops.<br/>
		/// This function sets up an SDL_RWops struct based on a memory area of a<br/>
		/// certain size. It assumes the memory area is not writable.<br/>
		/// Attempting to write to this RWops stream will report an error without<br/>
		/// writing to the memory buffer.<br/>
		/// This memory buffer is not copied by the RWops; the pointer you provide must<br/>
		/// remain valid until you close the stream. Closing the stream will not free<br/>
		/// the original buffer.<br/>
		/// If you need to write to a memory buffer, you should use SDL_RWFromMem()<br/>
		/// with a writable buffer of memory instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RWFromConstMem")]
		[return: NativeName(NativeNameType.Type, "SDL_RWops*")]
		[LibraryImport(LibName, EntryPoint = "SDL_RWFromConstMem")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial SDLRWops* SDLRWFromConstMemNative([NativeName(NativeNameType.Param, "mem")] [NativeName(NativeNameType.Type, "const void*")] void* mem, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "int")] int size);

		/// <summary>/// Use this function to prepare a read-only memory buffer for use with RWops.<br/>/// This function sets up an SDL_RWops struct based on a memory area of a<br/>/// certain size. It assumes the memory area is not writable.<br/>/// Attempting to write to this RWops stream will report an error without<br/>/// writing to the memory buffer.<br/>/// This memory buffer is not copied by the RWops; the pointer you provide must<br/>/// remain valid until you close the stream. Closing the stream will not free<br/>/// the original buffer.<br/>/// If you need to write to a memory buffer, you should use SDL_RWFromMem()<br/>/// with a writable buffer of memory instead.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWFromConstMem")]
		[return: NativeName(NativeNameType.Type, "SDL_RWops*")]
		public static SDLRWops* SDLRWFromConstMem([NativeName(NativeNameType.Param, "mem")] [NativeName(NativeNameType.Type, "const void*")] void* mem, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "int")] int size)
		{
			SDLRWops* ret = SDLRWFromConstMemNative(mem, size);
			return ret;
		}

		/// <summary>
		/// Use this function to allocate an empty, unpopulated SDL_RWops structure.<br/>
		/// Applications do not need to use this function unless they are providing<br/>
		/// their own SDL_RWops implementation. If you just need a SDL_RWops to<br/>
		/// read/write a common data source, you should use the built-in<br/>
		/// implementations in SDL, like SDL_RWFromFile() or SDL_RWFromMem(), etc.<br/>
		/// You must free the returned pointer with SDL_FreeRW(). Depending on your<br/>
		/// operating system and compiler, there may be a difference between the<br/>
		/// malloc() and free() your program uses and the versions SDL calls<br/>
		/// internally. Trying to mix the two can cause crashing such as segmentation<br/>
		/// faults. Since all SDL_RWops must free themselves when their **close**<br/>
		/// method is called, all SDL_RWops must be allocated through this function, so<br/>
		/// they can all be freed correctly with SDL_FreeRW().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AllocRW")]
		[return: NativeName(NativeNameType.Type, "SDL_RWops*")]
		[LibraryImport(LibName, EntryPoint = "SDL_AllocRW")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial SDLRWops* SDLAllocRWNative();

		/// <summary>/// Use this function to allocate an empty, unpopulated SDL_RWops structure.<br/>/// Applications do not need to use this function unless they are providing<br/>/// their own SDL_RWops implementation. If you just need a SDL_RWops to<br/>/// read/write a common data source, you should use the built-in<br/>/// implementations in SDL, like SDL_RWFromFile() or SDL_RWFromMem(), etc.<br/>/// You must free the returned pointer with SDL_FreeRW(). Depending on your<br/>/// operating system and compiler, there may be a difference between the<br/>/// malloc() and free() your program uses and the versions SDL calls<br/>/// internally. Trying to mix the two can cause crashing such as segmentation<br/>/// faults. Since all SDL_RWops must free themselves when their **close**<br/>/// method is called, all SDL_RWops must be allocated through this function, so<br/>/// they can all be freed correctly with SDL_FreeRW().<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_AllocRW")]
		[return: NativeName(NativeNameType.Type, "SDL_RWops*")]
		public static SDLRWops* SDLAllocRW()
		{
			SDLRWops* ret = SDLAllocRWNative();
			return ret;
		}

		/// <summary>
		/// Use this function to free an SDL_RWops structure allocated by<br/>
		/// SDL_AllocRW().<br/>
		/// Applications do not need to use this function unless they are providing<br/>
		/// their own SDL_RWops implementation. If you just need a SDL_RWops to<br/>
		/// read/write a common data source, you should use the built-in<br/>
		/// implementations in SDL, like SDL_RWFromFile() or SDL_RWFromMem(), etc, and<br/>
		/// call the **close** method on those SDL_RWops pointers when you are done<br/>
		/// with them.<br/>
		/// Only use SDL_FreeRW() on pointers returned by SDL_AllocRW(). The pointer is<br/>
		/// invalid as soon as this function returns. Any extra memory allocated during<br/>
		/// creation of the SDL_RWops is not freed by SDL_FreeRW(); the programmer must<br/>
		/// be responsible for managing that memory in their **close** method.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FreeRW")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "SDL_FreeRW")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SDLFreeRWNative([NativeName(NativeNameType.Param, "area")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* area);

		/// <summary>/// Use this function to free an SDL_RWops structure allocated by<br/>/// SDL_AllocRW().<br/>/// Applications do not need to use this function unless they are providing<br/>/// their own SDL_RWops implementation. If you just need a SDL_RWops to<br/>/// read/write a common data source, you should use the built-in<br/>/// implementations in SDL, like SDL_RWFromFile() or SDL_RWFromMem(), etc, and<br/>/// call the **close** method on those SDL_RWops pointers when you are done<br/>/// with them.<br/>/// Only use SDL_FreeRW() on pointers returned by SDL_AllocRW(). The pointer is<br/>/// invalid as soon as this function returns. Any extra memory allocated during<br/>/// creation of the SDL_RWops is not freed by SDL_FreeRW(); the programmer must<br/>/// be responsible for managing that memory in their **close** method.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_FreeRW")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLFreeRW([NativeName(NativeNameType.Param, "area")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* area)
		{
			SDLFreeRWNative(area);
		}

		/// <summary>
		/// Use this function to get the size of the data stream in an SDL_RWops.<br/>
		/// Prior to SDL 2.0.10, this function was a macro.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RWsize")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		[LibraryImport(LibName, EntryPoint = "SDL_RWsize")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial long SDLRWsizeNative([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* context);

		/// <summary>/// Use this function to get the size of the data stream in an SDL_RWops.<br/>/// Prior to SDL 2.0.10, this function was a macro.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWsize")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long SDLRWsize([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* context)
		{
			long ret = SDLRWsizeNative(context);
			return ret;
		}

		/// <summary>
		/// Seek within an SDL_RWops data stream.<br/>
		/// This function seeks to byte `offset`, relative to `whence`.<br/>
		/// `whence` may be any of the following values:<br/>
		/// - `RW_SEEK_SET`: seek from the beginning of data<br/>
		/// - `RW_SEEK_CUR`: seek relative to current read point<br/>
		/// - `RW_SEEK_END`: seek relative to the end of data<br/>
		/// If this stream can not seek, it will return -1.<br/>
		/// SDL_RWseek() is actually a wrapper function that calls the SDL_RWops's<br/>
		/// `seek` method appropriately, to simplify application development.<br/>
		/// Prior to SDL 2.0.10, this function was a macro.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RWseek")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		[LibraryImport(LibName, EntryPoint = "SDL_RWseek")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial long SDLRWseekNative([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* context, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Sint64")] long offset, [NativeName(NativeNameType.Param, "whence")] [NativeName(NativeNameType.Type, "int")] int whence);

		/// <summary>/// Seek within an SDL_RWops data stream.<br/>/// This function seeks to byte `offset`, relative to `whence`.<br/>/// `whence` may be any of the following values:<br/>/// - `RW_SEEK_SET`: seek from the beginning of data<br/>/// - `RW_SEEK_CUR`: seek relative to current read point<br/>/// - `RW_SEEK_END`: seek relative to the end of data<br/>/// If this stream can not seek, it will return -1.<br/>/// SDL_RWseek() is actually a wrapper function that calls the SDL_RWops's<br/>/// `seek` method appropriately, to simplify application development.<br/>/// Prior to SDL 2.0.10, this function was a macro.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWseek")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long SDLRWseek([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* context, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Sint64")] long offset, [NativeName(NativeNameType.Param, "whence")] [NativeName(NativeNameType.Type, "int")] int whence)
		{
			long ret = SDLRWseekNative(context, offset, whence);
			return ret;
		}

		/// <summary>
		/// Determine the current read/write offset in an SDL_RWops data stream.<br/>
		/// SDL_RWtell is actually a wrapper function that calls the SDL_RWops's `seek`<br/>
		/// method, with an offset of 0 bytes from `RW_SEEK_CUR`, to simplify<br/>
		/// application development.<br/>
		/// Prior to SDL 2.0.10, this function was a macro.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RWtell")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		[LibraryImport(LibName, EntryPoint = "SDL_RWtell")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial long SDLRWtellNative([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* context);

		/// <summary>/// Determine the current read/write offset in an SDL_RWops data stream.<br/>/// SDL_RWtell is actually a wrapper function that calls the SDL_RWops's `seek`<br/>/// method, with an offset of 0 bytes from `RW_SEEK_CUR`, to simplify<br/>/// application development.<br/>/// Prior to SDL 2.0.10, this function was a macro.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWtell")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long SDLRWtell([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* context)
		{
			long ret = SDLRWtellNative(context);
			return ret;
		}

		/// <summary>
		/// Read from a data source.<br/>
		/// This function reads up to `maxnum` objects each of size `size` from the<br/>
		/// data source to the area pointed at by `ptr`. This function may read less<br/>
		/// objects than requested. It will return zero when there has been an error or<br/>
		/// the data stream is completely read.<br/>
		/// SDL_RWread() is actually a function wrapper that calls the SDL_RWops's<br/>
		/// `read` method appropriately, to simplify application development.<br/>
		/// Prior to SDL 2.0.10, this function was a macro.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RWread")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		[LibraryImport(LibName, EntryPoint = "SDL_RWread")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ulong SDLRWreadNative([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* context, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void*")] void* ptr, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] ulong size, [NativeName(NativeNameType.Param, "maxnum")] [NativeName(NativeNameType.Type, "size_t")] ulong maxnum);

		/// <summary>/// Read from a data source.<br/>/// This function reads up to `maxnum` objects each of size `size` from the<br/>/// data source to the area pointed at by `ptr`. This function may read less<br/>/// objects than requested. It will return zero when there has been an error or<br/>/// the data stream is completely read.<br/>/// SDL_RWread() is actually a function wrapper that calls the SDL_RWops's<br/>/// `read` method appropriately, to simplify application development.<br/>/// Prior to SDL 2.0.10, this function was a macro.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWread")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLRWread([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* context, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void*")] void* ptr, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] ulong size, [NativeName(NativeNameType.Param, "maxnum")] [NativeName(NativeNameType.Type, "size_t")] ulong maxnum)
		{
			ulong ret = SDLRWreadNative(context, ptr, size, maxnum);
			return ret;
		}

		/// <summary>/// Read from a data source.<br/>/// This function reads up to `maxnum` objects each of size `size` from the<br/>/// data source to the area pointed at by `ptr`. This function may read less<br/>/// objects than requested. It will return zero when there has been an error or<br/>/// the data stream is completely read.<br/>/// SDL_RWread() is actually a function wrapper that calls the SDL_RWops's<br/>/// `read` method appropriately, to simplify application development.<br/>/// Prior to SDL 2.0.10, this function was a macro.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWread")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLRWread([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* context, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void*")] void* ptr, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "maxnum")] [NativeName(NativeNameType.Type, "size_t")] ulong maxnum)
		{
			ulong ret = SDLRWreadNative(context, ptr, size, maxnum);
			return ret;
		}

		/// <summary>/// Read from a data source.<br/>/// This function reads up to `maxnum` objects each of size `size` from the<br/>/// data source to the area pointed at by `ptr`. This function may read less<br/>/// objects than requested. It will return zero when there has been an error or<br/>/// the data stream is completely read.<br/>/// SDL_RWread() is actually a function wrapper that calls the SDL_RWops's<br/>/// `read` method appropriately, to simplify application development.<br/>/// Prior to SDL 2.0.10, this function was a macro.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWread")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLRWread([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* context, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void*")] void* ptr, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] ulong size, [NativeName(NativeNameType.Param, "maxnum")] [NativeName(NativeNameType.Type, "size_t")] nuint maxnum)
		{
			ulong ret = SDLRWreadNative(context, ptr, size, maxnum);
			return ret;
		}

		/// <summary>/// Read from a data source.<br/>/// This function reads up to `maxnum` objects each of size `size` from the<br/>/// data source to the area pointed at by `ptr`. This function may read less<br/>/// objects than requested. It will return zero when there has been an error or<br/>/// the data stream is completely read.<br/>/// SDL_RWread() is actually a function wrapper that calls the SDL_RWops's<br/>/// `read` method appropriately, to simplify application development.<br/>/// Prior to SDL 2.0.10, this function was a macro.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWread")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLRWread([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* context, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void*")] void* ptr, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "maxnum")] [NativeName(NativeNameType.Type, "size_t")] nuint maxnum)
		{
			ulong ret = SDLRWreadNative(context, ptr, size, maxnum);
			return ret;
		}

		/// <summary>
		/// Write to an SDL_RWops data stream.<br/>
		/// This function writes exactly `num` objects each of size `size` from the<br/>
		/// area pointed at by `ptr` to the stream. If this fails for any reason, it'll<br/>
		/// return less than `num` to demonstrate how far the write progressed. On<br/>
		/// success, it returns `num`.<br/>
		/// SDL_RWwrite is actually a function wrapper that calls the SDL_RWops's<br/>
		/// `write` method appropriately, to simplify application development.<br/>
		/// Prior to SDL 2.0.10, this function was a macro.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RWwrite")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		[LibraryImport(LibName, EntryPoint = "SDL_RWwrite")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ulong SDLRWwriteNative([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* context, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "const void*")] void* ptr, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] ulong size, [NativeName(NativeNameType.Param, "num")] [NativeName(NativeNameType.Type, "size_t")] ulong num);

		/// <summary>/// Write to an SDL_RWops data stream.<br/>/// This function writes exactly `num` objects each of size `size` from the<br/>/// area pointed at by `ptr` to the stream. If this fails for any reason, it'll<br/>/// return less than `num` to demonstrate how far the write progressed. On<br/>/// success, it returns `num`.<br/>/// SDL_RWwrite is actually a function wrapper that calls the SDL_RWops's<br/>/// `write` method appropriately, to simplify application development.<br/>/// Prior to SDL 2.0.10, this function was a macro.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWwrite")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLRWwrite([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* context, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "const void*")] void* ptr, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] ulong size, [NativeName(NativeNameType.Param, "num")] [NativeName(NativeNameType.Type, "size_t")] ulong num)
		{
			ulong ret = SDLRWwriteNative(context, ptr, size, num);
			return ret;
		}

		/// <summary>/// Write to an SDL_RWops data stream.<br/>/// This function writes exactly `num` objects each of size `size` from the<br/>/// area pointed at by `ptr` to the stream. If this fails for any reason, it'll<br/>/// return less than `num` to demonstrate how far the write progressed. On<br/>/// success, it returns `num`.<br/>/// SDL_RWwrite is actually a function wrapper that calls the SDL_RWops's<br/>/// `write` method appropriately, to simplify application development.<br/>/// Prior to SDL 2.0.10, this function was a macro.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWwrite")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLRWwrite([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* context, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "const void*")] void* ptr, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "num")] [NativeName(NativeNameType.Type, "size_t")] ulong num)
		{
			ulong ret = SDLRWwriteNative(context, ptr, size, num);
			return ret;
		}

		/// <summary>/// Write to an SDL_RWops data stream.<br/>/// This function writes exactly `num` objects each of size `size` from the<br/>/// area pointed at by `ptr` to the stream. If this fails for any reason, it'll<br/>/// return less than `num` to demonstrate how far the write progressed. On<br/>/// success, it returns `num`.<br/>/// SDL_RWwrite is actually a function wrapper that calls the SDL_RWops's<br/>/// `write` method appropriately, to simplify application development.<br/>/// Prior to SDL 2.0.10, this function was a macro.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWwrite")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLRWwrite([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* context, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "const void*")] void* ptr, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] ulong size, [NativeName(NativeNameType.Param, "num")] [NativeName(NativeNameType.Type, "size_t")] nuint num)
		{
			ulong ret = SDLRWwriteNative(context, ptr, size, num);
			return ret;
		}

		/// <summary>/// Write to an SDL_RWops data stream.<br/>/// This function writes exactly `num` objects each of size `size` from the<br/>/// area pointed at by `ptr` to the stream. If this fails for any reason, it'll<br/>/// return less than `num` to demonstrate how far the write progressed. On<br/>/// success, it returns `num`.<br/>/// SDL_RWwrite is actually a function wrapper that calls the SDL_RWops's<br/>/// `write` method appropriately, to simplify application development.<br/>/// Prior to SDL 2.0.10, this function was a macro.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWwrite")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLRWwrite([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* context, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "const void*")] void* ptr, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "num")] [NativeName(NativeNameType.Type, "size_t")] nuint num)
		{
			ulong ret = SDLRWwriteNative(context, ptr, size, num);
			return ret;
		}

		/// <summary>
		/// Close and free an allocated SDL_RWops structure.<br/>
		/// SDL_RWclose() closes and cleans up the SDL_RWops stream. It releases any<br/>
		/// resources used by the stream and frees the SDL_RWops itself with<br/>
		/// SDL_FreeRW(). This returns 0 on success, or -1 if the stream failed to<br/>
		/// flush to its output (e.g. to disk).<br/>
		/// Note that if this fails to flush the stream to disk, this function reports<br/>
		/// an error, but the SDL_RWops is still invalid once this function returns.<br/>
		/// Prior to SDL 2.0.10, this function was a macro.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RWclose")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_RWclose")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLRWcloseNative([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* context);

		/// <summary>/// Close and free an allocated SDL_RWops structure.<br/>/// SDL_RWclose() closes and cleans up the SDL_RWops stream. It releases any<br/>/// resources used by the stream and frees the SDL_RWops itself with<br/>/// SDL_FreeRW(). This returns 0 on success, or -1 if the stream failed to<br/>/// flush to its output (e.g. to disk).<br/>/// Note that if this fails to flush the stream to disk, this function reports<br/>/// an error, but the SDL_RWops is still invalid once this function returns.<br/>/// Prior to SDL 2.0.10, this function was a macro.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWclose")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRWclose([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* context)
		{
			int ret = SDLRWcloseNative(context);
			return ret;
		}

		/// <summary>
		/// Load all the data from an SDL data stream.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFile_RW")]
		[return: NativeName(NativeNameType.Type, "void*")]
		[LibraryImport(LibName, EntryPoint = "SDL_LoadFile_RW")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void* SDLLoadFileRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t*")] ulong* datasize, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc);

		/// <summary>/// Load all the data from an SDL data stream.<br/>/// The data is allocated with a zero byte at the end (null terminated) for<br/>/// convenience. This extra byte is not included in the value reported via<br/>/// `datasize`.<br/>/// The data should be freed with SDL_free().<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_LoadFile_RW")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLLoadFileRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t*")] ulong* datasize, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc)
		{
			void* ret = SDLLoadFileRWNative(src, datasize, freesrc);
			return ret;
		}

		/// <summary>/// Load all the data from an SDL data stream.<br/>/// The data is allocated with a zero byte at the end (null terminated) for<br/>/// convenience. This extra byte is not included in the value reported via<br/>/// `datasize`.<br/>/// The data should be freed with SDL_free().<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_LoadFile_RW")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLLoadFileRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t*")] ref nuint datasize, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc)
		{
			fixed (nuint* pdatasize = &datasize)
			{
				void* ret = SDLLoadFileRWNative(src, (ulong*)pdatasize, freesrc);
				return ret;
			}
		}

		/// <summary>
		/// Load all the data from a file path.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// Prior to SDL 2.0.10, this function was a macro wrapping around<br/>
		/// SDL_LoadFile_RW.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFile")]
		[return: NativeName(NativeNameType.Type, "void*")]
		[LibraryImport(LibName, EntryPoint = "SDL_LoadFile")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void* SDLLoadFileNative([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] byte* file, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t*")] ulong* datasize);

		/// <summary>/// Load all the data from a file path.<br/>/// The data is allocated with a zero byte at the end (null terminated) for<br/>/// convenience. This extra byte is not included in the value reported via<br/>/// `datasize`.<br/>/// The data should be freed with SDL_free().<br/>/// Prior to SDL 2.0.10, this function was a macro wrapping around<br/>/// SDL_LoadFile_RW.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_LoadFile")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLLoadFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] byte* file, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t*")] ulong* datasize)
		{
			void* ret = SDLLoadFileNative(file, datasize);
			return ret;
		}

		/// <summary>/// Load all the data from a file path.<br/>/// The data is allocated with a zero byte at the end (null terminated) for<br/>/// convenience. This extra byte is not included in the value reported via<br/>/// `datasize`.<br/>/// The data should be freed with SDL_free().<br/>/// Prior to SDL 2.0.10, this function was a macro wrapping around<br/>/// SDL_LoadFile_RW.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_LoadFile")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLLoadFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] byte* file, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t*")] ref nuint datasize)
		{
			fixed (nuint* pdatasize = &datasize)
			{
				void* ret = SDLLoadFileNative(file, (ulong*)pdatasize);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read a byte from an SDL_RWops.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadU8")]
		[return: NativeName(NativeNameType.Type, "Uint8")]
		[LibraryImport(LibName, EntryPoint = "SDL_ReadU8")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte SDLReadU8Native([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src);

		/// <summary>/// Use this function to read a byte from an SDL_RWops.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_ReadU8")]
		[return: NativeName(NativeNameType.Type, "Uint8")]
		public static byte SDLReadU8([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			byte ret = SDLReadU8Native(src);
			return ret;
		}

		/// <summary>
		/// Use this function to read 16 bits of little-endian data from an SDL_RWops<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadLE16")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		[LibraryImport(LibName, EntryPoint = "SDL_ReadLE16")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ushort SDLReadLE16Native([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src);

		/// <summary>/// Use this function to read 16 bits of little-endian data from an SDL_RWops<br/>/// and return in native format.<br/>/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>/// the native byte order.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_ReadLE16")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort SDLReadLE16([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			ushort ret = SDLReadLE16Native(src);
			return ret;
		}

		/// <summary>
		/// Use this function to read 16 bits of big-endian data from an SDL_RWops and<br/>
		/// return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadBE16")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		[LibraryImport(LibName, EntryPoint = "SDL_ReadBE16")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ushort SDLReadBE16Native([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src);

		/// <summary>/// Use this function to read 16 bits of big-endian data from an SDL_RWops and<br/>/// return in native format.<br/>/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>/// the native byte order.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_ReadBE16")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort SDLReadBE16([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			ushort ret = SDLReadBE16Native(src);
			return ret;
		}

		/// <summary>
		/// Use this function to read 32 bits of little-endian data from an SDL_RWops<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadLE32")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		[LibraryImport(LibName, EntryPoint = "SDL_ReadLE32")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial uint SDLReadLE32Native([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src);

		/// <summary>/// Use this function to read 32 bits of little-endian data from an SDL_RWops<br/>/// and return in native format.<br/>/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>/// the native byte order.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_ReadLE32")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLReadLE32([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			uint ret = SDLReadLE32Native(src);
			return ret;
		}

		/// <summary>
		/// Use this function to read 32 bits of big-endian data from an SDL_RWops and<br/>
		/// return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadBE32")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		[LibraryImport(LibName, EntryPoint = "SDL_ReadBE32")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial uint SDLReadBE32Native([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src);

		/// <summary>/// Use this function to read 32 bits of big-endian data from an SDL_RWops and<br/>/// return in native format.<br/>/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>/// the native byte order.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_ReadBE32")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLReadBE32([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			uint ret = SDLReadBE32Native(src);
			return ret;
		}

		/// <summary>
		/// Use this function to read 64 bits of little-endian data from an SDL_RWops<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadLE64")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		[LibraryImport(LibName, EntryPoint = "SDL_ReadLE64")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ulong SDLReadLE64Native([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src);

		/// <summary>/// Use this function to read 64 bits of little-endian data from an SDL_RWops<br/>/// and return in native format.<br/>/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>/// the native byte order.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_ReadLE64")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		public static ulong SDLReadLE64([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			ulong ret = SDLReadLE64Native(src);
			return ret;
		}

		/// <summary>
		/// Use this function to read 64 bits of big-endian data from an SDL_RWops and<br/>
		/// return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadBE64")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		[LibraryImport(LibName, EntryPoint = "SDL_ReadBE64")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ulong SDLReadBE64Native([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src);

		/// <summary>/// Use this function to read 64 bits of big-endian data from an SDL_RWops and<br/>/// return in native format.<br/>/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>/// the native byte order.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_ReadBE64")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		public static ulong SDLReadBE64([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			ulong ret = SDLReadBE64Native(src);
			return ret;
		}

		/// <summary>
		/// Use this function to write a byte to an SDL_RWops.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteU8")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		[LibraryImport(LibName, EntryPoint = "SDL_WriteU8")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ulong SDLWriteU8Native([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint8")] byte value);

		/// <summary>/// Use this function to write a byte to an SDL_RWops.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_WriteU8")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLWriteU8([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint8")] byte value)
		{
			ulong ret = SDLWriteU8Native(dst, value);
			return ret;
		}

		/// <summary>
		/// Use this function to write 16 bits in native format to a SDL_RWops as<br/>
		/// little-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in little-endian<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteLE16")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		[LibraryImport(LibName, EntryPoint = "SDL_WriteLE16")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ulong SDLWriteLE16Native([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint16")] ushort value);

		/// <summary>/// Use this function to write 16 bits in native format to a SDL_RWops as<br/>/// little-endian data.<br/>/// SDL byteswaps the data only if necessary, so the application always<br/>/// specifies native format, and the data written will be in little-endian<br/>/// format.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_WriteLE16")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLWriteLE16([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint16")] ushort value)
		{
			ulong ret = SDLWriteLE16Native(dst, value);
			return ret;
		}

		/// <summary>
		/// Use this function to write 16 bits in native format to a SDL_RWops as<br/>
		/// big-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in big-endian format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteBE16")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		[LibraryImport(LibName, EntryPoint = "SDL_WriteBE16")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ulong SDLWriteBE16Native([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint16")] ushort value);

		/// <summary>/// Use this function to write 16 bits in native format to a SDL_RWops as<br/>/// big-endian data.<br/>/// SDL byteswaps the data only if necessary, so the application always<br/>/// specifies native format, and the data written will be in big-endian format.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_WriteBE16")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLWriteBE16([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint16")] ushort value)
		{
			ulong ret = SDLWriteBE16Native(dst, value);
			return ret;
		}

		/// <summary>
		/// Use this function to write 32 bits in native format to a SDL_RWops as<br/>
		/// little-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in little-endian<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteLE32")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		[LibraryImport(LibName, EntryPoint = "SDL_WriteLE32")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ulong SDLWriteLE32Native([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint32")] uint value);

		/// <summary>/// Use this function to write 32 bits in native format to a SDL_RWops as<br/>/// little-endian data.<br/>/// SDL byteswaps the data only if necessary, so the application always<br/>/// specifies native format, and the data written will be in little-endian<br/>/// format.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_WriteLE32")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLWriteLE32([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint32")] uint value)
		{
			ulong ret = SDLWriteLE32Native(dst, value);
			return ret;
		}

		/// <summary>
		/// Use this function to write 32 bits in native format to a SDL_RWops as<br/>
		/// big-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in big-endian format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteBE32")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		[LibraryImport(LibName, EntryPoint = "SDL_WriteBE32")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ulong SDLWriteBE32Native([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint32")] uint value);

		/// <summary>/// Use this function to write 32 bits in native format to a SDL_RWops as<br/>/// big-endian data.<br/>/// SDL byteswaps the data only if necessary, so the application always<br/>/// specifies native format, and the data written will be in big-endian format.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_WriteBE32")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLWriteBE32([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint32")] uint value)
		{
			ulong ret = SDLWriteBE32Native(dst, value);
			return ret;
		}

		/// <summary>
		/// Use this function to write 64 bits in native format to a SDL_RWops as<br/>
		/// little-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in little-endian<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteLE64")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		[LibraryImport(LibName, EntryPoint = "SDL_WriteLE64")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ulong SDLWriteLE64Native([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint64")] ulong value);

		/// <summary>/// Use this function to write 64 bits in native format to a SDL_RWops as<br/>/// little-endian data.<br/>/// SDL byteswaps the data only if necessary, so the application always<br/>/// specifies native format, and the data written will be in little-endian<br/>/// format.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_WriteLE64")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLWriteLE64([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint64")] ulong value)
		{
			ulong ret = SDLWriteLE64Native(dst, value);
			return ret;
		}

		/// <summary>
		/// Use this function to write 64 bits in native format to a SDL_RWops as<br/>
		/// big-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in big-endian format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteBE64")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		[LibraryImport(LibName, EntryPoint = "SDL_WriteBE64")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ulong SDLWriteBE64Native([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint64")] ulong value);

		/// <summary>/// Use this function to write 64 bits in native format to a SDL_RWops as<br/>/// big-endian data.<br/>/// SDL byteswaps the data only if necessary, so the application always<br/>/// specifies native format, and the data written will be in big-endian format.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_WriteBE64")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLWriteBE64([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint64")] ulong value)
		{
			ulong ret = SDLWriteBE64Native(dst, value);
			return ret;
		}

		/// <summary>
		/// Use this function to get the number of built-in audio drivers.<br/>
		/// This function returns a hardcoded number. This never returns a negative<br/>
		/// value; if there are no drivers compiled into this build of SDL, this<br/>
		/// function returns zero. The presence of a driver in this list does not mean<br/>
		/// it will function, it just means SDL is capable of interacting with that<br/>
		/// interface. For example, a build of SDL might have esound support, but if<br/>
		/// there's no esound server available, SDL's esound driver would fail if used.<br/>
		/// By default, SDL tries all drivers, in its preferred order, until one is<br/>
		/// found to be usable.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumAudioDrivers")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_GetNumAudioDrivers")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLGetNumAudioDriversNative();

		/// <summary>/// Use this function to get the number of built-in audio drivers.<br/>/// This function returns a hardcoded number. This never returns a negative<br/>/// value; if there are no drivers compiled into this build of SDL, this<br/>/// function returns zero. The presence of a driver in this list does not mean<br/>/// it will function, it just means SDL is capable of interacting with that<br/>/// interface. For example, a build of SDL might have esound support, but if<br/>/// there's no esound server available, SDL's esound driver would fail if used.<br/>/// By default, SDL tries all drivers, in its preferred order, until one is<br/>/// found to be usable.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetNumAudioDrivers")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetNumAudioDrivers()
		{
			int ret = SDLGetNumAudioDriversNative();
			return ret;
		}

		/// <summary>
		/// Use this function to get the name of a built in audio driver.<br/>
		/// The list of audio drivers is given in the order that they are normally<br/>
		/// initialized by default; the drivers that seem more reasonable to choose<br/>
		/// first (as far as the SDL developers believe) are earlier in the list.<br/>
		/// The names of drivers are all simple, low-ASCII identifiers, like "alsa",<br/>
		/// "coreaudio" or "xaudio2". These never have Unicode characters, and are not<br/>
		/// meant to be proper names.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAudioDriver")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		[LibraryImport(LibName, EntryPoint = "SDL_GetAudioDriver")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte* SDLGetAudioDriverNative([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index);

		/// <summary>/// Use this function to get the name of a built in audio driver.<br/>/// The list of audio drivers is given in the order that they are normally<br/>/// initialized by default; the drivers that seem more reasonable to choose<br/>/// first (as far as the SDL developers believe) are earlier in the list.<br/>/// The names of drivers are all simple, low-ASCII identifiers, like "alsa",<br/>/// "coreaudio" or "xaudio2". These never have Unicode characters, and are not<br/>/// meant to be proper names.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetAudioDriver")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGetAudioDriver([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index)
		{
			byte* ret = SDLGetAudioDriverNative(index);
			return ret;
		}

		/// <summary>/// Use this function to get the name of a built in audio driver.<br/>/// The list of audio drivers is given in the order that they are normally<br/>/// initialized by default; the drivers that seem more reasonable to choose<br/>/// first (as far as the SDL developers believe) are earlier in the list.<br/>/// The names of drivers are all simple, low-ASCII identifiers, like "alsa",<br/>/// "coreaudio" or "xaudio2". These never have Unicode characters, and are not<br/>/// meant to be proper names.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetAudioDriver")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGetAudioDriverS([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index)
		{
			string ret = Utils.DecodeStringUTF8(SDLGetAudioDriverNative(index));
			return ret;
		}

		/// <summary>
		/// Use this function to initialize a particular audio driver.<br/>
		/// This function is used internally, and should not be used unless you have a<br/>
		/// specific need to designate the audio driver you want to use. You should<br/>
		/// normally use SDL_Init() or SDL_InitSubSystem().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AudioInit")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_AudioInit")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLAudioInitNative([NativeName(NativeNameType.Param, "driver_name")] [NativeName(NativeNameType.Type, "const char*")] byte* driverName);

		/// <summary>/// Use this function to initialize a particular audio driver.<br/>/// This function is used internally, and should not be used unless you have a<br/>/// specific need to designate the audio driver you want to use. You should<br/>/// normally use SDL_Init() or SDL_InitSubSystem().<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_AudioInit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLAudioInit([NativeName(NativeNameType.Param, "driver_name")] [NativeName(NativeNameType.Type, "const char*")] byte* driverName)
		{
			int ret = SDLAudioInitNative(driverName);
			return ret;
		}

		/// <summary>
		/// Use this function to shut down audio if you initialized it with<br/>
		/// SDL_AudioInit().<br/>
		/// This function is used internally, and should not be used unless you have a<br/>
		/// specific need to specify the audio driver you want to use. You should<br/>
		/// normally use SDL_Quit() or SDL_QuitSubSystem().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AudioQuit")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "SDL_AudioQuit")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SDLAudioQuitNative();

		/// <summary>/// Use this function to shut down audio if you initialized it with<br/>/// SDL_AudioInit().<br/>/// This function is used internally, and should not be used unless you have a<br/>/// specific need to specify the audio driver you want to use. You should<br/>/// normally use SDL_Quit() or SDL_QuitSubSystem().<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_AudioQuit")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLAudioQuit()
		{
			SDLAudioQuitNative();
		}

		/// <summary>
		/// Get the name of the current audio driver.<br/>
		/// The returned string points to internal static memory and thus never becomes<br/>
		/// invalid, even if you quit the audio subsystem and initialize a new driver<br/>
		/// (although such a case would return a different static string from another<br/>
		/// call to this function, of course). As such, you should not modify or free<br/>
		/// the returned string.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCurrentAudioDriver")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		[LibraryImport(LibName, EntryPoint = "SDL_GetCurrentAudioDriver")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte* SDLGetCurrentAudioDriverNative();

		/// <summary>/// Get the name of the current audio driver.<br/>/// The returned string points to internal static memory and thus never becomes<br/>/// invalid, even if you quit the audio subsystem and initialize a new driver<br/>/// (although such a case would return a different static string from another<br/>/// call to this function, of course). As such, you should not modify or free<br/>/// the returned string.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetCurrentAudioDriver")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGetCurrentAudioDriver()
		{
			byte* ret = SDLGetCurrentAudioDriverNative();
			return ret;
		}

		/// <summary>/// Get the name of the current audio driver.<br/>/// The returned string points to internal static memory and thus never becomes<br/>/// invalid, even if you quit the audio subsystem and initialize a new driver<br/>/// (although such a case would return a different static string from another<br/>/// call to this function, of course). As such, you should not modify or free<br/>/// the returned string.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetCurrentAudioDriver")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGetCurrentAudioDriverS()
		{
			string ret = Utils.DecodeStringUTF8(SDLGetCurrentAudioDriverNative());
			return ret;
		}

		/// <summary>
		/// This function is a legacy means of opening the audio device.<br/>
		/// This function remains for compatibility with SDL 1.2, but also because it's<br/>
		/// slightly easier to use than the new functions in SDL 2.0. The new, more<br/>
		/// powerful, and preferred way to do this is SDL_OpenAudioDevice().<br/>
		/// This function is roughly equivalent to:<br/>
		/// ```c<br/>
		/// SDL_OpenAudioDevice(NULL, 0, desired, obtained, SDL_AUDIO_ALLOW_ANY_CHANGE);<br/>
		/// ```<br/>
		/// With two notable exceptions:<br/>
		/// - If `obtained` is NULL, we use `desired` (and allow no changes), which<br/>
		/// means desired will be modified to have the correct values for silence,<br/>
		/// etc, and SDL will convert any differences between your app's specific<br/>
		/// request and the hardware behind the scenes.<br/>
		/// - The return value is always success or failure, and not a device ID, which<br/>
		/// means you can only have one device open at a time with this function.<br/>
		/// <br/>
		/// If `obtained` is NULL, the audio data passed to the callback<br/>
		/// function will be guaranteed to be in the requested format, and<br/>
		/// will be automatically converted to the actual hardware audio<br/>
		/// format if necessary. If `obtained` is NULL, `desired` will have<br/>
		/// fields modified.<br/>
		/// This function returns a negative error code on failure to open the<br/>
		/// audio device or failure to set up the audio thread; call<br/>
		/// SDL_GetError() for more information.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenAudio")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_OpenAudio")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLOpenAudioNative([NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* obtained);

		/// <summary>/// This function is a legacy means of opening the audio device.<br/>/// This function remains for compatibility with SDL 1.2, but also because it's<br/>/// slightly easier to use than the new functions in SDL 2.0. The new, more<br/>/// powerful, and preferred way to do this is SDL_OpenAudioDevice().<br/>/// This function is roughly equivalent to:<br/>/// ```c<br/>/// SDL_OpenAudioDevice(NULL, 0, desired, obtained, SDL_AUDIO_ALLOW_ANY_CHANGE);<br/>/// ```<br/>/// With two notable exceptions:<br/>/// - If `obtained` is NULL, we use `desired` (and allow no changes), which<br/>/// means desired will be modified to have the correct values for silence,<br/>/// etc, and SDL will convert any differences between your app's specific<br/>/// request and the hardware behind the scenes.<br/>/// - The return value is always success or failure, and not a device ID, which<br/>/// means you can only have one device open at a time with this function.<br/>/// <br/>/// If `obtained` is NULL, the audio data passed to the callback<br/>/// function will be guaranteed to be in the requested format, and<br/>/// will be automatically converted to the actual hardware audio<br/>/// format if necessary. If `obtained` is NULL, `desired` will have<br/>/// fields modified.<br/>/// This function returns a negative error code on failure to open the<br/>/// audio device or failure to set up the audio thread; call<br/>/// SDL_GetError() for more information.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_OpenAudio")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLOpenAudio([NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* obtained)
		{
			int ret = SDLOpenAudioNative(desired, obtained);
			return ret;
		}

		/// <summary>/// This function is a legacy means of opening the audio device.<br/>/// This function remains for compatibility with SDL 1.2, but also because it's<br/>/// slightly easier to use than the new functions in SDL 2.0. The new, more<br/>/// powerful, and preferred way to do this is SDL_OpenAudioDevice().<br/>/// This function is roughly equivalent to:<br/>/// ```c<br/>/// SDL_OpenAudioDevice(NULL, 0, desired, obtained, SDL_AUDIO_ALLOW_ANY_CHANGE);<br/>/// ```<br/>/// With two notable exceptions:<br/>/// - If `obtained` is NULL, we use `desired` (and allow no changes), which<br/>/// means desired will be modified to have the correct values for silence,<br/>/// etc, and SDL will convert any differences between your app's specific<br/>/// request and the hardware behind the scenes.<br/>/// - The return value is always success or failure, and not a device ID, which<br/>/// means you can only have one device open at a time with this function.<br/>/// <br/>/// If `obtained` is NULL, the audio data passed to the callback<br/>/// function will be guaranteed to be in the requested format, and<br/>/// will be automatically converted to the actual hardware audio<br/>/// format if necessary. If `obtained` is NULL, `desired` will have<br/>/// fields modified.<br/>/// This function returns a negative error code on failure to open the<br/>/// audio device or failure to set up the audio thread; call<br/>/// SDL_GetError() for more information.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_OpenAudio")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLOpenAudio([NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec obtained)
		{
			fixed (SDLAudioSpec* pobtained = &obtained)
			{
				int ret = SDLOpenAudioNative(desired, (SDLAudioSpec*)pobtained);
				return ret;
			}
		}

		/// <summary>
		/// Get the number of built-in audio devices.<br/>
		/// This function is only valid after successfully initializing the audio<br/>
		/// subsystem.<br/>
		/// Note that audio capture support is not implemented as of SDL 2.0.4, so the<br/>
		/// `iscapture` parameter is for future expansion and should always be zero for<br/>
		/// now.<br/>
		/// This function will return -1 if an explicit list of devices can't be<br/>
		/// determined. Returning -1 is not an error. For example, if SDL is set up to<br/>
		/// talk to a remote audio server, it can't list every one available on the<br/>
		/// Internet, but it will still allow a specific host to be specified in<br/>
		/// SDL_OpenAudioDevice().<br/>
		/// In many common cases, when this function returns a value <br/>
		/// <<br/>
		/// = 0, it can still<br/>
		/// successfully open the default device (NULL for first argument of<br/>
		/// SDL_OpenAudioDevice()).<br/>
		/// This function may trigger a complete redetect of available hardware. It<br/>
		/// should not be called for each iteration of a loop, but rather once at the<br/>
		/// start of a loop:<br/>
		/// ```c<br/>
		/// // Don't do this:<br/>
		/// for (int i = 0; i <br/>
		/// <<br/>
		/// SDL_GetNumAudioDevices(0); i++)<br/>
		/// // do this instead:<br/>
		/// const int count = SDL_GetNumAudioDevices(0);<br/>
		/// for (int i = 0; i <br/>
		/// <<br/>
		/// count; ++i) { do_something_here(); }<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumAudioDevices")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_GetNumAudioDevices")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLGetNumAudioDevicesNative([NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture);

		/// <summary>/// Get the number of built-in audio devices.<br/>/// This function is only valid after successfully initializing the audio<br/>/// subsystem.<br/>/// Note that audio capture support is not implemented as of SDL 2.0.4, so the<br/>/// `iscapture` parameter is for future expansion and should always be zero for<br/>/// now.<br/>/// This function will return -1 if an explicit list of devices can't be<br/>/// determined. Returning -1 is not an error. For example, if SDL is set up to<br/>/// talk to a remote audio server, it can't list every one available on the<br/>/// Internet, but it will still allow a specific host to be specified in<br/>/// SDL_OpenAudioDevice().<br/>/// In many common cases, when this function returns a value <br/>/// <<br/>/// = 0, it can still<br/>/// successfully open the default device (NULL for first argument of<br/>/// SDL_OpenAudioDevice()).<br/>/// This function may trigger a complete redetect of available hardware. It<br/>/// should not be called for each iteration of a loop, but rather once at the<br/>/// start of a loop:<br/>/// ```c<br/>/// // Don't do this:<br/>/// for (int i = 0; i <br/>/// <<br/>/// SDL_GetNumAudioDevices(0); i++)<br/>/// // do this instead:<br/>/// const int count = SDL_GetNumAudioDevices(0);<br/>/// for (int i = 0; i <br/>/// <<br/>/// count; ++i) { do_something_here(); }<br/>/// ```<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetNumAudioDevices")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetNumAudioDevices([NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture)
		{
			int ret = SDLGetNumAudioDevicesNative(iscapture);
			return ret;
		}

		/// <summary>
		/// Get the human-readable name of a specific audio device.<br/>
		/// This function is only valid after successfully initializing the audio<br/>
		/// subsystem. The values returned by this function reflect the latest call to<br/>
		/// SDL_GetNumAudioDevices(); re-call that function to redetect available<br/>
		/// hardware.<br/>
		/// The string returned by this function is UTF-8 encoded, read-only, and<br/>
		/// managed internally. You are not to free it. If you need to keep the string<br/>
		/// for any length of time, you should make your own copy of it, as it will be<br/>
		/// invalid next time any of several other SDL functions are called.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAudioDeviceName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		[LibraryImport(LibName, EntryPoint = "SDL_GetAudioDeviceName")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte* SDLGetAudioDeviceNameNative([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture);

		/// <summary>/// Get the human-readable name of a specific audio device.<br/>/// This function is only valid after successfully initializing the audio<br/>/// subsystem. The values returned by this function reflect the latest call to<br/>/// SDL_GetNumAudioDevices(); re-call that function to redetect available<br/>/// hardware.<br/>/// The string returned by this function is UTF-8 encoded, read-only, and<br/>/// managed internally. You are not to free it. If you need to keep the string<br/>/// for any length of time, you should make your own copy of it, as it will be<br/>/// invalid next time any of several other SDL functions are called.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetAudioDeviceName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGetAudioDeviceName([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture)
		{
			byte* ret = SDLGetAudioDeviceNameNative(index, iscapture);
			return ret;
		}

		/// <summary>/// Get the human-readable name of a specific audio device.<br/>/// This function is only valid after successfully initializing the audio<br/>/// subsystem. The values returned by this function reflect the latest call to<br/>/// SDL_GetNumAudioDevices(); re-call that function to redetect available<br/>/// hardware.<br/>/// The string returned by this function is UTF-8 encoded, read-only, and<br/>/// managed internally. You are not to free it. If you need to keep the string<br/>/// for any length of time, you should make your own copy of it, as it will be<br/>/// invalid next time any of several other SDL functions are called.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetAudioDeviceName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGetAudioDeviceNameS([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture)
		{
			string ret = Utils.DecodeStringUTF8(SDLGetAudioDeviceNameNative(index, iscapture));
			return ret;
		}

		/// <summary>
		/// Get the preferred audio format of a specific audio device.<br/>
		/// This function is only valid after a successfully initializing the audio<br/>
		/// subsystem. The values returned by this function reflect the latest call to<br/>
		/// SDL_GetNumAudioDevices(); re-call that function to redetect available<br/>
		/// hardware.<br/>
		/// `spec` will be filled with the sample rate, sample format, and channel<br/>
		/// count.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAudioDeviceSpec")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_GetAudioDeviceSpec")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLGetAudioDeviceSpecNative([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* spec);

		/// <summary>/// Get the preferred audio format of a specific audio device.<br/>/// This function is only valid after a successfully initializing the audio<br/>/// subsystem. The values returned by this function reflect the latest call to<br/>/// SDL_GetNumAudioDevices(); re-call that function to redetect available<br/>/// hardware.<br/>/// `spec` will be filled with the sample rate, sample format, and channel<br/>/// count.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetAudioDeviceSpec")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetAudioDeviceSpec([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* spec)
		{
			int ret = SDLGetAudioDeviceSpecNative(index, iscapture, spec);
			return ret;
		}

		/// <summary>/// Get the preferred audio format of a specific audio device.<br/>/// This function is only valid after a successfully initializing the audio<br/>/// subsystem. The values returned by this function reflect the latest call to<br/>/// SDL_GetNumAudioDevices(); re-call that function to redetect available<br/>/// hardware.<br/>/// `spec` will be filled with the sample rate, sample format, and channel<br/>/// count.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetAudioDeviceSpec")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetAudioDeviceSpec([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec spec)
		{
			fixed (SDLAudioSpec* pspec = &spec)
			{
				int ret = SDLGetAudioDeviceSpecNative(index, iscapture, (SDLAudioSpec*)pspec);
				return ret;
			}
		}

		/// <summary>
		/// Get the name and preferred format of the default audio device.<br/>
		/// Some (but not all!) platforms have an isolated mechanism to get information<br/>
		/// about the "default" device. This can actually be a completely different<br/>
		/// device that's not in the list you get from SDL_GetAudioDeviceSpec(). It can<br/>
		/// even be a network address! (This is discussed in SDL_OpenAudioDevice().)<br/>
		/// As a result, this call is not guaranteed to be performant, as it can query<br/>
		/// the sound server directly every time, unlike the other query functions. You<br/>
		/// should call this function sparingly!<br/>
		/// `spec` will be filled with the sample rate, sample format, and channel<br/>
		/// count, if a default device exists on the system. If `name` is provided,<br/>
		/// will be filled with either a dynamically-allocated UTF-8 string or NULL.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetDefaultAudioInfo")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_GetDefaultAudioInfo")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLGetDefaultAudioInfoNative([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char**")] byte** name, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* spec, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture);

		/// <summary>/// Get the name and preferred format of the default audio device.<br/>/// Some (but not all!) platforms have an isolated mechanism to get information<br/>/// about the "default" device. This can actually be a completely different<br/>/// device that's not in the list you get from SDL_GetAudioDeviceSpec(). It can<br/>/// even be a network address! (This is discussed in SDL_OpenAudioDevice().)<br/>/// As a result, this call is not guaranteed to be performant, as it can query<br/>/// the sound server directly every time, unlike the other query functions. You<br/>/// should call this function sparingly!<br/>/// `spec` will be filled with the sample rate, sample format, and channel<br/>/// count, if a default device exists on the system. If `name` is provided,<br/>/// will be filled with either a dynamically-allocated UTF-8 string or NULL.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetDefaultAudioInfo")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetDefaultAudioInfo([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char**")] byte** name, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* spec, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture)
		{
			int ret = SDLGetDefaultAudioInfoNative(name, spec, iscapture);
			return ret;
		}

		/// <summary>/// Get the name and preferred format of the default audio device.<br/>/// Some (but not all!) platforms have an isolated mechanism to get information<br/>/// about the "default" device. This can actually be a completely different<br/>/// device that's not in the list you get from SDL_GetAudioDeviceSpec(). It can<br/>/// even be a network address! (This is discussed in SDL_OpenAudioDevice().)<br/>/// As a result, this call is not guaranteed to be performant, as it can query<br/>/// the sound server directly every time, unlike the other query functions. You<br/>/// should call this function sparingly!<br/>/// `spec` will be filled with the sample rate, sample format, and channel<br/>/// count, if a default device exists on the system. If `name` is provided,<br/>/// will be filled with either a dynamically-allocated UTF-8 string or NULL.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetDefaultAudioInfo")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetDefaultAudioInfo([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char**")] byte** name, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec spec, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture)
		{
			fixed (SDLAudioSpec* pspec = &spec)
			{
				int ret = SDLGetDefaultAudioInfoNative(name, (SDLAudioSpec*)pspec, iscapture);
				return ret;
			}
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>
		/// this function will never return a 1 so as not to conflict with the legacy<br/>
		/// function.<br/>
		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>
		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>
		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>
		/// Passing in a `device` name of NULL requests the most reasonable default<br/>
		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>
		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>
		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>
		/// hostname/IP address for a remote audio server, or a filename in the<br/>
		/// diskaudio driver.<br/>
		/// An opened audio device starts out paused, and should be enabled for playing<br/>
		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>
		/// callback function to be called. Since the audio driver may modify the<br/>
		/// requested size of the audio buffer, you should allocate any local mixing<br/>
		/// buffers after you open the audio device.<br/>
		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>
		/// race conditions between your callback and other threads without fully<br/>
		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>
		/// callback, see SDL_AudioSpec.<br/>
		/// Managing the audio spec via 'desired' and 'obtained':<br/>
		/// When filling in the desired audio spec structure:<br/>
		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>
		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>
		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>
		/// frames_ (with stereo output, two samples--left and right--would make a<br/>
		/// single sample frame). This number should be a power of two, and may be<br/>
		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>
		/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>
		/// the application and CPU speed. Smaller values reduce latency, but can<br/>
		/// lead to underflow if the application is doing heavy processing and cannot<br/>
		/// fill the audio buffer in time. Note that the number of sample frames is<br/>
		/// directly related to time by the following formula: `ms =<br/>
		/// (sampleframes*1000)/freq`<br/>
		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->callback` should be set to a function that will be called when<br/>
		/// the audio device is ready for more data. It is passed a pointer to the<br/>
		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>
		/// usually runs in a separate thread, and so you should protect data<br/>
		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>
		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>
		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>
		/// more audio samples to be played (or for capture devices, call<br/>
		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>
		/// - `desired->userdata` is passed as the first parameter to your callback<br/>
		/// function. If you passed a NULL callback, this value is ignored.<br/>
		/// `allowed_changes` can have the following flags OR'd together:<br/>
		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>
		/// These flags specify how SDL should behave when a device cannot offer a<br/>
		/// specific feature. If the application requests a feature that the hardware<br/>
		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>
		/// For example, if you ask for float32 audio format, but the sound card only<br/>
		/// supports int16, SDL will set the hardware to int16. If you had set<br/>
		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>
		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>
		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>
		/// will keep the originally requested format in the `obtained` structure.<br/>
		/// The resulting audio specs, varying depending on hardware and on what<br/>
		/// changes were allowed, will then be written back to `obtained`.<br/>
		/// If your application can only handle one specific data format, pass a zero<br/>
		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>
		/// <br/>
		/// For compatibility with SDL 1.2, this will never return 1, since<br/>
		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenAudioDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID")]
		[LibraryImport(LibName, EntryPoint = "SDL_OpenAudioDevice")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial uint SDLOpenAudioDeviceNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "const char*")] byte* device, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "const SDL_AudioSpec*")] SDLAudioSpec* desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* obtained, [NativeName(NativeNameType.Param, "allowed_changes")] [NativeName(NativeNameType.Type, "int")] int allowedChanges);

		/// <summary>/// Open a specific audio device.<br/>/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>/// this function will never return a 1 so as not to conflict with the legacy<br/>/// function.<br/>/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>/// 2.0.5, recording is implemented and this value can be non-zero.<br/>/// Passing in a `device` name of NULL requests the most reasonable default<br/>/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>/// some drivers allow arbitrary and driver-specific strings, such as a<br/>/// hostname/IP address for a remote audio server, or a filename in the<br/>/// diskaudio driver.<br/>/// An opened audio device starts out paused, and should be enabled for playing<br/>/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>/// callback function to be called. Since the audio driver may modify the<br/>/// requested size of the audio buffer, you should allocate any local mixing<br/>/// buffers after you open the audio device.<br/>/// The audio callback runs in a separate thread in most cases; you can prevent<br/>/// race conditions between your callback and other threads without fully<br/>/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>/// callback, see SDL_AudioSpec.<br/>/// Managing the audio spec via 'desired' and 'obtained':<br/>/// When filling in the desired audio spec structure:<br/>/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>/// frames_ (with stereo output, two samples--left and right--would make a<br/>/// single sample frame). This number should be a power of two, and may be<br/>/// adjusted by the audio driver to a value more suitable for the hardware.<br/>/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>/// the application and CPU speed. Smaller values reduce latency, but can<br/>/// lead to underflow if the application is doing heavy processing and cannot<br/>/// fill the audio buffer in time. Note that the number of sample frames is<br/>/// directly related to time by the following formula: `ms =<br/>/// (sampleframes*1000)/freq`<br/>/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>/// - `desired->callback` should be set to a function that will be called when<br/>/// the audio device is ready for more data. It is passed a pointer to the<br/>/// audio buffer, and the length in bytes of the audio buffer. This function<br/>/// usually runs in a separate thread, and so you should protect data<br/>/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>/// more audio samples to be played (or for capture devices, call<br/>/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>/// - `desired->userdata` is passed as the first parameter to your callback<br/>/// function. If you passed a NULL callback, this value is ignored.<br/>/// `allowed_changes` can have the following flags OR'd together:<br/>/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>/// These flags specify how SDL should behave when a device cannot offer a<br/>/// specific feature. If the application requests a feature that the hardware<br/>/// doesn't offer, SDL will always try to get the closest equivalent.<br/>/// For example, if you ask for float32 audio format, but the sound card only<br/>/// supports int16, SDL will set the hardware to int16. If you had set<br/>/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>/// callback's float32 audio to int16 before feeding it to the hardware and<br/>/// will keep the originally requested format in the `obtained` structure.<br/>/// The resulting audio specs, varying depending on hardware and on what<br/>/// changes were allowed, will then be written back to `obtained`.<br/>/// If your application can only handle one specific data format, pass a zero<br/>/// for `allowed_changes` and let SDL transparently handle any differences.<br/>/// <br/>/// For compatibility with SDL 1.2, this will never return 1, since<br/>/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_OpenAudioDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID")]
		public static uint SDLOpenAudioDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "const char*")] byte* device, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "const SDL_AudioSpec*")] SDLAudioSpec* desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* obtained, [NativeName(NativeNameType.Param, "allowed_changes")] [NativeName(NativeNameType.Type, "int")] int allowedChanges)
		{
			uint ret = SDLOpenAudioDeviceNative(device, iscapture, desired, obtained, allowedChanges);
			return ret;
		}

		/// <summary>/// Open a specific audio device.<br/>/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>/// this function will never return a 1 so as not to conflict with the legacy<br/>/// function.<br/>/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>/// 2.0.5, recording is implemented and this value can be non-zero.<br/>/// Passing in a `device` name of NULL requests the most reasonable default<br/>/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>/// some drivers allow arbitrary and driver-specific strings, such as a<br/>/// hostname/IP address for a remote audio server, or a filename in the<br/>/// diskaudio driver.<br/>/// An opened audio device starts out paused, and should be enabled for playing<br/>/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>/// callback function to be called. Since the audio driver may modify the<br/>/// requested size of the audio buffer, you should allocate any local mixing<br/>/// buffers after you open the audio device.<br/>/// The audio callback runs in a separate thread in most cases; you can prevent<br/>/// race conditions between your callback and other threads without fully<br/>/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>/// callback, see SDL_AudioSpec.<br/>/// Managing the audio spec via 'desired' and 'obtained':<br/>/// When filling in the desired audio spec structure:<br/>/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>/// frames_ (with stereo output, two samples--left and right--would make a<br/>/// single sample frame). This number should be a power of two, and may be<br/>/// adjusted by the audio driver to a value more suitable for the hardware.<br/>/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>/// the application and CPU speed. Smaller values reduce latency, but can<br/>/// lead to underflow if the application is doing heavy processing and cannot<br/>/// fill the audio buffer in time. Note that the number of sample frames is<br/>/// directly related to time by the following formula: `ms =<br/>/// (sampleframes*1000)/freq`<br/>/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>/// - `desired->callback` should be set to a function that will be called when<br/>/// the audio device is ready for more data. It is passed a pointer to the<br/>/// audio buffer, and the length in bytes of the audio buffer. This function<br/>/// usually runs in a separate thread, and so you should protect data<br/>/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>/// more audio samples to be played (or for capture devices, call<br/>/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>/// - `desired->userdata` is passed as the first parameter to your callback<br/>/// function. If you passed a NULL callback, this value is ignored.<br/>/// `allowed_changes` can have the following flags OR'd together:<br/>/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>/// These flags specify how SDL should behave when a device cannot offer a<br/>/// specific feature. If the application requests a feature that the hardware<br/>/// doesn't offer, SDL will always try to get the closest equivalent.<br/>/// For example, if you ask for float32 audio format, but the sound card only<br/>/// supports int16, SDL will set the hardware to int16. If you had set<br/>/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>/// callback's float32 audio to int16 before feeding it to the hardware and<br/>/// will keep the originally requested format in the `obtained` structure.<br/>/// The resulting audio specs, varying depending on hardware and on what<br/>/// changes were allowed, will then be written back to `obtained`.<br/>/// If your application can only handle one specific data format, pass a zero<br/>/// for `allowed_changes` and let SDL transparently handle any differences.<br/>/// <br/>/// For compatibility with SDL 1.2, this will never return 1, since<br/>/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_OpenAudioDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID")]
		public static uint SDLOpenAudioDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "const char*")] byte* device, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "const SDL_AudioSpec*")] ref SDLAudioSpec desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* obtained, [NativeName(NativeNameType.Param, "allowed_changes")] [NativeName(NativeNameType.Type, "int")] int allowedChanges)
		{
			fixed (SDLAudioSpec* pdesired = &desired)
			{
				uint ret = SDLOpenAudioDeviceNative(device, iscapture, (SDLAudioSpec*)pdesired, obtained, allowedChanges);
				return ret;
			}
		}

		/// <summary>/// Open a specific audio device.<br/>/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>/// this function will never return a 1 so as not to conflict with the legacy<br/>/// function.<br/>/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>/// 2.0.5, recording is implemented and this value can be non-zero.<br/>/// Passing in a `device` name of NULL requests the most reasonable default<br/>/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>/// some drivers allow arbitrary and driver-specific strings, such as a<br/>/// hostname/IP address for a remote audio server, or a filename in the<br/>/// diskaudio driver.<br/>/// An opened audio device starts out paused, and should be enabled for playing<br/>/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>/// callback function to be called. Since the audio driver may modify the<br/>/// requested size of the audio buffer, you should allocate any local mixing<br/>/// buffers after you open the audio device.<br/>/// The audio callback runs in a separate thread in most cases; you can prevent<br/>/// race conditions between your callback and other threads without fully<br/>/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>/// callback, see SDL_AudioSpec.<br/>/// Managing the audio spec via 'desired' and 'obtained':<br/>/// When filling in the desired audio spec structure:<br/>/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>/// frames_ (with stereo output, two samples--left and right--would make a<br/>/// single sample frame). This number should be a power of two, and may be<br/>/// adjusted by the audio driver to a value more suitable for the hardware.<br/>/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>/// the application and CPU speed. Smaller values reduce latency, but can<br/>/// lead to underflow if the application is doing heavy processing and cannot<br/>/// fill the audio buffer in time. Note that the number of sample frames is<br/>/// directly related to time by the following formula: `ms =<br/>/// (sampleframes*1000)/freq`<br/>/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>/// - `desired->callback` should be set to a function that will be called when<br/>/// the audio device is ready for more data. It is passed a pointer to the<br/>/// audio buffer, and the length in bytes of the audio buffer. This function<br/>/// usually runs in a separate thread, and so you should protect data<br/>/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>/// more audio samples to be played (or for capture devices, call<br/>/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>/// - `desired->userdata` is passed as the first parameter to your callback<br/>/// function. If you passed a NULL callback, this value is ignored.<br/>/// `allowed_changes` can have the following flags OR'd together:<br/>/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>/// These flags specify how SDL should behave when a device cannot offer a<br/>/// specific feature. If the application requests a feature that the hardware<br/>/// doesn't offer, SDL will always try to get the closest equivalent.<br/>/// For example, if you ask for float32 audio format, but the sound card only<br/>/// supports int16, SDL will set the hardware to int16. If you had set<br/>/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>/// callback's float32 audio to int16 before feeding it to the hardware and<br/>/// will keep the originally requested format in the `obtained` structure.<br/>/// The resulting audio specs, varying depending on hardware and on what<br/>/// changes were allowed, will then be written back to `obtained`.<br/>/// If your application can only handle one specific data format, pass a zero<br/>/// for `allowed_changes` and let SDL transparently handle any differences.<br/>/// <br/>/// For compatibility with SDL 1.2, this will never return 1, since<br/>/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_OpenAudioDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID")]
		public static uint SDLOpenAudioDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "const char*")] byte* device, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "const SDL_AudioSpec*")] SDLAudioSpec* desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec obtained, [NativeName(NativeNameType.Param, "allowed_changes")] [NativeName(NativeNameType.Type, "int")] int allowedChanges)
		{
			fixed (SDLAudioSpec* pobtained = &obtained)
			{
				uint ret = SDLOpenAudioDeviceNative(device, iscapture, desired, (SDLAudioSpec*)pobtained, allowedChanges);
				return ret;
			}
		}

		/// <summary>/// Open a specific audio device.<br/>/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>/// this function will never return a 1 so as not to conflict with the legacy<br/>/// function.<br/>/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>/// 2.0.5, recording is implemented and this value can be non-zero.<br/>/// Passing in a `device` name of NULL requests the most reasonable default<br/>/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>/// some drivers allow arbitrary and driver-specific strings, such as a<br/>/// hostname/IP address for a remote audio server, or a filename in the<br/>/// diskaudio driver.<br/>/// An opened audio device starts out paused, and should be enabled for playing<br/>/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>/// callback function to be called. Since the audio driver may modify the<br/>/// requested size of the audio buffer, you should allocate any local mixing<br/>/// buffers after you open the audio device.<br/>/// The audio callback runs in a separate thread in most cases; you can prevent<br/>/// race conditions between your callback and other threads without fully<br/>/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>/// callback, see SDL_AudioSpec.<br/>/// Managing the audio spec via 'desired' and 'obtained':<br/>/// When filling in the desired audio spec structure:<br/>/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>/// frames_ (with stereo output, two samples--left and right--would make a<br/>/// single sample frame). This number should be a power of two, and may be<br/>/// adjusted by the audio driver to a value more suitable for the hardware.<br/>/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>/// the application and CPU speed. Smaller values reduce latency, but can<br/>/// lead to underflow if the application is doing heavy processing and cannot<br/>/// fill the audio buffer in time. Note that the number of sample frames is<br/>/// directly related to time by the following formula: `ms =<br/>/// (sampleframes*1000)/freq`<br/>/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>/// - `desired->callback` should be set to a function that will be called when<br/>/// the audio device is ready for more data. It is passed a pointer to the<br/>/// audio buffer, and the length in bytes of the audio buffer. This function<br/>/// usually runs in a separate thread, and so you should protect data<br/>/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>/// more audio samples to be played (or for capture devices, call<br/>/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>/// - `desired->userdata` is passed as the first parameter to your callback<br/>/// function. If you passed a NULL callback, this value is ignored.<br/>/// `allowed_changes` can have the following flags OR'd together:<br/>/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>/// These flags specify how SDL should behave when a device cannot offer a<br/>/// specific feature. If the application requests a feature that the hardware<br/>/// doesn't offer, SDL will always try to get the closest equivalent.<br/>/// For example, if you ask for float32 audio format, but the sound card only<br/>/// supports int16, SDL will set the hardware to int16. If you had set<br/>/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>/// callback's float32 audio to int16 before feeding it to the hardware and<br/>/// will keep the originally requested format in the `obtained` structure.<br/>/// The resulting audio specs, varying depending on hardware and on what<br/>/// changes were allowed, will then be written back to `obtained`.<br/>/// If your application can only handle one specific data format, pass a zero<br/>/// for `allowed_changes` and let SDL transparently handle any differences.<br/>/// <br/>/// For compatibility with SDL 1.2, this will never return 1, since<br/>/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_OpenAudioDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID")]
		public static uint SDLOpenAudioDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "const char*")] byte* device, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "const SDL_AudioSpec*")] ref SDLAudioSpec desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec obtained, [NativeName(NativeNameType.Param, "allowed_changes")] [NativeName(NativeNameType.Type, "int")] int allowedChanges)
		{
			fixed (SDLAudioSpec* pdesired = &desired)
			{
				fixed (SDLAudioSpec* pobtained = &obtained)
				{
					uint ret = SDLOpenAudioDeviceNative(device, iscapture, (SDLAudioSpec*)pdesired, (SDLAudioSpec*)pobtained, allowedChanges);
					return ret;
				}
			}
		}

		/// <summary>
		/// This function is a legacy means of querying the audio device.<br/>
		/// New programs might want to use SDL_GetAudioDeviceStatus() instead. This<br/>
		/// function is equivalent to calling...<br/>
		/// ```c<br/>
		/// SDL_GetAudioDeviceStatus(1);<br/>
		/// ```<br/>
		/// ...and is only useful if you used the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAudioStatus")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioStatus")]
		[LibraryImport(LibName, EntryPoint = "SDL_GetAudioStatus")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial SDLAudioStatus SDLGetAudioStatusNative();

		/// <summary>/// This function is a legacy means of querying the audio device.<br/>/// New programs might want to use SDL_GetAudioDeviceStatus() instead. This<br/>/// function is equivalent to calling...<br/>/// ```c<br/>/// SDL_GetAudioDeviceStatus(1);<br/>/// ```<br/>/// ...and is only useful if you used the legacy SDL_OpenAudio() function.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetAudioStatus")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioStatus")]
		public static SDLAudioStatus SDLGetAudioStatus()
		{
			SDLAudioStatus ret = SDLGetAudioStatusNative();
			return ret;
		}

		/// <summary>
		/// Use this function to get the current audio state of an audio device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAudioDeviceStatus")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioStatus")]
		[LibraryImport(LibName, EntryPoint = "SDL_GetAudioDeviceStatus")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial SDLAudioStatus SDLGetAudioDeviceStatusNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_AudioDeviceID")] uint dev);

		/// <summary>/// Use this function to get the current audio state of an audio device.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetAudioDeviceStatus")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioStatus")]
		public static SDLAudioStatus SDLGetAudioDeviceStatus([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_AudioDeviceID")] uint dev)
		{
			SDLAudioStatus ret = SDLGetAudioDeviceStatusNative(dev);
			return ret;
		}
	}
}
