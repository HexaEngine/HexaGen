// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL2
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Determine whether two rectangles intersect.<br/>
		/// If either pointer is NULL the function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[LibraryImport(LibName, EntryPoint = "SDL_HasIntersection")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial SDLBool SDLHasIntersectionNative([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* b);

		/// <summary>/// Determine whether two rectangles intersect.<br/>/// If either pointer is NULL the function will return SDL_FALSE.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_HasIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLHasIntersection([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* b)
		{
			SDLBool ret = SDLHasIntersectionNative(a, b);
			return ret;
		}

		/// <summary>/// Determine whether two rectangles intersect.<br/>/// If either pointer is NULL the function will return SDL_FALSE.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_HasIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLHasIntersection([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect b)
		{
			fixed (SDLRect* pb = &b)
			{
				SDLBool ret = SDLHasIntersectionNative(a, (SDLRect*)pb);
				return ret;
			}
		}

		/// <summary>
		/// Calculate the intersection of two rectangles.<br/>
		/// If `result` is NULL then this function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectRect")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[LibraryImport(LibName, EntryPoint = "SDL_IntersectRect")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial SDLBool SDLIntersectRectNative([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* result);

		/// <summary>/// Calculate the intersection of two rectangles.<br/>/// If `result` is NULL then this function will return SDL_FALSE.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRect")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* result)
		{
			SDLBool ret = SDLIntersectRectNative(a, b, result);
			return ret;
		}

		/// <summary>/// Calculate the intersection of two rectangles.<br/>/// If `result` is NULL then this function will return SDL_FALSE.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRect")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* result)
		{
			fixed (SDLRect* pb = &b)
			{
				SDLBool ret = SDLIntersectRectNative(a, (SDLRect*)pb, result);
				return ret;
			}
		}

		/// <summary>/// Calculate the intersection of two rectangles.<br/>/// If `result` is NULL then this function will return SDL_FALSE.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRect")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect result)
		{
			fixed (SDLRect* presult = &result)
			{
				SDLBool ret = SDLIntersectRectNative(a, b, (SDLRect*)presult);
				return ret;
			}
		}

		/// <summary>/// Calculate the intersection of two rectangles.<br/>/// If `result` is NULL then this function will return SDL_FALSE.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRect")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect result)
		{
			fixed (SDLRect* pb = &b)
			{
				fixed (SDLRect* presult = &result)
				{
					SDLBool ret = SDLIntersectRectNative(a, (SDLRect*)pb, (SDLRect*)presult);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the union of two rectangles.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnionRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "SDL_UnionRect")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SDLUnionRectNative([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* result);

		/// <summary>/// Calculate the union of two rectangles.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_UnionRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLUnionRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* result)
		{
			SDLUnionRectNative(a, b, result);
		}

		/// <summary>/// Calculate the union of two rectangles.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_UnionRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLUnionRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* result)
		{
			fixed (SDLRect* pb = &b)
			{
				SDLUnionRectNative(a, (SDLRect*)pb, result);
			}
		}

		/// <summary>/// Calculate the union of two rectangles.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_UnionRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLUnionRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect result)
		{
			fixed (SDLRect* presult = &result)
			{
				SDLUnionRectNative(a, b, (SDLRect*)presult);
			}
		}

		/// <summary>/// Calculate the union of two rectangles.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_UnionRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLUnionRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect result)
		{
			fixed (SDLRect* pb = &b)
			{
				fixed (SDLRect* presult = &result)
				{
					SDLUnionRectNative(a, (SDLRect*)pb, (SDLRect*)presult);
				}
			}
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnclosePoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[LibraryImport(LibName, EntryPoint = "SDL_EnclosePoints")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial SDLBool SDLEnclosePointsNative([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_Point*")] SDLPoint* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* result);

		/// <summary>/// Calculate a minimal rectangle enclosing a set of points.<br/>/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>/// considered.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_EnclosePoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLEnclosePoints([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_Point*")] SDLPoint* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* result)
		{
			SDLBool ret = SDLEnclosePointsNative(points, count, clip, result);
			return ret;
		}

		/// <summary>/// Calculate a minimal rectangle enclosing a set of points.<br/>/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>/// considered.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_EnclosePoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLEnclosePoints([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_Point*")] SDLPoint* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* result)
		{
			fixed (SDLRect* pclip = &clip)
			{
				SDLBool ret = SDLEnclosePointsNative(points, count, (SDLRect*)pclip, result);
				return ret;
			}
		}

		/// <summary>/// Calculate a minimal rectangle enclosing a set of points.<br/>/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>/// considered.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_EnclosePoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLEnclosePoints([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_Point*")] SDLPoint* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect result)
		{
			fixed (SDLRect* presult = &result)
			{
				SDLBool ret = SDLEnclosePointsNative(points, count, clip, (SDLRect*)presult);
				return ret;
			}
		}

		/// <summary>/// Calculate a minimal rectangle enclosing a set of points.<br/>/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>/// considered.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_EnclosePoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLEnclosePoints([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_Point*")] SDLPoint* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect result)
		{
			fixed (SDLRect* pclip = &clip)
			{
				fixed (SDLRect* presult = &result)
				{
					SDLBool ret = SDLEnclosePointsNative(points, count, (SDLRect*)pclip, (SDLRect*)presult);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[LibraryImport(LibName, EntryPoint = "SDL_IntersectRectAndLine")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial SDLBool SDLIntersectRectAndLineNative([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] int* y2);

		/// <summary>/// Calculate the intersection of a rectangle and line segment.<br/>/// This function is used to clip a line segment to a rectangle. A line segment<br/>/// contained entirely within the rectangle or that does not intersect will<br/>/// remain unchanged. A line segment that crosses the rectangle at either or<br/>/// both ends will be clipped to the boundary of the rectangle and the new<br/>/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] int* y2)
		{
			SDLBool ret = SDLIntersectRectAndLineNative(rect, x1, y1, x2, y2);
			return ret;
		}

		/// <summary>/// Calculate the intersection of a rectangle and line segment.<br/>/// This function is used to clip a line segment to a rectangle. A line segment<br/>/// contained entirely within the rectangle or that does not intersect will<br/>/// remain unchanged. A line segment that crosses the rectangle at either or<br/>/// both ends will be clipped to the boundary of the rectangle and the new<br/>/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] int* y2)
		{
			fixed (int* px1 = &x1)
			{
				SDLBool ret = SDLIntersectRectAndLineNative(rect, (int*)px1, y1, x2, y2);
				return ret;
			}
		}

		/// <summary>/// Calculate the intersection of a rectangle and line segment.<br/>/// This function is used to clip a line segment to a rectangle. A line segment<br/>/// contained entirely within the rectangle or that does not intersect will<br/>/// remain unchanged. A line segment that crosses the rectangle at either or<br/>/// both ends will be clipped to the boundary of the rectangle and the new<br/>/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] int* y2)
		{
			fixed (int* py1 = &y1)
			{
				SDLBool ret = SDLIntersectRectAndLineNative(rect, x1, (int*)py1, x2, y2);
				return ret;
			}
		}

		/// <summary>/// Calculate the intersection of a rectangle and line segment.<br/>/// This function is used to clip a line segment to a rectangle. A line segment<br/>/// contained entirely within the rectangle or that does not intersect will<br/>/// remain unchanged. A line segment that crosses the rectangle at either or<br/>/// both ends will be clipped to the boundary of the rectangle and the new<br/>/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] int* y2)
		{
			fixed (int* px1 = &x1)
			{
				fixed (int* py1 = &y1)
				{
					SDLBool ret = SDLIntersectRectAndLineNative(rect, (int*)px1, (int*)py1, x2, y2);
					return ret;
				}
			}
		}

		/// <summary>/// Calculate the intersection of a rectangle and line segment.<br/>/// This function is used to clip a line segment to a rectangle. A line segment<br/>/// contained entirely within the rectangle or that does not intersect will<br/>/// remain unchanged. A line segment that crosses the rectangle at either or<br/>/// both ends will be clipped to the boundary of the rectangle and the new<br/>/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] int* y2)
		{
			fixed (int* px2 = &x2)
			{
				SDLBool ret = SDLIntersectRectAndLineNative(rect, x1, y1, (int*)px2, y2);
				return ret;
			}
		}

		/// <summary>/// Calculate the intersection of a rectangle and line segment.<br/>/// This function is used to clip a line segment to a rectangle. A line segment<br/>/// contained entirely within the rectangle or that does not intersect will<br/>/// remain unchanged. A line segment that crosses the rectangle at either or<br/>/// both ends will be clipped to the boundary of the rectangle and the new<br/>/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] int* y2)
		{
			fixed (int* px1 = &x1)
			{
				fixed (int* px2 = &x2)
				{
					SDLBool ret = SDLIntersectRectAndLineNative(rect, (int*)px1, y1, (int*)px2, y2);
					return ret;
				}
			}
		}

		/// <summary>/// Calculate the intersection of a rectangle and line segment.<br/>/// This function is used to clip a line segment to a rectangle. A line segment<br/>/// contained entirely within the rectangle or that does not intersect will<br/>/// remain unchanged. A line segment that crosses the rectangle at either or<br/>/// both ends will be clipped to the boundary of the rectangle and the new<br/>/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] int* y2)
		{
			fixed (int* py1 = &y1)
			{
				fixed (int* px2 = &x2)
				{
					SDLBool ret = SDLIntersectRectAndLineNative(rect, x1, (int*)py1, (int*)px2, y2);
					return ret;
				}
			}
		}

		/// <summary>/// Calculate the intersection of a rectangle and line segment.<br/>/// This function is used to clip a line segment to a rectangle. A line segment<br/>/// contained entirely within the rectangle or that does not intersect will<br/>/// remain unchanged. A line segment that crosses the rectangle at either or<br/>/// both ends will be clipped to the boundary of the rectangle and the new<br/>/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] int* y2)
		{
			fixed (int* px1 = &x1)
			{
				fixed (int* py1 = &y1)
				{
					fixed (int* px2 = &x2)
					{
						SDLBool ret = SDLIntersectRectAndLineNative(rect, (int*)px1, (int*)py1, (int*)px2, y2);
						return ret;
					}
				}
			}
		}

		/// <summary>/// Calculate the intersection of a rectangle and line segment.<br/>/// This function is used to clip a line segment to a rectangle. A line segment<br/>/// contained entirely within the rectangle or that does not intersect will<br/>/// remain unchanged. A line segment that crosses the rectangle at either or<br/>/// both ends will be clipped to the boundary of the rectangle and the new<br/>/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] ref int y2)
		{
			fixed (int* py2 = &y2)
			{
				SDLBool ret = SDLIntersectRectAndLineNative(rect, x1, y1, x2, (int*)py2);
				return ret;
			}
		}

		/// <summary>/// Calculate the intersection of a rectangle and line segment.<br/>/// This function is used to clip a line segment to a rectangle. A line segment<br/>/// contained entirely within the rectangle or that does not intersect will<br/>/// remain unchanged. A line segment that crosses the rectangle at either or<br/>/// both ends will be clipped to the boundary of the rectangle and the new<br/>/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] ref int y2)
		{
			fixed (int* px1 = &x1)
			{
				fixed (int* py2 = &y2)
				{
					SDLBool ret = SDLIntersectRectAndLineNative(rect, (int*)px1, y1, x2, (int*)py2);
					return ret;
				}
			}
		}

		/// <summary>/// Calculate the intersection of a rectangle and line segment.<br/>/// This function is used to clip a line segment to a rectangle. A line segment<br/>/// contained entirely within the rectangle or that does not intersect will<br/>/// remain unchanged. A line segment that crosses the rectangle at either or<br/>/// both ends will be clipped to the boundary of the rectangle and the new<br/>/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] ref int y2)
		{
			fixed (int* py1 = &y1)
			{
				fixed (int* py2 = &y2)
				{
					SDLBool ret = SDLIntersectRectAndLineNative(rect, x1, (int*)py1, x2, (int*)py2);
					return ret;
				}
			}
		}

		/// <summary>/// Calculate the intersection of a rectangle and line segment.<br/>/// This function is used to clip a line segment to a rectangle. A line segment<br/>/// contained entirely within the rectangle or that does not intersect will<br/>/// remain unchanged. A line segment that crosses the rectangle at either or<br/>/// both ends will be clipped to the boundary of the rectangle and the new<br/>/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] ref int y2)
		{
			fixed (int* px1 = &x1)
			{
				fixed (int* py1 = &y1)
				{
					fixed (int* py2 = &y2)
					{
						SDLBool ret = SDLIntersectRectAndLineNative(rect, (int*)px1, (int*)py1, x2, (int*)py2);
						return ret;
					}
				}
			}
		}

		/// <summary>/// Calculate the intersection of a rectangle and line segment.<br/>/// This function is used to clip a line segment to a rectangle. A line segment<br/>/// contained entirely within the rectangle or that does not intersect will<br/>/// remain unchanged. A line segment that crosses the rectangle at either or<br/>/// both ends will be clipped to the boundary of the rectangle and the new<br/>/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] ref int y2)
		{
			fixed (int* px2 = &x2)
			{
				fixed (int* py2 = &y2)
				{
					SDLBool ret = SDLIntersectRectAndLineNative(rect, x1, y1, (int*)px2, (int*)py2);
					return ret;
				}
			}
		}

		/// <summary>/// Calculate the intersection of a rectangle and line segment.<br/>/// This function is used to clip a line segment to a rectangle. A line segment<br/>/// contained entirely within the rectangle or that does not intersect will<br/>/// remain unchanged. A line segment that crosses the rectangle at either or<br/>/// both ends will be clipped to the boundary of the rectangle and the new<br/>/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] ref int y2)
		{
			fixed (int* px1 = &x1)
			{
				fixed (int* px2 = &x2)
				{
					fixed (int* py2 = &y2)
					{
						SDLBool ret = SDLIntersectRectAndLineNative(rect, (int*)px1, y1, (int*)px2, (int*)py2);
						return ret;
					}
				}
			}
		}

		/// <summary>/// Calculate the intersection of a rectangle and line segment.<br/>/// This function is used to clip a line segment to a rectangle. A line segment<br/>/// contained entirely within the rectangle or that does not intersect will<br/>/// remain unchanged. A line segment that crosses the rectangle at either or<br/>/// both ends will be clipped to the boundary of the rectangle and the new<br/>/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] ref int y2)
		{
			fixed (int* py1 = &y1)
			{
				fixed (int* px2 = &x2)
				{
					fixed (int* py2 = &y2)
					{
						SDLBool ret = SDLIntersectRectAndLineNative(rect, x1, (int*)py1, (int*)px2, (int*)py2);
						return ret;
					}
				}
			}
		}

		/// <summary>/// Calculate the intersection of a rectangle and line segment.<br/>/// This function is used to clip a line segment to a rectangle. A line segment<br/>/// contained entirely within the rectangle or that does not intersect will<br/>/// remain unchanged. A line segment that crosses the rectangle at either or<br/>/// both ends will be clipped to the boundary of the rectangle and the new<br/>/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] ref int y2)
		{
			fixed (int* px1 = &x1)
			{
				fixed (int* py1 = &y1)
				{
					fixed (int* px2 = &x2)
					{
						fixed (int* py2 = &y2)
						{
							SDLBool ret = SDLIntersectRectAndLineNative(rect, (int*)px1, (int*)py1, (int*)px2, (int*)py2);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Determine whether two rectangles intersect with float precision.<br/>
		/// If either pointer is NULL the function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasIntersectionF")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[LibraryImport(LibName, EntryPoint = "SDL_HasIntersectionF")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial SDLBool SDLHasIntersectionFNative([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* b);

		/// <summary>/// Determine whether two rectangles intersect with float precision.<br/>/// If either pointer is NULL the function will return SDL_FALSE.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_HasIntersectionF")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLHasIntersectionF([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* b)
		{
			SDLBool ret = SDLHasIntersectionFNative(a, b);
			return ret;
		}

		/// <summary>/// Determine whether two rectangles intersect with float precision.<br/>/// If either pointer is NULL the function will return SDL_FALSE.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_HasIntersectionF")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLHasIntersectionF([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect b)
		{
			fixed (SDLFRect* pb = &b)
			{
				SDLBool ret = SDLHasIntersectionFNative(a, (SDLFRect*)pb);
				return ret;
			}
		}

		/// <summary>
		/// Calculate the intersection of two rectangles with float precision.<br/>
		/// If `result` is NULL then this function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectFRect")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[LibraryImport(LibName, EntryPoint = "SDL_IntersectFRect")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial SDLBool SDLIntersectFRectNative([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] SDLFRect* result);

		/// <summary>/// Calculate the intersection of two rectangles with float precision.<br/>/// If `result` is NULL then this function will return SDL_FALSE.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRect")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] SDLFRect* result)
		{
			SDLBool ret = SDLIntersectFRectNative(a, b, result);
			return ret;
		}

		/// <summary>/// Calculate the intersection of two rectangles with float precision.<br/>/// If `result` is NULL then this function will return SDL_FALSE.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRect")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] SDLFRect* result)
		{
			fixed (SDLFRect* pb = &b)
			{
				SDLBool ret = SDLIntersectFRectNative(a, (SDLFRect*)pb, result);
				return ret;
			}
		}

		/// <summary>/// Calculate the intersection of two rectangles with float precision.<br/>/// If `result` is NULL then this function will return SDL_FALSE.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRect")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] ref SDLFRect result)
		{
			fixed (SDLFRect* presult = &result)
			{
				SDLBool ret = SDLIntersectFRectNative(a, b, (SDLFRect*)presult);
				return ret;
			}
		}

		/// <summary>/// Calculate the intersection of two rectangles with float precision.<br/>/// If `result` is NULL then this function will return SDL_FALSE.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRect")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] ref SDLFRect result)
		{
			fixed (SDLFRect* pb = &b)
			{
				fixed (SDLFRect* presult = &result)
				{
					SDLBool ret = SDLIntersectFRectNative(a, (SDLFRect*)pb, (SDLFRect*)presult);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the union of two rectangles with float precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnionFRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "SDL_UnionFRect")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SDLUnionFRectNative([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] SDLFRect* result);

		/// <summary>/// Calculate the union of two rectangles with float precision.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_UnionFRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLUnionFRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] SDLFRect* result)
		{
			SDLUnionFRectNative(a, b, result);
		}

		/// <summary>/// Calculate the union of two rectangles with float precision.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_UnionFRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLUnionFRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] SDLFRect* result)
		{
			fixed (SDLFRect* pb = &b)
			{
				SDLUnionFRectNative(a, (SDLFRect*)pb, result);
			}
		}

		/// <summary>/// Calculate the union of two rectangles with float precision.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_UnionFRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLUnionFRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] ref SDLFRect result)
		{
			fixed (SDLFRect* presult = &result)
			{
				SDLUnionFRectNative(a, b, (SDLFRect*)presult);
			}
		}

		/// <summary>/// Calculate the union of two rectangles with float precision.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_UnionFRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLUnionFRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] ref SDLFRect result)
		{
			fixed (SDLFRect* pb = &b)
			{
				fixed (SDLFRect* presult = &result)
				{
					SDLUnionFRectNative(a, (SDLFRect*)pb, (SDLFRect*)presult);
				}
			}
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points with float<br/>
		/// precision.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EncloseFPoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[LibraryImport(LibName, EntryPoint = "SDL_EncloseFPoints")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial SDLBool SDLEncloseFPointsNative([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] SDLFPoint* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] SDLFRect* result);

		/// <summary>/// Calculate a minimal rectangle enclosing a set of points with float<br/>/// precision.<br/>/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>/// considered.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_EncloseFPoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLEncloseFPoints([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] SDLFPoint* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] SDLFRect* result)
		{
			SDLBool ret = SDLEncloseFPointsNative(points, count, clip, result);
			return ret;
		}

		/// <summary>/// Calculate a minimal rectangle enclosing a set of points with float<br/>/// precision.<br/>/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>/// considered.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_EncloseFPoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLEncloseFPoints([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] SDLFPoint* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] SDLFRect* result)
		{
			fixed (SDLFRect* pclip = &clip)
			{
				SDLBool ret = SDLEncloseFPointsNative(points, count, (SDLFRect*)pclip, result);
				return ret;
			}
		}

		/// <summary>/// Calculate a minimal rectangle enclosing a set of points with float<br/>/// precision.<br/>/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>/// considered.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_EncloseFPoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLEncloseFPoints([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] SDLFPoint* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] ref SDLFRect result)
		{
			fixed (SDLFRect* presult = &result)
			{
				SDLBool ret = SDLEncloseFPointsNative(points, count, clip, (SDLFRect*)presult);
				return ret;
			}
		}

		/// <summary>/// Calculate a minimal rectangle enclosing a set of points with float<br/>/// precision.<br/>/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>/// considered.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_EncloseFPoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLEncloseFPoints([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] SDLFPoint* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] ref SDLFRect result)
		{
			fixed (SDLFRect* pclip = &clip)
			{
				fixed (SDLFRect* presult = &result)
				{
					SDLBool ret = SDLEncloseFPointsNative(points, count, (SDLFRect*)pclip, (SDLFRect*)presult);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[LibraryImport(LibName, EntryPoint = "SDL_IntersectFRectAndLine")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial SDLBool SDLIntersectFRectAndLineNative([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] float* y2);

		/// <summary>/// Calculate the intersection of a rectangle and line segment with float<br/>/// precision.<br/>/// This function is used to clip a line segment to a rectangle. A line segment<br/>/// contained entirely within the rectangle or that does not intersect will<br/>/// remain unchanged. A line segment that crosses the rectangle at either or<br/>/// both ends will be clipped to the boundary of the rectangle and the new<br/>/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] float* y2)
		{
			SDLBool ret = SDLIntersectFRectAndLineNative(rect, x1, y1, x2, y2);
			return ret;
		}

		/// <summary>/// Calculate the intersection of a rectangle and line segment with float<br/>/// precision.<br/>/// This function is used to clip a line segment to a rectangle. A line segment<br/>/// contained entirely within the rectangle or that does not intersect will<br/>/// remain unchanged. A line segment that crosses the rectangle at either or<br/>/// both ends will be clipped to the boundary of the rectangle and the new<br/>/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] float* y2)
		{
			fixed (float* px1 = &x1)
			{
				SDLBool ret = SDLIntersectFRectAndLineNative(rect, (float*)px1, y1, x2, y2);
				return ret;
			}
		}

		/// <summary>/// Calculate the intersection of a rectangle and line segment with float<br/>/// precision.<br/>/// This function is used to clip a line segment to a rectangle. A line segment<br/>/// contained entirely within the rectangle or that does not intersect will<br/>/// remain unchanged. A line segment that crosses the rectangle at either or<br/>/// both ends will be clipped to the boundary of the rectangle and the new<br/>/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] float* y2)
		{
			fixed (float* py1 = &y1)
			{
				SDLBool ret = SDLIntersectFRectAndLineNative(rect, x1, (float*)py1, x2, y2);
				return ret;
			}
		}

		/// <summary>/// Calculate the intersection of a rectangle and line segment with float<br/>/// precision.<br/>/// This function is used to clip a line segment to a rectangle. A line segment<br/>/// contained entirely within the rectangle or that does not intersect will<br/>/// remain unchanged. A line segment that crosses the rectangle at either or<br/>/// both ends will be clipped to the boundary of the rectangle and the new<br/>/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] float* y2)
		{
			fixed (float* px1 = &x1)
			{
				fixed (float* py1 = &y1)
				{
					SDLBool ret = SDLIntersectFRectAndLineNative(rect, (float*)px1, (float*)py1, x2, y2);
					return ret;
				}
			}
		}

		/// <summary>/// Calculate the intersection of a rectangle and line segment with float<br/>/// precision.<br/>/// This function is used to clip a line segment to a rectangle. A line segment<br/>/// contained entirely within the rectangle or that does not intersect will<br/>/// remain unchanged. A line segment that crosses the rectangle at either or<br/>/// both ends will be clipped to the boundary of the rectangle and the new<br/>/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] float* y2)
		{
			fixed (float* px2 = &x2)
			{
				SDLBool ret = SDLIntersectFRectAndLineNative(rect, x1, y1, (float*)px2, y2);
				return ret;
			}
		}

		/// <summary>/// Calculate the intersection of a rectangle and line segment with float<br/>/// precision.<br/>/// This function is used to clip a line segment to a rectangle. A line segment<br/>/// contained entirely within the rectangle or that does not intersect will<br/>/// remain unchanged. A line segment that crosses the rectangle at either or<br/>/// both ends will be clipped to the boundary of the rectangle and the new<br/>/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] float* y2)
		{
			fixed (float* px1 = &x1)
			{
				fixed (float* px2 = &x2)
				{
					SDLBool ret = SDLIntersectFRectAndLineNative(rect, (float*)px1, y1, (float*)px2, y2);
					return ret;
				}
			}
		}

		/// <summary>/// Calculate the intersection of a rectangle and line segment with float<br/>/// precision.<br/>/// This function is used to clip a line segment to a rectangle. A line segment<br/>/// contained entirely within the rectangle or that does not intersect will<br/>/// remain unchanged. A line segment that crosses the rectangle at either or<br/>/// both ends will be clipped to the boundary of the rectangle and the new<br/>/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] float* y2)
		{
			fixed (float* py1 = &y1)
			{
				fixed (float* px2 = &x2)
				{
					SDLBool ret = SDLIntersectFRectAndLineNative(rect, x1, (float*)py1, (float*)px2, y2);
					return ret;
				}
			}
		}

		/// <summary>/// Calculate the intersection of a rectangle and line segment with float<br/>/// precision.<br/>/// This function is used to clip a line segment to a rectangle. A line segment<br/>/// contained entirely within the rectangle or that does not intersect will<br/>/// remain unchanged. A line segment that crosses the rectangle at either or<br/>/// both ends will be clipped to the boundary of the rectangle and the new<br/>/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] float* y2)
		{
			fixed (float* px1 = &x1)
			{
				fixed (float* py1 = &y1)
				{
					fixed (float* px2 = &x2)
					{
						SDLBool ret = SDLIntersectFRectAndLineNative(rect, (float*)px1, (float*)py1, (float*)px2, y2);
						return ret;
					}
				}
			}
		}

		/// <summary>/// Calculate the intersection of a rectangle and line segment with float<br/>/// precision.<br/>/// This function is used to clip a line segment to a rectangle. A line segment<br/>/// contained entirely within the rectangle or that does not intersect will<br/>/// remain unchanged. A line segment that crosses the rectangle at either or<br/>/// both ends will be clipped to the boundary of the rectangle and the new<br/>/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] ref float y2)
		{
			fixed (float* py2 = &y2)
			{
				SDLBool ret = SDLIntersectFRectAndLineNative(rect, x1, y1, x2, (float*)py2);
				return ret;
			}
		}

		/// <summary>/// Calculate the intersection of a rectangle and line segment with float<br/>/// precision.<br/>/// This function is used to clip a line segment to a rectangle. A line segment<br/>/// contained entirely within the rectangle or that does not intersect will<br/>/// remain unchanged. A line segment that crosses the rectangle at either or<br/>/// both ends will be clipped to the boundary of the rectangle and the new<br/>/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] ref float y2)
		{
			fixed (float* px1 = &x1)
			{
				fixed (float* py2 = &y2)
				{
					SDLBool ret = SDLIntersectFRectAndLineNative(rect, (float*)px1, y1, x2, (float*)py2);
					return ret;
				}
			}
		}

		/// <summary>/// Calculate the intersection of a rectangle and line segment with float<br/>/// precision.<br/>/// This function is used to clip a line segment to a rectangle. A line segment<br/>/// contained entirely within the rectangle or that does not intersect will<br/>/// remain unchanged. A line segment that crosses the rectangle at either or<br/>/// both ends will be clipped to the boundary of the rectangle and the new<br/>/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] ref float y2)
		{
			fixed (float* py1 = &y1)
			{
				fixed (float* py2 = &y2)
				{
					SDLBool ret = SDLIntersectFRectAndLineNative(rect, x1, (float*)py1, x2, (float*)py2);
					return ret;
				}
			}
		}

		/// <summary>/// Calculate the intersection of a rectangle and line segment with float<br/>/// precision.<br/>/// This function is used to clip a line segment to a rectangle. A line segment<br/>/// contained entirely within the rectangle or that does not intersect will<br/>/// remain unchanged. A line segment that crosses the rectangle at either or<br/>/// both ends will be clipped to the boundary of the rectangle and the new<br/>/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] ref float y2)
		{
			fixed (float* px1 = &x1)
			{
				fixed (float* py1 = &y1)
				{
					fixed (float* py2 = &y2)
					{
						SDLBool ret = SDLIntersectFRectAndLineNative(rect, (float*)px1, (float*)py1, x2, (float*)py2);
						return ret;
					}
				}
			}
		}

		/// <summary>/// Calculate the intersection of a rectangle and line segment with float<br/>/// precision.<br/>/// This function is used to clip a line segment to a rectangle. A line segment<br/>/// contained entirely within the rectangle or that does not intersect will<br/>/// remain unchanged. A line segment that crosses the rectangle at either or<br/>/// both ends will be clipped to the boundary of the rectangle and the new<br/>/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] ref float y2)
		{
			fixed (float* px2 = &x2)
			{
				fixed (float* py2 = &y2)
				{
					SDLBool ret = SDLIntersectFRectAndLineNative(rect, x1, y1, (float*)px2, (float*)py2);
					return ret;
				}
			}
		}

		/// <summary>/// Calculate the intersection of a rectangle and line segment with float<br/>/// precision.<br/>/// This function is used to clip a line segment to a rectangle. A line segment<br/>/// contained entirely within the rectangle or that does not intersect will<br/>/// remain unchanged. A line segment that crosses the rectangle at either or<br/>/// both ends will be clipped to the boundary of the rectangle and the new<br/>/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] ref float y2)
		{
			fixed (float* px1 = &x1)
			{
				fixed (float* px2 = &x2)
				{
					fixed (float* py2 = &y2)
					{
						SDLBool ret = SDLIntersectFRectAndLineNative(rect, (float*)px1, y1, (float*)px2, (float*)py2);
						return ret;
					}
				}
			}
		}

		/// <summary>/// Calculate the intersection of a rectangle and line segment with float<br/>/// precision.<br/>/// This function is used to clip a line segment to a rectangle. A line segment<br/>/// contained entirely within the rectangle or that does not intersect will<br/>/// remain unchanged. A line segment that crosses the rectangle at either or<br/>/// both ends will be clipped to the boundary of the rectangle and the new<br/>/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] ref float y2)
		{
			fixed (float* py1 = &y1)
			{
				fixed (float* px2 = &x2)
				{
					fixed (float* py2 = &y2)
					{
						SDLBool ret = SDLIntersectFRectAndLineNative(rect, x1, (float*)py1, (float*)px2, (float*)py2);
						return ret;
					}
				}
			}
		}

		/// <summary>/// Calculate the intersection of a rectangle and line segment with float<br/>/// precision.<br/>/// This function is used to clip a line segment to a rectangle. A line segment<br/>/// contained entirely within the rectangle or that does not intersect will<br/>/// remain unchanged. A line segment that crosses the rectangle at either or<br/>/// both ends will be clipped to the boundary of the rectangle and the new<br/>/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] ref float y2)
		{
			fixed (float* px1 = &x1)
			{
				fixed (float* py1 = &y1)
				{
					fixed (float* px2 = &x2)
					{
						fixed (float* py2 = &y2)
						{
							SDLBool ret = SDLIntersectFRectAndLineNative(rect, (float*)px1, (float*)py1, (float*)px2, (float*)py2);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Compose a custom blend mode for renderers.<br/>
		/// The functions SDL_SetRenderDrawBlendMode and SDL_SetTextureBlendMode accept<br/>
		/// the SDL_BlendMode returned by this function if the renderer supports it.<br/>
		/// A blend mode controls how the pixels from a drawing operation (source) get<br/>
		/// combined with the pixels from the render target (destination). First, the<br/>
		/// components of the source and destination pixels get multiplied with their<br/>
		/// blend factors. Then, the blend operation takes the two products and<br/>
		/// calculates the result that will get stored in the render target.<br/>
		/// Expressed in pseudocode, it would look like this:<br/>
		/// ```c<br/>
		/// dstRGB = colorOperation(srcRGB * srcColorFactor, dstRGB * dstColorFactor);<br/>
		/// dstA = alphaOperation(srcA * srcAlphaFactor, dstA * dstAlphaFactor);<br/>
		/// ```<br/>
		/// Where the functions `colorOperation(src, dst)` and `alphaOperation(src,<br/>
		/// dst)` can return one of the following:<br/>
		/// - `src + dst`<br/>
		/// - `src - dst`<br/>
		/// - `dst - src`<br/>
		/// - `min(src, dst)`<br/>
		/// - `max(src, dst)`<br/>
		/// The red, green, and blue components are always multiplied with the first,<br/>
		/// second, and third components of the SDL_BlendFactor, respectively. The<br/>
		/// fourth component is not used.<br/>
		/// The alpha component is always multiplied with the fourth component of the<br/>
		/// SDL_BlendFactor. The other components are not used in the alpha<br/>
		/// calculation.<br/>
		/// Support for these blend modes varies for each renderer. To check if a<br/>
		/// specific SDL_BlendMode is supported, create a renderer and pass it to<br/>
		/// either SDL_SetRenderDrawBlendMode or SDL_SetTextureBlendMode. They will<br/>
		/// return with an error if the blend mode is not supported.<br/>
		/// This list describes the support of custom blend modes for each renderer in<br/>
		/// SDL 2.0.6. All renderers support the four blend modes listed in the<br/>
		/// SDL_BlendMode enumeration.<br/>
		/// - **direct3d**: Supports all operations with all factors. However, some<br/>
		/// factors produce unexpected results with `SDL_BLENDOPERATION_MINIMUM` and<br/>
		/// `SDL_BLENDOPERATION_MAXIMUM`.<br/>
		/// - **direct3d11**: Same as Direct3D 9.<br/>
		/// - **opengl**: Supports the `SDL_BLENDOPERATION_ADD` operation with all<br/>
		/// factors. OpenGL versions 1.1, 1.2, and 1.3 do not work correctly with SDL<br/>
		/// 2.0.6.<br/>
		/// - **opengles**: Supports the `SDL_BLENDOPERATION_ADD` operation with all<br/>
		/// factors. Color and alpha factors need to be the same. OpenGL ES 1<br/>
		/// implementation specific: May also support `SDL_BLENDOPERATION_SUBTRACT`<br/>
		/// and `SDL_BLENDOPERATION_REV_SUBTRACT`. May support color and alpha<br/>
		/// operations being different from each other. May support color and alpha<br/>
		/// factors being different from each other.<br/>
		/// - **opengles2**: Supports the `SDL_BLENDOPERATION_ADD`,<br/>
		/// `SDL_BLENDOPERATION_SUBTRACT`, `SDL_BLENDOPERATION_REV_SUBTRACT`<br/>
		/// operations with all factors.<br/>
		/// - **psp**: No custom blend mode support.<br/>
		/// - **software**: No custom blend mode support.<br/>
		/// Some renderers do not provide an alpha component for the default render<br/>
		/// target. The `SDL_BLENDFACTOR_DST_ALPHA` and<br/>
		/// `SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA` factors do not have an effect in this<br/>
		/// case.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ComposeCustomBlendMode")]
		[return: NativeName(NativeNameType.Type, "SDL_BlendMode")]
		[LibraryImport(LibName, EntryPoint = "SDL_ComposeCustomBlendMode")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial SDLBlendMode SDLComposeCustomBlendModeNative([NativeName(NativeNameType.Param, "srcColorFactor")] [NativeName(NativeNameType.Type, "SDL_BlendFactor")] SDLBlendFactor srcColorFactor, [NativeName(NativeNameType.Param, "dstColorFactor")] [NativeName(NativeNameType.Type, "SDL_BlendFactor")] SDLBlendFactor dstColorFactor, [NativeName(NativeNameType.Param, "colorOperation")] [NativeName(NativeNameType.Type, "SDL_BlendOperation")] SDLBlendOperation colorOperation, [NativeName(NativeNameType.Param, "srcAlphaFactor")] [NativeName(NativeNameType.Type, "SDL_BlendFactor")] SDLBlendFactor srcAlphaFactor, [NativeName(NativeNameType.Param, "dstAlphaFactor")] [NativeName(NativeNameType.Type, "SDL_BlendFactor")] SDLBlendFactor dstAlphaFactor, [NativeName(NativeNameType.Param, "alphaOperation")] [NativeName(NativeNameType.Type, "SDL_BlendOperation")] SDLBlendOperation alphaOperation);

		/// <summary>/// Compose a custom blend mode for renderers.<br/>/// The functions SDL_SetRenderDrawBlendMode and SDL_SetTextureBlendMode accept<br/>/// the SDL_BlendMode returned by this function if the renderer supports it.<br/>/// A blend mode controls how the pixels from a drawing operation (source) get<br/>/// combined with the pixels from the render target (destination). First, the<br/>/// components of the source and destination pixels get multiplied with their<br/>/// blend factors. Then, the blend operation takes the two products and<br/>/// calculates the result that will get stored in the render target.<br/>/// Expressed in pseudocode, it would look like this:<br/>/// ```c<br/>/// dstRGB = colorOperation(srcRGB * srcColorFactor, dstRGB * dstColorFactor);<br/>/// dstA = alphaOperation(srcA * srcAlphaFactor, dstA * dstAlphaFactor);<br/>/// ```<br/>/// Where the functions `colorOperation(src, dst)` and `alphaOperation(src,<br/>/// dst)` can return one of the following:<br/>/// - `src + dst`<br/>/// - `src - dst`<br/>/// - `dst - src`<br/>/// - `min(src, dst)`<br/>/// - `max(src, dst)`<br/>/// The red, green, and blue components are always multiplied with the first,<br/>/// second, and third components of the SDL_BlendFactor, respectively. The<br/>/// fourth component is not used.<br/>/// The alpha component is always multiplied with the fourth component of the<br/>/// SDL_BlendFactor. The other components are not used in the alpha<br/>/// calculation.<br/>/// Support for these blend modes varies for each renderer. To check if a<br/>/// specific SDL_BlendMode is supported, create a renderer and pass it to<br/>/// either SDL_SetRenderDrawBlendMode or SDL_SetTextureBlendMode. They will<br/>/// return with an error if the blend mode is not supported.<br/>/// This list describes the support of custom blend modes for each renderer in<br/>/// SDL 2.0.6. All renderers support the four blend modes listed in the<br/>/// SDL_BlendMode enumeration.<br/>/// - **direct3d**: Supports all operations with all factors. However, some<br/>/// factors produce unexpected results with `SDL_BLENDOPERATION_MINIMUM` and<br/>/// `SDL_BLENDOPERATION_MAXIMUM`.<br/>/// - **direct3d11**: Same as Direct3D 9.<br/>/// - **opengl**: Supports the `SDL_BLENDOPERATION_ADD` operation with all<br/>/// factors. OpenGL versions 1.1, 1.2, and 1.3 do not work correctly with SDL<br/>/// 2.0.6.<br/>/// - **opengles**: Supports the `SDL_BLENDOPERATION_ADD` operation with all<br/>/// factors. Color and alpha factors need to be the same. OpenGL ES 1<br/>/// implementation specific: May also support `SDL_BLENDOPERATION_SUBTRACT`<br/>/// and `SDL_BLENDOPERATION_REV_SUBTRACT`. May support color and alpha<br/>/// operations being different from each other. May support color and alpha<br/>/// factors being different from each other.<br/>/// - **opengles2**: Supports the `SDL_BLENDOPERATION_ADD`,<br/>/// `SDL_BLENDOPERATION_SUBTRACT`, `SDL_BLENDOPERATION_REV_SUBTRACT`<br/>/// operations with all factors.<br/>/// - **psp**: No custom blend mode support.<br/>/// - **software**: No custom blend mode support.<br/>/// Some renderers do not provide an alpha component for the default render<br/>/// target. The `SDL_BLENDFACTOR_DST_ALPHA` and<br/>/// `SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA` factors do not have an effect in this<br/>/// case.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_ComposeCustomBlendMode")]
		[return: NativeName(NativeNameType.Type, "SDL_BlendMode")]
		public static SDLBlendMode SDLComposeCustomBlendMode([NativeName(NativeNameType.Param, "srcColorFactor")] [NativeName(NativeNameType.Type, "SDL_BlendFactor")] SDLBlendFactor srcColorFactor, [NativeName(NativeNameType.Param, "dstColorFactor")] [NativeName(NativeNameType.Type, "SDL_BlendFactor")] SDLBlendFactor dstColorFactor, [NativeName(NativeNameType.Param, "colorOperation")] [NativeName(NativeNameType.Type, "SDL_BlendOperation")] SDLBlendOperation colorOperation, [NativeName(NativeNameType.Param, "srcAlphaFactor")] [NativeName(NativeNameType.Type, "SDL_BlendFactor")] SDLBlendFactor srcAlphaFactor, [NativeName(NativeNameType.Param, "dstAlphaFactor")] [NativeName(NativeNameType.Type, "SDL_BlendFactor")] SDLBlendFactor dstAlphaFactor, [NativeName(NativeNameType.Param, "alphaOperation")] [NativeName(NativeNameType.Type, "SDL_BlendOperation")] SDLBlendOperation alphaOperation)
		{
			SDLBlendMode ret = SDLComposeCustomBlendModeNative(srcColorFactor, dstColorFactor, colorOperation, srcAlphaFactor, dstAlphaFactor, alphaOperation);
			return ret;
		}

		/// <summary>
		/// Allocate a new RGB surface.<br/>
		/// If `depth` is 4 or 8 bits, an empty palette is allocated for the surface.<br/>
		/// If `depth` is greater than 8 bits, the pixel format is set using the<br/>
		/// [RGBA]mask parameters.<br/>
		/// The [RGBA]mask parameters are the bitmasks used to extract that color from<br/>
		/// a pixel. For instance, `Rmask` being 0xFF000000 means the red data is<br/>
		/// stored in the most significant byte. Using zeros for the RGB masks sets a<br/>
		/// default value, based on the depth. For example:<br/>
		/// ```c++<br/>
		/// SDL_CreateRGBSurface(0,w,h,32,0,0,0,0);<br/>
		/// ```<br/>
		/// However, using zero for the Amask results in an Amask of 0.<br/>
		/// By default surfaces with an alpha mask are set up for blending as with:<br/>
		/// ```c++<br/>
		/// SDL_SetSurfaceBlendMode(surface, SDL_BLENDMODE_BLEND)<br/>
		/// ```<br/>
		/// You can change this by calling SDL_SetSurfaceBlendMode() and selecting a<br/>
		/// different `blendMode`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateRGBSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		[LibraryImport(LibName, EntryPoint = "SDL_CreateRGBSurface")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial SDLSurface* SDLCreateRGBSurfaceNative([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "depth")] [NativeName(NativeNameType.Type, "int")] int depth, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32")] uint rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32")] uint gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32")] uint bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32")] uint amask);

		/// <summary>/// Allocate a new RGB surface.<br/>/// If `depth` is 4 or 8 bits, an empty palette is allocated for the surface.<br/>/// If `depth` is greater than 8 bits, the pixel format is set using the<br/>/// [RGBA]mask parameters.<br/>/// The [RGBA]mask parameters are the bitmasks used to extract that color from<br/>/// a pixel. For instance, `Rmask` being 0xFF000000 means the red data is<br/>/// stored in the most significant byte. Using zeros for the RGB masks sets a<br/>/// default value, based on the depth. For example:<br/>/// ```c++<br/>/// SDL_CreateRGBSurface(0,w,h,32,0,0,0,0);<br/>/// ```<br/>/// However, using zero for the Amask results in an Amask of 0.<br/>/// By default surfaces with an alpha mask are set up for blending as with:<br/>/// ```c++<br/>/// SDL_SetSurfaceBlendMode(surface, SDL_BLENDMODE_BLEND)<br/>/// ```<br/>/// You can change this by calling SDL_SetSurfaceBlendMode() and selecting a<br/>/// different `blendMode`.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_CreateRGBSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* SDLCreateRGBSurface([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "depth")] [NativeName(NativeNameType.Type, "int")] int depth, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32")] uint rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32")] uint gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32")] uint bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32")] uint amask)
		{
			SDLSurface* ret = SDLCreateRGBSurfaceNative(flags, width, height, depth, rmask, gmask, bmask, amask);
			return ret;
		}

		/// <summary>
		/// Allocate a new RGB surface with a specific pixel format.<br/>
		/// This function operates mostly like SDL_CreateRGBSurface(), except instead<br/>
		/// of providing pixel color masks, you provide it with a predefined format<br/>
		/// from SDL_PixelFormatEnum.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateRGBSurfaceWithFormat")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		[LibraryImport(LibName, EntryPoint = "SDL_CreateRGBSurfaceWithFormat")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial SDLSurface* SDLCreateRGBSurfaceWithFormatNative([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "depth")] [NativeName(NativeNameType.Type, "int")] int depth, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format);

		/// <summary>/// Allocate a new RGB surface with a specific pixel format.<br/>/// This function operates mostly like SDL_CreateRGBSurface(), except instead<br/>/// of providing pixel color masks, you provide it with a predefined format<br/>/// from SDL_PixelFormatEnum.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_CreateRGBSurfaceWithFormat")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* SDLCreateRGBSurfaceWithFormat([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "depth")] [NativeName(NativeNameType.Type, "int")] int depth, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format)
		{
			SDLSurface* ret = SDLCreateRGBSurfaceWithFormatNative(flags, width, height, depth, format);
			return ret;
		}

		/// <summary>
		/// Allocate a new RGB surface with existing pixel data.<br/>
		/// This function operates mostly like SDL_CreateRGBSurface(), except it does<br/>
		/// not allocate memory for the pixel data, instead the caller provides an<br/>
		/// existing buffer of data for the surface to use.<br/>
		/// No copy is made of the pixel data. Pixel data is not managed automatically;<br/>
		/// you must free the surface before you free the pixel data.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateRGBSurfaceFrom")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		[LibraryImport(LibName, EntryPoint = "SDL_CreateRGBSurfaceFrom")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial SDLSurface* SDLCreateRGBSurfaceFromNative([NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "void*")] void* pixels, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "depth")] [NativeName(NativeNameType.Type, "int")] int depth, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int")] int pitch, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32")] uint rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32")] uint gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32")] uint bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32")] uint amask);

		/// <summary>/// Allocate a new RGB surface with existing pixel data.<br/>/// This function operates mostly like SDL_CreateRGBSurface(), except it does<br/>/// not allocate memory for the pixel data, instead the caller provides an<br/>/// existing buffer of data for the surface to use.<br/>/// No copy is made of the pixel data. Pixel data is not managed automatically;<br/>/// you must free the surface before you free the pixel data.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_CreateRGBSurfaceFrom")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* SDLCreateRGBSurfaceFrom([NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "void*")] void* pixels, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "depth")] [NativeName(NativeNameType.Type, "int")] int depth, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int")] int pitch, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32")] uint rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32")] uint gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32")] uint bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32")] uint amask)
		{
			SDLSurface* ret = SDLCreateRGBSurfaceFromNative(pixels, width, height, depth, pitch, rmask, gmask, bmask, amask);
			return ret;
		}

		/// <summary>
		/// Allocate a new RGB surface with with a specific pixel format and existing<br/>
		/// pixel data.<br/>
		/// This function operates mostly like SDL_CreateRGBSurfaceFrom(), except<br/>
		/// instead of providing pixel color masks, you provide it with a predefined<br/>
		/// format from SDL_PixelFormatEnum.<br/>
		/// No copy is made of the pixel data. Pixel data is not managed automatically;<br/>
		/// you must free the surface before you free the pixel data.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateRGBSurfaceWithFormatFrom")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		[LibraryImport(LibName, EntryPoint = "SDL_CreateRGBSurfaceWithFormatFrom")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial SDLSurface* SDLCreateRGBSurfaceWithFormatFromNative([NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "void*")] void* pixels, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "depth")] [NativeName(NativeNameType.Type, "int")] int depth, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int")] int pitch, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format);

		/// <summary>/// Allocate a new RGB surface with with a specific pixel format and existing<br/>/// pixel data.<br/>/// This function operates mostly like SDL_CreateRGBSurfaceFrom(), except<br/>/// instead of providing pixel color masks, you provide it with a predefined<br/>/// format from SDL_PixelFormatEnum.<br/>/// No copy is made of the pixel data. Pixel data is not managed automatically;<br/>/// you must free the surface before you free the pixel data.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_CreateRGBSurfaceWithFormatFrom")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* SDLCreateRGBSurfaceWithFormatFrom([NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "void*")] void* pixels, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "depth")] [NativeName(NativeNameType.Type, "int")] int depth, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int")] int pitch, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format)
		{
			SDLSurface* ret = SDLCreateRGBSurfaceWithFormatFromNative(pixels, width, height, depth, pitch, format);
			return ret;
		}

		/// <summary>
		/// Free an RGB surface.<br/>
		/// It is safe to pass NULL to this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FreeSurface")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "SDL_FreeSurface")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SDLFreeSurfaceNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface);

		/// <summary>/// Free an RGB surface.<br/>/// It is safe to pass NULL to this function.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_FreeSurface")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLFreeSurface([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface)
		{
			SDLFreeSurfaceNative(surface);
		}

		/// <summary>
		/// Set the palette used by a surface.<br/>
		/// A single palette can be shared with many surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfacePalette")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_SetSurfacePalette")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLSetSurfacePaletteNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette*")] SDLPalette* palette);

		/// <summary>/// Set the palette used by a surface.<br/>/// A single palette can be shared with many surfaces.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetSurfacePalette")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetSurfacePalette([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette*")] SDLPalette* palette)
		{
			int ret = SDLSetSurfacePaletteNative(surface, palette);
			return ret;
		}

		/// <summary>/// Set the palette used by a surface.<br/>/// A single palette can be shared with many surfaces.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetSurfacePalette")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetSurfacePalette([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette*")] ref SDLPalette palette)
		{
			fixed (SDLPalette* ppalette = &palette)
			{
				int ret = SDLSetSurfacePaletteNative(surface, (SDLPalette*)ppalette);
				return ret;
			}
		}

		/// <summary>
		/// Set up a surface for directly accessing the pixels.<br/>
		/// Between calls to SDL_LockSurface() / SDL_UnlockSurface(), you can write to<br/>
		/// and read from `surface->pixels`, using the pixel format stored in<br/>
		/// `surface->format`. Once you are done accessing the surface, you should use<br/>
		/// SDL_UnlockSurface() to release it.<br/>
		/// Not all surfaces require locking. If `SDL_MUSTLOCK(surface)` evaluates to<br/>
		/// 0, then you can read and write to the surface at any time, and the pixel<br/>
		/// format of the surface will not change.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockSurface")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_LockSurface")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLLockSurfaceNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface);

		/// <summary>/// Set up a surface for directly accessing the pixels.<br/>/// Between calls to SDL_LockSurface() / SDL_UnlockSurface(), you can write to<br/>/// and read from `surface->pixels`, using the pixel format stored in<br/>/// `surface->format`. Once you are done accessing the surface, you should use<br/>/// SDL_UnlockSurface() to release it.<br/>/// Not all surfaces require locking. If `SDL_MUSTLOCK(surface)` evaluates to<br/>/// 0, then you can read and write to the surface at any time, and the pixel<br/>/// format of the surface will not change.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_LockSurface")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLockSurface([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface)
		{
			int ret = SDLLockSurfaceNative(surface);
			return ret;
		}

		/// <summary>
		/// Release a surface after directly accessing the pixels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnlockSurface")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "SDL_UnlockSurface")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SDLUnlockSurfaceNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface);

		/// <summary>/// Release a surface after directly accessing the pixels.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_UnlockSurface")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLUnlockSurface([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface)
		{
			SDLUnlockSurfaceNative(surface);
		}

		/// <summary>
		/// Load a BMP image from a seekable SDL data stream.<br/>
		/// The new surface should be freed with SDL_FreeSurface(). Not doing so will<br/>
		/// result in a memory leak.<br/>
		/// src is an open SDL_RWops buffer, typically loaded with SDL_RWFromFile.<br/>
		/// Alternitavely, you might also use the macro SDL_LoadBMP to load a bitmap<br/>
		/// from a file, convert it to an SDL_Surface and then close the file.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadBMP_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		[LibraryImport(LibName, EntryPoint = "SDL_LoadBMP_RW")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial SDLSurface* SDLLoadBMPRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc);

		/// <summary>/// Load a BMP image from a seekable SDL data stream.<br/>/// The new surface should be freed with SDL_FreeSurface(). Not doing so will<br/>/// result in a memory leak.<br/>/// src is an open SDL_RWops buffer, typically loaded with SDL_RWFromFile.<br/>/// Alternitavely, you might also use the macro SDL_LoadBMP to load a bitmap<br/>/// from a file, convert it to an SDL_Surface and then close the file.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_LoadBMP_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* SDLLoadBMPRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc)
		{
			SDLSurface* ret = SDLLoadBMPRWNative(src, freesrc);
			return ret;
		}

		/// <summary>
		/// Save a surface to a seekable SDL data stream in BMP format.<br/>
		/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>
		/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>
		/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>
		/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>
		/// not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SaveBMP_RW")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_SaveBMP_RW")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLSaveBMPRWNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "freedst")] [NativeName(NativeNameType.Type, "int")] int freedst);

		/// <summary>/// Save a surface to a seekable SDL data stream in BMP format.<br/>/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>/// not supported.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_SaveBMP_RW")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSaveBMPRW([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "freedst")] [NativeName(NativeNameType.Type, "int")] int freedst)
		{
			int ret = SDLSaveBMPRWNative(surface, dst, freedst);
			return ret;
		}

		/// <summary>/// Save a surface to a seekable SDL data stream in BMP format.<br/>/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>/// not supported.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_SaveBMP_RW")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSaveBMPRW([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops dst, [NativeName(NativeNameType.Param, "freedst")] [NativeName(NativeNameType.Type, "int")] int freedst)
		{
			fixed (SDLRWops* pdst = &dst)
			{
				int ret = SDLSaveBMPRWNative(surface, (SDLRWops*)pdst, freedst);
				return ret;
			}
		}

		/// <summary>
		/// Set the RLE acceleration hint for a surface.<br/>
		/// If RLE is enabled, color key and alpha blending blits are much faster, but<br/>
		/// the surface must be locked before directly accessing the pixels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceRLE")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_SetSurfaceRLE")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLSetSurfaceRLENative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "flag")] [NativeName(NativeNameType.Type, "int")] int flag);

		/// <summary>/// Set the RLE acceleration hint for a surface.<br/>/// If RLE is enabled, color key and alpha blending blits are much faster, but<br/>/// the surface must be locked before directly accessing the pixels.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetSurfaceRLE")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetSurfaceRLE([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "flag")] [NativeName(NativeNameType.Type, "int")] int flag)
		{
			int ret = SDLSetSurfaceRLENative(surface, flag);
			return ret;
		}

		/// <summary>
		/// Returns whether the surface is RLE enabled<br/>
		/// It is safe to pass a NULL `surface` here; it will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasSurfaceRLE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[LibraryImport(LibName, EntryPoint = "SDL_HasSurfaceRLE")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial SDLBool SDLHasSurfaceRLENative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface);

		/// <summary>/// Returns whether the surface is RLE enabled<br/>/// It is safe to pass a NULL `surface` here; it will return SDL_FALSE.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_HasSurfaceRLE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLHasSurfaceRLE([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface)
		{
			SDLBool ret = SDLHasSurfaceRLENative(surface);
			return ret;
		}

		/// <summary>
		/// Set the color key (transparent pixel) in a surface.<br/>
		/// The color key defines a pixel value that will be treated as transparent in<br/>
		/// a blit. For example, one can use this to specify that cyan pixels should be<br/>
		/// considered transparent, and therefore not rendered.<br/>
		/// It is a pixel of the format used by the surface, as generated by<br/>
		/// SDL_MapRGB().<br/>
		/// RLE acceleration can substantially speed up blitting of images with large<br/>
		/// horizontal runs of transparent pixels. See SDL_SetSurfaceRLE() for details.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetColorKey")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_SetColorKey")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLSetColorKeyNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "flag")] [NativeName(NativeNameType.Type, "int")] int flag, [NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "Uint32")] uint key);

		/// <summary>/// Set the color key (transparent pixel) in a surface.<br/>/// The color key defines a pixel value that will be treated as transparent in<br/>/// a blit. For example, one can use this to specify that cyan pixels should be<br/>/// considered transparent, and therefore not rendered.<br/>/// It is a pixel of the format used by the surface, as generated by<br/>/// SDL_MapRGB().<br/>/// RLE acceleration can substantially speed up blitting of images with large<br/>/// horizontal runs of transparent pixels. See SDL_SetSurfaceRLE() for details.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetColorKey")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetColorKey([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "flag")] [NativeName(NativeNameType.Type, "int")] int flag, [NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "Uint32")] uint key)
		{
			int ret = SDLSetColorKeyNative(surface, flag, key);
			return ret;
		}

		/// <summary>
		/// Returns whether the surface has a color key<br/>
		/// It is safe to pass a NULL `surface` here; it will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasColorKey")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[LibraryImport(LibName, EntryPoint = "SDL_HasColorKey")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial SDLBool SDLHasColorKeyNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface);

		/// <summary>/// Returns whether the surface has a color key<br/>/// It is safe to pass a NULL `surface` here; it will return SDL_FALSE.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_HasColorKey")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLHasColorKey([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface)
		{
			SDLBool ret = SDLHasColorKeyNative(surface);
			return ret;
		}

		/// <summary>
		/// Get the color key (transparent pixel) for a surface.<br/>
		/// The color key is a pixel of the format used by the surface, as generated by<br/>
		/// SDL_MapRGB().<br/>
		/// If the surface doesn't have color key enabled this function returns -1.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetColorKey")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_GetColorKey")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLGetColorKeyNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "Uint32*")] uint* key);

		/// <summary>/// Get the color key (transparent pixel) for a surface.<br/>/// The color key is a pixel of the format used by the surface, as generated by<br/>/// SDL_MapRGB().<br/>/// If the surface doesn't have color key enabled this function returns -1.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetColorKey")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetColorKey([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "Uint32*")] uint* key)
		{
			int ret = SDLGetColorKeyNative(surface, key);
			return ret;
		}

		/// <summary>/// Get the color key (transparent pixel) for a surface.<br/>/// The color key is a pixel of the format used by the surface, as generated by<br/>/// SDL_MapRGB().<br/>/// If the surface doesn't have color key enabled this function returns -1.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetColorKey")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetColorKey([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint key)
		{
			fixed (uint* pkey = &key)
			{
				int ret = SDLGetColorKeyNative(surface, (uint*)pkey);
				return ret;
			}
		}

		/// <summary>
		/// Set an additional color value multiplied into blit operations.<br/>
		/// When this surface is blitted, during the blit operation each source color<br/>
		/// channel is modulated by the appropriate color value according to the<br/>
		/// following formula:<br/>
		/// `srcC = srcC * (color / 255)`<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_SetSurfaceColorMod")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLSetSurfaceColorModNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8")] byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8")] byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8")] byte b);

		/// <summary>/// Set an additional color value multiplied into blit operations.<br/>/// When this surface is blitted, during the blit operation each source color<br/>/// channel is modulated by the appropriate color value according to the<br/>/// following formula:<br/>/// `srcC = srcC * (color / 255)`<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8")] byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8")] byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8")] byte b)
		{
			int ret = SDLSetSurfaceColorModNative(surface, r, g, b);
			return ret;
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_GetSurfaceColorMod")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLGetSurfaceColorModNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b);

		/// <summary>/// Get the additional color value multiplied into blit operations.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			int ret = SDLGetSurfaceColorModNative(surface, r, g, b);
			return ret;
		}

		/// <summary>/// Get the additional color value multiplied into blit operations.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			fixed (byte* pr = &r)
			{
				int ret = SDLGetSurfaceColorModNative(surface, (byte*)pr, g, b);
				return ret;
			}
		}

		/// <summary>/// Get the additional color value multiplied into blit operations.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			fixed (byte* pg = &g)
			{
				int ret = SDLGetSurfaceColorModNative(surface, r, (byte*)pg, b);
				return ret;
			}
		}

		/// <summary>/// Get the additional color value multiplied into blit operations.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					int ret = SDLGetSurfaceColorModNative(surface, (byte*)pr, (byte*)pg, b);
					return ret;
				}
			}
		}

		/// <summary>/// Get the additional color value multiplied into blit operations.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b)
		{
			fixed (byte* pb = &b)
			{
				int ret = SDLGetSurfaceColorModNative(surface, r, g, (byte*)pb);
				return ret;
			}
		}

		/// <summary>/// Get the additional color value multiplied into blit operations.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pb = &b)
				{
					int ret = SDLGetSurfaceColorModNative(surface, (byte*)pr, g, (byte*)pb);
					return ret;
				}
			}
		}

		/// <summary>/// Get the additional color value multiplied into blit operations.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b)
		{
			fixed (byte* pg = &g)
			{
				fixed (byte* pb = &b)
				{
					int ret = SDLGetSurfaceColorModNative(surface, r, (byte*)pg, (byte*)pb);
					return ret;
				}
			}
		}

		/// <summary>/// Get the additional color value multiplied into blit operations.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						int ret = SDLGetSurfaceColorModNative(surface, (byte*)pr, (byte*)pg, (byte*)pb);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Set an additional alpha value used in blit operations.<br/>
		/// When this surface is blitted, during the blit operation the source alpha<br/>
		/// value is modulated by this alpha value according to the following formula:<br/>
		/// `srcA = srcA * (alpha / 255)`<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceAlphaMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_SetSurfaceAlphaMod")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLSetSurfaceAlphaModNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8")] byte alpha);

		/// <summary>/// Set an additional alpha value used in blit operations.<br/>/// When this surface is blitted, during the blit operation the source alpha<br/>/// value is modulated by this alpha value according to the following formula:<br/>/// `srcA = srcA * (alpha / 255)`<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetSurfaceAlphaMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetSurfaceAlphaMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8")] byte alpha)
		{
			int ret = SDLSetSurfaceAlphaModNative(surface, alpha);
			return ret;
		}

		/// <summary>
		/// Get the additional alpha value used in blit operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceAlphaMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_GetSurfaceAlphaMod")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLGetSurfaceAlphaModNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8*")] byte* alpha);

		/// <summary>/// Get the additional alpha value used in blit operations.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetSurfaceAlphaMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetSurfaceAlphaMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8*")] byte* alpha)
		{
			int ret = SDLGetSurfaceAlphaModNative(surface, alpha);
			return ret;
		}

		/// <summary>/// Get the additional alpha value used in blit operations.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetSurfaceAlphaMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetSurfaceAlphaMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte alpha)
		{
			fixed (byte* palpha = &alpha)
			{
				int ret = SDLGetSurfaceAlphaModNative(surface, (byte*)palpha);
				return ret;
			}
		}

		/// <summary>
		/// Set the blend mode used for blit operations.<br/>
		/// To copy a surface to another surface (or texture) without blending with the<br/>
		/// existing data, the blendmode of the SOURCE surface should be set to<br/>
		/// `SDL_BLENDMODE_NONE`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceBlendMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_SetSurfaceBlendMode")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLSetSurfaceBlendModeNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode")] SDLBlendMode blendMode);

		/// <summary>/// Set the blend mode used for blit operations.<br/>/// To copy a surface to another surface (or texture) without blending with the<br/>/// existing data, the blendmode of the SOURCE surface should be set to<br/>/// `SDL_BLENDMODE_NONE`.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetSurfaceBlendMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetSurfaceBlendMode([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode")] SDLBlendMode blendMode)
		{
			int ret = SDLSetSurfaceBlendModeNative(surface, blendMode);
			return ret;
		}

		/// <summary>
		/// Get the blend mode used for blit operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceBlendMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_GetSurfaceBlendMode")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLGetSurfaceBlendModeNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode*")] SDLBlendMode* blendMode);

		/// <summary>/// Get the blend mode used for blit operations.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetSurfaceBlendMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetSurfaceBlendMode([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode*")] SDLBlendMode* blendMode)
		{
			int ret = SDLGetSurfaceBlendModeNative(surface, blendMode);
			return ret;
		}

		/// <summary>/// Get the blend mode used for blit operations.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetSurfaceBlendMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetSurfaceBlendMode([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode*")] ref SDLBlendMode blendMode)
		{
			fixed (SDLBlendMode* pblendMode = &blendMode)
			{
				int ret = SDLGetSurfaceBlendModeNative(surface, (SDLBlendMode*)pblendMode);
				return ret;
			}
		}

		/// <summary>
		/// Set the clipping rectangle for a surface.<br/>
		/// When `surface` is the destination of a blit, only the area within the clip<br/>
		/// rectangle is drawn into.<br/>
		/// Note that blits are automatically clipped to the edges of the source and<br/>
		/// destination surfaces.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetClipRect")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[LibraryImport(LibName, EntryPoint = "SDL_SetClipRect")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial SDLBool SDLSetClipRectNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect);

		/// <summary>/// Set the clipping rectangle for a surface.<br/>/// When `surface` is the destination of a blit, only the area within the clip<br/>/// rectangle is drawn into.<br/>/// Note that blits are automatically clipped to the edges of the source and<br/>/// destination surfaces.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetClipRect")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLSetClipRect([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect)
		{
			SDLBool ret = SDLSetClipRectNative(surface, rect);
			return ret;
		}

		/// <summary>/// Set the clipping rectangle for a surface.<br/>/// When `surface` is the destination of a blit, only the area within the clip<br/>/// rectangle is drawn into.<br/>/// Note that blits are automatically clipped to the edges of the source and<br/>/// destination surfaces.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetClipRect")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLSetClipRect([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect)
		{
			fixed (SDLRect* prect = &rect)
			{
				SDLBool ret = SDLSetClipRectNative(surface, (SDLRect*)prect);
				return ret;
			}
		}

		/// <summary>
		/// Get the clipping rectangle for a surface.<br/>
		/// When `surface` is the destination of a blit, only the area within the clip<br/>
		/// rectangle is drawn into.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetClipRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "SDL_GetClipRect")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SDLGetClipRectNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* rect);

		/// <summary>/// Get the clipping rectangle for a surface.<br/>/// When `surface` is the destination of a blit, only the area within the clip<br/>/// rectangle is drawn into.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetClipRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetClipRect([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* rect)
		{
			SDLGetClipRectNative(surface, rect);
		}

		/// <summary>/// Get the clipping rectangle for a surface.<br/>/// When `surface` is the destination of a blit, only the area within the clip<br/>/// rectangle is drawn into.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetClipRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetClipRect([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect rect)
		{
			fixed (SDLRect* prect = &rect)
			{
				SDLGetClipRectNative(surface, (SDLRect*)prect);
			}
		}

		/// <summary>
		/// Creates a new surface identical to the existing surface.<br/>
		/// The returned surface should be freed with SDL_FreeSurface().<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DuplicateSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		[LibraryImport(LibName, EntryPoint = "SDL_DuplicateSurface")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial SDLSurface* SDLDuplicateSurfaceNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface);

		/// <summary>/// Creates a new surface identical to the existing surface.<br/>/// The returned surface should be freed with SDL_FreeSurface().<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_DuplicateSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* SDLDuplicateSurface([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface)
		{
			SDLSurface* ret = SDLDuplicateSurfaceNative(surface);
			return ret;
		}

		/// <summary>
		/// Copy an existing surface to a new surface of the specified format.<br/>
		/// This function is used to optimize images for faster *repeat* blitting. This<br/>
		/// is accomplished by converting the original and storing the result as a new<br/>
		/// surface. The new, optimized surface can then be used as the source for<br/>
		/// future blits, making them faster.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ConvertSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		[LibraryImport(LibName, EntryPoint = "SDL_ConvertSurface")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial SDLSurface* SDLConvertSurfaceNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] SDLPixelFormat* fmt, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags);

		/// <summary>/// Copy an existing surface to a new surface of the specified format.<br/>/// This function is used to optimize images for faster *repeat* blitting. This<br/>/// is accomplished by converting the original and storing the result as a new<br/>/// surface. The new, optimized surface can then be used as the source for<br/>/// future blits, making them faster.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_ConvertSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* SDLConvertSurface([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] SDLPixelFormat* fmt, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags)
		{
			SDLSurface* ret = SDLConvertSurfaceNative(src, fmt, flags);
			return ret;
		}

		/// <summary>/// Copy an existing surface to a new surface of the specified format.<br/>/// This function is used to optimize images for faster *repeat* blitting. This<br/>/// is accomplished by converting the original and storing the result as a new<br/>/// surface. The new, optimized surface can then be used as the source for<br/>/// future blits, making them faster.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_ConvertSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* SDLConvertSurface([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] ref SDLPixelFormat fmt, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags)
		{
			fixed (SDLPixelFormat* pfmt = &fmt)
			{
				SDLSurface* ret = SDLConvertSurfaceNative(src, (SDLPixelFormat*)pfmt, flags);
				return ret;
			}
		}

		/// <summary>
		/// Copy an existing surface to a new surface of the specified format enum.<br/>
		/// This function operates just like SDL_ConvertSurface(), but accepts an<br/>
		/// SDL_PixelFormatEnum value instead of an SDL_PixelFormat structure. As such,<br/>
		/// it might be easier to call but it doesn't have access to palette<br/>
		/// information for the destination surface, in case that would be important.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ConvertSurfaceFormat")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		[LibraryImport(LibName, EntryPoint = "SDL_ConvertSurfaceFormat")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial SDLSurface* SDLConvertSurfaceFormatNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "pixel_format")] [NativeName(NativeNameType.Type, "Uint32")] uint pixelFormat, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags);

		/// <summary>/// Copy an existing surface to a new surface of the specified format enum.<br/>/// This function operates just like SDL_ConvertSurface(), but accepts an<br/>/// SDL_PixelFormatEnum value instead of an SDL_PixelFormat structure. As such,<br/>/// it might be easier to call but it doesn't have access to palette<br/>/// information for the destination surface, in case that would be important.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_ConvertSurfaceFormat")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* SDLConvertSurfaceFormat([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "pixel_format")] [NativeName(NativeNameType.Type, "Uint32")] uint pixelFormat, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags)
		{
			SDLSurface* ret = SDLConvertSurfaceFormatNative(src, pixelFormat, flags);
			return ret;
		}

		/// <summary>
		/// Copy a block of pixels of one format to another format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ConvertPixels")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_ConvertPixels")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLConvertPixelsNative([NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "src_format")] [NativeName(NativeNameType.Type, "Uint32")] uint srcFormat, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const void*")] void* src, [NativeName(NativeNameType.Param, "src_pitch")] [NativeName(NativeNameType.Type, "int")] int srcPitch, [NativeName(NativeNameType.Param, "dst_format")] [NativeName(NativeNameType.Type, "Uint32")] uint dstFormat, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "void*")] void* dst, [NativeName(NativeNameType.Param, "dst_pitch")] [NativeName(NativeNameType.Type, "int")] int dstPitch);

		/// <summary>/// Copy a block of pixels of one format to another format.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_ConvertPixels")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLConvertPixels([NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "src_format")] [NativeName(NativeNameType.Type, "Uint32")] uint srcFormat, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const void*")] void* src, [NativeName(NativeNameType.Param, "src_pitch")] [NativeName(NativeNameType.Type, "int")] int srcPitch, [NativeName(NativeNameType.Param, "dst_format")] [NativeName(NativeNameType.Type, "Uint32")] uint dstFormat, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "void*")] void* dst, [NativeName(NativeNameType.Param, "dst_pitch")] [NativeName(NativeNameType.Type, "int")] int dstPitch)
		{
			int ret = SDLConvertPixelsNative(width, height, srcFormat, src, srcPitch, dstFormat, dst, dstPitch);
			return ret;
		}

		/// <summary>
		/// Premultiply the alpha on a block of pixels.<br/>
		/// This is safe to use with src == dst, but not for other overlapping areas.<br/>
		/// This function is currently only implemented for SDL_PIXELFORMAT_ARGB8888.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PremultiplyAlpha")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_PremultiplyAlpha")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLPremultiplyAlphaNative([NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "src_format")] [NativeName(NativeNameType.Type, "Uint32")] uint srcFormat, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const void*")] void* src, [NativeName(NativeNameType.Param, "src_pitch")] [NativeName(NativeNameType.Type, "int")] int srcPitch, [NativeName(NativeNameType.Param, "dst_format")] [NativeName(NativeNameType.Type, "Uint32")] uint dstFormat, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "void*")] void* dst, [NativeName(NativeNameType.Param, "dst_pitch")] [NativeName(NativeNameType.Type, "int")] int dstPitch);

		/// <summary>/// Premultiply the alpha on a block of pixels.<br/>/// This is safe to use with src == dst, but not for other overlapping areas.<br/>/// This function is currently only implemented for SDL_PIXELFORMAT_ARGB8888.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_PremultiplyAlpha")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLPremultiplyAlpha([NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "src_format")] [NativeName(NativeNameType.Type, "Uint32")] uint srcFormat, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const void*")] void* src, [NativeName(NativeNameType.Param, "src_pitch")] [NativeName(NativeNameType.Type, "int")] int srcPitch, [NativeName(NativeNameType.Param, "dst_format")] [NativeName(NativeNameType.Type, "Uint32")] uint dstFormat, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "void*")] void* dst, [NativeName(NativeNameType.Param, "dst_pitch")] [NativeName(NativeNameType.Type, "int")] int dstPitch)
		{
			int ret = SDLPremultiplyAlphaNative(width, height, srcFormat, src, srcPitch, dstFormat, dst, dstPitch);
			return ret;
		}

		/// <summary>
		/// Perform a fast fill of a rectangle with a specific color.<br/>
		/// `color` should be a pixel of the format used by the surface, and can be<br/>
		/// generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an<br/>
		/// alpha component then the destination is simply filled with that alpha<br/>
		/// information, no blending takes place.<br/>
		/// If there is a clip rectangle set on the destination (set via<br/>
		/// SDL_SetClipRect()), then this function will fill based on the intersection<br/>
		/// of the clip rectangle and `rect`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FillRect")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_FillRect")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLFillRectNative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Uint32")] uint color);

		/// <summary>/// Perform a fast fill of a rectangle with a specific color.<br/>/// `color` should be a pixel of the format used by the surface, and can be<br/>/// generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an<br/>/// alpha component then the destination is simply filled with that alpha<br/>/// information, no blending takes place.<br/>/// If there is a clip rectangle set on the destination (set via<br/>/// SDL_SetClipRect()), then this function will fill based on the intersection<br/>/// of the clip rectangle and `rect`.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_FillRect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLFillRect([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Uint32")] uint color)
		{
			int ret = SDLFillRectNative(dst, rect, color);
			return ret;
		}

		/// <summary>/// Perform a fast fill of a rectangle with a specific color.<br/>/// `color` should be a pixel of the format used by the surface, and can be<br/>/// generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an<br/>/// alpha component then the destination is simply filled with that alpha<br/>/// information, no blending takes place.<br/>/// If there is a clip rectangle set on the destination (set via<br/>/// SDL_SetClipRect()), then this function will fill based on the intersection<br/>/// of the clip rectangle and `rect`.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_FillRect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLFillRect([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Uint32")] uint color)
		{
			fixed (SDLRect* prect = &rect)
			{
				int ret = SDLFillRectNative(dst, (SDLRect*)prect, color);
				return ret;
			}
		}

		/// <summary>
		/// Perform a fast fill of a set of rectangles with a specific color.<br/>
		/// `color` should be a pixel of the format used by the surface, and can be<br/>
		/// generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an<br/>
		/// alpha component then the destination is simply filled with that alpha<br/>
		/// information, no blending takes place.<br/>
		/// If there is a clip rectangle set on the destination (set via<br/>
		/// SDL_SetClipRect()), then this function will fill based on the intersection<br/>
		/// of the clip rectangle and `rect`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FillRects")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_FillRects")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLFillRectsNative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "rects")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rects, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Uint32")] uint color);

		/// <summary>/// Perform a fast fill of a set of rectangles with a specific color.<br/>/// `color` should be a pixel of the format used by the surface, and can be<br/>/// generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an<br/>/// alpha component then the destination is simply filled with that alpha<br/>/// information, no blending takes place.<br/>/// If there is a clip rectangle set on the destination (set via<br/>/// SDL_SetClipRect()), then this function will fill based on the intersection<br/>/// of the clip rectangle and `rect`.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_FillRects")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLFillRects([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "rects")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rects, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Uint32")] uint color)
		{
			int ret = SDLFillRectsNative(dst, rects, count, color);
			return ret;
		}

		/// <summary>/// Perform a fast fill of a set of rectangles with a specific color.<br/>/// `color` should be a pixel of the format used by the surface, and can be<br/>/// generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an<br/>/// alpha component then the destination is simply filled with that alpha<br/>/// information, no blending takes place.<br/>/// If there is a clip rectangle set on the destination (set via<br/>/// SDL_SetClipRect()), then this function will fill based on the intersection<br/>/// of the clip rectangle and `rect`.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_FillRects")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLFillRects([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "rects")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rects, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Uint32")] uint color)
		{
			fixed (SDLRect* prects = &rects)
			{
				int ret = SDLFillRectsNative(dst, (SDLRect*)prects, count, color);
				return ret;
			}
		}

		/// <summary>
		/// Perform a fast blit from the source surface to the destination surface.<br/>
		/// SDL_UpperBlit() has been replaced by SDL_BlitSurface(), which is merely a<br/>
		/// macro for this function with a less confusing name.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpperBlit")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_UpperBlit")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLUpperBlitNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect);

		/// <summary>/// Perform a fast blit from the source surface to the destination surface.<br/>/// SDL_UpperBlit() has been replaced by SDL_BlitSurface(), which is merely a<br/>/// macro for this function with a less confusing name.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpperBlit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpperBlit([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect)
		{
			int ret = SDLUpperBlitNative(src, srcrect, dst, dstrect);
			return ret;
		}

		/// <summary>/// Perform a fast blit from the source surface to the destination surface.<br/>/// SDL_UpperBlit() has been replaced by SDL_BlitSurface(), which is merely a<br/>/// macro for this function with a less confusing name.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpperBlit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpperBlit([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				int ret = SDLUpperBlitNative(src, (SDLRect*)psrcrect, dst, dstrect);
				return ret;
			}
		}

		/// <summary>/// Perform a fast blit from the source surface to the destination surface.<br/>/// SDL_UpperBlit() has been replaced by SDL_BlitSurface(), which is merely a<br/>/// macro for this function with a less confusing name.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpperBlit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpperBlit([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				int ret = SDLUpperBlitNative(src, srcrect, (SDLSurface*)pdst, dstrect);
				return ret;
			}
		}

		/// <summary>/// Perform a fast blit from the source surface to the destination surface.<br/>/// SDL_UpperBlit() has been replaced by SDL_BlitSurface(), which is merely a<br/>/// macro for this function with a less confusing name.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpperBlit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpperBlit([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					int ret = SDLUpperBlitNative(src, (SDLRect*)psrcrect, (SDLSurface*)pdst, dstrect);
					return ret;
				}
			}
		}

		/// <summary>/// Perform a fast blit from the source surface to the destination surface.<br/>/// SDL_UpperBlit() has been replaced by SDL_BlitSurface(), which is merely a<br/>/// macro for this function with a less confusing name.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpperBlit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpperBlit([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLRect* pdstrect = &dstrect)
			{
				int ret = SDLUpperBlitNative(src, srcrect, dst, (SDLRect*)pdstrect);
				return ret;
			}
		}

		/// <summary>/// Perform a fast blit from the source surface to the destination surface.<br/>/// SDL_UpperBlit() has been replaced by SDL_BlitSurface(), which is merely a<br/>/// macro for this function with a less confusing name.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpperBlit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpperBlit([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					int ret = SDLUpperBlitNative(src, (SDLRect*)psrcrect, dst, (SDLRect*)pdstrect);
					return ret;
				}
			}
		}

		/// <summary>/// Perform a fast blit from the source surface to the destination surface.<br/>/// SDL_UpperBlit() has been replaced by SDL_BlitSurface(), which is merely a<br/>/// macro for this function with a less confusing name.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpperBlit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpperBlit([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					int ret = SDLUpperBlitNative(src, srcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
					return ret;
				}
			}
		}

		/// <summary>/// Perform a fast blit from the source surface to the destination surface.<br/>/// SDL_UpperBlit() has been replaced by SDL_BlitSurface(), which is merely a<br/>/// macro for this function with a less confusing name.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpperBlit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpperBlit([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						int ret = SDLUpperBlitNative(src, (SDLRect*)psrcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Perform low-level surface blitting only.<br/>
		/// This is a semi-private blit function and it performs low-level surface<br/>
		/// blitting, assuming the input rectangles have already been clipped.<br/>
		/// Unless you know what you're doing, you should be using SDL_BlitSurface()<br/>
		/// instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LowerBlit")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_LowerBlit")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLLowerBlitNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect);

		/// <summary>/// Perform low-level surface blitting only.<br/>/// This is a semi-private blit function and it performs low-level surface<br/>/// blitting, assuming the input rectangles have already been clipped.<br/>/// Unless you know what you're doing, you should be using SDL_BlitSurface()<br/>/// instead.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_LowerBlit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLowerBlit([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect)
		{
			int ret = SDLLowerBlitNative(src, srcrect, dst, dstrect);
			return ret;
		}

		/// <summary>/// Perform low-level surface blitting only.<br/>/// This is a semi-private blit function and it performs low-level surface<br/>/// blitting, assuming the input rectangles have already been clipped.<br/>/// Unless you know what you're doing, you should be using SDL_BlitSurface()<br/>/// instead.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_LowerBlit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLowerBlit([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				int ret = SDLLowerBlitNative(src, (SDLRect*)psrcrect, dst, dstrect);
				return ret;
			}
		}

		/// <summary>/// Perform low-level surface blitting only.<br/>/// This is a semi-private blit function and it performs low-level surface<br/>/// blitting, assuming the input rectangles have already been clipped.<br/>/// Unless you know what you're doing, you should be using SDL_BlitSurface()<br/>/// instead.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_LowerBlit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLowerBlit([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				int ret = SDLLowerBlitNative(src, srcrect, (SDLSurface*)pdst, dstrect);
				return ret;
			}
		}

		/// <summary>/// Perform low-level surface blitting only.<br/>/// This is a semi-private blit function and it performs low-level surface<br/>/// blitting, assuming the input rectangles have already been clipped.<br/>/// Unless you know what you're doing, you should be using SDL_BlitSurface()<br/>/// instead.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_LowerBlit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLowerBlit([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					int ret = SDLLowerBlitNative(src, (SDLRect*)psrcrect, (SDLSurface*)pdst, dstrect);
					return ret;
				}
			}
		}

		/// <summary>/// Perform low-level surface blitting only.<br/>/// This is a semi-private blit function and it performs low-level surface<br/>/// blitting, assuming the input rectangles have already been clipped.<br/>/// Unless you know what you're doing, you should be using SDL_BlitSurface()<br/>/// instead.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_LowerBlit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLowerBlit([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLRect* pdstrect = &dstrect)
			{
				int ret = SDLLowerBlitNative(src, srcrect, dst, (SDLRect*)pdstrect);
				return ret;
			}
		}

		/// <summary>/// Perform low-level surface blitting only.<br/>/// This is a semi-private blit function and it performs low-level surface<br/>/// blitting, assuming the input rectangles have already been clipped.<br/>/// Unless you know what you're doing, you should be using SDL_BlitSurface()<br/>/// instead.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_LowerBlit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLowerBlit([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					int ret = SDLLowerBlitNative(src, (SDLRect*)psrcrect, dst, (SDLRect*)pdstrect);
					return ret;
				}
			}
		}

		/// <summary>/// Perform low-level surface blitting only.<br/>/// This is a semi-private blit function and it performs low-level surface<br/>/// blitting, assuming the input rectangles have already been clipped.<br/>/// Unless you know what you're doing, you should be using SDL_BlitSurface()<br/>/// instead.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_LowerBlit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLowerBlit([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					int ret = SDLLowerBlitNative(src, srcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
					return ret;
				}
			}
		}

		/// <summary>/// Perform low-level surface blitting only.<br/>/// This is a semi-private blit function and it performs low-level surface<br/>/// blitting, assuming the input rectangles have already been clipped.<br/>/// Unless you know what you're doing, you should be using SDL_BlitSurface()<br/>/// instead.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_LowerBlit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLowerBlit([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						int ret = SDLLowerBlitNative(src, (SDLRect*)psrcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Perform a fast, low quality, stretch blit between two surfaces of the same<br/>
		/// format.<br/>
		/// Please use SDL_BlitScaled() instead.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SoftStretch")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_SoftStretch")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLSoftStretchNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* dstrect);

		/// <summary>/// Perform a fast, low quality, stretch blit between two surfaces of the same<br/>/// format.<br/>/// Please use SDL_BlitScaled() instead.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_SoftStretch")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSoftStretch([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* dstrect)
		{
			int ret = SDLSoftStretchNative(src, srcrect, dst, dstrect);
			return ret;
		}

		/// <summary>/// Perform a fast, low quality, stretch blit between two surfaces of the same<br/>/// format.<br/>/// Please use SDL_BlitScaled() instead.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_SoftStretch")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSoftStretch([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				int ret = SDLSoftStretchNative(src, (SDLRect*)psrcrect, dst, dstrect);
				return ret;
			}
		}

		/// <summary>/// Perform a fast, low quality, stretch blit between two surfaces of the same<br/>/// format.<br/>/// Please use SDL_BlitScaled() instead.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_SoftStretch")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSoftStretch([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				int ret = SDLSoftStretchNative(src, srcrect, (SDLSurface*)pdst, dstrect);
				return ret;
			}
		}

		/// <summary>/// Perform a fast, low quality, stretch blit between two surfaces of the same<br/>/// format.<br/>/// Please use SDL_BlitScaled() instead.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_SoftStretch")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSoftStretch([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					int ret = SDLSoftStretchNative(src, (SDLRect*)psrcrect, (SDLSurface*)pdst, dstrect);
					return ret;
				}
			}
		}

		/// <summary>/// Perform a fast, low quality, stretch blit between two surfaces of the same<br/>/// format.<br/>/// Please use SDL_BlitScaled() instead.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_SoftStretch")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSoftStretch([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLRect* pdstrect = &dstrect)
			{
				int ret = SDLSoftStretchNative(src, srcrect, dst, (SDLRect*)pdstrect);
				return ret;
			}
		}

		/// <summary>/// Perform a fast, low quality, stretch blit between two surfaces of the same<br/>/// format.<br/>/// Please use SDL_BlitScaled() instead.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_SoftStretch")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSoftStretch([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					int ret = SDLSoftStretchNative(src, (SDLRect*)psrcrect, dst, (SDLRect*)pdstrect);
					return ret;
				}
			}
		}

		/// <summary>/// Perform a fast, low quality, stretch blit between two surfaces of the same<br/>/// format.<br/>/// Please use SDL_BlitScaled() instead.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_SoftStretch")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSoftStretch([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					int ret = SDLSoftStretchNative(src, srcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
					return ret;
				}
			}
		}

		/// <summary>/// Perform a fast, low quality, stretch blit between two surfaces of the same<br/>/// format.<br/>/// Please use SDL_BlitScaled() instead.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_SoftStretch")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSoftStretch([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						int ret = SDLSoftStretchNative(src, (SDLRect*)psrcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Perform bilinear scaling between two surfaces of the same format, 32BPP.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SoftStretchLinear")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_SoftStretchLinear")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLSoftStretchLinearNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* dstrect);

		/// <summary>/// Perform bilinear scaling between two surfaces of the same format, 32BPP.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_SoftStretchLinear")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSoftStretchLinear([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* dstrect)
		{
			int ret = SDLSoftStretchLinearNative(src, srcrect, dst, dstrect);
			return ret;
		}

		/// <summary>/// Perform bilinear scaling between two surfaces of the same format, 32BPP.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_SoftStretchLinear")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSoftStretchLinear([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				int ret = SDLSoftStretchLinearNative(src, (SDLRect*)psrcrect, dst, dstrect);
				return ret;
			}
		}

		/// <summary>/// Perform bilinear scaling between two surfaces of the same format, 32BPP.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_SoftStretchLinear")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSoftStretchLinear([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				int ret = SDLSoftStretchLinearNative(src, srcrect, (SDLSurface*)pdst, dstrect);
				return ret;
			}
		}

		/// <summary>/// Perform bilinear scaling between two surfaces of the same format, 32BPP.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_SoftStretchLinear")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSoftStretchLinear([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					int ret = SDLSoftStretchLinearNative(src, (SDLRect*)psrcrect, (SDLSurface*)pdst, dstrect);
					return ret;
				}
			}
		}

		/// <summary>/// Perform bilinear scaling between two surfaces of the same format, 32BPP.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_SoftStretchLinear")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSoftStretchLinear([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLRect* pdstrect = &dstrect)
			{
				int ret = SDLSoftStretchLinearNative(src, srcrect, dst, (SDLRect*)pdstrect);
				return ret;
			}
		}

		/// <summary>/// Perform bilinear scaling between two surfaces of the same format, 32BPP.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_SoftStretchLinear")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSoftStretchLinear([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					int ret = SDLSoftStretchLinearNative(src, (SDLRect*)psrcrect, dst, (SDLRect*)pdstrect);
					return ret;
				}
			}
		}

		/// <summary>/// Perform bilinear scaling between two surfaces of the same format, 32BPP.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_SoftStretchLinear")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSoftStretchLinear([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					int ret = SDLSoftStretchLinearNative(src, srcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
					return ret;
				}
			}
		}

		/// <summary>/// Perform bilinear scaling between two surfaces of the same format, 32BPP.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_SoftStretchLinear")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSoftStretchLinear([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						int ret = SDLSoftStretchLinearNative(src, (SDLRect*)psrcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Perform a scaled surface copy to a destination surface.<br/>
		/// SDL_UpperBlitScaled() has been replaced by SDL_BlitScaled(), which is<br/>
		/// merely a macro for this function with a less confusing name.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpperBlitScaled")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_UpperBlitScaled")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLUpperBlitScaledNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect);

		/// <summary>/// Perform a scaled surface copy to a destination surface.<br/>/// SDL_UpperBlitScaled() has been replaced by SDL_BlitScaled(), which is<br/>/// merely a macro for this function with a less confusing name.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpperBlitScaled")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpperBlitScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect)
		{
			int ret = SDLUpperBlitScaledNative(src, srcrect, dst, dstrect);
			return ret;
		}

		/// <summary>/// Perform a scaled surface copy to a destination surface.<br/>/// SDL_UpperBlitScaled() has been replaced by SDL_BlitScaled(), which is<br/>/// merely a macro for this function with a less confusing name.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpperBlitScaled")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpperBlitScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				int ret = SDLUpperBlitScaledNative(src, (SDLRect*)psrcrect, dst, dstrect);
				return ret;
			}
		}

		/// <summary>/// Perform a scaled surface copy to a destination surface.<br/>/// SDL_UpperBlitScaled() has been replaced by SDL_BlitScaled(), which is<br/>/// merely a macro for this function with a less confusing name.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpperBlitScaled")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpperBlitScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				int ret = SDLUpperBlitScaledNative(src, srcrect, (SDLSurface*)pdst, dstrect);
				return ret;
			}
		}

		/// <summary>/// Perform a scaled surface copy to a destination surface.<br/>/// SDL_UpperBlitScaled() has been replaced by SDL_BlitScaled(), which is<br/>/// merely a macro for this function with a less confusing name.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpperBlitScaled")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpperBlitScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					int ret = SDLUpperBlitScaledNative(src, (SDLRect*)psrcrect, (SDLSurface*)pdst, dstrect);
					return ret;
				}
			}
		}

		/// <summary>/// Perform a scaled surface copy to a destination surface.<br/>/// SDL_UpperBlitScaled() has been replaced by SDL_BlitScaled(), which is<br/>/// merely a macro for this function with a less confusing name.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpperBlitScaled")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpperBlitScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLRect* pdstrect = &dstrect)
			{
				int ret = SDLUpperBlitScaledNative(src, srcrect, dst, (SDLRect*)pdstrect);
				return ret;
			}
		}

		/// <summary>/// Perform a scaled surface copy to a destination surface.<br/>/// SDL_UpperBlitScaled() has been replaced by SDL_BlitScaled(), which is<br/>/// merely a macro for this function with a less confusing name.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpperBlitScaled")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpperBlitScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					int ret = SDLUpperBlitScaledNative(src, (SDLRect*)psrcrect, dst, (SDLRect*)pdstrect);
					return ret;
				}
			}
		}

		/// <summary>/// Perform a scaled surface copy to a destination surface.<br/>/// SDL_UpperBlitScaled() has been replaced by SDL_BlitScaled(), which is<br/>/// merely a macro for this function with a less confusing name.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpperBlitScaled")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpperBlitScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					int ret = SDLUpperBlitScaledNative(src, srcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
					return ret;
				}
			}
		}

		/// <summary>/// Perform a scaled surface copy to a destination surface.<br/>/// SDL_UpperBlitScaled() has been replaced by SDL_BlitScaled(), which is<br/>/// merely a macro for this function with a less confusing name.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpperBlitScaled")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpperBlitScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						int ret = SDLUpperBlitScaledNative(src, (SDLRect*)psrcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Perform low-level surface scaled blitting only.<br/>
		/// This is a semi-private function and it performs low-level surface blitting,<br/>
		/// assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LowerBlitScaled")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_LowerBlitScaled")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLLowerBlitScaledNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect);

		/// <summary>/// Perform low-level surface scaled blitting only.<br/>/// This is a semi-private function and it performs low-level surface blitting,<br/>/// assuming the input rectangles have already been clipped.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_LowerBlitScaled")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLowerBlitScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect)
		{
			int ret = SDLLowerBlitScaledNative(src, srcrect, dst, dstrect);
			return ret;
		}

		/// <summary>/// Perform low-level surface scaled blitting only.<br/>/// This is a semi-private function and it performs low-level surface blitting,<br/>/// assuming the input rectangles have already been clipped.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_LowerBlitScaled")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLowerBlitScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				int ret = SDLLowerBlitScaledNative(src, (SDLRect*)psrcrect, dst, dstrect);
				return ret;
			}
		}

		/// <summary>/// Perform low-level surface scaled blitting only.<br/>/// This is a semi-private function and it performs low-level surface blitting,<br/>/// assuming the input rectangles have already been clipped.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_LowerBlitScaled")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLowerBlitScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				int ret = SDLLowerBlitScaledNative(src, srcrect, (SDLSurface*)pdst, dstrect);
				return ret;
			}
		}

		/// <summary>/// Perform low-level surface scaled blitting only.<br/>/// This is a semi-private function and it performs low-level surface blitting,<br/>/// assuming the input rectangles have already been clipped.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_LowerBlitScaled")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLowerBlitScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					int ret = SDLLowerBlitScaledNative(src, (SDLRect*)psrcrect, (SDLSurface*)pdst, dstrect);
					return ret;
				}
			}
		}

		/// <summary>/// Perform low-level surface scaled blitting only.<br/>/// This is a semi-private function and it performs low-level surface blitting,<br/>/// assuming the input rectangles have already been clipped.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_LowerBlitScaled")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLowerBlitScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLRect* pdstrect = &dstrect)
			{
				int ret = SDLLowerBlitScaledNative(src, srcrect, dst, (SDLRect*)pdstrect);
				return ret;
			}
		}

		/// <summary>/// Perform low-level surface scaled blitting only.<br/>/// This is a semi-private function and it performs low-level surface blitting,<br/>/// assuming the input rectangles have already been clipped.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_LowerBlitScaled")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLowerBlitScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					int ret = SDLLowerBlitScaledNative(src, (SDLRect*)psrcrect, dst, (SDLRect*)pdstrect);
					return ret;
				}
			}
		}

		/// <summary>/// Perform low-level surface scaled blitting only.<br/>/// This is a semi-private function and it performs low-level surface blitting,<br/>/// assuming the input rectangles have already been clipped.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_LowerBlitScaled")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLowerBlitScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					int ret = SDLLowerBlitScaledNative(src, srcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
					return ret;
				}
			}
		}

		/// <summary>/// Perform low-level surface scaled blitting only.<br/>/// This is a semi-private function and it performs low-level surface blitting,<br/>/// assuming the input rectangles have already been clipped.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_LowerBlitScaled")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLowerBlitScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						int ret = SDLLowerBlitScaledNative(src, (SDLRect*)psrcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Set the YUV conversion mode<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetYUVConversionMode")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "SDL_SetYUVConversionMode")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SDLSetYUVConversionModeNative([NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "SDL_YUV_CONVERSION_MODE")] SdlYuvConversionMode mode);

		/// <summary>/// Set the YUV conversion mode<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetYUVConversionMode")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLSetYUVConversionMode([NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "SDL_YUV_CONVERSION_MODE")] SdlYuvConversionMode mode)
		{
			SDLSetYUVConversionModeNative(mode);
		}

		/// <summary>
		/// Get the YUV conversion mode<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetYUVConversionMode")]
		[return: NativeName(NativeNameType.Type, "SDL_YUV_CONVERSION_MODE")]
		[LibraryImport(LibName, EntryPoint = "SDL_GetYUVConversionMode")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial SdlYuvConversionMode SDLGetYUVConversionModeNative();

		/// <summary>/// Get the YUV conversion mode<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetYUVConversionMode")]
		[return: NativeName(NativeNameType.Type, "SDL_YUV_CONVERSION_MODE")]
		public static SdlYuvConversionMode SDLGetYUVConversionMode()
		{
			SdlYuvConversionMode ret = SDLGetYUVConversionModeNative();
			return ret;
		}

		/// <summary>
		/// Get the YUV conversion mode, returning the correct mode for the resolution<br/>
		/// when the current conversion mode is SDL_YUV_CONVERSION_AUTOMATIC<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetYUVConversionModeForResolution")]
		[return: NativeName(NativeNameType.Type, "SDL_YUV_CONVERSION_MODE")]
		[LibraryImport(LibName, EntryPoint = "SDL_GetYUVConversionModeForResolution")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial SdlYuvConversionMode SDLGetYUVConversionModeForResolutionNative([NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height);

		/// <summary>/// Get the YUV conversion mode, returning the correct mode for the resolution<br/>/// when the current conversion mode is SDL_YUV_CONVERSION_AUTOMATIC<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetYUVConversionModeForResolution")]
		[return: NativeName(NativeNameType.Type, "SDL_YUV_CONVERSION_MODE")]
		public static SdlYuvConversionMode SDLGetYUVConversionModeForResolution([NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height)
		{
			SdlYuvConversionMode ret = SDLGetYUVConversionModeForResolutionNative(width, height);
			return ret;
		}

		/// <summary>
		/// Get the number of video drivers compiled into SDL.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumVideoDrivers")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_GetNumVideoDrivers")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLGetNumVideoDriversNative();

		/// <summary>/// Get the number of video drivers compiled into SDL.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetNumVideoDrivers")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetNumVideoDrivers()
		{
			int ret = SDLGetNumVideoDriversNative();
			return ret;
		}

		/// <summary>
		/// Get the name of a built in video driver.<br/>
		/// The video drivers are presented in the order in which they are normally<br/>
		/// checked during initialization.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetVideoDriver")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		[LibraryImport(LibName, EntryPoint = "SDL_GetVideoDriver")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte* SDLGetVideoDriverNative([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index);

		/// <summary>/// Get the name of a built in video driver.<br/>/// The video drivers are presented in the order in which they are normally<br/>/// checked during initialization.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetVideoDriver")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGetVideoDriver([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index)
		{
			byte* ret = SDLGetVideoDriverNative(index);
			return ret;
		}

		/// <summary>/// Get the name of a built in video driver.<br/>/// The video drivers are presented in the order in which they are normally<br/>/// checked during initialization.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetVideoDriver")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGetVideoDriverS([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index)
		{
			string ret = Utils.DecodeStringUTF8(SDLGetVideoDriverNative(index));
			return ret;
		}

		/// <summary>
		/// Initialize the video subsystem, optionally specifying a video driver.<br/>
		/// This function initializes the video subsystem, setting up a connection to<br/>
		/// the window manager, etc, and determines the available display modes and<br/>
		/// pixel formats, but does not initialize a window or graphics mode.<br/>
		/// If you use this function and you haven't used the SDL_INIT_VIDEO flag with<br/>
		/// either SDL_Init() or SDL_InitSubSystem(), you should call SDL_VideoQuit()<br/>
		/// before calling SDL_Quit().<br/>
		/// It is safe to call this function multiple times. SDL_VideoInit() will call<br/>
		/// SDL_VideoQuit() itself if the video subsystem has already been initialized.<br/>
		/// You can use SDL_GetNumVideoDrivers() and SDL_GetVideoDriver() to find a<br/>
		/// specific `driver_name`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_VideoInit")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_VideoInit")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLVideoInitNative([NativeName(NativeNameType.Param, "driver_name")] [NativeName(NativeNameType.Type, "const char*")] byte* driverName);

		/// <summary>/// Initialize the video subsystem, optionally specifying a video driver.<br/>/// This function initializes the video subsystem, setting up a connection to<br/>/// the window manager, etc, and determines the available display modes and<br/>/// pixel formats, but does not initialize a window or graphics mode.<br/>/// If you use this function and you haven't used the SDL_INIT_VIDEO flag with<br/>/// either SDL_Init() or SDL_InitSubSystem(), you should call SDL_VideoQuit()<br/>/// before calling SDL_Quit().<br/>/// It is safe to call this function multiple times. SDL_VideoInit() will call<br/>/// SDL_VideoQuit() itself if the video subsystem has already been initialized.<br/>/// You can use SDL_GetNumVideoDrivers() and SDL_GetVideoDriver() to find a<br/>/// specific `driver_name`.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_VideoInit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLVideoInit([NativeName(NativeNameType.Param, "driver_name")] [NativeName(NativeNameType.Type, "const char*")] byte* driverName)
		{
			int ret = SDLVideoInitNative(driverName);
			return ret;
		}

		/// <summary>
		/// Shut down the video subsystem, if initialized with SDL_VideoInit().<br/>
		/// This function closes all windows, and restores the original video mode.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_VideoQuit")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "SDL_VideoQuit")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SDLVideoQuitNative();

		/// <summary>/// Shut down the video subsystem, if initialized with SDL_VideoInit().<br/>/// This function closes all windows, and restores the original video mode.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_VideoQuit")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLVideoQuit()
		{
			SDLVideoQuitNative();
		}

		/// <summary>
		/// Get the name of the currently initialized video driver.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCurrentVideoDriver")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		[LibraryImport(LibName, EntryPoint = "SDL_GetCurrentVideoDriver")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte* SDLGetCurrentVideoDriverNative();

		/// <summary>/// Get the name of the currently initialized video driver.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetCurrentVideoDriver")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGetCurrentVideoDriver()
		{
			byte* ret = SDLGetCurrentVideoDriverNative();
			return ret;
		}

		/// <summary>/// Get the name of the currently initialized video driver.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetCurrentVideoDriver")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGetCurrentVideoDriverS()
		{
			string ret = Utils.DecodeStringUTF8(SDLGetCurrentVideoDriverNative());
			return ret;
		}

		/// <summary>
		/// Get the number of available video displays.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumVideoDisplays")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_GetNumVideoDisplays")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLGetNumVideoDisplaysNative();

		/// <summary>/// Get the number of available video displays.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetNumVideoDisplays")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetNumVideoDisplays()
		{
			int ret = SDLGetNumVideoDisplaysNative();
			return ret;
		}

		/// <summary>
		/// Get the name of a display in UTF-8 encoding.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetDisplayName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		[LibraryImport(LibName, EntryPoint = "SDL_GetDisplayName")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte* SDLGetDisplayNameNative([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex);

		/// <summary>/// Get the name of a display in UTF-8 encoding.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetDisplayName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGetDisplayName([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex)
		{
			byte* ret = SDLGetDisplayNameNative(displayIndex);
			return ret;
		}

		/// <summary>/// Get the name of a display in UTF-8 encoding.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetDisplayName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGetDisplayNameS([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex)
		{
			string ret = Utils.DecodeStringUTF8(SDLGetDisplayNameNative(displayIndex));
			return ret;
		}

		/// <summary>
		/// Get the desktop area represented by a display.<br/>
		/// The primary display (`displayIndex` zero) is always located at 0,0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetDisplayBounds")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_GetDisplayBounds")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLGetDisplayBoundsNative([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* rect);

		/// <summary>/// Get the desktop area represented by a display.<br/>/// The primary display (`displayIndex` zero) is always located at 0,0.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetDisplayBounds")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetDisplayBounds([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* rect)
		{
			int ret = SDLGetDisplayBoundsNative(displayIndex, rect);
			return ret;
		}

		/// <summary>/// Get the desktop area represented by a display.<br/>/// The primary display (`displayIndex` zero) is always located at 0,0.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetDisplayBounds")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetDisplayBounds([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect rect)
		{
			fixed (SDLRect* prect = &rect)
			{
				int ret = SDLGetDisplayBoundsNative(displayIndex, (SDLRect*)prect);
				return ret;
			}
		}

		/// <summary>
		/// Get the usable desktop area represented by a display.<br/>
		/// The primary display (`displayIndex` zero) is always located at 0,0.<br/>
		/// This is the same area as SDL_GetDisplayBounds() reports, but with portions<br/>
		/// reserved by the system removed. For example, on Apple's macOS, this<br/>
		/// subtracts the area occupied by the menu bar and dock.<br/>
		/// Setting a window to be fullscreen generally bypasses these unusable areas,<br/>
		/// so these are good guidelines for the maximum space available to a<br/>
		/// non-fullscreen window.<br/>
		/// The parameter `rect` is ignored if it is NULL.<br/>
		/// This function also returns -1 if the parameter `displayIndex` is out of<br/>
		/// range.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetDisplayUsableBounds")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_GetDisplayUsableBounds")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLGetDisplayUsableBoundsNative([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* rect);

		/// <summary>/// Get the usable desktop area represented by a display.<br/>/// The primary display (`displayIndex` zero) is always located at 0,0.<br/>/// This is the same area as SDL_GetDisplayBounds() reports, but with portions<br/>/// reserved by the system removed. For example, on Apple's macOS, this<br/>/// subtracts the area occupied by the menu bar and dock.<br/>/// Setting a window to be fullscreen generally bypasses these unusable areas,<br/>/// so these are good guidelines for the maximum space available to a<br/>/// non-fullscreen window.<br/>/// The parameter `rect` is ignored if it is NULL.<br/>/// This function also returns -1 if the parameter `displayIndex` is out of<br/>/// range.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetDisplayUsableBounds")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetDisplayUsableBounds([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* rect)
		{
			int ret = SDLGetDisplayUsableBoundsNative(displayIndex, rect);
			return ret;
		}

		/// <summary>/// Get the usable desktop area represented by a display.<br/>/// The primary display (`displayIndex` zero) is always located at 0,0.<br/>/// This is the same area as SDL_GetDisplayBounds() reports, but with portions<br/>/// reserved by the system removed. For example, on Apple's macOS, this<br/>/// subtracts the area occupied by the menu bar and dock.<br/>/// Setting a window to be fullscreen generally bypasses these unusable areas,<br/>/// so these are good guidelines for the maximum space available to a<br/>/// non-fullscreen window.<br/>/// The parameter `rect` is ignored if it is NULL.<br/>/// This function also returns -1 if the parameter `displayIndex` is out of<br/>/// range.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetDisplayUsableBounds")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetDisplayUsableBounds([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect rect)
		{
			fixed (SDLRect* prect = &rect)
			{
				int ret = SDLGetDisplayUsableBoundsNative(displayIndex, (SDLRect*)prect);
				return ret;
			}
		}

		/// <summary>
		/// Get the dots/pixels-per-inch for a display.<br/>
		/// Diagonal, horizontal and vertical DPI can all be optionally returned if the<br/>
		/// appropriate parameter is non-NULL.<br/>
		/// A failure of this function usually means that either no DPI information is<br/>
		/// available or the `displayIndex` is out of range.<br/>
		/// **WARNING**: This reports the DPI that the hardware reports, and it is not<br/>
		/// always reliable! It is almost always better to use SDL_GetWindowSize() to<br/>
		/// find the window size, which might be in logical points instead of pixels,<br/>
		/// and then SDL_GL_GetDrawableSize(), SDL_Vulkan_GetDrawableSize(),<br/>
		/// SDL_Metal_GetDrawableSize(), or SDL_GetRendererOutputSize(), and compare<br/>
		/// the two values to get an actual scaling value between the two. We will be<br/>
		/// rethinking how high-dpi details should be managed in SDL3 to make things<br/>
		/// more consistent, reliable, and clear.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetDisplayDPI")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_GetDisplayDPI")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLGetDisplayDPINative([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "ddpi")] [NativeName(NativeNameType.Type, "float*")] float* ddpi, [NativeName(NativeNameType.Param, "hdpi")] [NativeName(NativeNameType.Type, "float*")] float* hdpi, [NativeName(NativeNameType.Param, "vdpi")] [NativeName(NativeNameType.Type, "float*")] float* vdpi);

		/// <summary>/// Get the dots/pixels-per-inch for a display.<br/>/// Diagonal, horizontal and vertical DPI can all be optionally returned if the<br/>/// appropriate parameter is non-NULL.<br/>/// A failure of this function usually means that either no DPI information is<br/>/// available or the `displayIndex` is out of range.<br/>/// **WARNING**: This reports the DPI that the hardware reports, and it is not<br/>/// always reliable! It is almost always better to use SDL_GetWindowSize() to<br/>/// find the window size, which might be in logical points instead of pixels,<br/>/// and then SDL_GL_GetDrawableSize(), SDL_Vulkan_GetDrawableSize(),<br/>/// SDL_Metal_GetDrawableSize(), or SDL_GetRendererOutputSize(), and compare<br/>/// the two values to get an actual scaling value between the two. We will be<br/>/// rethinking how high-dpi details should be managed in SDL3 to make things<br/>/// more consistent, reliable, and clear.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetDisplayDPI")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetDisplayDPI([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "ddpi")] [NativeName(NativeNameType.Type, "float*")] float* ddpi, [NativeName(NativeNameType.Param, "hdpi")] [NativeName(NativeNameType.Type, "float*")] float* hdpi, [NativeName(NativeNameType.Param, "vdpi")] [NativeName(NativeNameType.Type, "float*")] float* vdpi)
		{
			int ret = SDLGetDisplayDPINative(displayIndex, ddpi, hdpi, vdpi);
			return ret;
		}

		/// <summary>/// Get the dots/pixels-per-inch for a display.<br/>/// Diagonal, horizontal and vertical DPI can all be optionally returned if the<br/>/// appropriate parameter is non-NULL.<br/>/// A failure of this function usually means that either no DPI information is<br/>/// available or the `displayIndex` is out of range.<br/>/// **WARNING**: This reports the DPI that the hardware reports, and it is not<br/>/// always reliable! It is almost always better to use SDL_GetWindowSize() to<br/>/// find the window size, which might be in logical points instead of pixels,<br/>/// and then SDL_GL_GetDrawableSize(), SDL_Vulkan_GetDrawableSize(),<br/>/// SDL_Metal_GetDrawableSize(), or SDL_GetRendererOutputSize(), and compare<br/>/// the two values to get an actual scaling value between the two. We will be<br/>/// rethinking how high-dpi details should be managed in SDL3 to make things<br/>/// more consistent, reliable, and clear.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetDisplayDPI")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetDisplayDPI([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "ddpi")] [NativeName(NativeNameType.Type, "float*")] ref float ddpi, [NativeName(NativeNameType.Param, "hdpi")] [NativeName(NativeNameType.Type, "float*")] float* hdpi, [NativeName(NativeNameType.Param, "vdpi")] [NativeName(NativeNameType.Type, "float*")] float* vdpi)
		{
			fixed (float* pddpi = &ddpi)
			{
				int ret = SDLGetDisplayDPINative(displayIndex, (float*)pddpi, hdpi, vdpi);
				return ret;
			}
		}

		/// <summary>/// Get the dots/pixels-per-inch for a display.<br/>/// Diagonal, horizontal and vertical DPI can all be optionally returned if the<br/>/// appropriate parameter is non-NULL.<br/>/// A failure of this function usually means that either no DPI information is<br/>/// available or the `displayIndex` is out of range.<br/>/// **WARNING**: This reports the DPI that the hardware reports, and it is not<br/>/// always reliable! It is almost always better to use SDL_GetWindowSize() to<br/>/// find the window size, which might be in logical points instead of pixels,<br/>/// and then SDL_GL_GetDrawableSize(), SDL_Vulkan_GetDrawableSize(),<br/>/// SDL_Metal_GetDrawableSize(), or SDL_GetRendererOutputSize(), and compare<br/>/// the two values to get an actual scaling value between the two. We will be<br/>/// rethinking how high-dpi details should be managed in SDL3 to make things<br/>/// more consistent, reliable, and clear.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetDisplayDPI")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetDisplayDPI([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "ddpi")] [NativeName(NativeNameType.Type, "float*")] float* ddpi, [NativeName(NativeNameType.Param, "hdpi")] [NativeName(NativeNameType.Type, "float*")] ref float hdpi, [NativeName(NativeNameType.Param, "vdpi")] [NativeName(NativeNameType.Type, "float*")] float* vdpi)
		{
			fixed (float* phdpi = &hdpi)
			{
				int ret = SDLGetDisplayDPINative(displayIndex, ddpi, (float*)phdpi, vdpi);
				return ret;
			}
		}

		/// <summary>/// Get the dots/pixels-per-inch for a display.<br/>/// Diagonal, horizontal and vertical DPI can all be optionally returned if the<br/>/// appropriate parameter is non-NULL.<br/>/// A failure of this function usually means that either no DPI information is<br/>/// available or the `displayIndex` is out of range.<br/>/// **WARNING**: This reports the DPI that the hardware reports, and it is not<br/>/// always reliable! It is almost always better to use SDL_GetWindowSize() to<br/>/// find the window size, which might be in logical points instead of pixels,<br/>/// and then SDL_GL_GetDrawableSize(), SDL_Vulkan_GetDrawableSize(),<br/>/// SDL_Metal_GetDrawableSize(), or SDL_GetRendererOutputSize(), and compare<br/>/// the two values to get an actual scaling value between the two. We will be<br/>/// rethinking how high-dpi details should be managed in SDL3 to make things<br/>/// more consistent, reliable, and clear.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetDisplayDPI")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetDisplayDPI([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "ddpi")] [NativeName(NativeNameType.Type, "float*")] ref float ddpi, [NativeName(NativeNameType.Param, "hdpi")] [NativeName(NativeNameType.Type, "float*")] ref float hdpi, [NativeName(NativeNameType.Param, "vdpi")] [NativeName(NativeNameType.Type, "float*")] float* vdpi)
		{
			fixed (float* pddpi = &ddpi)
			{
				fixed (float* phdpi = &hdpi)
				{
					int ret = SDLGetDisplayDPINative(displayIndex, (float*)pddpi, (float*)phdpi, vdpi);
					return ret;
				}
			}
		}

		/// <summary>/// Get the dots/pixels-per-inch for a display.<br/>/// Diagonal, horizontal and vertical DPI can all be optionally returned if the<br/>/// appropriate parameter is non-NULL.<br/>/// A failure of this function usually means that either no DPI information is<br/>/// available or the `displayIndex` is out of range.<br/>/// **WARNING**: This reports the DPI that the hardware reports, and it is not<br/>/// always reliable! It is almost always better to use SDL_GetWindowSize() to<br/>/// find the window size, which might be in logical points instead of pixels,<br/>/// and then SDL_GL_GetDrawableSize(), SDL_Vulkan_GetDrawableSize(),<br/>/// SDL_Metal_GetDrawableSize(), or SDL_GetRendererOutputSize(), and compare<br/>/// the two values to get an actual scaling value between the two. We will be<br/>/// rethinking how high-dpi details should be managed in SDL3 to make things<br/>/// more consistent, reliable, and clear.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetDisplayDPI")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetDisplayDPI([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "ddpi")] [NativeName(NativeNameType.Type, "float*")] float* ddpi, [NativeName(NativeNameType.Param, "hdpi")] [NativeName(NativeNameType.Type, "float*")] float* hdpi, [NativeName(NativeNameType.Param, "vdpi")] [NativeName(NativeNameType.Type, "float*")] ref float vdpi)
		{
			fixed (float* pvdpi = &vdpi)
			{
				int ret = SDLGetDisplayDPINative(displayIndex, ddpi, hdpi, (float*)pvdpi);
				return ret;
			}
		}

		/// <summary>/// Get the dots/pixels-per-inch for a display.<br/>/// Diagonal, horizontal and vertical DPI can all be optionally returned if the<br/>/// appropriate parameter is non-NULL.<br/>/// A failure of this function usually means that either no DPI information is<br/>/// available or the `displayIndex` is out of range.<br/>/// **WARNING**: This reports the DPI that the hardware reports, and it is not<br/>/// always reliable! It is almost always better to use SDL_GetWindowSize() to<br/>/// find the window size, which might be in logical points instead of pixels,<br/>/// and then SDL_GL_GetDrawableSize(), SDL_Vulkan_GetDrawableSize(),<br/>/// SDL_Metal_GetDrawableSize(), or SDL_GetRendererOutputSize(), and compare<br/>/// the two values to get an actual scaling value between the two. We will be<br/>/// rethinking how high-dpi details should be managed in SDL3 to make things<br/>/// more consistent, reliable, and clear.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetDisplayDPI")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetDisplayDPI([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "ddpi")] [NativeName(NativeNameType.Type, "float*")] ref float ddpi, [NativeName(NativeNameType.Param, "hdpi")] [NativeName(NativeNameType.Type, "float*")] float* hdpi, [NativeName(NativeNameType.Param, "vdpi")] [NativeName(NativeNameType.Type, "float*")] ref float vdpi)
		{
			fixed (float* pddpi = &ddpi)
			{
				fixed (float* pvdpi = &vdpi)
				{
					int ret = SDLGetDisplayDPINative(displayIndex, (float*)pddpi, hdpi, (float*)pvdpi);
					return ret;
				}
			}
		}

		/// <summary>/// Get the dots/pixels-per-inch for a display.<br/>/// Diagonal, horizontal and vertical DPI can all be optionally returned if the<br/>/// appropriate parameter is non-NULL.<br/>/// A failure of this function usually means that either no DPI information is<br/>/// available or the `displayIndex` is out of range.<br/>/// **WARNING**: This reports the DPI that the hardware reports, and it is not<br/>/// always reliable! It is almost always better to use SDL_GetWindowSize() to<br/>/// find the window size, which might be in logical points instead of pixels,<br/>/// and then SDL_GL_GetDrawableSize(), SDL_Vulkan_GetDrawableSize(),<br/>/// SDL_Metal_GetDrawableSize(), or SDL_GetRendererOutputSize(), and compare<br/>/// the two values to get an actual scaling value between the two. We will be<br/>/// rethinking how high-dpi details should be managed in SDL3 to make things<br/>/// more consistent, reliable, and clear.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetDisplayDPI")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetDisplayDPI([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "ddpi")] [NativeName(NativeNameType.Type, "float*")] float* ddpi, [NativeName(NativeNameType.Param, "hdpi")] [NativeName(NativeNameType.Type, "float*")] ref float hdpi, [NativeName(NativeNameType.Param, "vdpi")] [NativeName(NativeNameType.Type, "float*")] ref float vdpi)
		{
			fixed (float* phdpi = &hdpi)
			{
				fixed (float* pvdpi = &vdpi)
				{
					int ret = SDLGetDisplayDPINative(displayIndex, ddpi, (float*)phdpi, (float*)pvdpi);
					return ret;
				}
			}
		}

		/// <summary>/// Get the dots/pixels-per-inch for a display.<br/>/// Diagonal, horizontal and vertical DPI can all be optionally returned if the<br/>/// appropriate parameter is non-NULL.<br/>/// A failure of this function usually means that either no DPI information is<br/>/// available or the `displayIndex` is out of range.<br/>/// **WARNING**: This reports the DPI that the hardware reports, and it is not<br/>/// always reliable! It is almost always better to use SDL_GetWindowSize() to<br/>/// find the window size, which might be in logical points instead of pixels,<br/>/// and then SDL_GL_GetDrawableSize(), SDL_Vulkan_GetDrawableSize(),<br/>/// SDL_Metal_GetDrawableSize(), or SDL_GetRendererOutputSize(), and compare<br/>/// the two values to get an actual scaling value between the two. We will be<br/>/// rethinking how high-dpi details should be managed in SDL3 to make things<br/>/// more consistent, reliable, and clear.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetDisplayDPI")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetDisplayDPI([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "ddpi")] [NativeName(NativeNameType.Type, "float*")] ref float ddpi, [NativeName(NativeNameType.Param, "hdpi")] [NativeName(NativeNameType.Type, "float*")] ref float hdpi, [NativeName(NativeNameType.Param, "vdpi")] [NativeName(NativeNameType.Type, "float*")] ref float vdpi)
		{
			fixed (float* pddpi = &ddpi)
			{
				fixed (float* phdpi = &hdpi)
				{
					fixed (float* pvdpi = &vdpi)
					{
						int ret = SDLGetDisplayDPINative(displayIndex, (float*)pddpi, (float*)phdpi, (float*)pvdpi);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the orientation of a display.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetDisplayOrientation")]
		[return: NativeName(NativeNameType.Type, "SDL_DisplayOrientation")]
		[LibraryImport(LibName, EntryPoint = "SDL_GetDisplayOrientation")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial SDLDisplayOrientation SDLGetDisplayOrientationNative([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex);

		/// <summary>/// Get the orientation of a display.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetDisplayOrientation")]
		[return: NativeName(NativeNameType.Type, "SDL_DisplayOrientation")]
		public static SDLDisplayOrientation SDLGetDisplayOrientation([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex)
		{
			SDLDisplayOrientation ret = SDLGetDisplayOrientationNative(displayIndex);
			return ret;
		}

		/// <summary>
		/// Get the number of available display modes.<br/>
		/// The `displayIndex` needs to be in the range from 0 to<br/>
		/// SDL_GetNumVideoDisplays() - 1.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumDisplayModes")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_GetNumDisplayModes")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLGetNumDisplayModesNative([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex);

		/// <summary>/// Get the number of available display modes.<br/>/// The `displayIndex` needs to be in the range from 0 to<br/>/// SDL_GetNumVideoDisplays() - 1.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetNumDisplayModes")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetNumDisplayModes([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex)
		{
			int ret = SDLGetNumDisplayModesNative(displayIndex);
			return ret;
		}

		/// <summary>
		/// Get information about a specific display mode.<br/>
		/// The display modes are sorted in this priority:<br/>
		/// - width -> largest to smallest<br/>
		/// - height -> largest to smallest<br/>
		/// - bits per pixel -> more colors to fewer colors<br/>
		/// - packed pixel layout -> largest to smallest<br/>
		/// - refresh rate -> highest to lowest<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetDisplayMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_GetDisplayMode")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLGetDisplayModeNative([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "modeIndex")] [NativeName(NativeNameType.Type, "int")] int modeIndex, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "SDL_DisplayMode*")] SDLDisplayMode* mode);

		/// <summary>/// Get information about a specific display mode.<br/>/// The display modes are sorted in this priority:<br/>/// - width -> largest to smallest<br/>/// - height -> largest to smallest<br/>/// - bits per pixel -> more colors to fewer colors<br/>/// - packed pixel layout -> largest to smallest<br/>/// - refresh rate -> highest to lowest<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetDisplayMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetDisplayMode([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "modeIndex")] [NativeName(NativeNameType.Type, "int")] int modeIndex, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "SDL_DisplayMode*")] SDLDisplayMode* mode)
		{
			int ret = SDLGetDisplayModeNative(displayIndex, modeIndex, mode);
			return ret;
		}

		/// <summary>/// Get information about a specific display mode.<br/>/// The display modes are sorted in this priority:<br/>/// - width -> largest to smallest<br/>/// - height -> largest to smallest<br/>/// - bits per pixel -> more colors to fewer colors<br/>/// - packed pixel layout -> largest to smallest<br/>/// - refresh rate -> highest to lowest<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetDisplayMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetDisplayMode([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "modeIndex")] [NativeName(NativeNameType.Type, "int")] int modeIndex, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "SDL_DisplayMode*")] ref SDLDisplayMode mode)
		{
			fixed (SDLDisplayMode* pmode = &mode)
			{
				int ret = SDLGetDisplayModeNative(displayIndex, modeIndex, (SDLDisplayMode*)pmode);
				return ret;
			}
		}

		/// <summary>
		/// Get information about the desktop's display mode.<br/>
		/// There's a difference between this function and SDL_GetCurrentDisplayMode()<br/>
		/// when SDL runs fullscreen and has changed the resolution. In that case this<br/>
		/// function will return the previous native display mode, and not the current<br/>
		/// display mode.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetDesktopDisplayMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_GetDesktopDisplayMode")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLGetDesktopDisplayModeNative([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "SDL_DisplayMode*")] SDLDisplayMode* mode);

		/// <summary>/// Get information about the desktop's display mode.<br/>/// There's a difference between this function and SDL_GetCurrentDisplayMode()<br/>/// when SDL runs fullscreen and has changed the resolution. In that case this<br/>/// function will return the previous native display mode, and not the current<br/>/// display mode.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetDesktopDisplayMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetDesktopDisplayMode([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "SDL_DisplayMode*")] SDLDisplayMode* mode)
		{
			int ret = SDLGetDesktopDisplayModeNative(displayIndex, mode);
			return ret;
		}

		/// <summary>/// Get information about the desktop's display mode.<br/>/// There's a difference between this function and SDL_GetCurrentDisplayMode()<br/>/// when SDL runs fullscreen and has changed the resolution. In that case this<br/>/// function will return the previous native display mode, and not the current<br/>/// display mode.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetDesktopDisplayMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetDesktopDisplayMode([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "SDL_DisplayMode*")] ref SDLDisplayMode mode)
		{
			fixed (SDLDisplayMode* pmode = &mode)
			{
				int ret = SDLGetDesktopDisplayModeNative(displayIndex, (SDLDisplayMode*)pmode);
				return ret;
			}
		}

		/// <summary>
		/// Get information about the current display mode.<br/>
		/// There's a difference between this function and SDL_GetDesktopDisplayMode()<br/>
		/// when SDL runs fullscreen and has changed the resolution. In that case this<br/>
		/// function will return the current display mode, and not the previous native<br/>
		/// display mode.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCurrentDisplayMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_GetCurrentDisplayMode")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLGetCurrentDisplayModeNative([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "SDL_DisplayMode*")] SDLDisplayMode* mode);

		/// <summary>/// Get information about the current display mode.<br/>/// There's a difference between this function and SDL_GetDesktopDisplayMode()<br/>/// when SDL runs fullscreen and has changed the resolution. In that case this<br/>/// function will return the current display mode, and not the previous native<br/>/// display mode.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetCurrentDisplayMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetCurrentDisplayMode([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "SDL_DisplayMode*")] SDLDisplayMode* mode)
		{
			int ret = SDLGetCurrentDisplayModeNative(displayIndex, mode);
			return ret;
		}

		/// <summary>/// Get information about the current display mode.<br/>/// There's a difference between this function and SDL_GetDesktopDisplayMode()<br/>/// when SDL runs fullscreen and has changed the resolution. In that case this<br/>/// function will return the current display mode, and not the previous native<br/>/// display mode.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetCurrentDisplayMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetCurrentDisplayMode([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "SDL_DisplayMode*")] ref SDLDisplayMode mode)
		{
			fixed (SDLDisplayMode* pmode = &mode)
			{
				int ret = SDLGetCurrentDisplayModeNative(displayIndex, (SDLDisplayMode*)pmode);
				return ret;
			}
		}

		/// <summary>
		/// Get the closest match to the requested display mode.<br/>
		/// The available display modes are scanned and `closest` is filled in with the<br/>
		/// closest mode matching the requested mode and returned. The mode format and<br/>
		/// refresh rate default to the desktop mode if they are set to 0. The modes<br/>
		/// are scanned with size being first priority, format being second priority,<br/>
		/// and finally checking the refresh rate. If all the available modes are too<br/>
		/// small, then NULL is returned.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetClosestDisplayMode")]
		[return: NativeName(NativeNameType.Type, "SDL_DisplayMode*")]
		[LibraryImport(LibName, EntryPoint = "SDL_GetClosestDisplayMode")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial SDLDisplayMode* SDLGetClosestDisplayModeNative([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "const SDL_DisplayMode*")] SDLDisplayMode* mode, [NativeName(NativeNameType.Param, "closest")] [NativeName(NativeNameType.Type, "SDL_DisplayMode*")] SDLDisplayMode* closest);

		/// <summary>/// Get the closest match to the requested display mode.<br/>/// The available display modes are scanned and `closest` is filled in with the<br/>/// closest mode matching the requested mode and returned. The mode format and<br/>/// refresh rate default to the desktop mode if they are set to 0. The modes<br/>/// are scanned with size being first priority, format being second priority,<br/>/// and finally checking the refresh rate. If all the available modes are too<br/>/// small, then NULL is returned.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetClosestDisplayMode")]
		[return: NativeName(NativeNameType.Type, "SDL_DisplayMode*")]
		public static SDLDisplayMode* SDLGetClosestDisplayMode([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "const SDL_DisplayMode*")] SDLDisplayMode* mode, [NativeName(NativeNameType.Param, "closest")] [NativeName(NativeNameType.Type, "SDL_DisplayMode*")] SDLDisplayMode* closest)
		{
			SDLDisplayMode* ret = SDLGetClosestDisplayModeNative(displayIndex, mode, closest);
			return ret;
		}

		/// <summary>/// Get the closest match to the requested display mode.<br/>/// The available display modes are scanned and `closest` is filled in with the<br/>/// closest mode matching the requested mode and returned. The mode format and<br/>/// refresh rate default to the desktop mode if they are set to 0. The modes<br/>/// are scanned with size being first priority, format being second priority,<br/>/// and finally checking the refresh rate. If all the available modes are too<br/>/// small, then NULL is returned.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetClosestDisplayMode")]
		[return: NativeName(NativeNameType.Type, "SDL_DisplayMode*")]
		public static SDLDisplayMode* SDLGetClosestDisplayMode([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "const SDL_DisplayMode*")] ref SDLDisplayMode mode, [NativeName(NativeNameType.Param, "closest")] [NativeName(NativeNameType.Type, "SDL_DisplayMode*")] SDLDisplayMode* closest)
		{
			fixed (SDLDisplayMode* pmode = &mode)
			{
				SDLDisplayMode* ret = SDLGetClosestDisplayModeNative(displayIndex, (SDLDisplayMode*)pmode, closest);
				return ret;
			}
		}

		/// <summary>/// Get the closest match to the requested display mode.<br/>/// The available display modes are scanned and `closest` is filled in with the<br/>/// closest mode matching the requested mode and returned. The mode format and<br/>/// refresh rate default to the desktop mode if they are set to 0. The modes<br/>/// are scanned with size being first priority, format being second priority,<br/>/// and finally checking the refresh rate. If all the available modes are too<br/>/// small, then NULL is returned.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetClosestDisplayMode")]
		[return: NativeName(NativeNameType.Type, "SDL_DisplayMode*")]
		public static SDLDisplayMode* SDLGetClosestDisplayMode([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "const SDL_DisplayMode*")] SDLDisplayMode* mode, [NativeName(NativeNameType.Param, "closest")] [NativeName(NativeNameType.Type, "SDL_DisplayMode*")] ref SDLDisplayMode closest)
		{
			fixed (SDLDisplayMode* pclosest = &closest)
			{
				SDLDisplayMode* ret = SDLGetClosestDisplayModeNative(displayIndex, mode, (SDLDisplayMode*)pclosest);
				return ret;
			}
		}

		/// <summary>/// Get the closest match to the requested display mode.<br/>/// The available display modes are scanned and `closest` is filled in with the<br/>/// closest mode matching the requested mode and returned. The mode format and<br/>/// refresh rate default to the desktop mode if they are set to 0. The modes<br/>/// are scanned with size being first priority, format being second priority,<br/>/// and finally checking the refresh rate. If all the available modes are too<br/>/// small, then NULL is returned.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetClosestDisplayMode")]
		[return: NativeName(NativeNameType.Type, "SDL_DisplayMode*")]
		public static SDLDisplayMode* SDLGetClosestDisplayMode([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "const SDL_DisplayMode*")] ref SDLDisplayMode mode, [NativeName(NativeNameType.Param, "closest")] [NativeName(NativeNameType.Type, "SDL_DisplayMode*")] ref SDLDisplayMode closest)
		{
			fixed (SDLDisplayMode* pmode = &mode)
			{
				fixed (SDLDisplayMode* pclosest = &closest)
				{
					SDLDisplayMode* ret = SDLGetClosestDisplayModeNative(displayIndex, (SDLDisplayMode*)pmode, (SDLDisplayMode*)pclosest);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the index of the display containing a point<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPointDisplayIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_GetPointDisplayIndex")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLGetPointDisplayIndexNative([NativeName(NativeNameType.Param, "point")] [NativeName(NativeNameType.Type, "const SDL_Point*")] SDLPoint* point);

		/// <summary>/// Get the index of the display containing a point<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetPointDisplayIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetPointDisplayIndex([NativeName(NativeNameType.Param, "point")] [NativeName(NativeNameType.Type, "const SDL_Point*")] SDLPoint* point)
		{
			int ret = SDLGetPointDisplayIndexNative(point);
			return ret;
		}

		/// <summary>
		/// Get the index of the display primarily containing a rect<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectDisplayIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_GetRectDisplayIndex")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLGetRectDisplayIndexNative([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect);

		/// <summary>/// Get the index of the display primarily containing a rect<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRectDisplayIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRectDisplayIndex([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect)
		{
			int ret = SDLGetRectDisplayIndexNative(rect);
			return ret;
		}

		/// <summary>
		/// Get the index of the display associated with a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowDisplayIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_GetWindowDisplayIndex")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLGetWindowDisplayIndexNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window);

		/// <summary>/// Get the index of the display associated with a window.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowDisplayIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowDisplayIndex([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window)
		{
			int ret = SDLGetWindowDisplayIndexNative(window);
			return ret;
		}

		/// <summary>
		/// Set the display mode to use when a window is visible at fullscreen.<br/>
		/// This only affects the display mode used when the window is fullscreen. To<br/>
		/// change the window size when the window is not fullscreen, use<br/>
		/// SDL_SetWindowSize().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowDisplayMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		[LibraryImport(LibName, EntryPoint = "SDL_SetWindowDisplayMode")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int SDLSetWindowDisplayModeNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "const SDL_DisplayMode*")] SDLDisplayMode* mode);

		/// <summary>/// Set the display mode to use when a window is visible at fullscreen.<br/>/// This only affects the display mode used when the window is fullscreen. To<br/>/// change the window size when the window is not fullscreen, use<br/>/// SDL_SetWindowSize().<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowDisplayMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetWindowDisplayMode([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "const SDL_DisplayMode*")] SDLDisplayMode* mode)
		{
			int ret = SDLSetWindowDisplayModeNative(window, mode);
			return ret;
		}
	}
}
