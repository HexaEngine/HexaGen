// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL2
{
	public unsafe partial class SDL
	{
		/// <summary>/// Wait for a thread to finish.<br/>/// Threads that haven't been detached will remain (as a "zombie") until this<br/>/// function cleans them up. Not doing so is a resource leak.<br/>/// Once a thread has been cleaned up through this function, the SDL_Thread<br/>/// that references it becomes invalid and should not be referenced again. As<br/>/// such, only one thread may call SDL_WaitThread() on another.<br/>/// The return code for the thread function is placed in the area pointed to by<br/>/// `status`, if `status` is not NULL.<br/>/// You may not wait on a thread that has been used in a call to<br/>/// SDL_DetachThread(). Use either that function or this one, but not both, or<br/>/// behavior is undefined.<br/>/// It is safe to pass a NULL thread to this function; it is a no-op.<br/>/// Note that the thread pointer is freed by this function and is not valid<br/>/// afterward.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_WaitThread")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLWaitThread([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread*")] SDLThread* thread, [NativeName(NativeNameType.Param, "status")] [NativeName(NativeNameType.Type, "int*")] int* status)
		{
			SDLWaitThreadNative(thread, status);
		}

		/// <summary>/// Wait for a thread to finish.<br/>/// Threads that haven't been detached will remain (as a "zombie") until this<br/>/// function cleans them up. Not doing so is a resource leak.<br/>/// Once a thread has been cleaned up through this function, the SDL_Thread<br/>/// that references it becomes invalid and should not be referenced again. As<br/>/// such, only one thread may call SDL_WaitThread() on another.<br/>/// The return code for the thread function is placed in the area pointed to by<br/>/// `status`, if `status` is not NULL.<br/>/// You may not wait on a thread that has been used in a call to<br/>/// SDL_DetachThread(). Use either that function or this one, but not both, or<br/>/// behavior is undefined.<br/>/// It is safe to pass a NULL thread to this function; it is a no-op.<br/>/// Note that the thread pointer is freed by this function and is not valid<br/>/// afterward.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_WaitThread")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLWaitThread([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread*")] ref SDLThread thread, [NativeName(NativeNameType.Param, "status")] [NativeName(NativeNameType.Type, "int*")] int* status)
		{
			fixed (SDLThread* pthread = &thread)
			{
				SDLWaitThreadNative((SDLThread*)pthread, status);
			}
		}

		/// <summary>/// Wait for a thread to finish.<br/>/// Threads that haven't been detached will remain (as a "zombie") until this<br/>/// function cleans them up. Not doing so is a resource leak.<br/>/// Once a thread has been cleaned up through this function, the SDL_Thread<br/>/// that references it becomes invalid and should not be referenced again. As<br/>/// such, only one thread may call SDL_WaitThread() on another.<br/>/// The return code for the thread function is placed in the area pointed to by<br/>/// `status`, if `status` is not NULL.<br/>/// You may not wait on a thread that has been used in a call to<br/>/// SDL_DetachThread(). Use either that function or this one, but not both, or<br/>/// behavior is undefined.<br/>/// It is safe to pass a NULL thread to this function; it is a no-op.<br/>/// Note that the thread pointer is freed by this function and is not valid<br/>/// afterward.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_WaitThread")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLWaitThread([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread*")] SDLThread* thread, [NativeName(NativeNameType.Param, "status")] [NativeName(NativeNameType.Type, "int*")] ref int status)
		{
			fixed (int* pstatus = &status)
			{
				SDLWaitThreadNative(thread, (int*)pstatus);
			}
		}

		/// <summary>/// Wait for a thread to finish.<br/>/// Threads that haven't been detached will remain (as a "zombie") until this<br/>/// function cleans them up. Not doing so is a resource leak.<br/>/// Once a thread has been cleaned up through this function, the SDL_Thread<br/>/// that references it becomes invalid and should not be referenced again. As<br/>/// such, only one thread may call SDL_WaitThread() on another.<br/>/// The return code for the thread function is placed in the area pointed to by<br/>/// `status`, if `status` is not NULL.<br/>/// You may not wait on a thread that has been used in a call to<br/>/// SDL_DetachThread(). Use either that function or this one, but not both, or<br/>/// behavior is undefined.<br/>/// It is safe to pass a NULL thread to this function; it is a no-op.<br/>/// Note that the thread pointer is freed by this function and is not valid<br/>/// afterward.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_WaitThread")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLWaitThread([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread*")] ref SDLThread thread, [NativeName(NativeNameType.Param, "status")] [NativeName(NativeNameType.Type, "int*")] ref int status)
		{
			fixed (SDLThread* pthread = &thread)
			{
				fixed (int* pstatus = &status)
				{
					SDLWaitThreadNative((SDLThread*)pthread, (int*)pstatus);
				}
			}
		}

		/// <summary>
		/// Let a thread clean up on exit without intervention.<br/>
		/// A thread may be "detached" to signify that it should not remain until<br/>
		/// another thread has called SDL_WaitThread() on it. Detaching a thread is<br/>
		/// useful for long-running threads that nothing needs to synchronize with or<br/>
		/// further manage. When a detached thread is done, it simply goes away.<br/>
		/// There is no way to recover the return code of a detached thread. If you<br/>
		/// need this, don't detach the thread and instead use SDL_WaitThread().<br/>
		/// Once a thread is detached, you should usually assume the SDL_Thread isn't<br/>
		/// safe to reference again, as it will become invalid immediately upon the<br/>
		/// detached thread's exit, instead of remaining until someone has called<br/>
		/// SDL_WaitThread() to finally clean it up. As such, don't detach the same<br/>
		/// thread more than once.<br/>
		/// If a thread has already exited when passed to SDL_DetachThread(), it will<br/>
		/// stop waiting for a call to SDL_WaitThread() and clean up immediately. It is<br/>
		/// not safe to detach a thread that might be used with SDL_WaitThread().<br/>
		/// You may not call SDL_WaitThread() on a thread that has been detached. Use<br/>
		/// either that function or this one, but not both, or behavior is undefined.<br/>
		/// It is safe to pass NULL to this function; it is a no-op.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DetachThread")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SDLDetachThreadNative([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread*")] SDLThread* thread)
		{
			((delegate* unmanaged[Cdecl]<SDLThread*, void>)vt[179])(thread);
		}
		/// <summary>/// Let a thread clean up on exit without intervention.<br/>/// A thread may be "detached" to signify that it should not remain until<br/>/// another thread has called SDL_WaitThread() on it. Detaching a thread is<br/>/// useful for long-running threads that nothing needs to synchronize with or<br/>/// further manage. When a detached thread is done, it simply goes away.<br/>/// There is no way to recover the return code of a detached thread. If you<br/>/// need this, don't detach the thread and instead use SDL_WaitThread().<br/>/// Once a thread is detached, you should usually assume the SDL_Thread isn't<br/>/// safe to reference again, as it will become invalid immediately upon the<br/>/// detached thread's exit, instead of remaining until someone has called<br/>/// SDL_WaitThread() to finally clean it up. As such, don't detach the same<br/>/// thread more than once.<br/>/// If a thread has already exited when passed to SDL_DetachThread(), it will<br/>/// stop waiting for a call to SDL_WaitThread() and clean up immediately. It is<br/>/// not safe to detach a thread that might be used with SDL_WaitThread().<br/>/// You may not call SDL_WaitThread() on a thread that has been detached. Use<br/>/// either that function or this one, but not both, or behavior is undefined.<br/>/// It is safe to pass NULL to this function; it is a no-op.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_DetachThread")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLDetachThread([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread*")] SDLThread* thread)
		{
			SDLDetachThreadNative(thread);
		}

		/// <summary>/// Let a thread clean up on exit without intervention.<br/>/// A thread may be "detached" to signify that it should not remain until<br/>/// another thread has called SDL_WaitThread() on it. Detaching a thread is<br/>/// useful for long-running threads that nothing needs to synchronize with or<br/>/// further manage. When a detached thread is done, it simply goes away.<br/>/// There is no way to recover the return code of a detached thread. If you<br/>/// need this, don't detach the thread and instead use SDL_WaitThread().<br/>/// Once a thread is detached, you should usually assume the SDL_Thread isn't<br/>/// safe to reference again, as it will become invalid immediately upon the<br/>/// detached thread's exit, instead of remaining until someone has called<br/>/// SDL_WaitThread() to finally clean it up. As such, don't detach the same<br/>/// thread more than once.<br/>/// If a thread has already exited when passed to SDL_DetachThread(), it will<br/>/// stop waiting for a call to SDL_WaitThread() and clean up immediately. It is<br/>/// not safe to detach a thread that might be used with SDL_WaitThread().<br/>/// You may not call SDL_WaitThread() on a thread that has been detached. Use<br/>/// either that function or this one, but not both, or behavior is undefined.<br/>/// It is safe to pass NULL to this function; it is a no-op.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_DetachThread")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLDetachThread([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread*")] ref SDLThread thread)
		{
			fixed (SDLThread* pthread = &thread)
			{
				SDLDetachThreadNative((SDLThread*)pthread);
			}
		}

		/// <summary>
		/// Create a piece of thread-local storage.<br/>
		/// This creates an identifier that is globally visible to all threads but<br/>
		/// refers to data that is thread-specific.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TLSCreate")]
		[return: NativeName(NativeNameType.Type, "SDL_TLSID")]
		internal static uint SDLTLSCreateNative()
		{
			return ((delegate* unmanaged[Cdecl]<uint>)vt[180])();
		}
		/// <summary>/// Create a piece of thread-local storage.<br/>/// This creates an identifier that is globally visible to all threads but<br/>/// refers to data that is thread-specific.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_TLSCreate")]
		[return: NativeName(NativeNameType.Type, "SDL_TLSID")]
		public static uint SDLTLSCreate()
		{
			uint ret = SDLTLSCreateNative();
			return ret;
		}

		/// <summary>
		/// Get the current thread's value associated with a thread local storage ID.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TLSGet")]
		[return: NativeName(NativeNameType.Type, "void*")]
		internal static void* SDLTLSGetNative([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "SDL_TLSID")] uint id)
		{
			return ((delegate* unmanaged[Cdecl]<uint, void*>)vt[181])(id);
		}
		/// <summary>/// Get the current thread's value associated with a thread local storage ID.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_TLSGet")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLTLSGet([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "SDL_TLSID")] uint id)
		{
			void* ret = SDLTLSGetNative(id);
			return ret;
		}

		/// <summary>
		/// Set the current thread's value associated with a thread local storage ID.<br/>
		/// The function prototype for `destructor` is:<br/>
		/// ```c<br/>
		/// void destructor(void *value)<br/>
		/// ```<br/>
		/// where its parameter `value` is what was passed as `value` to SDL_TLSSet().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TLSSet")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLTLSSetNative([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "SDL_TLSID")] uint id, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const void*")] void* value, [NativeName(NativeNameType.Param, "destructor")] [NativeName(NativeNameType.Type, "void (*)(SDL_TLSID id, const void* value, void (*)(void*)* destructor)*")] delegate*<uint, void*, delegate*<void*, void>, void> destructor)
		{
			return ((delegate* unmanaged[Cdecl]<uint, void*, delegate*<uint, void*, delegate*<void*, void>, void>, int>)vt[182])(id, value, destructor);
		}
		/// <summary>/// Set the current thread's value associated with a thread local storage ID.<br/>/// The function prototype for `destructor` is:<br/>/// ```c<br/>/// void destructor(void *value)<br/>/// ```<br/>/// where its parameter `value` is what was passed as `value` to SDL_TLSSet().<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_TLSSet")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLTLSSet([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "SDL_TLSID")] uint id, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const void*")] void* value, [NativeName(NativeNameType.Param, "destructor")] [NativeName(NativeNameType.Type, "void (*)(SDL_TLSID id, const void* value, void (*)(void*)* destructor)*")] delegate*<uint, void*, delegate*<void*, void>, void> destructor)
		{
			int ret = SDLTLSSetNative(id, value, destructor);
			return ret;
		}

		/// <summary>
		/// Cleanup all TLS data for this thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TLSCleanup")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SDLTLSCleanupNative()
		{
			((delegate* unmanaged[Cdecl]<void>)vt[183])();
		}
		/// <summary>/// Cleanup all TLS data for this thread.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_TLSCleanup")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLTLSCleanup()
		{
			SDLTLSCleanupNative();
		}

		/// <summary>
		/// Use this function to create a new SDL_RWops structure for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string is treated roughly the same as in a call to the C<br/>
		/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>
		/// scenes.<br/>
		/// Available `mode` strings:<br/>
		/// - "r": Open a file for reading. The file must exist.<br/>
		/// - "w": Create an empty file for writing. If a file with the same name<br/>
		/// already exists its content is erased and the file is treated as a new<br/>
		/// empty file.<br/>
		/// - "a": Append to a file. Writing operations append data at the end of the<br/>
		/// file. The file is created if it does not exist.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// - "a+": Open a file for reading and appending. All writing operations are<br/>
		/// performed at the end of the file, protecting the previous content to be<br/>
		/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>
		/// anywhere in the file for reading, but writing operations will move it<br/>
		/// back to the end of file. The file is created if it does not exist.<br/>
		/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>
		/// be included in the `mode` string. This additional "b" character can either<br/>
		/// be appended at the end of the string (thus making the following compound<br/>
		/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>
		/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>
		/// Additional characters may follow the sequence, although they should have no<br/>
		/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>
		/// a text file.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// As a fallback, SDL_RWFromFile() will transparently open a matching filename<br/>
		/// in an Android app's `assets`.<br/>
		/// Closing the SDL_RWops will close the file handle SDL is holding internally.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RWFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_RWops*")]
		internal static SDLRWops* SDLRWFromFileNative([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] byte* file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "const char*")] byte* mode)
		{
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, SDLRWops*>)vt[184])(file, mode);
		}
		/// <summary>/// Use this function to create a new SDL_RWops structure for reading from<br/>/// and/or writing to a named file.<br/>/// The `mode` string is treated roughly the same as in a call to the C<br/>/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>/// scenes.<br/>/// Available `mode` strings:<br/>/// - "r": Open a file for reading. The file must exist.<br/>/// - "w": Create an empty file for writing. If a file with the same name<br/>/// already exists its content is erased and the file is treated as a new<br/>/// empty file.<br/>/// - "a": Append to a file. Writing operations append data at the end of the<br/>/// file. The file is created if it does not exist.<br/>/// - "r+": Open a file for update both reading and writing. The file must<br/>/// exist.<br/>/// - "w+": Create an empty file for both reading and writing. If a file with<br/>/// the same name already exists its content is erased and the file is<br/>/// treated as a new empty file.<br/>/// - "a+": Open a file for reading and appending. All writing operations are<br/>/// performed at the end of the file, protecting the previous content to be<br/>/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>/// anywhere in the file for reading, but writing operations will move it<br/>/// back to the end of file. The file is created if it does not exist.<br/>/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>/// be included in the `mode` string. This additional "b" character can either<br/>/// be appended at the end of the string (thus making the following compound<br/>/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>/// Additional characters may follow the sequence, although they should have no<br/>/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>/// a text file.<br/>/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>/// format, regardless of the underlying operating system.<br/>/// As a fallback, SDL_RWFromFile() will transparently open a matching filename<br/>/// in an Android app's `assets`.<br/>/// Closing the SDL_RWops will close the file handle SDL is holding internally.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_RWops*")]
		public static SDLRWops* SDLRWFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] byte* file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "const char*")] byte* mode)
		{
			SDLRWops* ret = SDLRWFromFileNative(file, mode);
			return ret;
		}

		/// <summary>/// Use this function to create a new SDL_RWops structure for reading from<br/>/// and/or writing to a named file.<br/>/// The `mode` string is treated roughly the same as in a call to the C<br/>/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>/// scenes.<br/>/// Available `mode` strings:<br/>/// - "r": Open a file for reading. The file must exist.<br/>/// - "w": Create an empty file for writing. If a file with the same name<br/>/// already exists its content is erased and the file is treated as a new<br/>/// empty file.<br/>/// - "a": Append to a file. Writing operations append data at the end of the<br/>/// file. The file is created if it does not exist.<br/>/// - "r+": Open a file for update both reading and writing. The file must<br/>/// exist.<br/>/// - "w+": Create an empty file for both reading and writing. If a file with<br/>/// the same name already exists its content is erased and the file is<br/>/// treated as a new empty file.<br/>/// - "a+": Open a file for reading and appending. All writing operations are<br/>/// performed at the end of the file, protecting the previous content to be<br/>/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>/// anywhere in the file for reading, but writing operations will move it<br/>/// back to the end of file. The file is created if it does not exist.<br/>/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>/// be included in the `mode` string. This additional "b" character can either<br/>/// be appended at the end of the string (thus making the following compound<br/>/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>/// Additional characters may follow the sequence, although they should have no<br/>/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>/// a text file.<br/>/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>/// format, regardless of the underlying operating system.<br/>/// As a fallback, SDL_RWFromFile() will transparently open a matching filename<br/>/// in an Android app's `assets`.<br/>/// Closing the SDL_RWops will close the file handle SDL is holding internally.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_RWops*")]
		public static SDLRWops* SDLRWFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] ref byte file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "const char*")] byte* mode)
		{
			fixed (byte* pfile = &file)
			{
				SDLRWops* ret = SDLRWFromFileNative((byte*)pfile, mode);
				return ret;
			}
		}

		/// <summary>/// Use this function to create a new SDL_RWops structure for reading from<br/>/// and/or writing to a named file.<br/>/// The `mode` string is treated roughly the same as in a call to the C<br/>/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>/// scenes.<br/>/// Available `mode` strings:<br/>/// - "r": Open a file for reading. The file must exist.<br/>/// - "w": Create an empty file for writing. If a file with the same name<br/>/// already exists its content is erased and the file is treated as a new<br/>/// empty file.<br/>/// - "a": Append to a file. Writing operations append data at the end of the<br/>/// file. The file is created if it does not exist.<br/>/// - "r+": Open a file for update both reading and writing. The file must<br/>/// exist.<br/>/// - "w+": Create an empty file for both reading and writing. If a file with<br/>/// the same name already exists its content is erased and the file is<br/>/// treated as a new empty file.<br/>/// - "a+": Open a file for reading and appending. All writing operations are<br/>/// performed at the end of the file, protecting the previous content to be<br/>/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>/// anywhere in the file for reading, but writing operations will move it<br/>/// back to the end of file. The file is created if it does not exist.<br/>/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>/// be included in the `mode` string. This additional "b" character can either<br/>/// be appended at the end of the string (thus making the following compound<br/>/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>/// Additional characters may follow the sequence, although they should have no<br/>/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>/// a text file.<br/>/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>/// format, regardless of the underlying operating system.<br/>/// As a fallback, SDL_RWFromFile() will transparently open a matching filename<br/>/// in an Android app's `assets`.<br/>/// Closing the SDL_RWops will close the file handle SDL is holding internally.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_RWops*")]
		public static SDLRWops* SDLRWFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] string file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "const char*")] byte* mode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLRWops* ret = SDLRWFromFileNative(pStr0, mode);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// Use this function to create a new SDL_RWops structure for reading from<br/>/// and/or writing to a named file.<br/>/// The `mode` string is treated roughly the same as in a call to the C<br/>/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>/// scenes.<br/>/// Available `mode` strings:<br/>/// - "r": Open a file for reading. The file must exist.<br/>/// - "w": Create an empty file for writing. If a file with the same name<br/>/// already exists its content is erased and the file is treated as a new<br/>/// empty file.<br/>/// - "a": Append to a file. Writing operations append data at the end of the<br/>/// file. The file is created if it does not exist.<br/>/// - "r+": Open a file for update both reading and writing. The file must<br/>/// exist.<br/>/// - "w+": Create an empty file for both reading and writing. If a file with<br/>/// the same name already exists its content is erased and the file is<br/>/// treated as a new empty file.<br/>/// - "a+": Open a file for reading and appending. All writing operations are<br/>/// performed at the end of the file, protecting the previous content to be<br/>/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>/// anywhere in the file for reading, but writing operations will move it<br/>/// back to the end of file. The file is created if it does not exist.<br/>/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>/// be included in the `mode` string. This additional "b" character can either<br/>/// be appended at the end of the string (thus making the following compound<br/>/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>/// Additional characters may follow the sequence, although they should have no<br/>/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>/// a text file.<br/>/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>/// format, regardless of the underlying operating system.<br/>/// As a fallback, SDL_RWFromFile() will transparently open a matching filename<br/>/// in an Android app's `assets`.<br/>/// Closing the SDL_RWops will close the file handle SDL is holding internally.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_RWops*")]
		public static SDLRWops* SDLRWFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] byte* file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "const char*")] ref byte mode)
		{
			fixed (byte* pmode = &mode)
			{
				SDLRWops* ret = SDLRWFromFileNative(file, (byte*)pmode);
				return ret;
			}
		}

		/// <summary>/// Use this function to create a new SDL_RWops structure for reading from<br/>/// and/or writing to a named file.<br/>/// The `mode` string is treated roughly the same as in a call to the C<br/>/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>/// scenes.<br/>/// Available `mode` strings:<br/>/// - "r": Open a file for reading. The file must exist.<br/>/// - "w": Create an empty file for writing. If a file with the same name<br/>/// already exists its content is erased and the file is treated as a new<br/>/// empty file.<br/>/// - "a": Append to a file. Writing operations append data at the end of the<br/>/// file. The file is created if it does not exist.<br/>/// - "r+": Open a file for update both reading and writing. The file must<br/>/// exist.<br/>/// - "w+": Create an empty file for both reading and writing. If a file with<br/>/// the same name already exists its content is erased and the file is<br/>/// treated as a new empty file.<br/>/// - "a+": Open a file for reading and appending. All writing operations are<br/>/// performed at the end of the file, protecting the previous content to be<br/>/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>/// anywhere in the file for reading, but writing operations will move it<br/>/// back to the end of file. The file is created if it does not exist.<br/>/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>/// be included in the `mode` string. This additional "b" character can either<br/>/// be appended at the end of the string (thus making the following compound<br/>/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>/// Additional characters may follow the sequence, although they should have no<br/>/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>/// a text file.<br/>/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>/// format, regardless of the underlying operating system.<br/>/// As a fallback, SDL_RWFromFile() will transparently open a matching filename<br/>/// in an Android app's `assets`.<br/>/// Closing the SDL_RWops will close the file handle SDL is holding internally.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_RWops*")]
		public static SDLRWops* SDLRWFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] byte* file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "const char*")] string mode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (mode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(mode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(mode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLRWops* ret = SDLRWFromFileNative(file, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// Use this function to create a new SDL_RWops structure for reading from<br/>/// and/or writing to a named file.<br/>/// The `mode` string is treated roughly the same as in a call to the C<br/>/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>/// scenes.<br/>/// Available `mode` strings:<br/>/// - "r": Open a file for reading. The file must exist.<br/>/// - "w": Create an empty file for writing. If a file with the same name<br/>/// already exists its content is erased and the file is treated as a new<br/>/// empty file.<br/>/// - "a": Append to a file. Writing operations append data at the end of the<br/>/// file. The file is created if it does not exist.<br/>/// - "r+": Open a file for update both reading and writing. The file must<br/>/// exist.<br/>/// - "w+": Create an empty file for both reading and writing. If a file with<br/>/// the same name already exists its content is erased and the file is<br/>/// treated as a new empty file.<br/>/// - "a+": Open a file for reading and appending. All writing operations are<br/>/// performed at the end of the file, protecting the previous content to be<br/>/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>/// anywhere in the file for reading, but writing operations will move it<br/>/// back to the end of file. The file is created if it does not exist.<br/>/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>/// be included in the `mode` string. This additional "b" character can either<br/>/// be appended at the end of the string (thus making the following compound<br/>/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>/// Additional characters may follow the sequence, although they should have no<br/>/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>/// a text file.<br/>/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>/// format, regardless of the underlying operating system.<br/>/// As a fallback, SDL_RWFromFile() will transparently open a matching filename<br/>/// in an Android app's `assets`.<br/>/// Closing the SDL_RWops will close the file handle SDL is holding internally.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_RWops*")]
		public static SDLRWops* SDLRWFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] ref byte file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "const char*")] ref byte mode)
		{
			fixed (byte* pfile = &file)
			{
				fixed (byte* pmode = &mode)
				{
					SDLRWops* ret = SDLRWFromFileNative((byte*)pfile, (byte*)pmode);
					return ret;
				}
			}
		}

		/// <summary>/// Use this function to create a new SDL_RWops structure for reading from<br/>/// and/or writing to a named file.<br/>/// The `mode` string is treated roughly the same as in a call to the C<br/>/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>/// scenes.<br/>/// Available `mode` strings:<br/>/// - "r": Open a file for reading. The file must exist.<br/>/// - "w": Create an empty file for writing. If a file with the same name<br/>/// already exists its content is erased and the file is treated as a new<br/>/// empty file.<br/>/// - "a": Append to a file. Writing operations append data at the end of the<br/>/// file. The file is created if it does not exist.<br/>/// - "r+": Open a file for update both reading and writing. The file must<br/>/// exist.<br/>/// - "w+": Create an empty file for both reading and writing. If a file with<br/>/// the same name already exists its content is erased and the file is<br/>/// treated as a new empty file.<br/>/// - "a+": Open a file for reading and appending. All writing operations are<br/>/// performed at the end of the file, protecting the previous content to be<br/>/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>/// anywhere in the file for reading, but writing operations will move it<br/>/// back to the end of file. The file is created if it does not exist.<br/>/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>/// be included in the `mode` string. This additional "b" character can either<br/>/// be appended at the end of the string (thus making the following compound<br/>/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>/// Additional characters may follow the sequence, although they should have no<br/>/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>/// a text file.<br/>/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>/// format, regardless of the underlying operating system.<br/>/// As a fallback, SDL_RWFromFile() will transparently open a matching filename<br/>/// in an Android app's `assets`.<br/>/// Closing the SDL_RWops will close the file handle SDL is holding internally.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_RWops*")]
		public static SDLRWops* SDLRWFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] string file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "const char*")] string mode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (mode != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(mode);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(mode, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			SDLRWops* ret = SDLRWFromFileNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Use this function to create an SDL_RWops structure from a standard I/O file<br/>
		/// pointer (stdio.h's `FILE*`).<br/>
		/// This function is not available on Windows, since files opened in an<br/>
		/// application on that platform cannot be used by a dynamically linked<br/>
		/// library.<br/>
		/// On some platforms, the first parameter is a `void*`, on others, it's a<br/>
		/// `FILE*`, depending on what system headers are available to SDL. It is<br/>
		/// always intended to be the `FILE*` type from the C runtime's stdio.h.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RWFromFP")]
		[return: NativeName(NativeNameType.Type, "SDL_RWops*")]
		internal static SDLRWops* SDLRWFromFPNative([NativeName(NativeNameType.Param, "fp")] [NativeName(NativeNameType.Type, "void*")] void* fp, [NativeName(NativeNameType.Param, "autoclose")] [NativeName(NativeNameType.Type, "SDL_bool")] SDLBool autoclose)
		{
			return ((delegate* unmanaged[Cdecl]<void*, SDLBool, SDLRWops*>)vt[185])(fp, autoclose);
		}
		/// <summary>/// Use this function to create an SDL_RWops structure from a standard I/O file<br/>/// pointer (stdio.h's `FILE*`).<br/>/// This function is not available on Windows, since files opened in an<br/>/// application on that platform cannot be used by a dynamically linked<br/>/// library.<br/>/// On some platforms, the first parameter is a `void*`, on others, it's a<br/>/// `FILE*`, depending on what system headers are available to SDL. It is<br/>/// always intended to be the `FILE*` type from the C runtime's stdio.h.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWFromFP")]
		[return: NativeName(NativeNameType.Type, "SDL_RWops*")]
		public static SDLRWops* SDLRWFromFP([NativeName(NativeNameType.Param, "fp")] [NativeName(NativeNameType.Type, "void*")] void* fp, [NativeName(NativeNameType.Param, "autoclose")] [NativeName(NativeNameType.Type, "SDL_bool")] SDLBool autoclose)
		{
			SDLRWops* ret = SDLRWFromFPNative(fp, autoclose);
			return ret;
		}

		/// <summary>
		/// Use this function to prepare a read-write memory buffer for use with<br/>
		/// SDL_RWops.<br/>
		/// This function sets up an SDL_RWops struct based on a memory area of a<br/>
		/// certain size, for both read and write access.<br/>
		/// This memory buffer is not copied by the RWops; the pointer you provide must<br/>
		/// remain valid until you close the stream. Closing the stream will not free<br/>
		/// the original buffer.<br/>
		/// If you need to make sure the RWops never writes to the memory buffer, you<br/>
		/// should use SDL_RWFromConstMem() with a read-only buffer of memory instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RWFromMem")]
		[return: NativeName(NativeNameType.Type, "SDL_RWops*")]
		internal static SDLRWops* SDLRWFromMemNative([NativeName(NativeNameType.Param, "mem")] [NativeName(NativeNameType.Type, "void*")] void* mem, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "int")] int size)
		{
			return ((delegate* unmanaged[Cdecl]<void*, int, SDLRWops*>)vt[186])(mem, size);
		}
		/// <summary>/// Use this function to prepare a read-write memory buffer for use with<br/>/// SDL_RWops.<br/>/// This function sets up an SDL_RWops struct based on a memory area of a<br/>/// certain size, for both read and write access.<br/>/// This memory buffer is not copied by the RWops; the pointer you provide must<br/>/// remain valid until you close the stream. Closing the stream will not free<br/>/// the original buffer.<br/>/// If you need to make sure the RWops never writes to the memory buffer, you<br/>/// should use SDL_RWFromConstMem() with a read-only buffer of memory instead.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWFromMem")]
		[return: NativeName(NativeNameType.Type, "SDL_RWops*")]
		public static SDLRWops* SDLRWFromMem([NativeName(NativeNameType.Param, "mem")] [NativeName(NativeNameType.Type, "void*")] void* mem, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "int")] int size)
		{
			SDLRWops* ret = SDLRWFromMemNative(mem, size);
			return ret;
		}

		/// <summary>
		/// Use this function to prepare a read-only memory buffer for use with RWops.<br/>
		/// This function sets up an SDL_RWops struct based on a memory area of a<br/>
		/// certain size. It assumes the memory area is not writable.<br/>
		/// Attempting to write to this RWops stream will report an error without<br/>
		/// writing to the memory buffer.<br/>
		/// This memory buffer is not copied by the RWops; the pointer you provide must<br/>
		/// remain valid until you close the stream. Closing the stream will not free<br/>
		/// the original buffer.<br/>
		/// If you need to write to a memory buffer, you should use SDL_RWFromMem()<br/>
		/// with a writable buffer of memory instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RWFromConstMem")]
		[return: NativeName(NativeNameType.Type, "SDL_RWops*")]
		internal static SDLRWops* SDLRWFromConstMemNative([NativeName(NativeNameType.Param, "mem")] [NativeName(NativeNameType.Type, "const void*")] void* mem, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "int")] int size)
		{
			return ((delegate* unmanaged[Cdecl]<void*, int, SDLRWops*>)vt[187])(mem, size);
		}
		/// <summary>/// Use this function to prepare a read-only memory buffer for use with RWops.<br/>/// This function sets up an SDL_RWops struct based on a memory area of a<br/>/// certain size. It assumes the memory area is not writable.<br/>/// Attempting to write to this RWops stream will report an error without<br/>/// writing to the memory buffer.<br/>/// This memory buffer is not copied by the RWops; the pointer you provide must<br/>/// remain valid until you close the stream. Closing the stream will not free<br/>/// the original buffer.<br/>/// If you need to write to a memory buffer, you should use SDL_RWFromMem()<br/>/// with a writable buffer of memory instead.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWFromConstMem")]
		[return: NativeName(NativeNameType.Type, "SDL_RWops*")]
		public static SDLRWops* SDLRWFromConstMem([NativeName(NativeNameType.Param, "mem")] [NativeName(NativeNameType.Type, "const void*")] void* mem, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "int")] int size)
		{
			SDLRWops* ret = SDLRWFromConstMemNative(mem, size);
			return ret;
		}

		/// <summary>
		/// Use this function to allocate an empty, unpopulated SDL_RWops structure.<br/>
		/// Applications do not need to use this function unless they are providing<br/>
		/// their own SDL_RWops implementation. If you just need a SDL_RWops to<br/>
		/// read/write a common data source, you should use the built-in<br/>
		/// implementations in SDL, like SDL_RWFromFile() or SDL_RWFromMem(), etc.<br/>
		/// You must free the returned pointer with SDL_FreeRW(). Depending on your<br/>
		/// operating system and compiler, there may be a difference between the<br/>
		/// malloc() and free() your program uses and the versions SDL calls<br/>
		/// internally. Trying to mix the two can cause crashing such as segmentation<br/>
		/// faults. Since all SDL_RWops must free themselves when their **close**<br/>
		/// method is called, all SDL_RWops must be allocated through this function, so<br/>
		/// they can all be freed correctly with SDL_FreeRW().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AllocRW")]
		[return: NativeName(NativeNameType.Type, "SDL_RWops*")]
		internal static SDLRWops* SDLAllocRWNative()
		{
			return ((delegate* unmanaged[Cdecl]<SDLRWops*>)vt[188])();
		}
		/// <summary>/// Use this function to allocate an empty, unpopulated SDL_RWops structure.<br/>/// Applications do not need to use this function unless they are providing<br/>/// their own SDL_RWops implementation. If you just need a SDL_RWops to<br/>/// read/write a common data source, you should use the built-in<br/>/// implementations in SDL, like SDL_RWFromFile() or SDL_RWFromMem(), etc.<br/>/// You must free the returned pointer with SDL_FreeRW(). Depending on your<br/>/// operating system and compiler, there may be a difference between the<br/>/// malloc() and free() your program uses and the versions SDL calls<br/>/// internally. Trying to mix the two can cause crashing such as segmentation<br/>/// faults. Since all SDL_RWops must free themselves when their **close**<br/>/// method is called, all SDL_RWops must be allocated through this function, so<br/>/// they can all be freed correctly with SDL_FreeRW().<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_AllocRW")]
		[return: NativeName(NativeNameType.Type, "SDL_RWops*")]
		public static SDLRWops* SDLAllocRW()
		{
			SDLRWops* ret = SDLAllocRWNative();
			return ret;
		}

		/// <summary>
		/// Use this function to free an SDL_RWops structure allocated by<br/>
		/// SDL_AllocRW().<br/>
		/// Applications do not need to use this function unless they are providing<br/>
		/// their own SDL_RWops implementation. If you just need a SDL_RWops to<br/>
		/// read/write a common data source, you should use the built-in<br/>
		/// implementations in SDL, like SDL_RWFromFile() or SDL_RWFromMem(), etc, and<br/>
		/// call the **close** method on those SDL_RWops pointers when you are done<br/>
		/// with them.<br/>
		/// Only use SDL_FreeRW() on pointers returned by SDL_AllocRW(). The pointer is<br/>
		/// invalid as soon as this function returns. Any extra memory allocated during<br/>
		/// creation of the SDL_RWops is not freed by SDL_FreeRW(); the programmer must<br/>
		/// be responsible for managing that memory in their **close** method.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FreeRW")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SDLFreeRWNative([NativeName(NativeNameType.Param, "area")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* area)
		{
			((delegate* unmanaged[Cdecl]<SDLRWops*, void>)vt[189])(area);
		}
		/// <summary>/// Use this function to free an SDL_RWops structure allocated by<br/>/// SDL_AllocRW().<br/>/// Applications do not need to use this function unless they are providing<br/>/// their own SDL_RWops implementation. If you just need a SDL_RWops to<br/>/// read/write a common data source, you should use the built-in<br/>/// implementations in SDL, like SDL_RWFromFile() or SDL_RWFromMem(), etc, and<br/>/// call the **close** method on those SDL_RWops pointers when you are done<br/>/// with them.<br/>/// Only use SDL_FreeRW() on pointers returned by SDL_AllocRW(). The pointer is<br/>/// invalid as soon as this function returns. Any extra memory allocated during<br/>/// creation of the SDL_RWops is not freed by SDL_FreeRW(); the programmer must<br/>/// be responsible for managing that memory in their **close** method.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_FreeRW")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLFreeRW([NativeName(NativeNameType.Param, "area")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* area)
		{
			SDLFreeRWNative(area);
		}

		/// <summary>/// Use this function to free an SDL_RWops structure allocated by<br/>/// SDL_AllocRW().<br/>/// Applications do not need to use this function unless they are providing<br/>/// their own SDL_RWops implementation. If you just need a SDL_RWops to<br/>/// read/write a common data source, you should use the built-in<br/>/// implementations in SDL, like SDL_RWFromFile() or SDL_RWFromMem(), etc, and<br/>/// call the **close** method on those SDL_RWops pointers when you are done<br/>/// with them.<br/>/// Only use SDL_FreeRW() on pointers returned by SDL_AllocRW(). The pointer is<br/>/// invalid as soon as this function returns. Any extra memory allocated during<br/>/// creation of the SDL_RWops is not freed by SDL_FreeRW(); the programmer must<br/>/// be responsible for managing that memory in their **close** method.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_FreeRW")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLFreeRW([NativeName(NativeNameType.Param, "area")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops area)
		{
			fixed (SDLRWops* parea = &area)
			{
				SDLFreeRWNative((SDLRWops*)parea);
			}
		}

		/// <summary>
		/// Use this function to get the size of the data stream in an SDL_RWops.<br/>
		/// Prior to SDL 2.0.10, this function was a macro.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RWsize")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		internal static long SDLRWsizeNative([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* context)
		{
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, long>)vt[190])(context);
		}
		/// <summary>/// Use this function to get the size of the data stream in an SDL_RWops.<br/>/// Prior to SDL 2.0.10, this function was a macro.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWsize")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long SDLRWsize([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* context)
		{
			long ret = SDLRWsizeNative(context);
			return ret;
		}

		/// <summary>/// Use this function to get the size of the data stream in an SDL_RWops.<br/>/// Prior to SDL 2.0.10, this function was a macro.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWsize")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long SDLRWsize([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops context)
		{
			fixed (SDLRWops* pcontext = &context)
			{
				long ret = SDLRWsizeNative((SDLRWops*)pcontext);
				return ret;
			}
		}

		/// <summary>
		/// Seek within an SDL_RWops data stream.<br/>
		/// This function seeks to byte `offset`, relative to `whence`.<br/>
		/// `whence` may be any of the following values:<br/>
		/// - `RW_SEEK_SET`: seek from the beginning of data<br/>
		/// - `RW_SEEK_CUR`: seek relative to current read point<br/>
		/// - `RW_SEEK_END`: seek relative to the end of data<br/>
		/// If this stream can not seek, it will return -1.<br/>
		/// SDL_RWseek() is actually a wrapper function that calls the SDL_RWops's<br/>
		/// `seek` method appropriately, to simplify application development.<br/>
		/// Prior to SDL 2.0.10, this function was a macro.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RWseek")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		internal static long SDLRWseekNative([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* context, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Sint64")] long offset, [NativeName(NativeNameType.Param, "whence")] [NativeName(NativeNameType.Type, "int")] int whence)
		{
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, long, int, long>)vt[191])(context, offset, whence);
		}
		/// <summary>/// Seek within an SDL_RWops data stream.<br/>/// This function seeks to byte `offset`, relative to `whence`.<br/>/// `whence` may be any of the following values:<br/>/// - `RW_SEEK_SET`: seek from the beginning of data<br/>/// - `RW_SEEK_CUR`: seek relative to current read point<br/>/// - `RW_SEEK_END`: seek relative to the end of data<br/>/// If this stream can not seek, it will return -1.<br/>/// SDL_RWseek() is actually a wrapper function that calls the SDL_RWops's<br/>/// `seek` method appropriately, to simplify application development.<br/>/// Prior to SDL 2.0.10, this function was a macro.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWseek")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long SDLRWseek([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* context, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Sint64")] long offset, [NativeName(NativeNameType.Param, "whence")] [NativeName(NativeNameType.Type, "int")] int whence)
		{
			long ret = SDLRWseekNative(context, offset, whence);
			return ret;
		}

		/// <summary>/// Seek within an SDL_RWops data stream.<br/>/// This function seeks to byte `offset`, relative to `whence`.<br/>/// `whence` may be any of the following values:<br/>/// - `RW_SEEK_SET`: seek from the beginning of data<br/>/// - `RW_SEEK_CUR`: seek relative to current read point<br/>/// - `RW_SEEK_END`: seek relative to the end of data<br/>/// If this stream can not seek, it will return -1.<br/>/// SDL_RWseek() is actually a wrapper function that calls the SDL_RWops's<br/>/// `seek` method appropriately, to simplify application development.<br/>/// Prior to SDL 2.0.10, this function was a macro.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWseek")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long SDLRWseek([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops context, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Sint64")] long offset, [NativeName(NativeNameType.Param, "whence")] [NativeName(NativeNameType.Type, "int")] int whence)
		{
			fixed (SDLRWops* pcontext = &context)
			{
				long ret = SDLRWseekNative((SDLRWops*)pcontext, offset, whence);
				return ret;
			}
		}

		/// <summary>
		/// Determine the current read/write offset in an SDL_RWops data stream.<br/>
		/// SDL_RWtell is actually a wrapper function that calls the SDL_RWops's `seek`<br/>
		/// method, with an offset of 0 bytes from `RW_SEEK_CUR`, to simplify<br/>
		/// application development.<br/>
		/// Prior to SDL 2.0.10, this function was a macro.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RWtell")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		internal static long SDLRWtellNative([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* context)
		{
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, long>)vt[192])(context);
		}
		/// <summary>/// Determine the current read/write offset in an SDL_RWops data stream.<br/>/// SDL_RWtell is actually a wrapper function that calls the SDL_RWops's `seek`<br/>/// method, with an offset of 0 bytes from `RW_SEEK_CUR`, to simplify<br/>/// application development.<br/>/// Prior to SDL 2.0.10, this function was a macro.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWtell")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long SDLRWtell([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* context)
		{
			long ret = SDLRWtellNative(context);
			return ret;
		}

		/// <summary>/// Determine the current read/write offset in an SDL_RWops data stream.<br/>/// SDL_RWtell is actually a wrapper function that calls the SDL_RWops's `seek`<br/>/// method, with an offset of 0 bytes from `RW_SEEK_CUR`, to simplify<br/>/// application development.<br/>/// Prior to SDL 2.0.10, this function was a macro.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWtell")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long SDLRWtell([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops context)
		{
			fixed (SDLRWops* pcontext = &context)
			{
				long ret = SDLRWtellNative((SDLRWops*)pcontext);
				return ret;
			}
		}

		/// <summary>
		/// Read from a data source.<br/>
		/// This function reads up to `maxnum` objects each of size `size` from the<br/>
		/// data source to the area pointed at by `ptr`. This function may read less<br/>
		/// objects than requested. It will return zero when there has been an error or<br/>
		/// the data stream is completely read.<br/>
		/// SDL_RWread() is actually a function wrapper that calls the SDL_RWops's<br/>
		/// `read` method appropriately, to simplify application development.<br/>
		/// Prior to SDL 2.0.10, this function was a macro.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RWread")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		internal static ulong SDLRWreadNative([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* context, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void*")] void* ptr, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] ulong size, [NativeName(NativeNameType.Param, "maxnum")] [NativeName(NativeNameType.Type, "size_t")] ulong maxnum)
		{
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, void*, ulong, ulong, ulong>)vt[193])(context, ptr, size, maxnum);
		}
		/// <summary>/// Read from a data source.<br/>/// This function reads up to `maxnum` objects each of size `size` from the<br/>/// data source to the area pointed at by `ptr`. This function may read less<br/>/// objects than requested. It will return zero when there has been an error or<br/>/// the data stream is completely read.<br/>/// SDL_RWread() is actually a function wrapper that calls the SDL_RWops's<br/>/// `read` method appropriately, to simplify application development.<br/>/// Prior to SDL 2.0.10, this function was a macro.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWread")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLRWread([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* context, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void*")] void* ptr, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] ulong size, [NativeName(NativeNameType.Param, "maxnum")] [NativeName(NativeNameType.Type, "size_t")] ulong maxnum)
		{
			ulong ret = SDLRWreadNative(context, ptr, size, maxnum);
			return ret;
		}

		/// <summary>/// Read from a data source.<br/>/// This function reads up to `maxnum` objects each of size `size` from the<br/>/// data source to the area pointed at by `ptr`. This function may read less<br/>/// objects than requested. It will return zero when there has been an error or<br/>/// the data stream is completely read.<br/>/// SDL_RWread() is actually a function wrapper that calls the SDL_RWops's<br/>/// `read` method appropriately, to simplify application development.<br/>/// Prior to SDL 2.0.10, this function was a macro.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWread")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLRWread([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops context, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void*")] void* ptr, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] ulong size, [NativeName(NativeNameType.Param, "maxnum")] [NativeName(NativeNameType.Type, "size_t")] ulong maxnum)
		{
			fixed (SDLRWops* pcontext = &context)
			{
				ulong ret = SDLRWreadNative((SDLRWops*)pcontext, ptr, size, maxnum);
				return ret;
			}
		}

		/// <summary>/// Read from a data source.<br/>/// This function reads up to `maxnum` objects each of size `size` from the<br/>/// data source to the area pointed at by `ptr`. This function may read less<br/>/// objects than requested. It will return zero when there has been an error or<br/>/// the data stream is completely read.<br/>/// SDL_RWread() is actually a function wrapper that calls the SDL_RWops's<br/>/// `read` method appropriately, to simplify application development.<br/>/// Prior to SDL 2.0.10, this function was a macro.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWread")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLRWread([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* context, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void*")] void* ptr, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "maxnum")] [NativeName(NativeNameType.Type, "size_t")] ulong maxnum)
		{
			ulong ret = SDLRWreadNative(context, ptr, size, maxnum);
			return ret;
		}

		/// <summary>/// Read from a data source.<br/>/// This function reads up to `maxnum` objects each of size `size` from the<br/>/// data source to the area pointed at by `ptr`. This function may read less<br/>/// objects than requested. It will return zero when there has been an error or<br/>/// the data stream is completely read.<br/>/// SDL_RWread() is actually a function wrapper that calls the SDL_RWops's<br/>/// `read` method appropriately, to simplify application development.<br/>/// Prior to SDL 2.0.10, this function was a macro.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWread")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLRWread([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops context, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void*")] void* ptr, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "maxnum")] [NativeName(NativeNameType.Type, "size_t")] ulong maxnum)
		{
			fixed (SDLRWops* pcontext = &context)
			{
				ulong ret = SDLRWreadNative((SDLRWops*)pcontext, ptr, size, maxnum);
				return ret;
			}
		}

		/// <summary>/// Read from a data source.<br/>/// This function reads up to `maxnum` objects each of size `size` from the<br/>/// data source to the area pointed at by `ptr`. This function may read less<br/>/// objects than requested. It will return zero when there has been an error or<br/>/// the data stream is completely read.<br/>/// SDL_RWread() is actually a function wrapper that calls the SDL_RWops's<br/>/// `read` method appropriately, to simplify application development.<br/>/// Prior to SDL 2.0.10, this function was a macro.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWread")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLRWread([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* context, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void*")] void* ptr, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] ulong size, [NativeName(NativeNameType.Param, "maxnum")] [NativeName(NativeNameType.Type, "size_t")] nuint maxnum)
		{
			ulong ret = SDLRWreadNative(context, ptr, size, maxnum);
			return ret;
		}

		/// <summary>/// Read from a data source.<br/>/// This function reads up to `maxnum` objects each of size `size` from the<br/>/// data source to the area pointed at by `ptr`. This function may read less<br/>/// objects than requested. It will return zero when there has been an error or<br/>/// the data stream is completely read.<br/>/// SDL_RWread() is actually a function wrapper that calls the SDL_RWops's<br/>/// `read` method appropriately, to simplify application development.<br/>/// Prior to SDL 2.0.10, this function was a macro.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWread")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLRWread([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops context, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void*")] void* ptr, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] ulong size, [NativeName(NativeNameType.Param, "maxnum")] [NativeName(NativeNameType.Type, "size_t")] nuint maxnum)
		{
			fixed (SDLRWops* pcontext = &context)
			{
				ulong ret = SDLRWreadNative((SDLRWops*)pcontext, ptr, size, maxnum);
				return ret;
			}
		}

		/// <summary>/// Read from a data source.<br/>/// This function reads up to `maxnum` objects each of size `size` from the<br/>/// data source to the area pointed at by `ptr`. This function may read less<br/>/// objects than requested. It will return zero when there has been an error or<br/>/// the data stream is completely read.<br/>/// SDL_RWread() is actually a function wrapper that calls the SDL_RWops's<br/>/// `read` method appropriately, to simplify application development.<br/>/// Prior to SDL 2.0.10, this function was a macro.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWread")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLRWread([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* context, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void*")] void* ptr, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "maxnum")] [NativeName(NativeNameType.Type, "size_t")] nuint maxnum)
		{
			ulong ret = SDLRWreadNative(context, ptr, size, maxnum);
			return ret;
		}

		/// <summary>/// Read from a data source.<br/>/// This function reads up to `maxnum` objects each of size `size` from the<br/>/// data source to the area pointed at by `ptr`. This function may read less<br/>/// objects than requested. It will return zero when there has been an error or<br/>/// the data stream is completely read.<br/>/// SDL_RWread() is actually a function wrapper that calls the SDL_RWops's<br/>/// `read` method appropriately, to simplify application development.<br/>/// Prior to SDL 2.0.10, this function was a macro.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWread")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLRWread([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops context, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void*")] void* ptr, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "maxnum")] [NativeName(NativeNameType.Type, "size_t")] nuint maxnum)
		{
			fixed (SDLRWops* pcontext = &context)
			{
				ulong ret = SDLRWreadNative((SDLRWops*)pcontext, ptr, size, maxnum);
				return ret;
			}
		}

		/// <summary>
		/// Write to an SDL_RWops data stream.<br/>
		/// This function writes exactly `num` objects each of size `size` from the<br/>
		/// area pointed at by `ptr` to the stream. If this fails for any reason, it'll<br/>
		/// return less than `num` to demonstrate how far the write progressed. On<br/>
		/// success, it returns `num`.<br/>
		/// SDL_RWwrite is actually a function wrapper that calls the SDL_RWops's<br/>
		/// `write` method appropriately, to simplify application development.<br/>
		/// Prior to SDL 2.0.10, this function was a macro.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RWwrite")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		internal static ulong SDLRWwriteNative([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* context, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "const void*")] void* ptr, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] ulong size, [NativeName(NativeNameType.Param, "num")] [NativeName(NativeNameType.Type, "size_t")] ulong num)
		{
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, void*, ulong, ulong, ulong>)vt[194])(context, ptr, size, num);
		}
		/// <summary>/// Write to an SDL_RWops data stream.<br/>/// This function writes exactly `num` objects each of size `size` from the<br/>/// area pointed at by `ptr` to the stream. If this fails for any reason, it'll<br/>/// return less than `num` to demonstrate how far the write progressed. On<br/>/// success, it returns `num`.<br/>/// SDL_RWwrite is actually a function wrapper that calls the SDL_RWops's<br/>/// `write` method appropriately, to simplify application development.<br/>/// Prior to SDL 2.0.10, this function was a macro.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWwrite")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLRWwrite([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* context, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "const void*")] void* ptr, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] ulong size, [NativeName(NativeNameType.Param, "num")] [NativeName(NativeNameType.Type, "size_t")] ulong num)
		{
			ulong ret = SDLRWwriteNative(context, ptr, size, num);
			return ret;
		}

		/// <summary>/// Write to an SDL_RWops data stream.<br/>/// This function writes exactly `num` objects each of size `size` from the<br/>/// area pointed at by `ptr` to the stream. If this fails for any reason, it'll<br/>/// return less than `num` to demonstrate how far the write progressed. On<br/>/// success, it returns `num`.<br/>/// SDL_RWwrite is actually a function wrapper that calls the SDL_RWops's<br/>/// `write` method appropriately, to simplify application development.<br/>/// Prior to SDL 2.0.10, this function was a macro.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWwrite")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLRWwrite([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops context, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "const void*")] void* ptr, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] ulong size, [NativeName(NativeNameType.Param, "num")] [NativeName(NativeNameType.Type, "size_t")] ulong num)
		{
			fixed (SDLRWops* pcontext = &context)
			{
				ulong ret = SDLRWwriteNative((SDLRWops*)pcontext, ptr, size, num);
				return ret;
			}
		}

		/// <summary>/// Write to an SDL_RWops data stream.<br/>/// This function writes exactly `num` objects each of size `size` from the<br/>/// area pointed at by `ptr` to the stream. If this fails for any reason, it'll<br/>/// return less than `num` to demonstrate how far the write progressed. On<br/>/// success, it returns `num`.<br/>/// SDL_RWwrite is actually a function wrapper that calls the SDL_RWops's<br/>/// `write` method appropriately, to simplify application development.<br/>/// Prior to SDL 2.0.10, this function was a macro.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWwrite")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLRWwrite([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* context, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "const void*")] void* ptr, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "num")] [NativeName(NativeNameType.Type, "size_t")] ulong num)
		{
			ulong ret = SDLRWwriteNative(context, ptr, size, num);
			return ret;
		}

		/// <summary>/// Write to an SDL_RWops data stream.<br/>/// This function writes exactly `num` objects each of size `size` from the<br/>/// area pointed at by `ptr` to the stream. If this fails for any reason, it'll<br/>/// return less than `num` to demonstrate how far the write progressed. On<br/>/// success, it returns `num`.<br/>/// SDL_RWwrite is actually a function wrapper that calls the SDL_RWops's<br/>/// `write` method appropriately, to simplify application development.<br/>/// Prior to SDL 2.0.10, this function was a macro.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWwrite")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLRWwrite([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops context, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "const void*")] void* ptr, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "num")] [NativeName(NativeNameType.Type, "size_t")] ulong num)
		{
			fixed (SDLRWops* pcontext = &context)
			{
				ulong ret = SDLRWwriteNative((SDLRWops*)pcontext, ptr, size, num);
				return ret;
			}
		}

		/// <summary>/// Write to an SDL_RWops data stream.<br/>/// This function writes exactly `num` objects each of size `size` from the<br/>/// area pointed at by `ptr` to the stream. If this fails for any reason, it'll<br/>/// return less than `num` to demonstrate how far the write progressed. On<br/>/// success, it returns `num`.<br/>/// SDL_RWwrite is actually a function wrapper that calls the SDL_RWops's<br/>/// `write` method appropriately, to simplify application development.<br/>/// Prior to SDL 2.0.10, this function was a macro.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWwrite")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLRWwrite([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* context, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "const void*")] void* ptr, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] ulong size, [NativeName(NativeNameType.Param, "num")] [NativeName(NativeNameType.Type, "size_t")] nuint num)
		{
			ulong ret = SDLRWwriteNative(context, ptr, size, num);
			return ret;
		}

		/// <summary>/// Write to an SDL_RWops data stream.<br/>/// This function writes exactly `num` objects each of size `size` from the<br/>/// area pointed at by `ptr` to the stream. If this fails for any reason, it'll<br/>/// return less than `num` to demonstrate how far the write progressed. On<br/>/// success, it returns `num`.<br/>/// SDL_RWwrite is actually a function wrapper that calls the SDL_RWops's<br/>/// `write` method appropriately, to simplify application development.<br/>/// Prior to SDL 2.0.10, this function was a macro.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWwrite")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLRWwrite([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops context, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "const void*")] void* ptr, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] ulong size, [NativeName(NativeNameType.Param, "num")] [NativeName(NativeNameType.Type, "size_t")] nuint num)
		{
			fixed (SDLRWops* pcontext = &context)
			{
				ulong ret = SDLRWwriteNative((SDLRWops*)pcontext, ptr, size, num);
				return ret;
			}
		}

		/// <summary>/// Write to an SDL_RWops data stream.<br/>/// This function writes exactly `num` objects each of size `size` from the<br/>/// area pointed at by `ptr` to the stream. If this fails for any reason, it'll<br/>/// return less than `num` to demonstrate how far the write progressed. On<br/>/// success, it returns `num`.<br/>/// SDL_RWwrite is actually a function wrapper that calls the SDL_RWops's<br/>/// `write` method appropriately, to simplify application development.<br/>/// Prior to SDL 2.0.10, this function was a macro.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWwrite")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLRWwrite([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* context, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "const void*")] void* ptr, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "num")] [NativeName(NativeNameType.Type, "size_t")] nuint num)
		{
			ulong ret = SDLRWwriteNative(context, ptr, size, num);
			return ret;
		}

		/// <summary>/// Write to an SDL_RWops data stream.<br/>/// This function writes exactly `num` objects each of size `size` from the<br/>/// area pointed at by `ptr` to the stream. If this fails for any reason, it'll<br/>/// return less than `num` to demonstrate how far the write progressed. On<br/>/// success, it returns `num`.<br/>/// SDL_RWwrite is actually a function wrapper that calls the SDL_RWops's<br/>/// `write` method appropriately, to simplify application development.<br/>/// Prior to SDL 2.0.10, this function was a macro.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWwrite")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLRWwrite([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops context, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "const void*")] void* ptr, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "num")] [NativeName(NativeNameType.Type, "size_t")] nuint num)
		{
			fixed (SDLRWops* pcontext = &context)
			{
				ulong ret = SDLRWwriteNative((SDLRWops*)pcontext, ptr, size, num);
				return ret;
			}
		}

		/// <summary>
		/// Close and free an allocated SDL_RWops structure.<br/>
		/// SDL_RWclose() closes and cleans up the SDL_RWops stream. It releases any<br/>
		/// resources used by the stream and frees the SDL_RWops itself with<br/>
		/// SDL_FreeRW(). This returns 0 on success, or -1 if the stream failed to<br/>
		/// flush to its output (e.g. to disk).<br/>
		/// Note that if this fails to flush the stream to disk, this function reports<br/>
		/// an error, but the SDL_RWops is still invalid once this function returns.<br/>
		/// Prior to SDL 2.0.10, this function was a macro.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RWclose")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLRWcloseNative([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* context)
		{
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int>)vt[195])(context);
		}
		/// <summary>/// Close and free an allocated SDL_RWops structure.<br/>/// SDL_RWclose() closes and cleans up the SDL_RWops stream. It releases any<br/>/// resources used by the stream and frees the SDL_RWops itself with<br/>/// SDL_FreeRW(). This returns 0 on success, or -1 if the stream failed to<br/>/// flush to its output (e.g. to disk).<br/>/// Note that if this fails to flush the stream to disk, this function reports<br/>/// an error, but the SDL_RWops is still invalid once this function returns.<br/>/// Prior to SDL 2.0.10, this function was a macro.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWclose")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRWclose([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* context)
		{
			int ret = SDLRWcloseNative(context);
			return ret;
		}

		/// <summary>/// Close and free an allocated SDL_RWops structure.<br/>/// SDL_RWclose() closes and cleans up the SDL_RWops stream. It releases any<br/>/// resources used by the stream and frees the SDL_RWops itself with<br/>/// SDL_FreeRW(). This returns 0 on success, or -1 if the stream failed to<br/>/// flush to its output (e.g. to disk).<br/>/// Note that if this fails to flush the stream to disk, this function reports<br/>/// an error, but the SDL_RWops is still invalid once this function returns.<br/>/// Prior to SDL 2.0.10, this function was a macro.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWclose")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRWclose([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops context)
		{
			fixed (SDLRWops* pcontext = &context)
			{
				int ret = SDLRWcloseNative((SDLRWops*)pcontext);
				return ret;
			}
		}

		/// <summary>
		/// Load all the data from an SDL data stream.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFile_RW")]
		[return: NativeName(NativeNameType.Type, "void*")]
		internal static void* SDLLoadFileRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t*")] ulong* datasize, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc)
		{
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, ulong*, int, void*>)vt[196])(src, datasize, freesrc);
		}
		/// <summary>/// Load all the data from an SDL data stream.<br/>/// The data is allocated with a zero byte at the end (null terminated) for<br/>/// convenience. This extra byte is not included in the value reported via<br/>/// `datasize`.<br/>/// The data should be freed with SDL_free().<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_LoadFile_RW")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLLoadFileRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t*")] ulong* datasize, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc)
		{
			void* ret = SDLLoadFileRWNative(src, datasize, freesrc);
			return ret;
		}

		/// <summary>/// Load all the data from an SDL data stream.<br/>/// The data is allocated with a zero byte at the end (null terminated) for<br/>/// convenience. This extra byte is not included in the value reported via<br/>/// `datasize`.<br/>/// The data should be freed with SDL_free().<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_LoadFile_RW")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLLoadFileRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t*")] ulong* datasize, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc)
		{
			fixed (SDLRWops* psrc = &src)
			{
				void* ret = SDLLoadFileRWNative((SDLRWops*)psrc, datasize, freesrc);
				return ret;
			}
		}

		/// <summary>/// Load all the data from an SDL data stream.<br/>/// The data is allocated with a zero byte at the end (null terminated) for<br/>/// convenience. This extra byte is not included in the value reported via<br/>/// `datasize`.<br/>/// The data should be freed with SDL_free().<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_LoadFile_RW")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLLoadFileRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t*")] ref nuint datasize, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc)
		{
			fixed (nuint* pdatasize = &datasize)
			{
				void* ret = SDLLoadFileRWNative(src, (ulong*)pdatasize, freesrc);
				return ret;
			}
		}

		/// <summary>/// Load all the data from an SDL data stream.<br/>/// The data is allocated with a zero byte at the end (null terminated) for<br/>/// convenience. This extra byte is not included in the value reported via<br/>/// `datasize`.<br/>/// The data should be freed with SDL_free().<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_LoadFile_RW")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLLoadFileRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t*")] ref nuint datasize, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc)
		{
			fixed (SDLRWops* psrc = &src)
			{
				fixed (nuint* pdatasize = &datasize)
				{
					void* ret = SDLLoadFileRWNative((SDLRWops*)psrc, (ulong*)pdatasize, freesrc);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load all the data from a file path.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// Prior to SDL 2.0.10, this function was a macro wrapping around<br/>
		/// SDL_LoadFile_RW.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFile")]
		[return: NativeName(NativeNameType.Type, "void*")]
		internal static void* SDLLoadFileNative([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] byte* file, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t*")] ulong* datasize)
		{
			return ((delegate* unmanaged[Cdecl]<byte*, ulong*, void*>)vt[197])(file, datasize);
		}
		/// <summary>/// Load all the data from a file path.<br/>/// The data is allocated with a zero byte at the end (null terminated) for<br/>/// convenience. This extra byte is not included in the value reported via<br/>/// `datasize`.<br/>/// The data should be freed with SDL_free().<br/>/// Prior to SDL 2.0.10, this function was a macro wrapping around<br/>/// SDL_LoadFile_RW.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_LoadFile")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLLoadFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] byte* file, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t*")] ulong* datasize)
		{
			void* ret = SDLLoadFileNative(file, datasize);
			return ret;
		}

		/// <summary>/// Load all the data from a file path.<br/>/// The data is allocated with a zero byte at the end (null terminated) for<br/>/// convenience. This extra byte is not included in the value reported via<br/>/// `datasize`.<br/>/// The data should be freed with SDL_free().<br/>/// Prior to SDL 2.0.10, this function was a macro wrapping around<br/>/// SDL_LoadFile_RW.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_LoadFile")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLLoadFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] ref byte file, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t*")] ulong* datasize)
		{
			fixed (byte* pfile = &file)
			{
				void* ret = SDLLoadFileNative((byte*)pfile, datasize);
				return ret;
			}
		}

		/// <summary>/// Load all the data from a file path.<br/>/// The data is allocated with a zero byte at the end (null terminated) for<br/>/// convenience. This extra byte is not included in the value reported via<br/>/// `datasize`.<br/>/// The data should be freed with SDL_free().<br/>/// Prior to SDL 2.0.10, this function was a macro wrapping around<br/>/// SDL_LoadFile_RW.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_LoadFile")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLLoadFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] string file, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t*")] ulong* datasize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			void* ret = SDLLoadFileNative(pStr0, datasize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// Load all the data from a file path.<br/>/// The data is allocated with a zero byte at the end (null terminated) for<br/>/// convenience. This extra byte is not included in the value reported via<br/>/// `datasize`.<br/>/// The data should be freed with SDL_free().<br/>/// Prior to SDL 2.0.10, this function was a macro wrapping around<br/>/// SDL_LoadFile_RW.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_LoadFile")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLLoadFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] byte* file, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t*")] ref nuint datasize)
		{
			fixed (nuint* pdatasize = &datasize)
			{
				void* ret = SDLLoadFileNative(file, (ulong*)pdatasize);
				return ret;
			}
		}

		/// <summary>/// Load all the data from a file path.<br/>/// The data is allocated with a zero byte at the end (null terminated) for<br/>/// convenience. This extra byte is not included in the value reported via<br/>/// `datasize`.<br/>/// The data should be freed with SDL_free().<br/>/// Prior to SDL 2.0.10, this function was a macro wrapping around<br/>/// SDL_LoadFile_RW.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_LoadFile")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLLoadFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] ref byte file, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t*")] ref nuint datasize)
		{
			fixed (byte* pfile = &file)
			{
				fixed (nuint* pdatasize = &datasize)
				{
					void* ret = SDLLoadFileNative((byte*)pfile, (ulong*)pdatasize);
					return ret;
				}
			}
		}

		/// <summary>/// Load all the data from a file path.<br/>/// The data is allocated with a zero byte at the end (null terminated) for<br/>/// convenience. This extra byte is not included in the value reported via<br/>/// `datasize`.<br/>/// The data should be freed with SDL_free().<br/>/// Prior to SDL 2.0.10, this function was a macro wrapping around<br/>/// SDL_LoadFile_RW.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_LoadFile")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLLoadFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] string file, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t*")] ref nuint datasize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (nuint* pdatasize = &datasize)
			{
				void* ret = SDLLoadFileNative(pStr0, (ulong*)pdatasize);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read a byte from an SDL_RWops.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadU8")]
		[return: NativeName(NativeNameType.Type, "Uint8")]
		internal static byte SDLReadU8Native([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, byte>)vt[198])(src);
		}
		/// <summary>/// Use this function to read a byte from an SDL_RWops.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_ReadU8")]
		[return: NativeName(NativeNameType.Type, "Uint8")]
		public static byte SDLReadU8([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			byte ret = SDLReadU8Native(src);
			return ret;
		}

		/// <summary>/// Use this function to read a byte from an SDL_RWops.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_ReadU8")]
		[return: NativeName(NativeNameType.Type, "Uint8")]
		public static byte SDLReadU8([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				byte ret = SDLReadU8Native((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read 16 bits of little-endian data from an SDL_RWops<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadLE16")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		internal static ushort SDLReadLE16Native([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, ushort>)vt[199])(src);
		}
		/// <summary>/// Use this function to read 16 bits of little-endian data from an SDL_RWops<br/>/// and return in native format.<br/>/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>/// the native byte order.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_ReadLE16")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort SDLReadLE16([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			ushort ret = SDLReadLE16Native(src);
			return ret;
		}

		/// <summary>/// Use this function to read 16 bits of little-endian data from an SDL_RWops<br/>/// and return in native format.<br/>/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>/// the native byte order.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_ReadLE16")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort SDLReadLE16([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				ushort ret = SDLReadLE16Native((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read 16 bits of big-endian data from an SDL_RWops and<br/>
		/// return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadBE16")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		internal static ushort SDLReadBE16Native([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, ushort>)vt[200])(src);
		}
		/// <summary>/// Use this function to read 16 bits of big-endian data from an SDL_RWops and<br/>/// return in native format.<br/>/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>/// the native byte order.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_ReadBE16")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort SDLReadBE16([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			ushort ret = SDLReadBE16Native(src);
			return ret;
		}

		/// <summary>/// Use this function to read 16 bits of big-endian data from an SDL_RWops and<br/>/// return in native format.<br/>/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>/// the native byte order.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_ReadBE16")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort SDLReadBE16([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				ushort ret = SDLReadBE16Native((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read 32 bits of little-endian data from an SDL_RWops<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadLE32")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		internal static uint SDLReadLE32Native([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, uint>)vt[201])(src);
		}
		/// <summary>/// Use this function to read 32 bits of little-endian data from an SDL_RWops<br/>/// and return in native format.<br/>/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>/// the native byte order.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_ReadLE32")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLReadLE32([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			uint ret = SDLReadLE32Native(src);
			return ret;
		}

		/// <summary>/// Use this function to read 32 bits of little-endian data from an SDL_RWops<br/>/// and return in native format.<br/>/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>/// the native byte order.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_ReadLE32")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLReadLE32([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				uint ret = SDLReadLE32Native((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read 32 bits of big-endian data from an SDL_RWops and<br/>
		/// return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadBE32")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		internal static uint SDLReadBE32Native([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, uint>)vt[202])(src);
		}
		/// <summary>/// Use this function to read 32 bits of big-endian data from an SDL_RWops and<br/>/// return in native format.<br/>/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>/// the native byte order.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_ReadBE32")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLReadBE32([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			uint ret = SDLReadBE32Native(src);
			return ret;
		}

		/// <summary>/// Use this function to read 32 bits of big-endian data from an SDL_RWops and<br/>/// return in native format.<br/>/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>/// the native byte order.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_ReadBE32")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLReadBE32([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				uint ret = SDLReadBE32Native((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read 64 bits of little-endian data from an SDL_RWops<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadLE64")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		internal static ulong SDLReadLE64Native([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, ulong>)vt[203])(src);
		}
		/// <summary>/// Use this function to read 64 bits of little-endian data from an SDL_RWops<br/>/// and return in native format.<br/>/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>/// the native byte order.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_ReadLE64")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		public static ulong SDLReadLE64([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			ulong ret = SDLReadLE64Native(src);
			return ret;
		}

		/// <summary>/// Use this function to read 64 bits of little-endian data from an SDL_RWops<br/>/// and return in native format.<br/>/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>/// the native byte order.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_ReadLE64")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		public static ulong SDLReadLE64([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				ulong ret = SDLReadLE64Native((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read 64 bits of big-endian data from an SDL_RWops and<br/>
		/// return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadBE64")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		internal static ulong SDLReadBE64Native([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, ulong>)vt[204])(src);
		}
		/// <summary>/// Use this function to read 64 bits of big-endian data from an SDL_RWops and<br/>/// return in native format.<br/>/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>/// the native byte order.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_ReadBE64")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		public static ulong SDLReadBE64([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			ulong ret = SDLReadBE64Native(src);
			return ret;
		}

		/// <summary>/// Use this function to read 64 bits of big-endian data from an SDL_RWops and<br/>/// return in native format.<br/>/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>/// the native byte order.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_ReadBE64")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		public static ulong SDLReadBE64([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				ulong ret = SDLReadBE64Native((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to write a byte to an SDL_RWops.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteU8")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		internal static ulong SDLWriteU8Native([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint8")] byte value)
		{
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, byte, ulong>)vt[205])(dst, value);
		}
		/// <summary>/// Use this function to write a byte to an SDL_RWops.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_WriteU8")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLWriteU8([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint8")] byte value)
		{
			ulong ret = SDLWriteU8Native(dst, value);
			return ret;
		}

		/// <summary>/// Use this function to write a byte to an SDL_RWops.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_WriteU8")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLWriteU8([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint8")] byte value)
		{
			fixed (SDLRWops* pdst = &dst)
			{
				ulong ret = SDLWriteU8Native((SDLRWops*)pdst, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to write 16 bits in native format to a SDL_RWops as<br/>
		/// little-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in little-endian<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteLE16")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		internal static ulong SDLWriteLE16Native([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint16")] ushort value)
		{
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, ushort, ulong>)vt[206])(dst, value);
		}
		/// <summary>/// Use this function to write 16 bits in native format to a SDL_RWops as<br/>/// little-endian data.<br/>/// SDL byteswaps the data only if necessary, so the application always<br/>/// specifies native format, and the data written will be in little-endian<br/>/// format.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_WriteLE16")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLWriteLE16([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint16")] ushort value)
		{
			ulong ret = SDLWriteLE16Native(dst, value);
			return ret;
		}

		/// <summary>/// Use this function to write 16 bits in native format to a SDL_RWops as<br/>/// little-endian data.<br/>/// SDL byteswaps the data only if necessary, so the application always<br/>/// specifies native format, and the data written will be in little-endian<br/>/// format.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_WriteLE16")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLWriteLE16([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint16")] ushort value)
		{
			fixed (SDLRWops* pdst = &dst)
			{
				ulong ret = SDLWriteLE16Native((SDLRWops*)pdst, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to write 16 bits in native format to a SDL_RWops as<br/>
		/// big-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in big-endian format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteBE16")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		internal static ulong SDLWriteBE16Native([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint16")] ushort value)
		{
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, ushort, ulong>)vt[207])(dst, value);
		}
		/// <summary>/// Use this function to write 16 bits in native format to a SDL_RWops as<br/>/// big-endian data.<br/>/// SDL byteswaps the data only if necessary, so the application always<br/>/// specifies native format, and the data written will be in big-endian format.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_WriteBE16")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLWriteBE16([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint16")] ushort value)
		{
			ulong ret = SDLWriteBE16Native(dst, value);
			return ret;
		}

		/// <summary>/// Use this function to write 16 bits in native format to a SDL_RWops as<br/>/// big-endian data.<br/>/// SDL byteswaps the data only if necessary, so the application always<br/>/// specifies native format, and the data written will be in big-endian format.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_WriteBE16")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLWriteBE16([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint16")] ushort value)
		{
			fixed (SDLRWops* pdst = &dst)
			{
				ulong ret = SDLWriteBE16Native((SDLRWops*)pdst, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to write 32 bits in native format to a SDL_RWops as<br/>
		/// little-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in little-endian<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteLE32")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		internal static ulong SDLWriteLE32Native([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint32")] uint value)
		{
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, uint, ulong>)vt[208])(dst, value);
		}
		/// <summary>/// Use this function to write 32 bits in native format to a SDL_RWops as<br/>/// little-endian data.<br/>/// SDL byteswaps the data only if necessary, so the application always<br/>/// specifies native format, and the data written will be in little-endian<br/>/// format.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_WriteLE32")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLWriteLE32([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint32")] uint value)
		{
			ulong ret = SDLWriteLE32Native(dst, value);
			return ret;
		}

		/// <summary>/// Use this function to write 32 bits in native format to a SDL_RWops as<br/>/// little-endian data.<br/>/// SDL byteswaps the data only if necessary, so the application always<br/>/// specifies native format, and the data written will be in little-endian<br/>/// format.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_WriteLE32")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLWriteLE32([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint32")] uint value)
		{
			fixed (SDLRWops* pdst = &dst)
			{
				ulong ret = SDLWriteLE32Native((SDLRWops*)pdst, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to write 32 bits in native format to a SDL_RWops as<br/>
		/// big-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in big-endian format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteBE32")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		internal static ulong SDLWriteBE32Native([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint32")] uint value)
		{
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, uint, ulong>)vt[209])(dst, value);
		}
		/// <summary>/// Use this function to write 32 bits in native format to a SDL_RWops as<br/>/// big-endian data.<br/>/// SDL byteswaps the data only if necessary, so the application always<br/>/// specifies native format, and the data written will be in big-endian format.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_WriteBE32")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLWriteBE32([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint32")] uint value)
		{
			ulong ret = SDLWriteBE32Native(dst, value);
			return ret;
		}

		/// <summary>/// Use this function to write 32 bits in native format to a SDL_RWops as<br/>/// big-endian data.<br/>/// SDL byteswaps the data only if necessary, so the application always<br/>/// specifies native format, and the data written will be in big-endian format.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_WriteBE32")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLWriteBE32([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint32")] uint value)
		{
			fixed (SDLRWops* pdst = &dst)
			{
				ulong ret = SDLWriteBE32Native((SDLRWops*)pdst, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to write 64 bits in native format to a SDL_RWops as<br/>
		/// little-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in little-endian<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteLE64")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		internal static ulong SDLWriteLE64Native([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint64")] ulong value)
		{
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, ulong, ulong>)vt[210])(dst, value);
		}
		/// <summary>/// Use this function to write 64 bits in native format to a SDL_RWops as<br/>/// little-endian data.<br/>/// SDL byteswaps the data only if necessary, so the application always<br/>/// specifies native format, and the data written will be in little-endian<br/>/// format.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_WriteLE64")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLWriteLE64([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint64")] ulong value)
		{
			ulong ret = SDLWriteLE64Native(dst, value);
			return ret;
		}

		/// <summary>/// Use this function to write 64 bits in native format to a SDL_RWops as<br/>/// little-endian data.<br/>/// SDL byteswaps the data only if necessary, so the application always<br/>/// specifies native format, and the data written will be in little-endian<br/>/// format.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_WriteLE64")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLWriteLE64([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint64")] ulong value)
		{
			fixed (SDLRWops* pdst = &dst)
			{
				ulong ret = SDLWriteLE64Native((SDLRWops*)pdst, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to write 64 bits in native format to a SDL_RWops as<br/>
		/// big-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in big-endian format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteBE64")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		internal static ulong SDLWriteBE64Native([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint64")] ulong value)
		{
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, ulong, ulong>)vt[211])(dst, value);
		}
		/// <summary>/// Use this function to write 64 bits in native format to a SDL_RWops as<br/>/// big-endian data.<br/>/// SDL byteswaps the data only if necessary, so the application always<br/>/// specifies native format, and the data written will be in big-endian format.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_WriteBE64")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLWriteBE64([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint64")] ulong value)
		{
			ulong ret = SDLWriteBE64Native(dst, value);
			return ret;
		}

		/// <summary>/// Use this function to write 64 bits in native format to a SDL_RWops as<br/>/// big-endian data.<br/>/// SDL byteswaps the data only if necessary, so the application always<br/>/// specifies native format, and the data written will be in big-endian format.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_WriteBE64")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLWriteBE64([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint64")] ulong value)
		{
			fixed (SDLRWops* pdst = &dst)
			{
				ulong ret = SDLWriteBE64Native((SDLRWops*)pdst, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to get the number of built-in audio drivers.<br/>
		/// This function returns a hardcoded number. This never returns a negative<br/>
		/// value; if there are no drivers compiled into this build of SDL, this<br/>
		/// function returns zero. The presence of a driver in this list does not mean<br/>
		/// it will function, it just means SDL is capable of interacting with that<br/>
		/// interface. For example, a build of SDL might have esound support, but if<br/>
		/// there's no esound server available, SDL's esound driver would fail if used.<br/>
		/// By default, SDL tries all drivers, in its preferred order, until one is<br/>
		/// found to be usable.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumAudioDrivers")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLGetNumAudioDriversNative()
		{
			return ((delegate* unmanaged[Cdecl]<int>)vt[212])();
		}
		/// <summary>/// Use this function to get the number of built-in audio drivers.<br/>/// This function returns a hardcoded number. This never returns a negative<br/>/// value; if there are no drivers compiled into this build of SDL, this<br/>/// function returns zero. The presence of a driver in this list does not mean<br/>/// it will function, it just means SDL is capable of interacting with that<br/>/// interface. For example, a build of SDL might have esound support, but if<br/>/// there's no esound server available, SDL's esound driver would fail if used.<br/>/// By default, SDL tries all drivers, in its preferred order, until one is<br/>/// found to be usable.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetNumAudioDrivers")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetNumAudioDrivers()
		{
			int ret = SDLGetNumAudioDriversNative();
			return ret;
		}

		/// <summary>
		/// Use this function to get the name of a built in audio driver.<br/>
		/// The list of audio drivers is given in the order that they are normally<br/>
		/// initialized by default; the drivers that seem more reasonable to choose<br/>
		/// first (as far as the SDL developers believe) are earlier in the list.<br/>
		/// The names of drivers are all simple, low-ASCII identifiers, like "alsa",<br/>
		/// "coreaudio" or "xaudio2". These never have Unicode characters, and are not<br/>
		/// meant to be proper names.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAudioDriver")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		internal static byte* SDLGetAudioDriverNative([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index)
		{
			return ((delegate* unmanaged[Cdecl]<int, byte*>)vt[213])(index);
		}
		/// <summary>/// Use this function to get the name of a built in audio driver.<br/>/// The list of audio drivers is given in the order that they are normally<br/>/// initialized by default; the drivers that seem more reasonable to choose<br/>/// first (as far as the SDL developers believe) are earlier in the list.<br/>/// The names of drivers are all simple, low-ASCII identifiers, like "alsa",<br/>/// "coreaudio" or "xaudio2". These never have Unicode characters, and are not<br/>/// meant to be proper names.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetAudioDriver")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGetAudioDriver([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index)
		{
			byte* ret = SDLGetAudioDriverNative(index);
			return ret;
		}

		/// <summary>/// Use this function to get the name of a built in audio driver.<br/>/// The list of audio drivers is given in the order that they are normally<br/>/// initialized by default; the drivers that seem more reasonable to choose<br/>/// first (as far as the SDL developers believe) are earlier in the list.<br/>/// The names of drivers are all simple, low-ASCII identifiers, like "alsa",<br/>/// "coreaudio" or "xaudio2". These never have Unicode characters, and are not<br/>/// meant to be proper names.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetAudioDriver")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGetAudioDriverS([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index)
		{
			string ret = Utils.DecodeStringUTF8(SDLGetAudioDriverNative(index));
			return ret;
		}

		/// <summary>
		/// Use this function to initialize a particular audio driver.<br/>
		/// This function is used internally, and should not be used unless you have a<br/>
		/// specific need to designate the audio driver you want to use. You should<br/>
		/// normally use SDL_Init() or SDL_InitSubSystem().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AudioInit")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLAudioInitNative([NativeName(NativeNameType.Param, "driver_name")] [NativeName(NativeNameType.Type, "const char*")] byte* driverName)
		{
			return ((delegate* unmanaged[Cdecl]<byte*, int>)vt[214])(driverName);
		}
		/// <summary>/// Use this function to initialize a particular audio driver.<br/>/// This function is used internally, and should not be used unless you have a<br/>/// specific need to designate the audio driver you want to use. You should<br/>/// normally use SDL_Init() or SDL_InitSubSystem().<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_AudioInit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLAudioInit([NativeName(NativeNameType.Param, "driver_name")] [NativeName(NativeNameType.Type, "const char*")] byte* driverName)
		{
			int ret = SDLAudioInitNative(driverName);
			return ret;
		}

		/// <summary>/// Use this function to initialize a particular audio driver.<br/>/// This function is used internally, and should not be used unless you have a<br/>/// specific need to designate the audio driver you want to use. You should<br/>/// normally use SDL_Init() or SDL_InitSubSystem().<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_AudioInit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLAudioInit([NativeName(NativeNameType.Param, "driver_name")] [NativeName(NativeNameType.Type, "const char*")] ref byte driverName)
		{
			fixed (byte* pdriverName = &driverName)
			{
				int ret = SDLAudioInitNative((byte*)pdriverName);
				return ret;
			}
		}

		/// <summary>/// Use this function to initialize a particular audio driver.<br/>/// This function is used internally, and should not be used unless you have a<br/>/// specific need to designate the audio driver you want to use. You should<br/>/// normally use SDL_Init() or SDL_InitSubSystem().<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_AudioInit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLAudioInit([NativeName(NativeNameType.Param, "driver_name")] [NativeName(NativeNameType.Type, "const char*")] string driverName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (driverName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(driverName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(driverName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SDLAudioInitNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Use this function to shut down audio if you initialized it with<br/>
		/// SDL_AudioInit().<br/>
		/// This function is used internally, and should not be used unless you have a<br/>
		/// specific need to specify the audio driver you want to use. You should<br/>
		/// normally use SDL_Quit() or SDL_QuitSubSystem().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AudioQuit")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SDLAudioQuitNative()
		{
			((delegate* unmanaged[Cdecl]<void>)vt[215])();
		}
		/// <summary>/// Use this function to shut down audio if you initialized it with<br/>/// SDL_AudioInit().<br/>/// This function is used internally, and should not be used unless you have a<br/>/// specific need to specify the audio driver you want to use. You should<br/>/// normally use SDL_Quit() or SDL_QuitSubSystem().<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_AudioQuit")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLAudioQuit()
		{
			SDLAudioQuitNative();
		}

		/// <summary>
		/// Get the name of the current audio driver.<br/>
		/// The returned string points to internal static memory and thus never becomes<br/>
		/// invalid, even if you quit the audio subsystem and initialize a new driver<br/>
		/// (although such a case would return a different static string from another<br/>
		/// call to this function, of course). As such, you should not modify or free<br/>
		/// the returned string.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCurrentAudioDriver")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		internal static byte* SDLGetCurrentAudioDriverNative()
		{
			return ((delegate* unmanaged[Cdecl]<byte*>)vt[216])();
		}
		/// <summary>/// Get the name of the current audio driver.<br/>/// The returned string points to internal static memory and thus never becomes<br/>/// invalid, even if you quit the audio subsystem and initialize a new driver<br/>/// (although such a case would return a different static string from another<br/>/// call to this function, of course). As such, you should not modify or free<br/>/// the returned string.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetCurrentAudioDriver")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGetCurrentAudioDriver()
		{
			byte* ret = SDLGetCurrentAudioDriverNative();
			return ret;
		}

		/// <summary>/// Get the name of the current audio driver.<br/>/// The returned string points to internal static memory and thus never becomes<br/>/// invalid, even if you quit the audio subsystem and initialize a new driver<br/>/// (although such a case would return a different static string from another<br/>/// call to this function, of course). As such, you should not modify or free<br/>/// the returned string.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetCurrentAudioDriver")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGetCurrentAudioDriverS()
		{
			string ret = Utils.DecodeStringUTF8(SDLGetCurrentAudioDriverNative());
			return ret;
		}

		/// <summary>
		/// This function is a legacy means of opening the audio device.<br/>
		/// This function remains for compatibility with SDL 1.2, but also because it's<br/>
		/// slightly easier to use than the new functions in SDL 2.0. The new, more<br/>
		/// powerful, and preferred way to do this is SDL_OpenAudioDevice().<br/>
		/// This function is roughly equivalent to:<br/>
		/// ```c<br/>
		/// SDL_OpenAudioDevice(NULL, 0, desired, obtained, SDL_AUDIO_ALLOW_ANY_CHANGE);<br/>
		/// ```<br/>
		/// With two notable exceptions:<br/>
		/// - If `obtained` is NULL, we use `desired` (and allow no changes), which<br/>
		/// means desired will be modified to have the correct values for silence,<br/>
		/// etc, and SDL will convert any differences between your app's specific<br/>
		/// request and the hardware behind the scenes.<br/>
		/// - The return value is always success or failure, and not a device ID, which<br/>
		/// means you can only have one device open at a time with this function.<br/>
		/// <br/>
		/// If `obtained` is NULL, the audio data passed to the callback<br/>
		/// function will be guaranteed to be in the requested format, and<br/>
		/// will be automatically converted to the actual hardware audio<br/>
		/// format if necessary. If `obtained` is NULL, `desired` will have<br/>
		/// fields modified.<br/>
		/// This function returns a negative error code on failure to open the<br/>
		/// audio device or failure to set up the audio thread; call<br/>
		/// SDL_GetError() for more information.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenAudio")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLOpenAudioNative([NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* obtained)
		{
			return ((delegate* unmanaged[Cdecl]<SDLAudioSpec*, SDLAudioSpec*, int>)vt[217])(desired, obtained);
		}
		/// <summary>/// This function is a legacy means of opening the audio device.<br/>/// This function remains for compatibility with SDL 1.2, but also because it's<br/>/// slightly easier to use than the new functions in SDL 2.0. The new, more<br/>/// powerful, and preferred way to do this is SDL_OpenAudioDevice().<br/>/// This function is roughly equivalent to:<br/>/// ```c<br/>/// SDL_OpenAudioDevice(NULL, 0, desired, obtained, SDL_AUDIO_ALLOW_ANY_CHANGE);<br/>/// ```<br/>/// With two notable exceptions:<br/>/// - If `obtained` is NULL, we use `desired` (and allow no changes), which<br/>/// means desired will be modified to have the correct values for silence,<br/>/// etc, and SDL will convert any differences between your app's specific<br/>/// request and the hardware behind the scenes.<br/>/// - The return value is always success or failure, and not a device ID, which<br/>/// means you can only have one device open at a time with this function.<br/>/// <br/>/// If `obtained` is NULL, the audio data passed to the callback<br/>/// function will be guaranteed to be in the requested format, and<br/>/// will be automatically converted to the actual hardware audio<br/>/// format if necessary. If `obtained` is NULL, `desired` will have<br/>/// fields modified.<br/>/// This function returns a negative error code on failure to open the<br/>/// audio device or failure to set up the audio thread; call<br/>/// SDL_GetError() for more information.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_OpenAudio")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLOpenAudio([NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* obtained)
		{
			int ret = SDLOpenAudioNative(desired, obtained);
			return ret;
		}

		/// <summary>/// This function is a legacy means of opening the audio device.<br/>/// This function remains for compatibility with SDL 1.2, but also because it's<br/>/// slightly easier to use than the new functions in SDL 2.0. The new, more<br/>/// powerful, and preferred way to do this is SDL_OpenAudioDevice().<br/>/// This function is roughly equivalent to:<br/>/// ```c<br/>/// SDL_OpenAudioDevice(NULL, 0, desired, obtained, SDL_AUDIO_ALLOW_ANY_CHANGE);<br/>/// ```<br/>/// With two notable exceptions:<br/>/// - If `obtained` is NULL, we use `desired` (and allow no changes), which<br/>/// means desired will be modified to have the correct values for silence,<br/>/// etc, and SDL will convert any differences between your app's specific<br/>/// request and the hardware behind the scenes.<br/>/// - The return value is always success or failure, and not a device ID, which<br/>/// means you can only have one device open at a time with this function.<br/>/// <br/>/// If `obtained` is NULL, the audio data passed to the callback<br/>/// function will be guaranteed to be in the requested format, and<br/>/// will be automatically converted to the actual hardware audio<br/>/// format if necessary. If `obtained` is NULL, `desired` will have<br/>/// fields modified.<br/>/// This function returns a negative error code on failure to open the<br/>/// audio device or failure to set up the audio thread; call<br/>/// SDL_GetError() for more information.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_OpenAudio")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLOpenAudio([NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* obtained)
		{
			fixed (SDLAudioSpec* pdesired = &desired)
			{
				int ret = SDLOpenAudioNative((SDLAudioSpec*)pdesired, obtained);
				return ret;
			}
		}

		/// <summary>/// This function is a legacy means of opening the audio device.<br/>/// This function remains for compatibility with SDL 1.2, but also because it's<br/>/// slightly easier to use than the new functions in SDL 2.0. The new, more<br/>/// powerful, and preferred way to do this is SDL_OpenAudioDevice().<br/>/// This function is roughly equivalent to:<br/>/// ```c<br/>/// SDL_OpenAudioDevice(NULL, 0, desired, obtained, SDL_AUDIO_ALLOW_ANY_CHANGE);<br/>/// ```<br/>/// With two notable exceptions:<br/>/// - If `obtained` is NULL, we use `desired` (and allow no changes), which<br/>/// means desired will be modified to have the correct values for silence,<br/>/// etc, and SDL will convert any differences between your app's specific<br/>/// request and the hardware behind the scenes.<br/>/// - The return value is always success or failure, and not a device ID, which<br/>/// means you can only have one device open at a time with this function.<br/>/// <br/>/// If `obtained` is NULL, the audio data passed to the callback<br/>/// function will be guaranteed to be in the requested format, and<br/>/// will be automatically converted to the actual hardware audio<br/>/// format if necessary. If `obtained` is NULL, `desired` will have<br/>/// fields modified.<br/>/// This function returns a negative error code on failure to open the<br/>/// audio device or failure to set up the audio thread; call<br/>/// SDL_GetError() for more information.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_OpenAudio")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLOpenAudio([NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec obtained)
		{
			fixed (SDLAudioSpec* pobtained = &obtained)
			{
				int ret = SDLOpenAudioNative(desired, (SDLAudioSpec*)pobtained);
				return ret;
			}
		}

		/// <summary>/// This function is a legacy means of opening the audio device.<br/>/// This function remains for compatibility with SDL 1.2, but also because it's<br/>/// slightly easier to use than the new functions in SDL 2.0. The new, more<br/>/// powerful, and preferred way to do this is SDL_OpenAudioDevice().<br/>/// This function is roughly equivalent to:<br/>/// ```c<br/>/// SDL_OpenAudioDevice(NULL, 0, desired, obtained, SDL_AUDIO_ALLOW_ANY_CHANGE);<br/>/// ```<br/>/// With two notable exceptions:<br/>/// - If `obtained` is NULL, we use `desired` (and allow no changes), which<br/>/// means desired will be modified to have the correct values for silence,<br/>/// etc, and SDL will convert any differences between your app's specific<br/>/// request and the hardware behind the scenes.<br/>/// - The return value is always success or failure, and not a device ID, which<br/>/// means you can only have one device open at a time with this function.<br/>/// <br/>/// If `obtained` is NULL, the audio data passed to the callback<br/>/// function will be guaranteed to be in the requested format, and<br/>/// will be automatically converted to the actual hardware audio<br/>/// format if necessary. If `obtained` is NULL, `desired` will have<br/>/// fields modified.<br/>/// This function returns a negative error code on failure to open the<br/>/// audio device or failure to set up the audio thread; call<br/>/// SDL_GetError() for more information.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_OpenAudio")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLOpenAudio([NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec obtained)
		{
			fixed (SDLAudioSpec* pdesired = &desired)
			{
				fixed (SDLAudioSpec* pobtained = &obtained)
				{
					int ret = SDLOpenAudioNative((SDLAudioSpec*)pdesired, (SDLAudioSpec*)pobtained);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the number of built-in audio devices.<br/>
		/// This function is only valid after successfully initializing the audio<br/>
		/// subsystem.<br/>
		/// Note that audio capture support is not implemented as of SDL 2.0.4, so the<br/>
		/// `iscapture` parameter is for future expansion and should always be zero for<br/>
		/// now.<br/>
		/// This function will return -1 if an explicit list of devices can't be<br/>
		/// determined. Returning -1 is not an error. For example, if SDL is set up to<br/>
		/// talk to a remote audio server, it can't list every one available on the<br/>
		/// Internet, but it will still allow a specific host to be specified in<br/>
		/// SDL_OpenAudioDevice().<br/>
		/// In many common cases, when this function returns a value <br/>
		/// <<br/>
		/// = 0, it can still<br/>
		/// successfully open the default device (NULL for first argument of<br/>
		/// SDL_OpenAudioDevice()).<br/>
		/// This function may trigger a complete redetect of available hardware. It<br/>
		/// should not be called for each iteration of a loop, but rather once at the<br/>
		/// start of a loop:<br/>
		/// ```c<br/>
		/// // Don't do this:<br/>
		/// for (int i = 0; i <br/>
		/// <<br/>
		/// SDL_GetNumAudioDevices(0); i++)<br/>
		/// // do this instead:<br/>
		/// const int count = SDL_GetNumAudioDevices(0);<br/>
		/// for (int i = 0; i <br/>
		/// <<br/>
		/// count; ++i) { do_something_here(); }<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumAudioDevices")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLGetNumAudioDevicesNative([NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture)
		{
			return ((delegate* unmanaged[Cdecl]<int, int>)vt[218])(iscapture);
		}
		/// <summary>/// Get the number of built-in audio devices.<br/>/// This function is only valid after successfully initializing the audio<br/>/// subsystem.<br/>/// Note that audio capture support is not implemented as of SDL 2.0.4, so the<br/>/// `iscapture` parameter is for future expansion and should always be zero for<br/>/// now.<br/>/// This function will return -1 if an explicit list of devices can't be<br/>/// determined. Returning -1 is not an error. For example, if SDL is set up to<br/>/// talk to a remote audio server, it can't list every one available on the<br/>/// Internet, but it will still allow a specific host to be specified in<br/>/// SDL_OpenAudioDevice().<br/>/// In many common cases, when this function returns a value <br/>/// <<br/>/// = 0, it can still<br/>/// successfully open the default device (NULL for first argument of<br/>/// SDL_OpenAudioDevice()).<br/>/// This function may trigger a complete redetect of available hardware. It<br/>/// should not be called for each iteration of a loop, but rather once at the<br/>/// start of a loop:<br/>/// ```c<br/>/// // Don't do this:<br/>/// for (int i = 0; i <br/>/// <<br/>/// SDL_GetNumAudioDevices(0); i++)<br/>/// // do this instead:<br/>/// const int count = SDL_GetNumAudioDevices(0);<br/>/// for (int i = 0; i <br/>/// <<br/>/// count; ++i) { do_something_here(); }<br/>/// ```<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetNumAudioDevices")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetNumAudioDevices([NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture)
		{
			int ret = SDLGetNumAudioDevicesNative(iscapture);
			return ret;
		}

		/// <summary>
		/// Get the human-readable name of a specific audio device.<br/>
		/// This function is only valid after successfully initializing the audio<br/>
		/// subsystem. The values returned by this function reflect the latest call to<br/>
		/// SDL_GetNumAudioDevices(); re-call that function to redetect available<br/>
		/// hardware.<br/>
		/// The string returned by this function is UTF-8 encoded, read-only, and<br/>
		/// managed internally. You are not to free it. If you need to keep the string<br/>
		/// for any length of time, you should make your own copy of it, as it will be<br/>
		/// invalid next time any of several other SDL functions are called.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAudioDeviceName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		internal static byte* SDLGetAudioDeviceNameNative([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture)
		{
			return ((delegate* unmanaged[Cdecl]<int, int, byte*>)vt[219])(index, iscapture);
		}
		/// <summary>/// Get the human-readable name of a specific audio device.<br/>/// This function is only valid after successfully initializing the audio<br/>/// subsystem. The values returned by this function reflect the latest call to<br/>/// SDL_GetNumAudioDevices(); re-call that function to redetect available<br/>/// hardware.<br/>/// The string returned by this function is UTF-8 encoded, read-only, and<br/>/// managed internally. You are not to free it. If you need to keep the string<br/>/// for any length of time, you should make your own copy of it, as it will be<br/>/// invalid next time any of several other SDL functions are called.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetAudioDeviceName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGetAudioDeviceName([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture)
		{
			byte* ret = SDLGetAudioDeviceNameNative(index, iscapture);
			return ret;
		}

		/// <summary>/// Get the human-readable name of a specific audio device.<br/>/// This function is only valid after successfully initializing the audio<br/>/// subsystem. The values returned by this function reflect the latest call to<br/>/// SDL_GetNumAudioDevices(); re-call that function to redetect available<br/>/// hardware.<br/>/// The string returned by this function is UTF-8 encoded, read-only, and<br/>/// managed internally. You are not to free it. If you need to keep the string<br/>/// for any length of time, you should make your own copy of it, as it will be<br/>/// invalid next time any of several other SDL functions are called.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetAudioDeviceName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGetAudioDeviceNameS([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture)
		{
			string ret = Utils.DecodeStringUTF8(SDLGetAudioDeviceNameNative(index, iscapture));
			return ret;
		}

		/// <summary>
		/// Get the preferred audio format of a specific audio device.<br/>
		/// This function is only valid after a successfully initializing the audio<br/>
		/// subsystem. The values returned by this function reflect the latest call to<br/>
		/// SDL_GetNumAudioDevices(); re-call that function to redetect available<br/>
		/// hardware.<br/>
		/// `spec` will be filled with the sample rate, sample format, and channel<br/>
		/// count.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAudioDeviceSpec")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLGetAudioDeviceSpecNative([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* spec)
		{
			return ((delegate* unmanaged[Cdecl]<int, int, SDLAudioSpec*, int>)vt[220])(index, iscapture, spec);
		}
		/// <summary>/// Get the preferred audio format of a specific audio device.<br/>/// This function is only valid after a successfully initializing the audio<br/>/// subsystem. The values returned by this function reflect the latest call to<br/>/// SDL_GetNumAudioDevices(); re-call that function to redetect available<br/>/// hardware.<br/>/// `spec` will be filled with the sample rate, sample format, and channel<br/>/// count.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetAudioDeviceSpec")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetAudioDeviceSpec([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* spec)
		{
			int ret = SDLGetAudioDeviceSpecNative(index, iscapture, spec);
			return ret;
		}

		/// <summary>/// Get the preferred audio format of a specific audio device.<br/>/// This function is only valid after a successfully initializing the audio<br/>/// subsystem. The values returned by this function reflect the latest call to<br/>/// SDL_GetNumAudioDevices(); re-call that function to redetect available<br/>/// hardware.<br/>/// `spec` will be filled with the sample rate, sample format, and channel<br/>/// count.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetAudioDeviceSpec")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetAudioDeviceSpec([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec spec)
		{
			fixed (SDLAudioSpec* pspec = &spec)
			{
				int ret = SDLGetAudioDeviceSpecNative(index, iscapture, (SDLAudioSpec*)pspec);
				return ret;
			}
		}

		/// <summary>
		/// Get the name and preferred format of the default audio device.<br/>
		/// Some (but not all!) platforms have an isolated mechanism to get information<br/>
		/// about the "default" device. This can actually be a completely different<br/>
		/// device that's not in the list you get from SDL_GetAudioDeviceSpec(). It can<br/>
		/// even be a network address! (This is discussed in SDL_OpenAudioDevice().)<br/>
		/// As a result, this call is not guaranteed to be performant, as it can query<br/>
		/// the sound server directly every time, unlike the other query functions. You<br/>
		/// should call this function sparingly!<br/>
		/// `spec` will be filled with the sample rate, sample format, and channel<br/>
		/// count, if a default device exists on the system. If `name` is provided,<br/>
		/// will be filled with either a dynamically-allocated UTF-8 string or NULL.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetDefaultAudioInfo")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLGetDefaultAudioInfoNative([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char**")] byte** name, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* spec, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture)
		{
			return ((delegate* unmanaged[Cdecl]<byte**, SDLAudioSpec*, int, int>)vt[221])(name, spec, iscapture);
		}
		/// <summary>/// Get the name and preferred format of the default audio device.<br/>/// Some (but not all!) platforms have an isolated mechanism to get information<br/>/// about the "default" device. This can actually be a completely different<br/>/// device that's not in the list you get from SDL_GetAudioDeviceSpec(). It can<br/>/// even be a network address! (This is discussed in SDL_OpenAudioDevice().)<br/>/// As a result, this call is not guaranteed to be performant, as it can query<br/>/// the sound server directly every time, unlike the other query functions. You<br/>/// should call this function sparingly!<br/>/// `spec` will be filled with the sample rate, sample format, and channel<br/>/// count, if a default device exists on the system. If `name` is provided,<br/>/// will be filled with either a dynamically-allocated UTF-8 string or NULL.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetDefaultAudioInfo")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetDefaultAudioInfo([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char**")] byte** name, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* spec, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture)
		{
			int ret = SDLGetDefaultAudioInfoNative(name, spec, iscapture);
			return ret;
		}

		/// <summary>/// Get the name and preferred format of the default audio device.<br/>/// Some (but not all!) platforms have an isolated mechanism to get information<br/>/// about the "default" device. This can actually be a completely different<br/>/// device that's not in the list you get from SDL_GetAudioDeviceSpec(). It can<br/>/// even be a network address! (This is discussed in SDL_OpenAudioDevice().)<br/>/// As a result, this call is not guaranteed to be performant, as it can query<br/>/// the sound server directly every time, unlike the other query functions. You<br/>/// should call this function sparingly!<br/>/// `spec` will be filled with the sample rate, sample format, and channel<br/>/// count, if a default device exists on the system. If `name` is provided,<br/>/// will be filled with either a dynamically-allocated UTF-8 string or NULL.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetDefaultAudioInfo")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetDefaultAudioInfo([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char**")] ref byte* name, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* spec, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture)
		{
			fixed (byte** pname = &name)
			{
				int ret = SDLGetDefaultAudioInfoNative((byte**)pname, spec, iscapture);
				return ret;
			}
		}

		/// <summary>/// Get the name and preferred format of the default audio device.<br/>/// Some (but not all!) platforms have an isolated mechanism to get information<br/>/// about the "default" device. This can actually be a completely different<br/>/// device that's not in the list you get from SDL_GetAudioDeviceSpec(). It can<br/>/// even be a network address! (This is discussed in SDL_OpenAudioDevice().)<br/>/// As a result, this call is not guaranteed to be performant, as it can query<br/>/// the sound server directly every time, unlike the other query functions. You<br/>/// should call this function sparingly!<br/>/// `spec` will be filled with the sample rate, sample format, and channel<br/>/// count, if a default device exists on the system. If `name` is provided,<br/>/// will be filled with either a dynamically-allocated UTF-8 string or NULL.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetDefaultAudioInfo")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetDefaultAudioInfo([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char**")] byte** name, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec spec, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture)
		{
			fixed (SDLAudioSpec* pspec = &spec)
			{
				int ret = SDLGetDefaultAudioInfoNative(name, (SDLAudioSpec*)pspec, iscapture);
				return ret;
			}
		}

		/// <summary>/// Get the name and preferred format of the default audio device.<br/>/// Some (but not all!) platforms have an isolated mechanism to get information<br/>/// about the "default" device. This can actually be a completely different<br/>/// device that's not in the list you get from SDL_GetAudioDeviceSpec(). It can<br/>/// even be a network address! (This is discussed in SDL_OpenAudioDevice().)<br/>/// As a result, this call is not guaranteed to be performant, as it can query<br/>/// the sound server directly every time, unlike the other query functions. You<br/>/// should call this function sparingly!<br/>/// `spec` will be filled with the sample rate, sample format, and channel<br/>/// count, if a default device exists on the system. If `name` is provided,<br/>/// will be filled with either a dynamically-allocated UTF-8 string or NULL.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetDefaultAudioInfo")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetDefaultAudioInfo([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char**")] ref byte* name, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec spec, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture)
		{
			fixed (byte** pname = &name)
			{
				fixed (SDLAudioSpec* pspec = &spec)
				{
					int ret = SDLGetDefaultAudioInfoNative((byte**)pname, (SDLAudioSpec*)pspec, iscapture);
					return ret;
				}
			}
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>
		/// this function will never return a 1 so as not to conflict with the legacy<br/>
		/// function.<br/>
		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>
		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>
		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>
		/// Passing in a `device` name of NULL requests the most reasonable default<br/>
		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>
		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>
		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>
		/// hostname/IP address for a remote audio server, or a filename in the<br/>
		/// diskaudio driver.<br/>
		/// An opened audio device starts out paused, and should be enabled for playing<br/>
		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>
		/// callback function to be called. Since the audio driver may modify the<br/>
		/// requested size of the audio buffer, you should allocate any local mixing<br/>
		/// buffers after you open the audio device.<br/>
		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>
		/// race conditions between your callback and other threads without fully<br/>
		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>
		/// callback, see SDL_AudioSpec.<br/>
		/// Managing the audio spec via 'desired' and 'obtained':<br/>
		/// When filling in the desired audio spec structure:<br/>
		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>
		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>
		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>
		/// frames_ (with stereo output, two samples--left and right--would make a<br/>
		/// single sample frame). This number should be a power of two, and may be<br/>
		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>
		/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>
		/// the application and CPU speed. Smaller values reduce latency, but can<br/>
		/// lead to underflow if the application is doing heavy processing and cannot<br/>
		/// fill the audio buffer in time. Note that the number of sample frames is<br/>
		/// directly related to time by the following formula: `ms =<br/>
		/// (sampleframes*1000)/freq`<br/>
		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->callback` should be set to a function that will be called when<br/>
		/// the audio device is ready for more data. It is passed a pointer to the<br/>
		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>
		/// usually runs in a separate thread, and so you should protect data<br/>
		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>
		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>
		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>
		/// more audio samples to be played (or for capture devices, call<br/>
		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>
		/// - `desired->userdata` is passed as the first parameter to your callback<br/>
		/// function. If you passed a NULL callback, this value is ignored.<br/>
		/// `allowed_changes` can have the following flags OR'd together:<br/>
		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>
		/// These flags specify how SDL should behave when a device cannot offer a<br/>
		/// specific feature. If the application requests a feature that the hardware<br/>
		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>
		/// For example, if you ask for float32 audio format, but the sound card only<br/>
		/// supports int16, SDL will set the hardware to int16. If you had set<br/>
		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>
		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>
		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>
		/// will keep the originally requested format in the `obtained` structure.<br/>
		/// The resulting audio specs, varying depending on hardware and on what<br/>
		/// changes were allowed, will then be written back to `obtained`.<br/>
		/// If your application can only handle one specific data format, pass a zero<br/>
		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>
		/// <br/>
		/// For compatibility with SDL 1.2, this will never return 1, since<br/>
		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenAudioDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID")]
		internal static uint SDLOpenAudioDeviceNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "const char*")] byte* device, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "const SDL_AudioSpec*")] SDLAudioSpec* desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* obtained, [NativeName(NativeNameType.Param, "allowed_changes")] [NativeName(NativeNameType.Type, "int")] int allowedChanges)
		{
			return ((delegate* unmanaged[Cdecl]<byte*, int, SDLAudioSpec*, SDLAudioSpec*, int, uint>)vt[222])(device, iscapture, desired, obtained, allowedChanges);
		}
		/// <summary>/// Open a specific audio device.<br/>/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>/// this function will never return a 1 so as not to conflict with the legacy<br/>/// function.<br/>/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>/// 2.0.5, recording is implemented and this value can be non-zero.<br/>/// Passing in a `device` name of NULL requests the most reasonable default<br/>/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>/// some drivers allow arbitrary and driver-specific strings, such as a<br/>/// hostname/IP address for a remote audio server, or a filename in the<br/>/// diskaudio driver.<br/>/// An opened audio device starts out paused, and should be enabled for playing<br/>/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>/// callback function to be called. Since the audio driver may modify the<br/>/// requested size of the audio buffer, you should allocate any local mixing<br/>/// buffers after you open the audio device.<br/>/// The audio callback runs in a separate thread in most cases; you can prevent<br/>/// race conditions between your callback and other threads without fully<br/>/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>/// callback, see SDL_AudioSpec.<br/>/// Managing the audio spec via 'desired' and 'obtained':<br/>/// When filling in the desired audio spec structure:<br/>/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>/// frames_ (with stereo output, two samples--left and right--would make a<br/>/// single sample frame). This number should be a power of two, and may be<br/>/// adjusted by the audio driver to a value more suitable for the hardware.<br/>/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>/// the application and CPU speed. Smaller values reduce latency, but can<br/>/// lead to underflow if the application is doing heavy processing and cannot<br/>/// fill the audio buffer in time. Note that the number of sample frames is<br/>/// directly related to time by the following formula: `ms =<br/>/// (sampleframes*1000)/freq`<br/>/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>/// - `desired->callback` should be set to a function that will be called when<br/>/// the audio device is ready for more data. It is passed a pointer to the<br/>/// audio buffer, and the length in bytes of the audio buffer. This function<br/>/// usually runs in a separate thread, and so you should protect data<br/>/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>/// more audio samples to be played (or for capture devices, call<br/>/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>/// - `desired->userdata` is passed as the first parameter to your callback<br/>/// function. If you passed a NULL callback, this value is ignored.<br/>/// `allowed_changes` can have the following flags OR'd together:<br/>/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>/// These flags specify how SDL should behave when a device cannot offer a<br/>/// specific feature. If the application requests a feature that the hardware<br/>/// doesn't offer, SDL will always try to get the closest equivalent.<br/>/// For example, if you ask for float32 audio format, but the sound card only<br/>/// supports int16, SDL will set the hardware to int16. If you had set<br/>/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>/// callback's float32 audio to int16 before feeding it to the hardware and<br/>/// will keep the originally requested format in the `obtained` structure.<br/>/// The resulting audio specs, varying depending on hardware and on what<br/>/// changes were allowed, will then be written back to `obtained`.<br/>/// If your application can only handle one specific data format, pass a zero<br/>/// for `allowed_changes` and let SDL transparently handle any differences.<br/>/// <br/>/// For compatibility with SDL 1.2, this will never return 1, since<br/>/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_OpenAudioDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID")]
		public static uint SDLOpenAudioDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "const char*")] byte* device, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "const SDL_AudioSpec*")] SDLAudioSpec* desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* obtained, [NativeName(NativeNameType.Param, "allowed_changes")] [NativeName(NativeNameType.Type, "int")] int allowedChanges)
		{
			uint ret = SDLOpenAudioDeviceNative(device, iscapture, desired, obtained, allowedChanges);
			return ret;
		}

		/// <summary>/// Open a specific audio device.<br/>/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>/// this function will never return a 1 so as not to conflict with the legacy<br/>/// function.<br/>/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>/// 2.0.5, recording is implemented and this value can be non-zero.<br/>/// Passing in a `device` name of NULL requests the most reasonable default<br/>/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>/// some drivers allow arbitrary and driver-specific strings, such as a<br/>/// hostname/IP address for a remote audio server, or a filename in the<br/>/// diskaudio driver.<br/>/// An opened audio device starts out paused, and should be enabled for playing<br/>/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>/// callback function to be called. Since the audio driver may modify the<br/>/// requested size of the audio buffer, you should allocate any local mixing<br/>/// buffers after you open the audio device.<br/>/// The audio callback runs in a separate thread in most cases; you can prevent<br/>/// race conditions between your callback and other threads without fully<br/>/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>/// callback, see SDL_AudioSpec.<br/>/// Managing the audio spec via 'desired' and 'obtained':<br/>/// When filling in the desired audio spec structure:<br/>/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>/// frames_ (with stereo output, two samples--left and right--would make a<br/>/// single sample frame). This number should be a power of two, and may be<br/>/// adjusted by the audio driver to a value more suitable for the hardware.<br/>/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>/// the application and CPU speed. Smaller values reduce latency, but can<br/>/// lead to underflow if the application is doing heavy processing and cannot<br/>/// fill the audio buffer in time. Note that the number of sample frames is<br/>/// directly related to time by the following formula: `ms =<br/>/// (sampleframes*1000)/freq`<br/>/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>/// - `desired->callback` should be set to a function that will be called when<br/>/// the audio device is ready for more data. It is passed a pointer to the<br/>/// audio buffer, and the length in bytes of the audio buffer. This function<br/>/// usually runs in a separate thread, and so you should protect data<br/>/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>/// more audio samples to be played (or for capture devices, call<br/>/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>/// - `desired->userdata` is passed as the first parameter to your callback<br/>/// function. If you passed a NULL callback, this value is ignored.<br/>/// `allowed_changes` can have the following flags OR'd together:<br/>/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>/// These flags specify how SDL should behave when a device cannot offer a<br/>/// specific feature. If the application requests a feature that the hardware<br/>/// doesn't offer, SDL will always try to get the closest equivalent.<br/>/// For example, if you ask for float32 audio format, but the sound card only<br/>/// supports int16, SDL will set the hardware to int16. If you had set<br/>/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>/// callback's float32 audio to int16 before feeding it to the hardware and<br/>/// will keep the originally requested format in the `obtained` structure.<br/>/// The resulting audio specs, varying depending on hardware and on what<br/>/// changes were allowed, will then be written back to `obtained`.<br/>/// If your application can only handle one specific data format, pass a zero<br/>/// for `allowed_changes` and let SDL transparently handle any differences.<br/>/// <br/>/// For compatibility with SDL 1.2, this will never return 1, since<br/>/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_OpenAudioDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID")]
		public static uint SDLOpenAudioDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "const char*")] ref byte device, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "const SDL_AudioSpec*")] SDLAudioSpec* desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* obtained, [NativeName(NativeNameType.Param, "allowed_changes")] [NativeName(NativeNameType.Type, "int")] int allowedChanges)
		{
			fixed (byte* pdevice = &device)
			{
				uint ret = SDLOpenAudioDeviceNative((byte*)pdevice, iscapture, desired, obtained, allowedChanges);
				return ret;
			}
		}

		/// <summary>/// Open a specific audio device.<br/>/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>/// this function will never return a 1 so as not to conflict with the legacy<br/>/// function.<br/>/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>/// 2.0.5, recording is implemented and this value can be non-zero.<br/>/// Passing in a `device` name of NULL requests the most reasonable default<br/>/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>/// some drivers allow arbitrary and driver-specific strings, such as a<br/>/// hostname/IP address for a remote audio server, or a filename in the<br/>/// diskaudio driver.<br/>/// An opened audio device starts out paused, and should be enabled for playing<br/>/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>/// callback function to be called. Since the audio driver may modify the<br/>/// requested size of the audio buffer, you should allocate any local mixing<br/>/// buffers after you open the audio device.<br/>/// The audio callback runs in a separate thread in most cases; you can prevent<br/>/// race conditions between your callback and other threads without fully<br/>/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>/// callback, see SDL_AudioSpec.<br/>/// Managing the audio spec via 'desired' and 'obtained':<br/>/// When filling in the desired audio spec structure:<br/>/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>/// frames_ (with stereo output, two samples--left and right--would make a<br/>/// single sample frame). This number should be a power of two, and may be<br/>/// adjusted by the audio driver to a value more suitable for the hardware.<br/>/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>/// the application and CPU speed. Smaller values reduce latency, but can<br/>/// lead to underflow if the application is doing heavy processing and cannot<br/>/// fill the audio buffer in time. Note that the number of sample frames is<br/>/// directly related to time by the following formula: `ms =<br/>/// (sampleframes*1000)/freq`<br/>/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>/// - `desired->callback` should be set to a function that will be called when<br/>/// the audio device is ready for more data. It is passed a pointer to the<br/>/// audio buffer, and the length in bytes of the audio buffer. This function<br/>/// usually runs in a separate thread, and so you should protect data<br/>/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>/// more audio samples to be played (or for capture devices, call<br/>/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>/// - `desired->userdata` is passed as the first parameter to your callback<br/>/// function. If you passed a NULL callback, this value is ignored.<br/>/// `allowed_changes` can have the following flags OR'd together:<br/>/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>/// These flags specify how SDL should behave when a device cannot offer a<br/>/// specific feature. If the application requests a feature that the hardware<br/>/// doesn't offer, SDL will always try to get the closest equivalent.<br/>/// For example, if you ask for float32 audio format, but the sound card only<br/>/// supports int16, SDL will set the hardware to int16. If you had set<br/>/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>/// callback's float32 audio to int16 before feeding it to the hardware and<br/>/// will keep the originally requested format in the `obtained` structure.<br/>/// The resulting audio specs, varying depending on hardware and on what<br/>/// changes were allowed, will then be written back to `obtained`.<br/>/// If your application can only handle one specific data format, pass a zero<br/>/// for `allowed_changes` and let SDL transparently handle any differences.<br/>/// <br/>/// For compatibility with SDL 1.2, this will never return 1, since<br/>/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_OpenAudioDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID")]
		public static uint SDLOpenAudioDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "const char*")] string device, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "const SDL_AudioSpec*")] SDLAudioSpec* desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* obtained, [NativeName(NativeNameType.Param, "allowed_changes")] [NativeName(NativeNameType.Type, "int")] int allowedChanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (device != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(device);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(device, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = SDLOpenAudioDeviceNative(pStr0, iscapture, desired, obtained, allowedChanges);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// Open a specific audio device.<br/>/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>/// this function will never return a 1 so as not to conflict with the legacy<br/>/// function.<br/>/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>/// 2.0.5, recording is implemented and this value can be non-zero.<br/>/// Passing in a `device` name of NULL requests the most reasonable default<br/>/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>/// some drivers allow arbitrary and driver-specific strings, such as a<br/>/// hostname/IP address for a remote audio server, or a filename in the<br/>/// diskaudio driver.<br/>/// An opened audio device starts out paused, and should be enabled for playing<br/>/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>/// callback function to be called. Since the audio driver may modify the<br/>/// requested size of the audio buffer, you should allocate any local mixing<br/>/// buffers after you open the audio device.<br/>/// The audio callback runs in a separate thread in most cases; you can prevent<br/>/// race conditions between your callback and other threads without fully<br/>/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>/// callback, see SDL_AudioSpec.<br/>/// Managing the audio spec via 'desired' and 'obtained':<br/>/// When filling in the desired audio spec structure:<br/>/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>/// frames_ (with stereo output, two samples--left and right--would make a<br/>/// single sample frame). This number should be a power of two, and may be<br/>/// adjusted by the audio driver to a value more suitable for the hardware.<br/>/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>/// the application and CPU speed. Smaller values reduce latency, but can<br/>/// lead to underflow if the application is doing heavy processing and cannot<br/>/// fill the audio buffer in time. Note that the number of sample frames is<br/>/// directly related to time by the following formula: `ms =<br/>/// (sampleframes*1000)/freq`<br/>/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>/// - `desired->callback` should be set to a function that will be called when<br/>/// the audio device is ready for more data. It is passed a pointer to the<br/>/// audio buffer, and the length in bytes of the audio buffer. This function<br/>/// usually runs in a separate thread, and so you should protect data<br/>/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>/// more audio samples to be played (or for capture devices, call<br/>/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>/// - `desired->userdata` is passed as the first parameter to your callback<br/>/// function. If you passed a NULL callback, this value is ignored.<br/>/// `allowed_changes` can have the following flags OR'd together:<br/>/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>/// These flags specify how SDL should behave when a device cannot offer a<br/>/// specific feature. If the application requests a feature that the hardware<br/>/// doesn't offer, SDL will always try to get the closest equivalent.<br/>/// For example, if you ask for float32 audio format, but the sound card only<br/>/// supports int16, SDL will set the hardware to int16. If you had set<br/>/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>/// callback's float32 audio to int16 before feeding it to the hardware and<br/>/// will keep the originally requested format in the `obtained` structure.<br/>/// The resulting audio specs, varying depending on hardware and on what<br/>/// changes were allowed, will then be written back to `obtained`.<br/>/// If your application can only handle one specific data format, pass a zero<br/>/// for `allowed_changes` and let SDL transparently handle any differences.<br/>/// <br/>/// For compatibility with SDL 1.2, this will never return 1, since<br/>/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_OpenAudioDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID")]
		public static uint SDLOpenAudioDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "const char*")] byte* device, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "const SDL_AudioSpec*")] ref SDLAudioSpec desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* obtained, [NativeName(NativeNameType.Param, "allowed_changes")] [NativeName(NativeNameType.Type, "int")] int allowedChanges)
		{
			fixed (SDLAudioSpec* pdesired = &desired)
			{
				uint ret = SDLOpenAudioDeviceNative(device, iscapture, (SDLAudioSpec*)pdesired, obtained, allowedChanges);
				return ret;
			}
		}

		/// <summary>/// Open a specific audio device.<br/>/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>/// this function will never return a 1 so as not to conflict with the legacy<br/>/// function.<br/>/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>/// 2.0.5, recording is implemented and this value can be non-zero.<br/>/// Passing in a `device` name of NULL requests the most reasonable default<br/>/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>/// some drivers allow arbitrary and driver-specific strings, such as a<br/>/// hostname/IP address for a remote audio server, or a filename in the<br/>/// diskaudio driver.<br/>/// An opened audio device starts out paused, and should be enabled for playing<br/>/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>/// callback function to be called. Since the audio driver may modify the<br/>/// requested size of the audio buffer, you should allocate any local mixing<br/>/// buffers after you open the audio device.<br/>/// The audio callback runs in a separate thread in most cases; you can prevent<br/>/// race conditions between your callback and other threads without fully<br/>/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>/// callback, see SDL_AudioSpec.<br/>/// Managing the audio spec via 'desired' and 'obtained':<br/>/// When filling in the desired audio spec structure:<br/>/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>/// frames_ (with stereo output, two samples--left and right--would make a<br/>/// single sample frame). This number should be a power of two, and may be<br/>/// adjusted by the audio driver to a value more suitable for the hardware.<br/>/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>/// the application and CPU speed. Smaller values reduce latency, but can<br/>/// lead to underflow if the application is doing heavy processing and cannot<br/>/// fill the audio buffer in time. Note that the number of sample frames is<br/>/// directly related to time by the following formula: `ms =<br/>/// (sampleframes*1000)/freq`<br/>/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>/// - `desired->callback` should be set to a function that will be called when<br/>/// the audio device is ready for more data. It is passed a pointer to the<br/>/// audio buffer, and the length in bytes of the audio buffer. This function<br/>/// usually runs in a separate thread, and so you should protect data<br/>/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>/// more audio samples to be played (or for capture devices, call<br/>/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>/// - `desired->userdata` is passed as the first parameter to your callback<br/>/// function. If you passed a NULL callback, this value is ignored.<br/>/// `allowed_changes` can have the following flags OR'd together:<br/>/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>/// These flags specify how SDL should behave when a device cannot offer a<br/>/// specific feature. If the application requests a feature that the hardware<br/>/// doesn't offer, SDL will always try to get the closest equivalent.<br/>/// For example, if you ask for float32 audio format, but the sound card only<br/>/// supports int16, SDL will set the hardware to int16. If you had set<br/>/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>/// callback's float32 audio to int16 before feeding it to the hardware and<br/>/// will keep the originally requested format in the `obtained` structure.<br/>/// The resulting audio specs, varying depending on hardware and on what<br/>/// changes were allowed, will then be written back to `obtained`.<br/>/// If your application can only handle one specific data format, pass a zero<br/>/// for `allowed_changes` and let SDL transparently handle any differences.<br/>/// <br/>/// For compatibility with SDL 1.2, this will never return 1, since<br/>/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_OpenAudioDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID")]
		public static uint SDLOpenAudioDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "const char*")] ref byte device, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "const SDL_AudioSpec*")] ref SDLAudioSpec desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* obtained, [NativeName(NativeNameType.Param, "allowed_changes")] [NativeName(NativeNameType.Type, "int")] int allowedChanges)
		{
			fixed (byte* pdevice = &device)
			{
				fixed (SDLAudioSpec* pdesired = &desired)
				{
					uint ret = SDLOpenAudioDeviceNative((byte*)pdevice, iscapture, (SDLAudioSpec*)pdesired, obtained, allowedChanges);
					return ret;
				}
			}
		}

		/// <summary>/// Open a specific audio device.<br/>/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>/// this function will never return a 1 so as not to conflict with the legacy<br/>/// function.<br/>/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>/// 2.0.5, recording is implemented and this value can be non-zero.<br/>/// Passing in a `device` name of NULL requests the most reasonable default<br/>/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>/// some drivers allow arbitrary and driver-specific strings, such as a<br/>/// hostname/IP address for a remote audio server, or a filename in the<br/>/// diskaudio driver.<br/>/// An opened audio device starts out paused, and should be enabled for playing<br/>/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>/// callback function to be called. Since the audio driver may modify the<br/>/// requested size of the audio buffer, you should allocate any local mixing<br/>/// buffers after you open the audio device.<br/>/// The audio callback runs in a separate thread in most cases; you can prevent<br/>/// race conditions between your callback and other threads without fully<br/>/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>/// callback, see SDL_AudioSpec.<br/>/// Managing the audio spec via 'desired' and 'obtained':<br/>/// When filling in the desired audio spec structure:<br/>/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>/// frames_ (with stereo output, two samples--left and right--would make a<br/>/// single sample frame). This number should be a power of two, and may be<br/>/// adjusted by the audio driver to a value more suitable for the hardware.<br/>/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>/// the application and CPU speed. Smaller values reduce latency, but can<br/>/// lead to underflow if the application is doing heavy processing and cannot<br/>/// fill the audio buffer in time. Note that the number of sample frames is<br/>/// directly related to time by the following formula: `ms =<br/>/// (sampleframes*1000)/freq`<br/>/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>/// - `desired->callback` should be set to a function that will be called when<br/>/// the audio device is ready for more data. It is passed a pointer to the<br/>/// audio buffer, and the length in bytes of the audio buffer. This function<br/>/// usually runs in a separate thread, and so you should protect data<br/>/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>/// more audio samples to be played (or for capture devices, call<br/>/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>/// - `desired->userdata` is passed as the first parameter to your callback<br/>/// function. If you passed a NULL callback, this value is ignored.<br/>/// `allowed_changes` can have the following flags OR'd together:<br/>/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>/// These flags specify how SDL should behave when a device cannot offer a<br/>/// specific feature. If the application requests a feature that the hardware<br/>/// doesn't offer, SDL will always try to get the closest equivalent.<br/>/// For example, if you ask for float32 audio format, but the sound card only<br/>/// supports int16, SDL will set the hardware to int16. If you had set<br/>/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>/// callback's float32 audio to int16 before feeding it to the hardware and<br/>/// will keep the originally requested format in the `obtained` structure.<br/>/// The resulting audio specs, varying depending on hardware and on what<br/>/// changes were allowed, will then be written back to `obtained`.<br/>/// If your application can only handle one specific data format, pass a zero<br/>/// for `allowed_changes` and let SDL transparently handle any differences.<br/>/// <br/>/// For compatibility with SDL 1.2, this will never return 1, since<br/>/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_OpenAudioDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID")]
		public static uint SDLOpenAudioDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "const char*")] string device, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "const SDL_AudioSpec*")] ref SDLAudioSpec desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* obtained, [NativeName(NativeNameType.Param, "allowed_changes")] [NativeName(NativeNameType.Type, "int")] int allowedChanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (device != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(device);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(device, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (SDLAudioSpec* pdesired = &desired)
			{
				uint ret = SDLOpenAudioDeviceNative(pStr0, iscapture, (SDLAudioSpec*)pdesired, obtained, allowedChanges);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>/// Open a specific audio device.<br/>/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>/// this function will never return a 1 so as not to conflict with the legacy<br/>/// function.<br/>/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>/// 2.0.5, recording is implemented and this value can be non-zero.<br/>/// Passing in a `device` name of NULL requests the most reasonable default<br/>/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>/// some drivers allow arbitrary and driver-specific strings, such as a<br/>/// hostname/IP address for a remote audio server, or a filename in the<br/>/// diskaudio driver.<br/>/// An opened audio device starts out paused, and should be enabled for playing<br/>/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>/// callback function to be called. Since the audio driver may modify the<br/>/// requested size of the audio buffer, you should allocate any local mixing<br/>/// buffers after you open the audio device.<br/>/// The audio callback runs in a separate thread in most cases; you can prevent<br/>/// race conditions between your callback and other threads without fully<br/>/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>/// callback, see SDL_AudioSpec.<br/>/// Managing the audio spec via 'desired' and 'obtained':<br/>/// When filling in the desired audio spec structure:<br/>/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>/// frames_ (with stereo output, two samples--left and right--would make a<br/>/// single sample frame). This number should be a power of two, and may be<br/>/// adjusted by the audio driver to a value more suitable for the hardware.<br/>/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>/// the application and CPU speed. Smaller values reduce latency, but can<br/>/// lead to underflow if the application is doing heavy processing and cannot<br/>/// fill the audio buffer in time. Note that the number of sample frames is<br/>/// directly related to time by the following formula: `ms =<br/>/// (sampleframes*1000)/freq`<br/>/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>/// - `desired->callback` should be set to a function that will be called when<br/>/// the audio device is ready for more data. It is passed a pointer to the<br/>/// audio buffer, and the length in bytes of the audio buffer. This function<br/>/// usually runs in a separate thread, and so you should protect data<br/>/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>/// more audio samples to be played (or for capture devices, call<br/>/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>/// - `desired->userdata` is passed as the first parameter to your callback<br/>/// function. If you passed a NULL callback, this value is ignored.<br/>/// `allowed_changes` can have the following flags OR'd together:<br/>/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>/// These flags specify how SDL should behave when a device cannot offer a<br/>/// specific feature. If the application requests a feature that the hardware<br/>/// doesn't offer, SDL will always try to get the closest equivalent.<br/>/// For example, if you ask for float32 audio format, but the sound card only<br/>/// supports int16, SDL will set the hardware to int16. If you had set<br/>/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>/// callback's float32 audio to int16 before feeding it to the hardware and<br/>/// will keep the originally requested format in the `obtained` structure.<br/>/// The resulting audio specs, varying depending on hardware and on what<br/>/// changes were allowed, will then be written back to `obtained`.<br/>/// If your application can only handle one specific data format, pass a zero<br/>/// for `allowed_changes` and let SDL transparently handle any differences.<br/>/// <br/>/// For compatibility with SDL 1.2, this will never return 1, since<br/>/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_OpenAudioDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID")]
		public static uint SDLOpenAudioDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "const char*")] byte* device, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "const SDL_AudioSpec*")] SDLAudioSpec* desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec obtained, [NativeName(NativeNameType.Param, "allowed_changes")] [NativeName(NativeNameType.Type, "int")] int allowedChanges)
		{
			fixed (SDLAudioSpec* pobtained = &obtained)
			{
				uint ret = SDLOpenAudioDeviceNative(device, iscapture, desired, (SDLAudioSpec*)pobtained, allowedChanges);
				return ret;
			}
		}

		/// <summary>/// Open a specific audio device.<br/>/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>/// this function will never return a 1 so as not to conflict with the legacy<br/>/// function.<br/>/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>/// 2.0.5, recording is implemented and this value can be non-zero.<br/>/// Passing in a `device` name of NULL requests the most reasonable default<br/>/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>/// some drivers allow arbitrary and driver-specific strings, such as a<br/>/// hostname/IP address for a remote audio server, or a filename in the<br/>/// diskaudio driver.<br/>/// An opened audio device starts out paused, and should be enabled for playing<br/>/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>/// callback function to be called. Since the audio driver may modify the<br/>/// requested size of the audio buffer, you should allocate any local mixing<br/>/// buffers after you open the audio device.<br/>/// The audio callback runs in a separate thread in most cases; you can prevent<br/>/// race conditions between your callback and other threads without fully<br/>/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>/// callback, see SDL_AudioSpec.<br/>/// Managing the audio spec via 'desired' and 'obtained':<br/>/// When filling in the desired audio spec structure:<br/>/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>/// frames_ (with stereo output, two samples--left and right--would make a<br/>/// single sample frame). This number should be a power of two, and may be<br/>/// adjusted by the audio driver to a value more suitable for the hardware.<br/>/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>/// the application and CPU speed. Smaller values reduce latency, but can<br/>/// lead to underflow if the application is doing heavy processing and cannot<br/>/// fill the audio buffer in time. Note that the number of sample frames is<br/>/// directly related to time by the following formula: `ms =<br/>/// (sampleframes*1000)/freq`<br/>/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>/// - `desired->callback` should be set to a function that will be called when<br/>/// the audio device is ready for more data. It is passed a pointer to the<br/>/// audio buffer, and the length in bytes of the audio buffer. This function<br/>/// usually runs in a separate thread, and so you should protect data<br/>/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>/// more audio samples to be played (or for capture devices, call<br/>/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>/// - `desired->userdata` is passed as the first parameter to your callback<br/>/// function. If you passed a NULL callback, this value is ignored.<br/>/// `allowed_changes` can have the following flags OR'd together:<br/>/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>/// These flags specify how SDL should behave when a device cannot offer a<br/>/// specific feature. If the application requests a feature that the hardware<br/>/// doesn't offer, SDL will always try to get the closest equivalent.<br/>/// For example, if you ask for float32 audio format, but the sound card only<br/>/// supports int16, SDL will set the hardware to int16. If you had set<br/>/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>/// callback's float32 audio to int16 before feeding it to the hardware and<br/>/// will keep the originally requested format in the `obtained` structure.<br/>/// The resulting audio specs, varying depending on hardware and on what<br/>/// changes were allowed, will then be written back to `obtained`.<br/>/// If your application can only handle one specific data format, pass a zero<br/>/// for `allowed_changes` and let SDL transparently handle any differences.<br/>/// <br/>/// For compatibility with SDL 1.2, this will never return 1, since<br/>/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_OpenAudioDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID")]
		public static uint SDLOpenAudioDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "const char*")] ref byte device, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "const SDL_AudioSpec*")] SDLAudioSpec* desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec obtained, [NativeName(NativeNameType.Param, "allowed_changes")] [NativeName(NativeNameType.Type, "int")] int allowedChanges)
		{
			fixed (byte* pdevice = &device)
			{
				fixed (SDLAudioSpec* pobtained = &obtained)
				{
					uint ret = SDLOpenAudioDeviceNative((byte*)pdevice, iscapture, desired, (SDLAudioSpec*)pobtained, allowedChanges);
					return ret;
				}
			}
		}

		/// <summary>/// Open a specific audio device.<br/>/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>/// this function will never return a 1 so as not to conflict with the legacy<br/>/// function.<br/>/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>/// 2.0.5, recording is implemented and this value can be non-zero.<br/>/// Passing in a `device` name of NULL requests the most reasonable default<br/>/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>/// some drivers allow arbitrary and driver-specific strings, such as a<br/>/// hostname/IP address for a remote audio server, or a filename in the<br/>/// diskaudio driver.<br/>/// An opened audio device starts out paused, and should be enabled for playing<br/>/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>/// callback function to be called. Since the audio driver may modify the<br/>/// requested size of the audio buffer, you should allocate any local mixing<br/>/// buffers after you open the audio device.<br/>/// The audio callback runs in a separate thread in most cases; you can prevent<br/>/// race conditions between your callback and other threads without fully<br/>/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>/// callback, see SDL_AudioSpec.<br/>/// Managing the audio spec via 'desired' and 'obtained':<br/>/// When filling in the desired audio spec structure:<br/>/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>/// frames_ (with stereo output, two samples--left and right--would make a<br/>/// single sample frame). This number should be a power of two, and may be<br/>/// adjusted by the audio driver to a value more suitable for the hardware.<br/>/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>/// the application and CPU speed. Smaller values reduce latency, but can<br/>/// lead to underflow if the application is doing heavy processing and cannot<br/>/// fill the audio buffer in time. Note that the number of sample frames is<br/>/// directly related to time by the following formula: `ms =<br/>/// (sampleframes*1000)/freq`<br/>/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>/// - `desired->callback` should be set to a function that will be called when<br/>/// the audio device is ready for more data. It is passed a pointer to the<br/>/// audio buffer, and the length in bytes of the audio buffer. This function<br/>/// usually runs in a separate thread, and so you should protect data<br/>/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>/// more audio samples to be played (or for capture devices, call<br/>/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>/// - `desired->userdata` is passed as the first parameter to your callback<br/>/// function. If you passed a NULL callback, this value is ignored.<br/>/// `allowed_changes` can have the following flags OR'd together:<br/>/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>/// These flags specify how SDL should behave when a device cannot offer a<br/>/// specific feature. If the application requests a feature that the hardware<br/>/// doesn't offer, SDL will always try to get the closest equivalent.<br/>/// For example, if you ask for float32 audio format, but the sound card only<br/>/// supports int16, SDL will set the hardware to int16. If you had set<br/>/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>/// callback's float32 audio to int16 before feeding it to the hardware and<br/>/// will keep the originally requested format in the `obtained` structure.<br/>/// The resulting audio specs, varying depending on hardware and on what<br/>/// changes were allowed, will then be written back to `obtained`.<br/>/// If your application can only handle one specific data format, pass a zero<br/>/// for `allowed_changes` and let SDL transparently handle any differences.<br/>/// <br/>/// For compatibility with SDL 1.2, this will never return 1, since<br/>/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_OpenAudioDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID")]
		public static uint SDLOpenAudioDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "const char*")] string device, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "const SDL_AudioSpec*")] SDLAudioSpec* desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec obtained, [NativeName(NativeNameType.Param, "allowed_changes")] [NativeName(NativeNameType.Type, "int")] int allowedChanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (device != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(device);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(device, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (SDLAudioSpec* pobtained = &obtained)
			{
				uint ret = SDLOpenAudioDeviceNative(pStr0, iscapture, desired, (SDLAudioSpec*)pobtained, allowedChanges);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>/// Open a specific audio device.<br/>/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>/// this function will never return a 1 so as not to conflict with the legacy<br/>/// function.<br/>/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>/// 2.0.5, recording is implemented and this value can be non-zero.<br/>/// Passing in a `device` name of NULL requests the most reasonable default<br/>/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>/// some drivers allow arbitrary and driver-specific strings, such as a<br/>/// hostname/IP address for a remote audio server, or a filename in the<br/>/// diskaudio driver.<br/>/// An opened audio device starts out paused, and should be enabled for playing<br/>/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>/// callback function to be called. Since the audio driver may modify the<br/>/// requested size of the audio buffer, you should allocate any local mixing<br/>/// buffers after you open the audio device.<br/>/// The audio callback runs in a separate thread in most cases; you can prevent<br/>/// race conditions between your callback and other threads without fully<br/>/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>/// callback, see SDL_AudioSpec.<br/>/// Managing the audio spec via 'desired' and 'obtained':<br/>/// When filling in the desired audio spec structure:<br/>/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>/// frames_ (with stereo output, two samples--left and right--would make a<br/>/// single sample frame). This number should be a power of two, and may be<br/>/// adjusted by the audio driver to a value more suitable for the hardware.<br/>/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>/// the application and CPU speed. Smaller values reduce latency, but can<br/>/// lead to underflow if the application is doing heavy processing and cannot<br/>/// fill the audio buffer in time. Note that the number of sample frames is<br/>/// directly related to time by the following formula: `ms =<br/>/// (sampleframes*1000)/freq`<br/>/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>/// - `desired->callback` should be set to a function that will be called when<br/>/// the audio device is ready for more data. It is passed a pointer to the<br/>/// audio buffer, and the length in bytes of the audio buffer. This function<br/>/// usually runs in a separate thread, and so you should protect data<br/>/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>/// more audio samples to be played (or for capture devices, call<br/>/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>/// - `desired->userdata` is passed as the first parameter to your callback<br/>/// function. If you passed a NULL callback, this value is ignored.<br/>/// `allowed_changes` can have the following flags OR'd together:<br/>/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>/// These flags specify how SDL should behave when a device cannot offer a<br/>/// specific feature. If the application requests a feature that the hardware<br/>/// doesn't offer, SDL will always try to get the closest equivalent.<br/>/// For example, if you ask for float32 audio format, but the sound card only<br/>/// supports int16, SDL will set the hardware to int16. If you had set<br/>/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>/// callback's float32 audio to int16 before feeding it to the hardware and<br/>/// will keep the originally requested format in the `obtained` structure.<br/>/// The resulting audio specs, varying depending on hardware and on what<br/>/// changes were allowed, will then be written back to `obtained`.<br/>/// If your application can only handle one specific data format, pass a zero<br/>/// for `allowed_changes` and let SDL transparently handle any differences.<br/>/// <br/>/// For compatibility with SDL 1.2, this will never return 1, since<br/>/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_OpenAudioDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID")]
		public static uint SDLOpenAudioDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "const char*")] byte* device, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "const SDL_AudioSpec*")] ref SDLAudioSpec desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec obtained, [NativeName(NativeNameType.Param, "allowed_changes")] [NativeName(NativeNameType.Type, "int")] int allowedChanges)
		{
			fixed (SDLAudioSpec* pdesired = &desired)
			{
				fixed (SDLAudioSpec* pobtained = &obtained)
				{
					uint ret = SDLOpenAudioDeviceNative(device, iscapture, (SDLAudioSpec*)pdesired, (SDLAudioSpec*)pobtained, allowedChanges);
					return ret;
				}
			}
		}

		/// <summary>/// Open a specific audio device.<br/>/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>/// this function will never return a 1 so as not to conflict with the legacy<br/>/// function.<br/>/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>/// 2.0.5, recording is implemented and this value can be non-zero.<br/>/// Passing in a `device` name of NULL requests the most reasonable default<br/>/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>/// some drivers allow arbitrary and driver-specific strings, such as a<br/>/// hostname/IP address for a remote audio server, or a filename in the<br/>/// diskaudio driver.<br/>/// An opened audio device starts out paused, and should be enabled for playing<br/>/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>/// callback function to be called. Since the audio driver may modify the<br/>/// requested size of the audio buffer, you should allocate any local mixing<br/>/// buffers after you open the audio device.<br/>/// The audio callback runs in a separate thread in most cases; you can prevent<br/>/// race conditions between your callback and other threads without fully<br/>/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>/// callback, see SDL_AudioSpec.<br/>/// Managing the audio spec via 'desired' and 'obtained':<br/>/// When filling in the desired audio spec structure:<br/>/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>/// frames_ (with stereo output, two samples--left and right--would make a<br/>/// single sample frame). This number should be a power of two, and may be<br/>/// adjusted by the audio driver to a value more suitable for the hardware.<br/>/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>/// the application and CPU speed. Smaller values reduce latency, but can<br/>/// lead to underflow if the application is doing heavy processing and cannot<br/>/// fill the audio buffer in time. Note that the number of sample frames is<br/>/// directly related to time by the following formula: `ms =<br/>/// (sampleframes*1000)/freq`<br/>/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>/// - `desired->callback` should be set to a function that will be called when<br/>/// the audio device is ready for more data. It is passed a pointer to the<br/>/// audio buffer, and the length in bytes of the audio buffer. This function<br/>/// usually runs in a separate thread, and so you should protect data<br/>/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>/// more audio samples to be played (or for capture devices, call<br/>/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>/// - `desired->userdata` is passed as the first parameter to your callback<br/>/// function. If you passed a NULL callback, this value is ignored.<br/>/// `allowed_changes` can have the following flags OR'd together:<br/>/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>/// These flags specify how SDL should behave when a device cannot offer a<br/>/// specific feature. If the application requests a feature that the hardware<br/>/// doesn't offer, SDL will always try to get the closest equivalent.<br/>/// For example, if you ask for float32 audio format, but the sound card only<br/>/// supports int16, SDL will set the hardware to int16. If you had set<br/>/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>/// callback's float32 audio to int16 before feeding it to the hardware and<br/>/// will keep the originally requested format in the `obtained` structure.<br/>/// The resulting audio specs, varying depending on hardware and on what<br/>/// changes were allowed, will then be written back to `obtained`.<br/>/// If your application can only handle one specific data format, pass a zero<br/>/// for `allowed_changes` and let SDL transparently handle any differences.<br/>/// <br/>/// For compatibility with SDL 1.2, this will never return 1, since<br/>/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_OpenAudioDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID")]
		public static uint SDLOpenAudioDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "const char*")] ref byte device, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "const SDL_AudioSpec*")] ref SDLAudioSpec desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec obtained, [NativeName(NativeNameType.Param, "allowed_changes")] [NativeName(NativeNameType.Type, "int")] int allowedChanges)
		{
			fixed (byte* pdevice = &device)
			{
				fixed (SDLAudioSpec* pdesired = &desired)
				{
					fixed (SDLAudioSpec* pobtained = &obtained)
					{
						uint ret = SDLOpenAudioDeviceNative((byte*)pdevice, iscapture, (SDLAudioSpec*)pdesired, (SDLAudioSpec*)pobtained, allowedChanges);
						return ret;
					}
				}
			}
		}

		/// <summary>/// Open a specific audio device.<br/>/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>/// this function will never return a 1 so as not to conflict with the legacy<br/>/// function.<br/>/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>/// 2.0.5, recording is implemented and this value can be non-zero.<br/>/// Passing in a `device` name of NULL requests the most reasonable default<br/>/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>/// some drivers allow arbitrary and driver-specific strings, such as a<br/>/// hostname/IP address for a remote audio server, or a filename in the<br/>/// diskaudio driver.<br/>/// An opened audio device starts out paused, and should be enabled for playing<br/>/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>/// callback function to be called. Since the audio driver may modify the<br/>/// requested size of the audio buffer, you should allocate any local mixing<br/>/// buffers after you open the audio device.<br/>/// The audio callback runs in a separate thread in most cases; you can prevent<br/>/// race conditions between your callback and other threads without fully<br/>/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>/// callback, see SDL_AudioSpec.<br/>/// Managing the audio spec via 'desired' and 'obtained':<br/>/// When filling in the desired audio spec structure:<br/>/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>/// frames_ (with stereo output, two samples--left and right--would make a<br/>/// single sample frame). This number should be a power of two, and may be<br/>/// adjusted by the audio driver to a value more suitable for the hardware.<br/>/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>/// the application and CPU speed. Smaller values reduce latency, but can<br/>/// lead to underflow if the application is doing heavy processing and cannot<br/>/// fill the audio buffer in time. Note that the number of sample frames is<br/>/// directly related to time by the following formula: `ms =<br/>/// (sampleframes*1000)/freq`<br/>/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>/// - `desired->callback` should be set to a function that will be called when<br/>/// the audio device is ready for more data. It is passed a pointer to the<br/>/// audio buffer, and the length in bytes of the audio buffer. This function<br/>/// usually runs in a separate thread, and so you should protect data<br/>/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>/// more audio samples to be played (or for capture devices, call<br/>/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>/// - `desired->userdata` is passed as the first parameter to your callback<br/>/// function. If you passed a NULL callback, this value is ignored.<br/>/// `allowed_changes` can have the following flags OR'd together:<br/>/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>/// These flags specify how SDL should behave when a device cannot offer a<br/>/// specific feature. If the application requests a feature that the hardware<br/>/// doesn't offer, SDL will always try to get the closest equivalent.<br/>/// For example, if you ask for float32 audio format, but the sound card only<br/>/// supports int16, SDL will set the hardware to int16. If you had set<br/>/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>/// callback's float32 audio to int16 before feeding it to the hardware and<br/>/// will keep the originally requested format in the `obtained` structure.<br/>/// The resulting audio specs, varying depending on hardware and on what<br/>/// changes were allowed, will then be written back to `obtained`.<br/>/// If your application can only handle one specific data format, pass a zero<br/>/// for `allowed_changes` and let SDL transparently handle any differences.<br/>/// <br/>/// For compatibility with SDL 1.2, this will never return 1, since<br/>/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_OpenAudioDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID")]
		public static uint SDLOpenAudioDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "const char*")] string device, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "const SDL_AudioSpec*")] ref SDLAudioSpec desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec obtained, [NativeName(NativeNameType.Param, "allowed_changes")] [NativeName(NativeNameType.Type, "int")] int allowedChanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (device != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(device);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(device, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (SDLAudioSpec* pdesired = &desired)
			{
				fixed (SDLAudioSpec* pobtained = &obtained)
				{
					uint ret = SDLOpenAudioDeviceNative(pStr0, iscapture, (SDLAudioSpec*)pdesired, (SDLAudioSpec*)pobtained, allowedChanges);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// This function is a legacy means of querying the audio device.<br/>
		/// New programs might want to use SDL_GetAudioDeviceStatus() instead. This<br/>
		/// function is equivalent to calling...<br/>
		/// ```c<br/>
		/// SDL_GetAudioDeviceStatus(1);<br/>
		/// ```<br/>
		/// ...and is only useful if you used the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAudioStatus")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioStatus")]
		internal static SDLAudioStatus SDLGetAudioStatusNative()
		{
			return ((delegate* unmanaged[Cdecl]<SDLAudioStatus>)vt[223])();
		}
		/// <summary>/// This function is a legacy means of querying the audio device.<br/>/// New programs might want to use SDL_GetAudioDeviceStatus() instead. This<br/>/// function is equivalent to calling...<br/>/// ```c<br/>/// SDL_GetAudioDeviceStatus(1);<br/>/// ```<br/>/// ...and is only useful if you used the legacy SDL_OpenAudio() function.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetAudioStatus")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioStatus")]
		public static SDLAudioStatus SDLGetAudioStatus()
		{
			SDLAudioStatus ret = SDLGetAudioStatusNative();
			return ret;
		}

		/// <summary>
		/// Use this function to get the current audio state of an audio device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAudioDeviceStatus")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioStatus")]
		internal static SDLAudioStatus SDLGetAudioDeviceStatusNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_AudioDeviceID")] uint dev)
		{
			return ((delegate* unmanaged[Cdecl]<uint, SDLAudioStatus>)vt[224])(dev);
		}
		/// <summary>/// Use this function to get the current audio state of an audio device.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetAudioDeviceStatus")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioStatus")]
		public static SDLAudioStatus SDLGetAudioDeviceStatus([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_AudioDeviceID")] uint dev)
		{
			SDLAudioStatus ret = SDLGetAudioDeviceStatusNative(dev);
			return ret;
		}

		/// <summary>
		/// This function is a legacy means of pausing the audio device.<br/>
		/// New programs might want to use SDL_PauseAudioDevice() instead. This<br/>
		/// function is equivalent to calling...<br/>
		/// ```c<br/>
		/// SDL_PauseAudioDevice(1, pause_on);<br/>
		/// ```<br/>
		/// ...and is only useful if you used the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PauseAudio")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SDLPauseAudioNative([NativeName(NativeNameType.Param, "pause_on")] [NativeName(NativeNameType.Type, "int")] int pauseOn)
		{
			((delegate* unmanaged[Cdecl]<int, void>)vt[225])(pauseOn);
		}
		/// <summary>/// This function is a legacy means of pausing the audio device.<br/>/// New programs might want to use SDL_PauseAudioDevice() instead. This<br/>/// function is equivalent to calling...<br/>/// ```c<br/>/// SDL_PauseAudioDevice(1, pause_on);<br/>/// ```<br/>/// ...and is only useful if you used the legacy SDL_OpenAudio() function.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_PauseAudio")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLPauseAudio([NativeName(NativeNameType.Param, "pause_on")] [NativeName(NativeNameType.Type, "int")] int pauseOn)
		{
			SDLPauseAudioNative(pauseOn);
		}

		/// <summary>
		/// Use this function to pause and unpause audio playback on a specified<br/>
		/// device.<br/>
		/// This function pauses and unpauses the audio callback processing for a given<br/>
		/// device. Newly-opened audio devices start in the paused state, so you must<br/>
		/// call this function with **pause_on**=0 after opening the specified audio<br/>
		/// device to start playing sound. This allows you to safely initialize data<br/>
		/// for your callback function after opening the audio device. Silence will be<br/>
		/// written to the audio device while paused, and the audio callback is<br/>
		/// guaranteed to not be called. Pausing one device does not prevent other<br/>
		/// unpaused devices from running their callbacks.<br/>
		/// Pausing state does not stack; even if you pause a device several times, a<br/>
		/// single unpause will start the device playing again, and vice versa. This is<br/>
		/// different from how SDL_LockAudioDevice() works.<br/>
		/// If you just need to protect a few variables from race conditions vs your<br/>
		/// callback, you shouldn't pause the audio device, as it will lead to dropouts<br/>
		/// in the audio playback. Instead, you should use SDL_LockAudioDevice().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PauseAudioDevice")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SDLPauseAudioDeviceNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_AudioDeviceID")] uint dev, [NativeName(NativeNameType.Param, "pause_on")] [NativeName(NativeNameType.Type, "int")] int pauseOn)
		{
			((delegate* unmanaged[Cdecl]<uint, int, void>)vt[226])(dev, pauseOn);
		}
		/// <summary>/// Use this function to pause and unpause audio playback on a specified<br/>/// device.<br/>/// This function pauses and unpauses the audio callback processing for a given<br/>/// device. Newly-opened audio devices start in the paused state, so you must<br/>/// call this function with **pause_on**=0 after opening the specified audio<br/>/// device to start playing sound. This allows you to safely initialize data<br/>/// for your callback function after opening the audio device. Silence will be<br/>/// written to the audio device while paused, and the audio callback is<br/>/// guaranteed to not be called. Pausing one device does not prevent other<br/>/// unpaused devices from running their callbacks.<br/>/// Pausing state does not stack; even if you pause a device several times, a<br/>/// single unpause will start the device playing again, and vice versa. This is<br/>/// different from how SDL_LockAudioDevice() works.<br/>/// If you just need to protect a few variables from race conditions vs your<br/>/// callback, you shouldn't pause the audio device, as it will lead to dropouts<br/>/// in the audio playback. Instead, you should use SDL_LockAudioDevice().<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_PauseAudioDevice")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLPauseAudioDevice([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_AudioDeviceID")] uint dev, [NativeName(NativeNameType.Param, "pause_on")] [NativeName(NativeNameType.Type, "int")] int pauseOn)
		{
			SDLPauseAudioDeviceNative(dev, pauseOn);
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>
		/// freed before the function returns.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>
		/// and the pointer to the audio data allocated by the function is written to<br/>
		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>
		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>
		/// data in the buffer. The `samples` member is set to a sane default and all<br/>
		/// others are set to zero.<br/>
		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>
		/// messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>
		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>
		/// more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioSpec*")]
		internal static SDLAudioSpec* SDLLoadWAVRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8**")] byte** audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32*")] uint* audioLen)
		{
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int, SDLAudioSpec*, byte**, uint*, SDLAudioSpec*>)vt[227])(src, freesrc, spec, audioBuf, audioLen);
		}
		/// <summary>/// Load the audio data of a WAVE file into memory.<br/>/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>/// be valid pointers. The entire data portion of the file is then loaded into<br/>/// memory and decoded if necessary.<br/>/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>/// freed before the function returns.<br/>/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>/// cause an error.<br/>/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>/// and the pointer to the audio data allocated by the function is written to<br/>/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>/// data in the buffer. The `samples` member is set to a sane default and all<br/>/// others are set to zero.<br/>/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>/// `audio_buf` when it is no longer used.<br/>/// Because of the underspecification of the .WAV format, there are many<br/>/// problematic files in the wild that cause issues with strict decoders. To<br/>/// provide compatibility with these files, this decoder is lenient in regards<br/>/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>/// tune the behavior of the loading process.<br/>/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>/// the headers), too big, or unsupported causes an error. Additionally, any<br/>/// critical I/O error from the data source will terminate the loading process<br/>/// with an error. The function returns NULL on error and in all cases (with<br/>/// the exception of `src` being NULL), an appropriate error message will be<br/>/// set.<br/>/// It is required that the data source supports seeking.<br/>/// Example:<br/>/// ```c<br/>/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>/// &spec<br/>/// , <br/>/// &buf<br/>/// , <br/>/// &len<br/>/// );<br/>/// ```<br/>/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>/// messy way:<br/>/// ```c<br/>/// SDL_LoadWAV("sample.wav", <br/>/// &spec<br/>/// , <br/>/// &buf<br/>/// , <br/>/// &len<br/>/// );<br/>/// ```<br/>/// <br/>/// This function returns NULL if the .WAV file cannot be opened, uses<br/>/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>/// more information.<br/>/// When the application is done with the data returned in<br/>/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_LoadWAV_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioSpec*")]
		public static SDLAudioSpec* SDLLoadWAVRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8**")] byte** audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32*")] uint* audioLen)
		{
			SDLAudioSpec* ret = SDLLoadWAVRWNative(src, freesrc, spec, audioBuf, audioLen);
			return ret;
		}
	}
}
