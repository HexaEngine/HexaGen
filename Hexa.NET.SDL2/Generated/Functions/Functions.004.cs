// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL2
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Close and free an allocated SDL_RWops structure.<br/>
		/// SDL_RWclose() closes and cleans up the SDL_RWops stream. It releases any<br/>
		/// resources used by the stream and frees the SDL_RWops itself with<br/>
		/// SDL_FreeRW(). This returns 0 on success, or -1 if the stream failed to<br/>
		/// flush to its output (e.g. to disk).<br/>
		/// Note that if this fails to flush the stream to disk, this function reports<br/>
		/// an error, but the SDL_RWops is still invalid once this function returns.<br/>
		/// Prior to SDL 2.0.10, this function was a macro.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RWclose")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRWclose([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops context)
		{
			fixed (SDLRWops* pcontext = &context)
			{
				int ret = SDLRWcloseNative((SDLRWops*)pcontext);
				return ret;
			}
		}

		/// <summary>
		/// Load all the data from an SDL data stream.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFile_RW")]
		[return: NativeName(NativeNameType.Type, "void*")]
		internal static void* SDLLoadFileRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t*")] ulong* datasize, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, ulong*, int, void*>)vt[196])(src, datasize, freesrc);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint, int, nint>)vt[196])((nint)src, (nint)datasize, freesrc);
			#endif
		}

		/// <summary>
		/// Load all the data from an SDL data stream.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFile_RW")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLLoadFileRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t*")] ulong* datasize, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc)
		{
			void* ret = SDLLoadFileRWNative(src, datasize, freesrc);
			return ret;
		}

		/// <summary>
		/// Load all the data from an SDL data stream.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFile_RW")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLLoadFileRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t*")] ulong* datasize, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc)
		{
			fixed (SDLRWops* psrc = &src)
			{
				void* ret = SDLLoadFileRWNative((SDLRWops*)psrc, datasize, freesrc);
				return ret;
			}
		}

		/// <summary>
		/// Load all the data from an SDL data stream.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFile_RW")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLLoadFileRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t*")] ref nuint datasize, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc)
		{
			fixed (nuint* pdatasize = &datasize)
			{
				void* ret = SDLLoadFileRWNative(src, (ulong*)pdatasize, freesrc);
				return ret;
			}
		}

		/// <summary>
		/// Load all the data from an SDL data stream.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFile_RW")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLLoadFileRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t*")] ref nuint datasize, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc)
		{
			fixed (SDLRWops* psrc = &src)
			{
				fixed (nuint* pdatasize = &datasize)
				{
					void* ret = SDLLoadFileRWNative((SDLRWops*)psrc, (ulong*)pdatasize, freesrc);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load all the data from a file path.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// Prior to SDL 2.0.10, this function was a macro wrapping around<br/>
		/// SDL_LoadFile_RW.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFile")]
		[return: NativeName(NativeNameType.Type, "void*")]
		internal static void* SDLLoadFileNative([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] byte* file, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t*")] ulong* datasize)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, ulong*, void*>)vt[197])(file, datasize);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)vt[197])((nint)file, (nint)datasize);
			#endif
		}

		/// <summary>
		/// Load all the data from a file path.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// Prior to SDL 2.0.10, this function was a macro wrapping around<br/>
		/// SDL_LoadFile_RW.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFile")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLLoadFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] byte* file, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t*")] ulong* datasize)
		{
			void* ret = SDLLoadFileNative(file, datasize);
			return ret;
		}

		/// <summary>
		/// Load all the data from a file path.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// Prior to SDL 2.0.10, this function was a macro wrapping around<br/>
		/// SDL_LoadFile_RW.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFile")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLLoadFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] ref byte file, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t*")] ulong* datasize)
		{
			fixed (byte* pfile = &file)
			{
				void* ret = SDLLoadFileNative((byte*)pfile, datasize);
				return ret;
			}
		}

		/// <summary>
		/// Load all the data from a file path.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// Prior to SDL 2.0.10, this function was a macro wrapping around<br/>
		/// SDL_LoadFile_RW.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFile")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLLoadFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> file, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t*")] ulong* datasize)
		{
			fixed (byte* pfile = file)
			{
				void* ret = SDLLoadFileNative((byte*)pfile, datasize);
				return ret;
			}
		}

		/// <summary>
		/// Load all the data from a file path.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// Prior to SDL 2.0.10, this function was a macro wrapping around<br/>
		/// SDL_LoadFile_RW.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFile")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLLoadFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] string file, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t*")] ulong* datasize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			void* ret = SDLLoadFileNative(pStr0, datasize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Load all the data from a file path.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// Prior to SDL 2.0.10, this function was a macro wrapping around<br/>
		/// SDL_LoadFile_RW.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFile")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLLoadFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] byte* file, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t*")] ref nuint datasize)
		{
			fixed (nuint* pdatasize = &datasize)
			{
				void* ret = SDLLoadFileNative(file, (ulong*)pdatasize);
				return ret;
			}
		}

		/// <summary>
		/// Load all the data from a file path.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// Prior to SDL 2.0.10, this function was a macro wrapping around<br/>
		/// SDL_LoadFile_RW.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFile")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLLoadFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] ref byte file, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t*")] ref nuint datasize)
		{
			fixed (byte* pfile = &file)
			{
				fixed (nuint* pdatasize = &datasize)
				{
					void* ret = SDLLoadFileNative((byte*)pfile, (ulong*)pdatasize);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load all the data from a file path.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// Prior to SDL 2.0.10, this function was a macro wrapping around<br/>
		/// SDL_LoadFile_RW.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFile")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLLoadFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> file, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t*")] ref nuint datasize)
		{
			fixed (byte* pfile = file)
			{
				fixed (nuint* pdatasize = &datasize)
				{
					void* ret = SDLLoadFileNative((byte*)pfile, (ulong*)pdatasize);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load all the data from a file path.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// Prior to SDL 2.0.10, this function was a macro wrapping around<br/>
		/// SDL_LoadFile_RW.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFile")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLLoadFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] string file, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t*")] ref nuint datasize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (nuint* pdatasize = &datasize)
			{
				void* ret = SDLLoadFileNative(pStr0, (ulong*)pdatasize);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read a byte from an SDL_RWops.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadU8")]
		[return: NativeName(NativeNameType.Type, "Uint8")]
		internal static byte SDLReadU8Native([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, byte>)vt[198])(src);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)vt[198])((nint)src);
			#endif
		}

		/// <summary>
		/// Use this function to read a byte from an SDL_RWops.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadU8")]
		[return: NativeName(NativeNameType.Type, "Uint8")]
		public static byte SDLReadU8([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			byte ret = SDLReadU8Native(src);
			return ret;
		}

		/// <summary>
		/// Use this function to read a byte from an SDL_RWops.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadU8")]
		[return: NativeName(NativeNameType.Type, "Uint8")]
		public static byte SDLReadU8([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				byte ret = SDLReadU8Native((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read 16 bits of little-endian data from an SDL_RWops<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadLE16")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		internal static ushort SDLReadLE16Native([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, ushort>)vt[199])(src);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<nint, ushort>)vt[199])((nint)src);
			#endif
		}

		/// <summary>
		/// Use this function to read 16 bits of little-endian data from an SDL_RWops<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadLE16")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort SDLReadLE16([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			ushort ret = SDLReadLE16Native(src);
			return ret;
		}

		/// <summary>
		/// Use this function to read 16 bits of little-endian data from an SDL_RWops<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadLE16")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort SDLReadLE16([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				ushort ret = SDLReadLE16Native((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read 16 bits of big-endian data from an SDL_RWops and<br/>
		/// return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadBE16")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		internal static ushort SDLReadBE16Native([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, ushort>)vt[200])(src);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<nint, ushort>)vt[200])((nint)src);
			#endif
		}

		/// <summary>
		/// Use this function to read 16 bits of big-endian data from an SDL_RWops and<br/>
		/// return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadBE16")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort SDLReadBE16([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			ushort ret = SDLReadBE16Native(src);
			return ret;
		}

		/// <summary>
		/// Use this function to read 16 bits of big-endian data from an SDL_RWops and<br/>
		/// return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadBE16")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort SDLReadBE16([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				ushort ret = SDLReadBE16Native((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read 32 bits of little-endian data from an SDL_RWops<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadLE32")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		internal static uint SDLReadLE32Native([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, uint>)vt[201])(src);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)vt[201])((nint)src);
			#endif
		}

		/// <summary>
		/// Use this function to read 32 bits of little-endian data from an SDL_RWops<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadLE32")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLReadLE32([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			uint ret = SDLReadLE32Native(src);
			return ret;
		}

		/// <summary>
		/// Use this function to read 32 bits of little-endian data from an SDL_RWops<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadLE32")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLReadLE32([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				uint ret = SDLReadLE32Native((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read 32 bits of big-endian data from an SDL_RWops and<br/>
		/// return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadBE32")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		internal static uint SDLReadBE32Native([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, uint>)vt[202])(src);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)vt[202])((nint)src);
			#endif
		}

		/// <summary>
		/// Use this function to read 32 bits of big-endian data from an SDL_RWops and<br/>
		/// return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadBE32")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLReadBE32([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			uint ret = SDLReadBE32Native(src);
			return ret;
		}

		/// <summary>
		/// Use this function to read 32 bits of big-endian data from an SDL_RWops and<br/>
		/// return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadBE32")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLReadBE32([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				uint ret = SDLReadBE32Native((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read 64 bits of little-endian data from an SDL_RWops<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadLE64")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		internal static ulong SDLReadLE64Native([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, ulong>)vt[203])(src);
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<nint, ulong>)vt[203])((nint)src);
			#endif
		}

		/// <summary>
		/// Use this function to read 64 bits of little-endian data from an SDL_RWops<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadLE64")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		public static ulong SDLReadLE64([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			ulong ret = SDLReadLE64Native(src);
			return ret;
		}

		/// <summary>
		/// Use this function to read 64 bits of little-endian data from an SDL_RWops<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadLE64")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		public static ulong SDLReadLE64([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				ulong ret = SDLReadLE64Native((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read 64 bits of big-endian data from an SDL_RWops and<br/>
		/// return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadBE64")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		internal static ulong SDLReadBE64Native([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, ulong>)vt[204])(src);
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<nint, ulong>)vt[204])((nint)src);
			#endif
		}

		/// <summary>
		/// Use this function to read 64 bits of big-endian data from an SDL_RWops and<br/>
		/// return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadBE64")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		public static ulong SDLReadBE64([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			ulong ret = SDLReadBE64Native(src);
			return ret;
		}

		/// <summary>
		/// Use this function to read 64 bits of big-endian data from an SDL_RWops and<br/>
		/// return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadBE64")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		public static ulong SDLReadBE64([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				ulong ret = SDLReadBE64Native((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to write a byte to an SDL_RWops.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteU8")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		internal static ulong SDLWriteU8Native([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint8")] byte value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, byte, ulong>)vt[205])(dst, value);
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<nint, byte, ulong>)vt[205])((nint)dst, value);
			#endif
		}

		/// <summary>
		/// Use this function to write a byte to an SDL_RWops.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteU8")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLWriteU8([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint8")] byte value)
		{
			ulong ret = SDLWriteU8Native(dst, value);
			return ret;
		}

		/// <summary>
		/// Use this function to write a byte to an SDL_RWops.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteU8")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLWriteU8([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint8")] byte value)
		{
			fixed (SDLRWops* pdst = &dst)
			{
				ulong ret = SDLWriteU8Native((SDLRWops*)pdst, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to write 16 bits in native format to a SDL_RWops as<br/>
		/// little-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in little-endian<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteLE16")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		internal static ulong SDLWriteLE16Native([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint16")] ushort value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, ushort, ulong>)vt[206])(dst, value);
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<nint, ushort, ulong>)vt[206])((nint)dst, value);
			#endif
		}

		/// <summary>
		/// Use this function to write 16 bits in native format to a SDL_RWops as<br/>
		/// little-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in little-endian<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteLE16")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLWriteLE16([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint16")] ushort value)
		{
			ulong ret = SDLWriteLE16Native(dst, value);
			return ret;
		}

		/// <summary>
		/// Use this function to write 16 bits in native format to a SDL_RWops as<br/>
		/// little-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in little-endian<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteLE16")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLWriteLE16([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint16")] ushort value)
		{
			fixed (SDLRWops* pdst = &dst)
			{
				ulong ret = SDLWriteLE16Native((SDLRWops*)pdst, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to write 16 bits in native format to a SDL_RWops as<br/>
		/// big-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in big-endian format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteBE16")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		internal static ulong SDLWriteBE16Native([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint16")] ushort value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, ushort, ulong>)vt[207])(dst, value);
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<nint, ushort, ulong>)vt[207])((nint)dst, value);
			#endif
		}

		/// <summary>
		/// Use this function to write 16 bits in native format to a SDL_RWops as<br/>
		/// big-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in big-endian format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteBE16")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLWriteBE16([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint16")] ushort value)
		{
			ulong ret = SDLWriteBE16Native(dst, value);
			return ret;
		}

		/// <summary>
		/// Use this function to write 16 bits in native format to a SDL_RWops as<br/>
		/// big-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in big-endian format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteBE16")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLWriteBE16([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint16")] ushort value)
		{
			fixed (SDLRWops* pdst = &dst)
			{
				ulong ret = SDLWriteBE16Native((SDLRWops*)pdst, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to write 32 bits in native format to a SDL_RWops as<br/>
		/// little-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in little-endian<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteLE32")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		internal static ulong SDLWriteLE32Native([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint32")] uint value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, uint, ulong>)vt[208])(dst, value);
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<nint, uint, ulong>)vt[208])((nint)dst, value);
			#endif
		}

		/// <summary>
		/// Use this function to write 32 bits in native format to a SDL_RWops as<br/>
		/// little-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in little-endian<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteLE32")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLWriteLE32([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint32")] uint value)
		{
			ulong ret = SDLWriteLE32Native(dst, value);
			return ret;
		}

		/// <summary>
		/// Use this function to write 32 bits in native format to a SDL_RWops as<br/>
		/// little-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in little-endian<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteLE32")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLWriteLE32([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint32")] uint value)
		{
			fixed (SDLRWops* pdst = &dst)
			{
				ulong ret = SDLWriteLE32Native((SDLRWops*)pdst, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to write 32 bits in native format to a SDL_RWops as<br/>
		/// big-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in big-endian format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteBE32")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		internal static ulong SDLWriteBE32Native([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint32")] uint value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, uint, ulong>)vt[209])(dst, value);
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<nint, uint, ulong>)vt[209])((nint)dst, value);
			#endif
		}

		/// <summary>
		/// Use this function to write 32 bits in native format to a SDL_RWops as<br/>
		/// big-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in big-endian format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteBE32")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLWriteBE32([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint32")] uint value)
		{
			ulong ret = SDLWriteBE32Native(dst, value);
			return ret;
		}

		/// <summary>
		/// Use this function to write 32 bits in native format to a SDL_RWops as<br/>
		/// big-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in big-endian format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteBE32")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLWriteBE32([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint32")] uint value)
		{
			fixed (SDLRWops* pdst = &dst)
			{
				ulong ret = SDLWriteBE32Native((SDLRWops*)pdst, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to write 64 bits in native format to a SDL_RWops as<br/>
		/// little-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in little-endian<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteLE64")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		internal static ulong SDLWriteLE64Native([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint64")] ulong value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, ulong, ulong>)vt[210])(dst, value);
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<nint, ulong, ulong>)vt[210])((nint)dst, value);
			#endif
		}

		/// <summary>
		/// Use this function to write 64 bits in native format to a SDL_RWops as<br/>
		/// little-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in little-endian<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteLE64")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLWriteLE64([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint64")] ulong value)
		{
			ulong ret = SDLWriteLE64Native(dst, value);
			return ret;
		}

		/// <summary>
		/// Use this function to write 64 bits in native format to a SDL_RWops as<br/>
		/// little-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in little-endian<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteLE64")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLWriteLE64([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint64")] ulong value)
		{
			fixed (SDLRWops* pdst = &dst)
			{
				ulong ret = SDLWriteLE64Native((SDLRWops*)pdst, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to write 64 bits in native format to a SDL_RWops as<br/>
		/// big-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in big-endian format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteBE64")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		internal static ulong SDLWriteBE64Native([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint64")] ulong value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, ulong, ulong>)vt[211])(dst, value);
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<nint, ulong, ulong>)vt[211])((nint)dst, value);
			#endif
		}

		/// <summary>
		/// Use this function to write 64 bits in native format to a SDL_RWops as<br/>
		/// big-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in big-endian format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteBE64")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLWriteBE64([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint64")] ulong value)
		{
			ulong ret = SDLWriteBE64Native(dst, value);
			return ret;
		}

		/// <summary>
		/// Use this function to write 64 bits in native format to a SDL_RWops as<br/>
		/// big-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in big-endian format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteBE64")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static ulong SDLWriteBE64([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint64")] ulong value)
		{
			fixed (SDLRWops* pdst = &dst)
			{
				ulong ret = SDLWriteBE64Native((SDLRWops*)pdst, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to get the number of built-in audio drivers.<br/>
		/// This function returns a hardcoded number. This never returns a negative<br/>
		/// value; if there are no drivers compiled into this build of SDL, this<br/>
		/// function returns zero. The presence of a driver in this list does not mean<br/>
		/// it will function, it just means SDL is capable of interacting with that<br/>
		/// interface. For example, a build of SDL might have esound support, but if<br/>
		/// there's no esound server available, SDL's esound driver would fail if used.<br/>
		/// By default, SDL tries all drivers, in its preferred order, until one is<br/>
		/// found to be usable.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumAudioDrivers")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLGetNumAudioDriversNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)vt[212])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)vt[212])();
			#endif
		}

		/// <summary>
		/// Use this function to get the number of built-in audio drivers.<br/>
		/// This function returns a hardcoded number. This never returns a negative<br/>
		/// value; if there are no drivers compiled into this build of SDL, this<br/>
		/// function returns zero. The presence of a driver in this list does not mean<br/>
		/// it will function, it just means SDL is capable of interacting with that<br/>
		/// interface. For example, a build of SDL might have esound support, but if<br/>
		/// there's no esound server available, SDL's esound driver would fail if used.<br/>
		/// By default, SDL tries all drivers, in its preferred order, until one is<br/>
		/// found to be usable.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumAudioDrivers")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetNumAudioDrivers()
		{
			int ret = SDLGetNumAudioDriversNative();
			return ret;
		}

		/// <summary>
		/// Use this function to get the name of a built in audio driver.<br/>
		/// The list of audio drivers is given in the order that they are normally<br/>
		/// initialized by default; the drivers that seem more reasonable to choose<br/>
		/// first (as far as the SDL developers believe) are earlier in the list.<br/>
		/// The names of drivers are all simple, low-ASCII identifiers, like "alsa",<br/>
		/// "coreaudio" or "xaudio2". These never have Unicode characters, and are not<br/>
		/// meant to be proper names.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAudioDriver")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		internal static byte* SDLGetAudioDriverNative([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*>)vt[213])(index);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint>)vt[213])(index);
			#endif
		}

		/// <summary>
		/// Use this function to get the name of a built in audio driver.<br/>
		/// The list of audio drivers is given in the order that they are normally<br/>
		/// initialized by default; the drivers that seem more reasonable to choose<br/>
		/// first (as far as the SDL developers believe) are earlier in the list.<br/>
		/// The names of drivers are all simple, low-ASCII identifiers, like "alsa",<br/>
		/// "coreaudio" or "xaudio2". These never have Unicode characters, and are not<br/>
		/// meant to be proper names.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAudioDriver")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGetAudioDriver([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index)
		{
			byte* ret = SDLGetAudioDriverNative(index);
			return ret;
		}

		/// <summary>
		/// Use this function to get the name of a built in audio driver.<br/>
		/// The list of audio drivers is given in the order that they are normally<br/>
		/// initialized by default; the drivers that seem more reasonable to choose<br/>
		/// first (as far as the SDL developers believe) are earlier in the list.<br/>
		/// The names of drivers are all simple, low-ASCII identifiers, like "alsa",<br/>
		/// "coreaudio" or "xaudio2". These never have Unicode characters, and are not<br/>
		/// meant to be proper names.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAudioDriver")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGetAudioDriverS([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index)
		{
			string ret = Utils.DecodeStringUTF8(SDLGetAudioDriverNative(index));
			return ret;
		}

		/// <summary>
		/// Use this function to initialize a particular audio driver.<br/>
		/// This function is used internally, and should not be used unless you have a<br/>
		/// specific need to designate the audio driver you want to use. You should<br/>
		/// normally use SDL_Init() or SDL_InitSubSystem().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AudioInit")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLAudioInitNative([NativeName(NativeNameType.Param, "driver_name")] [NativeName(NativeNameType.Type, "const char*")] byte* driverName)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int>)vt[214])(driverName);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)vt[214])((nint)driverName);
			#endif
		}

		/// <summary>
		/// Use this function to initialize a particular audio driver.<br/>
		/// This function is used internally, and should not be used unless you have a<br/>
		/// specific need to designate the audio driver you want to use. You should<br/>
		/// normally use SDL_Init() or SDL_InitSubSystem().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AudioInit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLAudioInit([NativeName(NativeNameType.Param, "driver_name")] [NativeName(NativeNameType.Type, "const char*")] byte* driverName)
		{
			int ret = SDLAudioInitNative(driverName);
			return ret;
		}

		/// <summary>
		/// Use this function to initialize a particular audio driver.<br/>
		/// This function is used internally, and should not be used unless you have a<br/>
		/// specific need to designate the audio driver you want to use. You should<br/>
		/// normally use SDL_Init() or SDL_InitSubSystem().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AudioInit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLAudioInit([NativeName(NativeNameType.Param, "driver_name")] [NativeName(NativeNameType.Type, "const char*")] ref byte driverName)
		{
			fixed (byte* pdriverName = &driverName)
			{
				int ret = SDLAudioInitNative((byte*)pdriverName);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to initialize a particular audio driver.<br/>
		/// This function is used internally, and should not be used unless you have a<br/>
		/// specific need to designate the audio driver you want to use. You should<br/>
		/// normally use SDL_Init() or SDL_InitSubSystem().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AudioInit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLAudioInit([NativeName(NativeNameType.Param, "driver_name")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> driverName)
		{
			fixed (byte* pdriverName = driverName)
			{
				int ret = SDLAudioInitNative((byte*)pdriverName);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to initialize a particular audio driver.<br/>
		/// This function is used internally, and should not be used unless you have a<br/>
		/// specific need to designate the audio driver you want to use. You should<br/>
		/// normally use SDL_Init() or SDL_InitSubSystem().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AudioInit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLAudioInit([NativeName(NativeNameType.Param, "driver_name")] [NativeName(NativeNameType.Type, "const char*")] string driverName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (driverName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(driverName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(driverName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SDLAudioInitNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Use this function to shut down audio if you initialized it with<br/>
		/// SDL_AudioInit().<br/>
		/// This function is used internally, and should not be used unless you have a<br/>
		/// specific need to specify the audio driver you want to use. You should<br/>
		/// normally use SDL_Quit() or SDL_QuitSubSystem().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AudioQuit")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SDLAudioQuitNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[215])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[215])();
			#endif
		}

		/// <summary>
		/// Use this function to shut down audio if you initialized it with<br/>
		/// SDL_AudioInit().<br/>
		/// This function is used internally, and should not be used unless you have a<br/>
		/// specific need to specify the audio driver you want to use. You should<br/>
		/// normally use SDL_Quit() or SDL_QuitSubSystem().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AudioQuit")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLAudioQuit()
		{
			SDLAudioQuitNative();
		}

		/// <summary>
		/// Get the name of the current audio driver.<br/>
		/// The returned string points to internal static memory and thus never becomes<br/>
		/// invalid, even if you quit the audio subsystem and initialize a new driver<br/>
		/// (although such a case would return a different static string from another<br/>
		/// call to this function, of course). As such, you should not modify or free<br/>
		/// the returned string.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCurrentAudioDriver")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		internal static byte* SDLGetCurrentAudioDriverNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*>)vt[216])();
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint>)vt[216])();
			#endif
		}

		/// <summary>
		/// Get the name of the current audio driver.<br/>
		/// The returned string points to internal static memory and thus never becomes<br/>
		/// invalid, even if you quit the audio subsystem and initialize a new driver<br/>
		/// (although such a case would return a different static string from another<br/>
		/// call to this function, of course). As such, you should not modify or free<br/>
		/// the returned string.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCurrentAudioDriver")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGetCurrentAudioDriver()
		{
			byte* ret = SDLGetCurrentAudioDriverNative();
			return ret;
		}

		/// <summary>
		/// Get the name of the current audio driver.<br/>
		/// The returned string points to internal static memory and thus never becomes<br/>
		/// invalid, even if you quit the audio subsystem and initialize a new driver<br/>
		/// (although such a case would return a different static string from another<br/>
		/// call to this function, of course). As such, you should not modify or free<br/>
		/// the returned string.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCurrentAudioDriver")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGetCurrentAudioDriverS()
		{
			string ret = Utils.DecodeStringUTF8(SDLGetCurrentAudioDriverNative());
			return ret;
		}

		/// <summary>
		/// This function is a legacy means of opening the audio device.<br/>
		/// This function remains for compatibility with SDL 1.2, but also because it's<br/>
		/// slightly easier to use than the new functions in SDL 2.0. The new, more<br/>
		/// powerful, and preferred way to do this is SDL_OpenAudioDevice().<br/>
		/// This function is roughly equivalent to:<br/>
		/// ```c<br/>
		/// SDL_OpenAudioDevice(NULL, 0, desired, obtained, SDL_AUDIO_ALLOW_ANY_CHANGE);<br/>
		/// ```<br/>
		/// With two notable exceptions:<br/>
		/// - If `obtained` is NULL, we use `desired` (and allow no changes), which<br/>
		/// means desired will be modified to have the correct values for silence,<br/>
		/// etc, and SDL will convert any differences between your app's specific<br/>
		/// request and the hardware behind the scenes.<br/>
		/// - The return value is always success or failure, and not a device ID, which<br/>
		/// means you can only have one device open at a time with this function.<br/>
		/// <br/>
		/// If `obtained` is NULL, the audio data passed to the callback<br/>
		/// function will be guaranteed to be in the requested format, and<br/>
		/// will be automatically converted to the actual hardware audio<br/>
		/// format if necessary. If `obtained` is NULL, `desired` will have<br/>
		/// fields modified.<br/>
		/// This function returns a negative error code on failure to open the<br/>
		/// audio device or failure to set up the audio thread; call<br/>
		/// SDL_GetError() for more information.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenAudio")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLOpenAudioNative([NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* obtained)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAudioSpec*, SDLAudioSpec*, int>)vt[217])(desired, obtained);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)vt[217])((nint)desired, (nint)obtained);
			#endif
		}

		/// <summary>
		/// This function is a legacy means of opening the audio device.<br/>
		/// This function remains for compatibility with SDL 1.2, but also because it's<br/>
		/// slightly easier to use than the new functions in SDL 2.0. The new, more<br/>
		/// powerful, and preferred way to do this is SDL_OpenAudioDevice().<br/>
		/// This function is roughly equivalent to:<br/>
		/// ```c<br/>
		/// SDL_OpenAudioDevice(NULL, 0, desired, obtained, SDL_AUDIO_ALLOW_ANY_CHANGE);<br/>
		/// ```<br/>
		/// With two notable exceptions:<br/>
		/// - If `obtained` is NULL, we use `desired` (and allow no changes), which<br/>
		/// means desired will be modified to have the correct values for silence,<br/>
		/// etc, and SDL will convert any differences between your app's specific<br/>
		/// request and the hardware behind the scenes.<br/>
		/// - The return value is always success or failure, and not a device ID, which<br/>
		/// means you can only have one device open at a time with this function.<br/>
		/// <br/>
		/// If `obtained` is NULL, the audio data passed to the callback<br/>
		/// function will be guaranteed to be in the requested format, and<br/>
		/// will be automatically converted to the actual hardware audio<br/>
		/// format if necessary. If `obtained` is NULL, `desired` will have<br/>
		/// fields modified.<br/>
		/// This function returns a negative error code on failure to open the<br/>
		/// audio device or failure to set up the audio thread; call<br/>
		/// SDL_GetError() for more information.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenAudio")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLOpenAudio([NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* obtained)
		{
			int ret = SDLOpenAudioNative(desired, obtained);
			return ret;
		}

		/// <summary>
		/// This function is a legacy means of opening the audio device.<br/>
		/// This function remains for compatibility with SDL 1.2, but also because it's<br/>
		/// slightly easier to use than the new functions in SDL 2.0. The new, more<br/>
		/// powerful, and preferred way to do this is SDL_OpenAudioDevice().<br/>
		/// This function is roughly equivalent to:<br/>
		/// ```c<br/>
		/// SDL_OpenAudioDevice(NULL, 0, desired, obtained, SDL_AUDIO_ALLOW_ANY_CHANGE);<br/>
		/// ```<br/>
		/// With two notable exceptions:<br/>
		/// - If `obtained` is NULL, we use `desired` (and allow no changes), which<br/>
		/// means desired will be modified to have the correct values for silence,<br/>
		/// etc, and SDL will convert any differences between your app's specific<br/>
		/// request and the hardware behind the scenes.<br/>
		/// - The return value is always success or failure, and not a device ID, which<br/>
		/// means you can only have one device open at a time with this function.<br/>
		/// <br/>
		/// If `obtained` is NULL, the audio data passed to the callback<br/>
		/// function will be guaranteed to be in the requested format, and<br/>
		/// will be automatically converted to the actual hardware audio<br/>
		/// format if necessary. If `obtained` is NULL, `desired` will have<br/>
		/// fields modified.<br/>
		/// This function returns a negative error code on failure to open the<br/>
		/// audio device or failure to set up the audio thread; call<br/>
		/// SDL_GetError() for more information.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenAudio")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLOpenAudio([NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* obtained)
		{
			fixed (SDLAudioSpec* pdesired = &desired)
			{
				int ret = SDLOpenAudioNative((SDLAudioSpec*)pdesired, obtained);
				return ret;
			}
		}

		/// <summary>
		/// This function is a legacy means of opening the audio device.<br/>
		/// This function remains for compatibility with SDL 1.2, but also because it's<br/>
		/// slightly easier to use than the new functions in SDL 2.0. The new, more<br/>
		/// powerful, and preferred way to do this is SDL_OpenAudioDevice().<br/>
		/// This function is roughly equivalent to:<br/>
		/// ```c<br/>
		/// SDL_OpenAudioDevice(NULL, 0, desired, obtained, SDL_AUDIO_ALLOW_ANY_CHANGE);<br/>
		/// ```<br/>
		/// With two notable exceptions:<br/>
		/// - If `obtained` is NULL, we use `desired` (and allow no changes), which<br/>
		/// means desired will be modified to have the correct values for silence,<br/>
		/// etc, and SDL will convert any differences between your app's specific<br/>
		/// request and the hardware behind the scenes.<br/>
		/// - The return value is always success or failure, and not a device ID, which<br/>
		/// means you can only have one device open at a time with this function.<br/>
		/// <br/>
		/// If `obtained` is NULL, the audio data passed to the callback<br/>
		/// function will be guaranteed to be in the requested format, and<br/>
		/// will be automatically converted to the actual hardware audio<br/>
		/// format if necessary. If `obtained` is NULL, `desired` will have<br/>
		/// fields modified.<br/>
		/// This function returns a negative error code on failure to open the<br/>
		/// audio device or failure to set up the audio thread; call<br/>
		/// SDL_GetError() for more information.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenAudio")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLOpenAudio([NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec obtained)
		{
			fixed (SDLAudioSpec* pobtained = &obtained)
			{
				int ret = SDLOpenAudioNative(desired, (SDLAudioSpec*)pobtained);
				return ret;
			}
		}

		/// <summary>
		/// This function is a legacy means of opening the audio device.<br/>
		/// This function remains for compatibility with SDL 1.2, but also because it's<br/>
		/// slightly easier to use than the new functions in SDL 2.0. The new, more<br/>
		/// powerful, and preferred way to do this is SDL_OpenAudioDevice().<br/>
		/// This function is roughly equivalent to:<br/>
		/// ```c<br/>
		/// SDL_OpenAudioDevice(NULL, 0, desired, obtained, SDL_AUDIO_ALLOW_ANY_CHANGE);<br/>
		/// ```<br/>
		/// With two notable exceptions:<br/>
		/// - If `obtained` is NULL, we use `desired` (and allow no changes), which<br/>
		/// means desired will be modified to have the correct values for silence,<br/>
		/// etc, and SDL will convert any differences between your app's specific<br/>
		/// request and the hardware behind the scenes.<br/>
		/// - The return value is always success or failure, and not a device ID, which<br/>
		/// means you can only have one device open at a time with this function.<br/>
		/// <br/>
		/// If `obtained` is NULL, the audio data passed to the callback<br/>
		/// function will be guaranteed to be in the requested format, and<br/>
		/// will be automatically converted to the actual hardware audio<br/>
		/// format if necessary. If `obtained` is NULL, `desired` will have<br/>
		/// fields modified.<br/>
		/// This function returns a negative error code on failure to open the<br/>
		/// audio device or failure to set up the audio thread; call<br/>
		/// SDL_GetError() for more information.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenAudio")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLOpenAudio([NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec obtained)
		{
			fixed (SDLAudioSpec* pdesired = &desired)
			{
				fixed (SDLAudioSpec* pobtained = &obtained)
				{
					int ret = SDLOpenAudioNative((SDLAudioSpec*)pdesired, (SDLAudioSpec*)pobtained);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the number of built-in audio devices.<br/>
		/// This function is only valid after successfully initializing the audio<br/>
		/// subsystem.<br/>
		/// Note that audio capture support is not implemented as of SDL 2.0.4, so the<br/>
		/// `iscapture` parameter is for future expansion and should always be zero for<br/>
		/// now.<br/>
		/// This function will return -1 if an explicit list of devices can't be<br/>
		/// determined. Returning -1 is not an error. For example, if SDL is set up to<br/>
		/// talk to a remote audio server, it can't list every one available on the<br/>
		/// Internet, but it will still allow a specific host to be specified in<br/>
		/// SDL_OpenAudioDevice().<br/>
		/// In many common cases, when this function returns a value <br/>
		/// <<br/>
		/// = 0, it can still<br/>
		/// successfully open the default device (NULL for first argument of<br/>
		/// SDL_OpenAudioDevice()).<br/>
		/// This function may trigger a complete redetect of available hardware. It<br/>
		/// should not be called for each iteration of a loop, but rather once at the<br/>
		/// start of a loop:<br/>
		/// ```c<br/>
		/// // Don't do this:<br/>
		/// for (int i = 0; i <br/>
		/// <<br/>
		/// SDL_GetNumAudioDevices(0); i++)<br/>
		/// // do this instead:<br/>
		/// const int count = SDL_GetNumAudioDevices(0);<br/>
		/// for (int i = 0; i <br/>
		/// <<br/>
		/// count; ++i) { do_something_here(); }<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumAudioDevices")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLGetNumAudioDevicesNative([NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)vt[218])(iscapture);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)vt[218])(iscapture);
			#endif
		}

		/// <summary>
		/// Get the number of built-in audio devices.<br/>
		/// This function is only valid after successfully initializing the audio<br/>
		/// subsystem.<br/>
		/// Note that audio capture support is not implemented as of SDL 2.0.4, so the<br/>
		/// `iscapture` parameter is for future expansion and should always be zero for<br/>
		/// now.<br/>
		/// This function will return -1 if an explicit list of devices can't be<br/>
		/// determined. Returning -1 is not an error. For example, if SDL is set up to<br/>
		/// talk to a remote audio server, it can't list every one available on the<br/>
		/// Internet, but it will still allow a specific host to be specified in<br/>
		/// SDL_OpenAudioDevice().<br/>
		/// In many common cases, when this function returns a value <br/>
		/// <<br/>
		/// = 0, it can still<br/>
		/// successfully open the default device (NULL for first argument of<br/>
		/// SDL_OpenAudioDevice()).<br/>
		/// This function may trigger a complete redetect of available hardware. It<br/>
		/// should not be called for each iteration of a loop, but rather once at the<br/>
		/// start of a loop:<br/>
		/// ```c<br/>
		/// // Don't do this:<br/>
		/// for (int i = 0; i <br/>
		/// <<br/>
		/// SDL_GetNumAudioDevices(0); i++)<br/>
		/// // do this instead:<br/>
		/// const int count = SDL_GetNumAudioDevices(0);<br/>
		/// for (int i = 0; i <br/>
		/// <<br/>
		/// count; ++i) { do_something_here(); }<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumAudioDevices")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetNumAudioDevices([NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture)
		{
			int ret = SDLGetNumAudioDevicesNative(iscapture);
			return ret;
		}

		/// <summary>
		/// Get the human-readable name of a specific audio device.<br/>
		/// This function is only valid after successfully initializing the audio<br/>
		/// subsystem. The values returned by this function reflect the latest call to<br/>
		/// SDL_GetNumAudioDevices(); re-call that function to redetect available<br/>
		/// hardware.<br/>
		/// The string returned by this function is UTF-8 encoded, read-only, and<br/>
		/// managed internally. You are not to free it. If you need to keep the string<br/>
		/// for any length of time, you should make your own copy of it, as it will be<br/>
		/// invalid next time any of several other SDL functions are called.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAudioDeviceName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		internal static byte* SDLGetAudioDeviceNameNative([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, byte*>)vt[219])(index, iscapture);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, int, nint>)vt[219])(index, iscapture);
			#endif
		}

		/// <summary>
		/// Get the human-readable name of a specific audio device.<br/>
		/// This function is only valid after successfully initializing the audio<br/>
		/// subsystem. The values returned by this function reflect the latest call to<br/>
		/// SDL_GetNumAudioDevices(); re-call that function to redetect available<br/>
		/// hardware.<br/>
		/// The string returned by this function is UTF-8 encoded, read-only, and<br/>
		/// managed internally. You are not to free it. If you need to keep the string<br/>
		/// for any length of time, you should make your own copy of it, as it will be<br/>
		/// invalid next time any of several other SDL functions are called.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAudioDeviceName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGetAudioDeviceName([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture)
		{
			byte* ret = SDLGetAudioDeviceNameNative(index, iscapture);
			return ret;
		}

		/// <summary>
		/// Get the human-readable name of a specific audio device.<br/>
		/// This function is only valid after successfully initializing the audio<br/>
		/// subsystem. The values returned by this function reflect the latest call to<br/>
		/// SDL_GetNumAudioDevices(); re-call that function to redetect available<br/>
		/// hardware.<br/>
		/// The string returned by this function is UTF-8 encoded, read-only, and<br/>
		/// managed internally. You are not to free it. If you need to keep the string<br/>
		/// for any length of time, you should make your own copy of it, as it will be<br/>
		/// invalid next time any of several other SDL functions are called.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAudioDeviceName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGetAudioDeviceNameS([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture)
		{
			string ret = Utils.DecodeStringUTF8(SDLGetAudioDeviceNameNative(index, iscapture));
			return ret;
		}

		/// <summary>
		/// Get the preferred audio format of a specific audio device.<br/>
		/// This function is only valid after a successfully initializing the audio<br/>
		/// subsystem. The values returned by this function reflect the latest call to<br/>
		/// SDL_GetNumAudioDevices(); re-call that function to redetect available<br/>
		/// hardware.<br/>
		/// `spec` will be filled with the sample rate, sample format, and channel<br/>
		/// count.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAudioDeviceSpec")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLGetAudioDeviceSpecNative([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* spec)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, SDLAudioSpec*, int>)vt[220])(index, iscapture, spec);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int, nint, int>)vt[220])(index, iscapture, (nint)spec);
			#endif
		}

		/// <summary>
		/// Get the preferred audio format of a specific audio device.<br/>
		/// This function is only valid after a successfully initializing the audio<br/>
		/// subsystem. The values returned by this function reflect the latest call to<br/>
		/// SDL_GetNumAudioDevices(); re-call that function to redetect available<br/>
		/// hardware.<br/>
		/// `spec` will be filled with the sample rate, sample format, and channel<br/>
		/// count.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAudioDeviceSpec")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetAudioDeviceSpec([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* spec)
		{
			int ret = SDLGetAudioDeviceSpecNative(index, iscapture, spec);
			return ret;
		}

		/// <summary>
		/// Get the preferred audio format of a specific audio device.<br/>
		/// This function is only valid after a successfully initializing the audio<br/>
		/// subsystem. The values returned by this function reflect the latest call to<br/>
		/// SDL_GetNumAudioDevices(); re-call that function to redetect available<br/>
		/// hardware.<br/>
		/// `spec` will be filled with the sample rate, sample format, and channel<br/>
		/// count.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAudioDeviceSpec")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetAudioDeviceSpec([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec spec)
		{
			fixed (SDLAudioSpec* pspec = &spec)
			{
				int ret = SDLGetAudioDeviceSpecNative(index, iscapture, (SDLAudioSpec*)pspec);
				return ret;
			}
		}

		/// <summary>
		/// Get the name and preferred format of the default audio device.<br/>
		/// Some (but not all!) platforms have an isolated mechanism to get information<br/>
		/// about the "default" device. This can actually be a completely different<br/>
		/// device that's not in the list you get from SDL_GetAudioDeviceSpec(). It can<br/>
		/// even be a network address! (This is discussed in SDL_OpenAudioDevice().)<br/>
		/// As a result, this call is not guaranteed to be performant, as it can query<br/>
		/// the sound server directly every time, unlike the other query functions. You<br/>
		/// should call this function sparingly!<br/>
		/// `spec` will be filled with the sample rate, sample format, and channel<br/>
		/// count, if a default device exists on the system. If `name` is provided,<br/>
		/// will be filled with either a dynamically-allocated UTF-8 string or NULL.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetDefaultAudioInfo")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLGetDefaultAudioInfoNative([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char**")] byte** name, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* spec, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte**, SDLAudioSpec*, int, int>)vt[221])(name, spec, iscapture);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int, int>)vt[221])((nint)name, (nint)spec, iscapture);
			#endif
		}

		/// <summary>
		/// Get the name and preferred format of the default audio device.<br/>
		/// Some (but not all!) platforms have an isolated mechanism to get information<br/>
		/// about the "default" device. This can actually be a completely different<br/>
		/// device that's not in the list you get from SDL_GetAudioDeviceSpec(). It can<br/>
		/// even be a network address! (This is discussed in SDL_OpenAudioDevice().)<br/>
		/// As a result, this call is not guaranteed to be performant, as it can query<br/>
		/// the sound server directly every time, unlike the other query functions. You<br/>
		/// should call this function sparingly!<br/>
		/// `spec` will be filled with the sample rate, sample format, and channel<br/>
		/// count, if a default device exists on the system. If `name` is provided,<br/>
		/// will be filled with either a dynamically-allocated UTF-8 string or NULL.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetDefaultAudioInfo")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetDefaultAudioInfo([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char**")] byte** name, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* spec, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture)
		{
			int ret = SDLGetDefaultAudioInfoNative(name, spec, iscapture);
			return ret;
		}

		/// <summary>
		/// Get the name and preferred format of the default audio device.<br/>
		/// Some (but not all!) platforms have an isolated mechanism to get information<br/>
		/// about the "default" device. This can actually be a completely different<br/>
		/// device that's not in the list you get from SDL_GetAudioDeviceSpec(). It can<br/>
		/// even be a network address! (This is discussed in SDL_OpenAudioDevice().)<br/>
		/// As a result, this call is not guaranteed to be performant, as it can query<br/>
		/// the sound server directly every time, unlike the other query functions. You<br/>
		/// should call this function sparingly!<br/>
		/// `spec` will be filled with the sample rate, sample format, and channel<br/>
		/// count, if a default device exists on the system. If `name` is provided,<br/>
		/// will be filled with either a dynamically-allocated UTF-8 string or NULL.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetDefaultAudioInfo")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetDefaultAudioInfo([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char**")] ref byte* name, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* spec, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture)
		{
			fixed (byte** pname = &name)
			{
				int ret = SDLGetDefaultAudioInfoNative((byte**)pname, spec, iscapture);
				return ret;
			}
		}

		/// <summary>
		/// Get the name and preferred format of the default audio device.<br/>
		/// Some (but not all!) platforms have an isolated mechanism to get information<br/>
		/// about the "default" device. This can actually be a completely different<br/>
		/// device that's not in the list you get from SDL_GetAudioDeviceSpec(). It can<br/>
		/// even be a network address! (This is discussed in SDL_OpenAudioDevice().)<br/>
		/// As a result, this call is not guaranteed to be performant, as it can query<br/>
		/// the sound server directly every time, unlike the other query functions. You<br/>
		/// should call this function sparingly!<br/>
		/// `spec` will be filled with the sample rate, sample format, and channel<br/>
		/// count, if a default device exists on the system. If `name` is provided,<br/>
		/// will be filled with either a dynamically-allocated UTF-8 string or NULL.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetDefaultAudioInfo")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetDefaultAudioInfo([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char**")] byte** name, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec spec, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture)
		{
			fixed (SDLAudioSpec* pspec = &spec)
			{
				int ret = SDLGetDefaultAudioInfoNative(name, (SDLAudioSpec*)pspec, iscapture);
				return ret;
			}
		}

		/// <summary>
		/// Get the name and preferred format of the default audio device.<br/>
		/// Some (but not all!) platforms have an isolated mechanism to get information<br/>
		/// about the "default" device. This can actually be a completely different<br/>
		/// device that's not in the list you get from SDL_GetAudioDeviceSpec(). It can<br/>
		/// even be a network address! (This is discussed in SDL_OpenAudioDevice().)<br/>
		/// As a result, this call is not guaranteed to be performant, as it can query<br/>
		/// the sound server directly every time, unlike the other query functions. You<br/>
		/// should call this function sparingly!<br/>
		/// `spec` will be filled with the sample rate, sample format, and channel<br/>
		/// count, if a default device exists on the system. If `name` is provided,<br/>
		/// will be filled with either a dynamically-allocated UTF-8 string or NULL.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetDefaultAudioInfo")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetDefaultAudioInfo([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char**")] ref byte* name, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec spec, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture)
		{
			fixed (byte** pname = &name)
			{
				fixed (SDLAudioSpec* pspec = &spec)
				{
					int ret = SDLGetDefaultAudioInfoNative((byte**)pname, (SDLAudioSpec*)pspec, iscapture);
					return ret;
				}
			}
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>
		/// this function will never return a 1 so as not to conflict with the legacy<br/>
		/// function.<br/>
		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>
		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>
		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>
		/// Passing in a `device` name of NULL requests the most reasonable default<br/>
		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>
		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>
		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>
		/// hostname/IP address for a remote audio server, or a filename in the<br/>
		/// diskaudio driver.<br/>
		/// An opened audio device starts out paused, and should be enabled for playing<br/>
		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>
		/// callback function to be called. Since the audio driver may modify the<br/>
		/// requested size of the audio buffer, you should allocate any local mixing<br/>
		/// buffers after you open the audio device.<br/>
		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>
		/// race conditions between your callback and other threads without fully<br/>
		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>
		/// callback, see SDL_AudioSpec.<br/>
		/// Managing the audio spec via 'desired' and 'obtained':<br/>
		/// When filling in the desired audio spec structure:<br/>
		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>
		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>
		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>
		/// frames_ (with stereo output, two samples--left and right--would make a<br/>
		/// single sample frame). This number should be a power of two, and may be<br/>
		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>
		/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>
		/// the application and CPU speed. Smaller values reduce latency, but can<br/>
		/// lead to underflow if the application is doing heavy processing and cannot<br/>
		/// fill the audio buffer in time. Note that the number of sample frames is<br/>
		/// directly related to time by the following formula: `ms =<br/>
		/// (sampleframes*1000)/freq`<br/>
		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->callback` should be set to a function that will be called when<br/>
		/// the audio device is ready for more data. It is passed a pointer to the<br/>
		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>
		/// usually runs in a separate thread, and so you should protect data<br/>
		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>
		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>
		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>
		/// more audio samples to be played (or for capture devices, call<br/>
		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>
		/// - `desired->userdata` is passed as the first parameter to your callback<br/>
		/// function. If you passed a NULL callback, this value is ignored.<br/>
		/// `allowed_changes` can have the following flags OR'd together:<br/>
		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>
		/// These flags specify how SDL should behave when a device cannot offer a<br/>
		/// specific feature. If the application requests a feature that the hardware<br/>
		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>
		/// For example, if you ask for float32 audio format, but the sound card only<br/>
		/// supports int16, SDL will set the hardware to int16. If you had set<br/>
		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>
		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>
		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>
		/// will keep the originally requested format in the `obtained` structure.<br/>
		/// The resulting audio specs, varying depending on hardware and on what<br/>
		/// changes were allowed, will then be written back to `obtained`.<br/>
		/// If your application can only handle one specific data format, pass a zero<br/>
		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>
		/// <br/>
		/// For compatibility with SDL 1.2, this will never return 1, since<br/>
		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenAudioDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID")]
		internal static uint SDLOpenAudioDeviceNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "const char*")] byte* device, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "const SDL_AudioSpec*")] SDLAudioSpec* desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* obtained, [NativeName(NativeNameType.Param, "allowed_changes")] [NativeName(NativeNameType.Type, "int")] int allowedChanges)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int, SDLAudioSpec*, SDLAudioSpec*, int, uint>)vt[222])(device, iscapture, desired, obtained, allowedChanges);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, int, nint, nint, int, uint>)vt[222])((nint)device, iscapture, (nint)desired, (nint)obtained, allowedChanges);
			#endif
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>
		/// this function will never return a 1 so as not to conflict with the legacy<br/>
		/// function.<br/>
		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>
		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>
		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>
		/// Passing in a `device` name of NULL requests the most reasonable default<br/>
		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>
		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>
		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>
		/// hostname/IP address for a remote audio server, or a filename in the<br/>
		/// diskaudio driver.<br/>
		/// An opened audio device starts out paused, and should be enabled for playing<br/>
		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>
		/// callback function to be called. Since the audio driver may modify the<br/>
		/// requested size of the audio buffer, you should allocate any local mixing<br/>
		/// buffers after you open the audio device.<br/>
		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>
		/// race conditions between your callback and other threads without fully<br/>
		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>
		/// callback, see SDL_AudioSpec.<br/>
		/// Managing the audio spec via 'desired' and 'obtained':<br/>
		/// When filling in the desired audio spec structure:<br/>
		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>
		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>
		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>
		/// frames_ (with stereo output, two samples--left and right--would make a<br/>
		/// single sample frame). This number should be a power of two, and may be<br/>
		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>
		/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>
		/// the application and CPU speed. Smaller values reduce latency, but can<br/>
		/// lead to underflow if the application is doing heavy processing and cannot<br/>
		/// fill the audio buffer in time. Note that the number of sample frames is<br/>
		/// directly related to time by the following formula: `ms =<br/>
		/// (sampleframes*1000)/freq`<br/>
		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->callback` should be set to a function that will be called when<br/>
		/// the audio device is ready for more data. It is passed a pointer to the<br/>
		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>
		/// usually runs in a separate thread, and so you should protect data<br/>
		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>
		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>
		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>
		/// more audio samples to be played (or for capture devices, call<br/>
		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>
		/// - `desired->userdata` is passed as the first parameter to your callback<br/>
		/// function. If you passed a NULL callback, this value is ignored.<br/>
		/// `allowed_changes` can have the following flags OR'd together:<br/>
		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>
		/// These flags specify how SDL should behave when a device cannot offer a<br/>
		/// specific feature. If the application requests a feature that the hardware<br/>
		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>
		/// For example, if you ask for float32 audio format, but the sound card only<br/>
		/// supports int16, SDL will set the hardware to int16. If you had set<br/>
		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>
		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>
		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>
		/// will keep the originally requested format in the `obtained` structure.<br/>
		/// The resulting audio specs, varying depending on hardware and on what<br/>
		/// changes were allowed, will then be written back to `obtained`.<br/>
		/// If your application can only handle one specific data format, pass a zero<br/>
		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>
		/// <br/>
		/// For compatibility with SDL 1.2, this will never return 1, since<br/>
		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenAudioDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID")]
		public static uint SDLOpenAudioDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "const char*")] byte* device, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "const SDL_AudioSpec*")] SDLAudioSpec* desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* obtained, [NativeName(NativeNameType.Param, "allowed_changes")] [NativeName(NativeNameType.Type, "int")] int allowedChanges)
		{
			uint ret = SDLOpenAudioDeviceNative(device, iscapture, desired, obtained, allowedChanges);
			return ret;
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>
		/// this function will never return a 1 so as not to conflict with the legacy<br/>
		/// function.<br/>
		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>
		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>
		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>
		/// Passing in a `device` name of NULL requests the most reasonable default<br/>
		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>
		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>
		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>
		/// hostname/IP address for a remote audio server, or a filename in the<br/>
		/// diskaudio driver.<br/>
		/// An opened audio device starts out paused, and should be enabled for playing<br/>
		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>
		/// callback function to be called. Since the audio driver may modify the<br/>
		/// requested size of the audio buffer, you should allocate any local mixing<br/>
		/// buffers after you open the audio device.<br/>
		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>
		/// race conditions between your callback and other threads without fully<br/>
		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>
		/// callback, see SDL_AudioSpec.<br/>
		/// Managing the audio spec via 'desired' and 'obtained':<br/>
		/// When filling in the desired audio spec structure:<br/>
		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>
		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>
		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>
		/// frames_ (with stereo output, two samples--left and right--would make a<br/>
		/// single sample frame). This number should be a power of two, and may be<br/>
		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>
		/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>
		/// the application and CPU speed. Smaller values reduce latency, but can<br/>
		/// lead to underflow if the application is doing heavy processing and cannot<br/>
		/// fill the audio buffer in time. Note that the number of sample frames is<br/>
		/// directly related to time by the following formula: `ms =<br/>
		/// (sampleframes*1000)/freq`<br/>
		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->callback` should be set to a function that will be called when<br/>
		/// the audio device is ready for more data. It is passed a pointer to the<br/>
		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>
		/// usually runs in a separate thread, and so you should protect data<br/>
		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>
		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>
		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>
		/// more audio samples to be played (or for capture devices, call<br/>
		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>
		/// - `desired->userdata` is passed as the first parameter to your callback<br/>
		/// function. If you passed a NULL callback, this value is ignored.<br/>
		/// `allowed_changes` can have the following flags OR'd together:<br/>
		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>
		/// These flags specify how SDL should behave when a device cannot offer a<br/>
		/// specific feature. If the application requests a feature that the hardware<br/>
		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>
		/// For example, if you ask for float32 audio format, but the sound card only<br/>
		/// supports int16, SDL will set the hardware to int16. If you had set<br/>
		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>
		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>
		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>
		/// will keep the originally requested format in the `obtained` structure.<br/>
		/// The resulting audio specs, varying depending on hardware and on what<br/>
		/// changes were allowed, will then be written back to `obtained`.<br/>
		/// If your application can only handle one specific data format, pass a zero<br/>
		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>
		/// <br/>
		/// For compatibility with SDL 1.2, this will never return 1, since<br/>
		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenAudioDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID")]
		public static uint SDLOpenAudioDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "const char*")] ref byte device, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "const SDL_AudioSpec*")] SDLAudioSpec* desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* obtained, [NativeName(NativeNameType.Param, "allowed_changes")] [NativeName(NativeNameType.Type, "int")] int allowedChanges)
		{
			fixed (byte* pdevice = &device)
			{
				uint ret = SDLOpenAudioDeviceNative((byte*)pdevice, iscapture, desired, obtained, allowedChanges);
				return ret;
			}
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>
		/// this function will never return a 1 so as not to conflict with the legacy<br/>
		/// function.<br/>
		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>
		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>
		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>
		/// Passing in a `device` name of NULL requests the most reasonable default<br/>
		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>
		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>
		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>
		/// hostname/IP address for a remote audio server, or a filename in the<br/>
		/// diskaudio driver.<br/>
		/// An opened audio device starts out paused, and should be enabled for playing<br/>
		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>
		/// callback function to be called. Since the audio driver may modify the<br/>
		/// requested size of the audio buffer, you should allocate any local mixing<br/>
		/// buffers after you open the audio device.<br/>
		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>
		/// race conditions between your callback and other threads without fully<br/>
		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>
		/// callback, see SDL_AudioSpec.<br/>
		/// Managing the audio spec via 'desired' and 'obtained':<br/>
		/// When filling in the desired audio spec structure:<br/>
		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>
		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>
		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>
		/// frames_ (with stereo output, two samples--left and right--would make a<br/>
		/// single sample frame). This number should be a power of two, and may be<br/>
		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>
		/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>
		/// the application and CPU speed. Smaller values reduce latency, but can<br/>
		/// lead to underflow if the application is doing heavy processing and cannot<br/>
		/// fill the audio buffer in time. Note that the number of sample frames is<br/>
		/// directly related to time by the following formula: `ms =<br/>
		/// (sampleframes*1000)/freq`<br/>
		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->callback` should be set to a function that will be called when<br/>
		/// the audio device is ready for more data. It is passed a pointer to the<br/>
		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>
		/// usually runs in a separate thread, and so you should protect data<br/>
		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>
		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>
		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>
		/// more audio samples to be played (or for capture devices, call<br/>
		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>
		/// - `desired->userdata` is passed as the first parameter to your callback<br/>
		/// function. If you passed a NULL callback, this value is ignored.<br/>
		/// `allowed_changes` can have the following flags OR'd together:<br/>
		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>
		/// These flags specify how SDL should behave when a device cannot offer a<br/>
		/// specific feature. If the application requests a feature that the hardware<br/>
		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>
		/// For example, if you ask for float32 audio format, but the sound card only<br/>
		/// supports int16, SDL will set the hardware to int16. If you had set<br/>
		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>
		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>
		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>
		/// will keep the originally requested format in the `obtained` structure.<br/>
		/// The resulting audio specs, varying depending on hardware and on what<br/>
		/// changes were allowed, will then be written back to `obtained`.<br/>
		/// If your application can only handle one specific data format, pass a zero<br/>
		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>
		/// <br/>
		/// For compatibility with SDL 1.2, this will never return 1, since<br/>
		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenAudioDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID")]
		public static uint SDLOpenAudioDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> device, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "const SDL_AudioSpec*")] SDLAudioSpec* desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* obtained, [NativeName(NativeNameType.Param, "allowed_changes")] [NativeName(NativeNameType.Type, "int")] int allowedChanges)
		{
			fixed (byte* pdevice = device)
			{
				uint ret = SDLOpenAudioDeviceNative((byte*)pdevice, iscapture, desired, obtained, allowedChanges);
				return ret;
			}
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>
		/// this function will never return a 1 so as not to conflict with the legacy<br/>
		/// function.<br/>
		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>
		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>
		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>
		/// Passing in a `device` name of NULL requests the most reasonable default<br/>
		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>
		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>
		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>
		/// hostname/IP address for a remote audio server, or a filename in the<br/>
		/// diskaudio driver.<br/>
		/// An opened audio device starts out paused, and should be enabled for playing<br/>
		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>
		/// callback function to be called. Since the audio driver may modify the<br/>
		/// requested size of the audio buffer, you should allocate any local mixing<br/>
		/// buffers after you open the audio device.<br/>
		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>
		/// race conditions between your callback and other threads without fully<br/>
		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>
		/// callback, see SDL_AudioSpec.<br/>
		/// Managing the audio spec via 'desired' and 'obtained':<br/>
		/// When filling in the desired audio spec structure:<br/>
		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>
		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>
		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>
		/// frames_ (with stereo output, two samples--left and right--would make a<br/>
		/// single sample frame). This number should be a power of two, and may be<br/>
		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>
		/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>
		/// the application and CPU speed. Smaller values reduce latency, but can<br/>
		/// lead to underflow if the application is doing heavy processing and cannot<br/>
		/// fill the audio buffer in time. Note that the number of sample frames is<br/>
		/// directly related to time by the following formula: `ms =<br/>
		/// (sampleframes*1000)/freq`<br/>
		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->callback` should be set to a function that will be called when<br/>
		/// the audio device is ready for more data. It is passed a pointer to the<br/>
		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>
		/// usually runs in a separate thread, and so you should protect data<br/>
		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>
		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>
		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>
		/// more audio samples to be played (or for capture devices, call<br/>
		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>
		/// - `desired->userdata` is passed as the first parameter to your callback<br/>
		/// function. If you passed a NULL callback, this value is ignored.<br/>
		/// `allowed_changes` can have the following flags OR'd together:<br/>
		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>
		/// These flags specify how SDL should behave when a device cannot offer a<br/>
		/// specific feature. If the application requests a feature that the hardware<br/>
		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>
		/// For example, if you ask for float32 audio format, but the sound card only<br/>
		/// supports int16, SDL will set the hardware to int16. If you had set<br/>
		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>
		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>
		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>
		/// will keep the originally requested format in the `obtained` structure.<br/>
		/// The resulting audio specs, varying depending on hardware and on what<br/>
		/// changes were allowed, will then be written back to `obtained`.<br/>
		/// If your application can only handle one specific data format, pass a zero<br/>
		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>
		/// <br/>
		/// For compatibility with SDL 1.2, this will never return 1, since<br/>
		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenAudioDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID")]
		public static uint SDLOpenAudioDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "const char*")] string device, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "const SDL_AudioSpec*")] SDLAudioSpec* desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* obtained, [NativeName(NativeNameType.Param, "allowed_changes")] [NativeName(NativeNameType.Type, "int")] int allowedChanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (device != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(device);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(device, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = SDLOpenAudioDeviceNative(pStr0, iscapture, desired, obtained, allowedChanges);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>
		/// this function will never return a 1 so as not to conflict with the legacy<br/>
		/// function.<br/>
		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>
		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>
		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>
		/// Passing in a `device` name of NULL requests the most reasonable default<br/>
		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>
		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>
		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>
		/// hostname/IP address for a remote audio server, or a filename in the<br/>
		/// diskaudio driver.<br/>
		/// An opened audio device starts out paused, and should be enabled for playing<br/>
		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>
		/// callback function to be called. Since the audio driver may modify the<br/>
		/// requested size of the audio buffer, you should allocate any local mixing<br/>
		/// buffers after you open the audio device.<br/>
		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>
		/// race conditions between your callback and other threads without fully<br/>
		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>
		/// callback, see SDL_AudioSpec.<br/>
		/// Managing the audio spec via 'desired' and 'obtained':<br/>
		/// When filling in the desired audio spec structure:<br/>
		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>
		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>
		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>
		/// frames_ (with stereo output, two samples--left and right--would make a<br/>
		/// single sample frame). This number should be a power of two, and may be<br/>
		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>
		/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>
		/// the application and CPU speed. Smaller values reduce latency, but can<br/>
		/// lead to underflow if the application is doing heavy processing and cannot<br/>
		/// fill the audio buffer in time. Note that the number of sample frames is<br/>
		/// directly related to time by the following formula: `ms =<br/>
		/// (sampleframes*1000)/freq`<br/>
		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->callback` should be set to a function that will be called when<br/>
		/// the audio device is ready for more data. It is passed a pointer to the<br/>
		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>
		/// usually runs in a separate thread, and so you should protect data<br/>
		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>
		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>
		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>
		/// more audio samples to be played (or for capture devices, call<br/>
		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>
		/// - `desired->userdata` is passed as the first parameter to your callback<br/>
		/// function. If you passed a NULL callback, this value is ignored.<br/>
		/// `allowed_changes` can have the following flags OR'd together:<br/>
		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>
		/// These flags specify how SDL should behave when a device cannot offer a<br/>
		/// specific feature. If the application requests a feature that the hardware<br/>
		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>
		/// For example, if you ask for float32 audio format, but the sound card only<br/>
		/// supports int16, SDL will set the hardware to int16. If you had set<br/>
		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>
		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>
		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>
		/// will keep the originally requested format in the `obtained` structure.<br/>
		/// The resulting audio specs, varying depending on hardware and on what<br/>
		/// changes were allowed, will then be written back to `obtained`.<br/>
		/// If your application can only handle one specific data format, pass a zero<br/>
		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>
		/// <br/>
		/// For compatibility with SDL 1.2, this will never return 1, since<br/>
		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenAudioDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID")]
		public static uint SDLOpenAudioDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "const char*")] byte* device, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "const SDL_AudioSpec*")] ref SDLAudioSpec desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* obtained, [NativeName(NativeNameType.Param, "allowed_changes")] [NativeName(NativeNameType.Type, "int")] int allowedChanges)
		{
			fixed (SDLAudioSpec* pdesired = &desired)
			{
				uint ret = SDLOpenAudioDeviceNative(device, iscapture, (SDLAudioSpec*)pdesired, obtained, allowedChanges);
				return ret;
			}
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>
		/// this function will never return a 1 so as not to conflict with the legacy<br/>
		/// function.<br/>
		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>
		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>
		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>
		/// Passing in a `device` name of NULL requests the most reasonable default<br/>
		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>
		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>
		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>
		/// hostname/IP address for a remote audio server, or a filename in the<br/>
		/// diskaudio driver.<br/>
		/// An opened audio device starts out paused, and should be enabled for playing<br/>
		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>
		/// callback function to be called. Since the audio driver may modify the<br/>
		/// requested size of the audio buffer, you should allocate any local mixing<br/>
		/// buffers after you open the audio device.<br/>
		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>
		/// race conditions between your callback and other threads without fully<br/>
		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>
		/// callback, see SDL_AudioSpec.<br/>
		/// Managing the audio spec via 'desired' and 'obtained':<br/>
		/// When filling in the desired audio spec structure:<br/>
		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>
		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>
		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>
		/// frames_ (with stereo output, two samples--left and right--would make a<br/>
		/// single sample frame). This number should be a power of two, and may be<br/>
		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>
		/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>
		/// the application and CPU speed. Smaller values reduce latency, but can<br/>
		/// lead to underflow if the application is doing heavy processing and cannot<br/>
		/// fill the audio buffer in time. Note that the number of sample frames is<br/>
		/// directly related to time by the following formula: `ms =<br/>
		/// (sampleframes*1000)/freq`<br/>
		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->callback` should be set to a function that will be called when<br/>
		/// the audio device is ready for more data. It is passed a pointer to the<br/>
		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>
		/// usually runs in a separate thread, and so you should protect data<br/>
		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>
		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>
		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>
		/// more audio samples to be played (or for capture devices, call<br/>
		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>
		/// - `desired->userdata` is passed as the first parameter to your callback<br/>
		/// function. If you passed a NULL callback, this value is ignored.<br/>
		/// `allowed_changes` can have the following flags OR'd together:<br/>
		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>
		/// These flags specify how SDL should behave when a device cannot offer a<br/>
		/// specific feature. If the application requests a feature that the hardware<br/>
		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>
		/// For example, if you ask for float32 audio format, but the sound card only<br/>
		/// supports int16, SDL will set the hardware to int16. If you had set<br/>
		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>
		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>
		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>
		/// will keep the originally requested format in the `obtained` structure.<br/>
		/// The resulting audio specs, varying depending on hardware and on what<br/>
		/// changes were allowed, will then be written back to `obtained`.<br/>
		/// If your application can only handle one specific data format, pass a zero<br/>
		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>
		/// <br/>
		/// For compatibility with SDL 1.2, this will never return 1, since<br/>
		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenAudioDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID")]
		public static uint SDLOpenAudioDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "const char*")] ref byte device, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "const SDL_AudioSpec*")] ref SDLAudioSpec desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* obtained, [NativeName(NativeNameType.Param, "allowed_changes")] [NativeName(NativeNameType.Type, "int")] int allowedChanges)
		{
			fixed (byte* pdevice = &device)
			{
				fixed (SDLAudioSpec* pdesired = &desired)
				{
					uint ret = SDLOpenAudioDeviceNative((byte*)pdevice, iscapture, (SDLAudioSpec*)pdesired, obtained, allowedChanges);
					return ret;
				}
			}
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>
		/// this function will never return a 1 so as not to conflict with the legacy<br/>
		/// function.<br/>
		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>
		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>
		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>
		/// Passing in a `device` name of NULL requests the most reasonable default<br/>
		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>
		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>
		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>
		/// hostname/IP address for a remote audio server, or a filename in the<br/>
		/// diskaudio driver.<br/>
		/// An opened audio device starts out paused, and should be enabled for playing<br/>
		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>
		/// callback function to be called. Since the audio driver may modify the<br/>
		/// requested size of the audio buffer, you should allocate any local mixing<br/>
		/// buffers after you open the audio device.<br/>
		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>
		/// race conditions between your callback and other threads without fully<br/>
		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>
		/// callback, see SDL_AudioSpec.<br/>
		/// Managing the audio spec via 'desired' and 'obtained':<br/>
		/// When filling in the desired audio spec structure:<br/>
		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>
		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>
		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>
		/// frames_ (with stereo output, two samples--left and right--would make a<br/>
		/// single sample frame). This number should be a power of two, and may be<br/>
		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>
		/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>
		/// the application and CPU speed. Smaller values reduce latency, but can<br/>
		/// lead to underflow if the application is doing heavy processing and cannot<br/>
		/// fill the audio buffer in time. Note that the number of sample frames is<br/>
		/// directly related to time by the following formula: `ms =<br/>
		/// (sampleframes*1000)/freq`<br/>
		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->callback` should be set to a function that will be called when<br/>
		/// the audio device is ready for more data. It is passed a pointer to the<br/>
		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>
		/// usually runs in a separate thread, and so you should protect data<br/>
		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>
		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>
		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>
		/// more audio samples to be played (or for capture devices, call<br/>
		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>
		/// - `desired->userdata` is passed as the first parameter to your callback<br/>
		/// function. If you passed a NULL callback, this value is ignored.<br/>
		/// `allowed_changes` can have the following flags OR'd together:<br/>
		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>
		/// These flags specify how SDL should behave when a device cannot offer a<br/>
		/// specific feature. If the application requests a feature that the hardware<br/>
		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>
		/// For example, if you ask for float32 audio format, but the sound card only<br/>
		/// supports int16, SDL will set the hardware to int16. If you had set<br/>
		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>
		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>
		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>
		/// will keep the originally requested format in the `obtained` structure.<br/>
		/// The resulting audio specs, varying depending on hardware and on what<br/>
		/// changes were allowed, will then be written back to `obtained`.<br/>
		/// If your application can only handle one specific data format, pass a zero<br/>
		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>
		/// <br/>
		/// For compatibility with SDL 1.2, this will never return 1, since<br/>
		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenAudioDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID")]
		public static uint SDLOpenAudioDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> device, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "const SDL_AudioSpec*")] ref SDLAudioSpec desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* obtained, [NativeName(NativeNameType.Param, "allowed_changes")] [NativeName(NativeNameType.Type, "int")] int allowedChanges)
		{
			fixed (byte* pdevice = device)
			{
				fixed (SDLAudioSpec* pdesired = &desired)
				{
					uint ret = SDLOpenAudioDeviceNative((byte*)pdevice, iscapture, (SDLAudioSpec*)pdesired, obtained, allowedChanges);
					return ret;
				}
			}
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>
		/// this function will never return a 1 so as not to conflict with the legacy<br/>
		/// function.<br/>
		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>
		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>
		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>
		/// Passing in a `device` name of NULL requests the most reasonable default<br/>
		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>
		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>
		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>
		/// hostname/IP address for a remote audio server, or a filename in the<br/>
		/// diskaudio driver.<br/>
		/// An opened audio device starts out paused, and should be enabled for playing<br/>
		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>
		/// callback function to be called. Since the audio driver may modify the<br/>
		/// requested size of the audio buffer, you should allocate any local mixing<br/>
		/// buffers after you open the audio device.<br/>
		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>
		/// race conditions between your callback and other threads without fully<br/>
		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>
		/// callback, see SDL_AudioSpec.<br/>
		/// Managing the audio spec via 'desired' and 'obtained':<br/>
		/// When filling in the desired audio spec structure:<br/>
		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>
		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>
		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>
		/// frames_ (with stereo output, two samples--left and right--would make a<br/>
		/// single sample frame). This number should be a power of two, and may be<br/>
		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>
		/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>
		/// the application and CPU speed. Smaller values reduce latency, but can<br/>
		/// lead to underflow if the application is doing heavy processing and cannot<br/>
		/// fill the audio buffer in time. Note that the number of sample frames is<br/>
		/// directly related to time by the following formula: `ms =<br/>
		/// (sampleframes*1000)/freq`<br/>
		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->callback` should be set to a function that will be called when<br/>
		/// the audio device is ready for more data. It is passed a pointer to the<br/>
		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>
		/// usually runs in a separate thread, and so you should protect data<br/>
		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>
		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>
		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>
		/// more audio samples to be played (or for capture devices, call<br/>
		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>
		/// - `desired->userdata` is passed as the first parameter to your callback<br/>
		/// function. If you passed a NULL callback, this value is ignored.<br/>
		/// `allowed_changes` can have the following flags OR'd together:<br/>
		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>
		/// These flags specify how SDL should behave when a device cannot offer a<br/>
		/// specific feature. If the application requests a feature that the hardware<br/>
		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>
		/// For example, if you ask for float32 audio format, but the sound card only<br/>
		/// supports int16, SDL will set the hardware to int16. If you had set<br/>
		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>
		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>
		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>
		/// will keep the originally requested format in the `obtained` structure.<br/>
		/// The resulting audio specs, varying depending on hardware and on what<br/>
		/// changes were allowed, will then be written back to `obtained`.<br/>
		/// If your application can only handle one specific data format, pass a zero<br/>
		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>
		/// <br/>
		/// For compatibility with SDL 1.2, this will never return 1, since<br/>
		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenAudioDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID")]
		public static uint SDLOpenAudioDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "const char*")] string device, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "const SDL_AudioSpec*")] ref SDLAudioSpec desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* obtained, [NativeName(NativeNameType.Param, "allowed_changes")] [NativeName(NativeNameType.Type, "int")] int allowedChanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (device != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(device);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(device, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (SDLAudioSpec* pdesired = &desired)
			{
				uint ret = SDLOpenAudioDeviceNative(pStr0, iscapture, (SDLAudioSpec*)pdesired, obtained, allowedChanges);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>
		/// this function will never return a 1 so as not to conflict with the legacy<br/>
		/// function.<br/>
		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>
		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>
		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>
		/// Passing in a `device` name of NULL requests the most reasonable default<br/>
		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>
		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>
		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>
		/// hostname/IP address for a remote audio server, or a filename in the<br/>
		/// diskaudio driver.<br/>
		/// An opened audio device starts out paused, and should be enabled for playing<br/>
		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>
		/// callback function to be called. Since the audio driver may modify the<br/>
		/// requested size of the audio buffer, you should allocate any local mixing<br/>
		/// buffers after you open the audio device.<br/>
		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>
		/// race conditions between your callback and other threads without fully<br/>
		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>
		/// callback, see SDL_AudioSpec.<br/>
		/// Managing the audio spec via 'desired' and 'obtained':<br/>
		/// When filling in the desired audio spec structure:<br/>
		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>
		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>
		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>
		/// frames_ (with stereo output, two samples--left and right--would make a<br/>
		/// single sample frame). This number should be a power of two, and may be<br/>
		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>
		/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>
		/// the application and CPU speed. Smaller values reduce latency, but can<br/>
		/// lead to underflow if the application is doing heavy processing and cannot<br/>
		/// fill the audio buffer in time. Note that the number of sample frames is<br/>
		/// directly related to time by the following formula: `ms =<br/>
		/// (sampleframes*1000)/freq`<br/>
		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->callback` should be set to a function that will be called when<br/>
		/// the audio device is ready for more data. It is passed a pointer to the<br/>
		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>
		/// usually runs in a separate thread, and so you should protect data<br/>
		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>
		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>
		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>
		/// more audio samples to be played (or for capture devices, call<br/>
		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>
		/// - `desired->userdata` is passed as the first parameter to your callback<br/>
		/// function. If you passed a NULL callback, this value is ignored.<br/>
		/// `allowed_changes` can have the following flags OR'd together:<br/>
		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>
		/// These flags specify how SDL should behave when a device cannot offer a<br/>
		/// specific feature. If the application requests a feature that the hardware<br/>
		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>
		/// For example, if you ask for float32 audio format, but the sound card only<br/>
		/// supports int16, SDL will set the hardware to int16. If you had set<br/>
		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>
		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>
		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>
		/// will keep the originally requested format in the `obtained` structure.<br/>
		/// The resulting audio specs, varying depending on hardware and on what<br/>
		/// changes were allowed, will then be written back to `obtained`.<br/>
		/// If your application can only handle one specific data format, pass a zero<br/>
		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>
		/// <br/>
		/// For compatibility with SDL 1.2, this will never return 1, since<br/>
		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenAudioDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID")]
		public static uint SDLOpenAudioDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "const char*")] byte* device, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "const SDL_AudioSpec*")] SDLAudioSpec* desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec obtained, [NativeName(NativeNameType.Param, "allowed_changes")] [NativeName(NativeNameType.Type, "int")] int allowedChanges)
		{
			fixed (SDLAudioSpec* pobtained = &obtained)
			{
				uint ret = SDLOpenAudioDeviceNative(device, iscapture, desired, (SDLAudioSpec*)pobtained, allowedChanges);
				return ret;
			}
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>
		/// this function will never return a 1 so as not to conflict with the legacy<br/>
		/// function.<br/>
		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>
		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>
		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>
		/// Passing in a `device` name of NULL requests the most reasonable default<br/>
		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>
		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>
		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>
		/// hostname/IP address for a remote audio server, or a filename in the<br/>
		/// diskaudio driver.<br/>
		/// An opened audio device starts out paused, and should be enabled for playing<br/>
		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>
		/// callback function to be called. Since the audio driver may modify the<br/>
		/// requested size of the audio buffer, you should allocate any local mixing<br/>
		/// buffers after you open the audio device.<br/>
		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>
		/// race conditions between your callback and other threads without fully<br/>
		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>
		/// callback, see SDL_AudioSpec.<br/>
		/// Managing the audio spec via 'desired' and 'obtained':<br/>
		/// When filling in the desired audio spec structure:<br/>
		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>
		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>
		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>
		/// frames_ (with stereo output, two samples--left and right--would make a<br/>
		/// single sample frame). This number should be a power of two, and may be<br/>
		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>
		/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>
		/// the application and CPU speed. Smaller values reduce latency, but can<br/>
		/// lead to underflow if the application is doing heavy processing and cannot<br/>
		/// fill the audio buffer in time. Note that the number of sample frames is<br/>
		/// directly related to time by the following formula: `ms =<br/>
		/// (sampleframes*1000)/freq`<br/>
		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->callback` should be set to a function that will be called when<br/>
		/// the audio device is ready for more data. It is passed a pointer to the<br/>
		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>
		/// usually runs in a separate thread, and so you should protect data<br/>
		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>
		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>
		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>
		/// more audio samples to be played (or for capture devices, call<br/>
		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>
		/// - `desired->userdata` is passed as the first parameter to your callback<br/>
		/// function. If you passed a NULL callback, this value is ignored.<br/>
		/// `allowed_changes` can have the following flags OR'd together:<br/>
		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>
		/// These flags specify how SDL should behave when a device cannot offer a<br/>
		/// specific feature. If the application requests a feature that the hardware<br/>
		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>
		/// For example, if you ask for float32 audio format, but the sound card only<br/>
		/// supports int16, SDL will set the hardware to int16. If you had set<br/>
		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>
		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>
		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>
		/// will keep the originally requested format in the `obtained` structure.<br/>
		/// The resulting audio specs, varying depending on hardware and on what<br/>
		/// changes were allowed, will then be written back to `obtained`.<br/>
		/// If your application can only handle one specific data format, pass a zero<br/>
		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>
		/// <br/>
		/// For compatibility with SDL 1.2, this will never return 1, since<br/>
		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenAudioDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID")]
		public static uint SDLOpenAudioDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "const char*")] ref byte device, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "const SDL_AudioSpec*")] SDLAudioSpec* desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec obtained, [NativeName(NativeNameType.Param, "allowed_changes")] [NativeName(NativeNameType.Type, "int")] int allowedChanges)
		{
			fixed (byte* pdevice = &device)
			{
				fixed (SDLAudioSpec* pobtained = &obtained)
				{
					uint ret = SDLOpenAudioDeviceNative((byte*)pdevice, iscapture, desired, (SDLAudioSpec*)pobtained, allowedChanges);
					return ret;
				}
			}
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>
		/// this function will never return a 1 so as not to conflict with the legacy<br/>
		/// function.<br/>
		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>
		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>
		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>
		/// Passing in a `device` name of NULL requests the most reasonable default<br/>
		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>
		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>
		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>
		/// hostname/IP address for a remote audio server, or a filename in the<br/>
		/// diskaudio driver.<br/>
		/// An opened audio device starts out paused, and should be enabled for playing<br/>
		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>
		/// callback function to be called. Since the audio driver may modify the<br/>
		/// requested size of the audio buffer, you should allocate any local mixing<br/>
		/// buffers after you open the audio device.<br/>
		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>
		/// race conditions between your callback and other threads without fully<br/>
		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>
		/// callback, see SDL_AudioSpec.<br/>
		/// Managing the audio spec via 'desired' and 'obtained':<br/>
		/// When filling in the desired audio spec structure:<br/>
		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>
		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>
		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>
		/// frames_ (with stereo output, two samples--left and right--would make a<br/>
		/// single sample frame). This number should be a power of two, and may be<br/>
		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>
		/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>
		/// the application and CPU speed. Smaller values reduce latency, but can<br/>
		/// lead to underflow if the application is doing heavy processing and cannot<br/>
		/// fill the audio buffer in time. Note that the number of sample frames is<br/>
		/// directly related to time by the following formula: `ms =<br/>
		/// (sampleframes*1000)/freq`<br/>
		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->callback` should be set to a function that will be called when<br/>
		/// the audio device is ready for more data. It is passed a pointer to the<br/>
		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>
		/// usually runs in a separate thread, and so you should protect data<br/>
		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>
		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>
		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>
		/// more audio samples to be played (or for capture devices, call<br/>
		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>
		/// - `desired->userdata` is passed as the first parameter to your callback<br/>
		/// function. If you passed a NULL callback, this value is ignored.<br/>
		/// `allowed_changes` can have the following flags OR'd together:<br/>
		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>
		/// These flags specify how SDL should behave when a device cannot offer a<br/>
		/// specific feature. If the application requests a feature that the hardware<br/>
		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>
		/// For example, if you ask for float32 audio format, but the sound card only<br/>
		/// supports int16, SDL will set the hardware to int16. If you had set<br/>
		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>
		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>
		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>
		/// will keep the originally requested format in the `obtained` structure.<br/>
		/// The resulting audio specs, varying depending on hardware and on what<br/>
		/// changes were allowed, will then be written back to `obtained`.<br/>
		/// If your application can only handle one specific data format, pass a zero<br/>
		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>
		/// <br/>
		/// For compatibility with SDL 1.2, this will never return 1, since<br/>
		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenAudioDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID")]
		public static uint SDLOpenAudioDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> device, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "const SDL_AudioSpec*")] SDLAudioSpec* desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec obtained, [NativeName(NativeNameType.Param, "allowed_changes")] [NativeName(NativeNameType.Type, "int")] int allowedChanges)
		{
			fixed (byte* pdevice = device)
			{
				fixed (SDLAudioSpec* pobtained = &obtained)
				{
					uint ret = SDLOpenAudioDeviceNative((byte*)pdevice, iscapture, desired, (SDLAudioSpec*)pobtained, allowedChanges);
					return ret;
				}
			}
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>
		/// this function will never return a 1 so as not to conflict with the legacy<br/>
		/// function.<br/>
		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>
		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>
		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>
		/// Passing in a `device` name of NULL requests the most reasonable default<br/>
		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>
		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>
		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>
		/// hostname/IP address for a remote audio server, or a filename in the<br/>
		/// diskaudio driver.<br/>
		/// An opened audio device starts out paused, and should be enabled for playing<br/>
		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>
		/// callback function to be called. Since the audio driver may modify the<br/>
		/// requested size of the audio buffer, you should allocate any local mixing<br/>
		/// buffers after you open the audio device.<br/>
		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>
		/// race conditions between your callback and other threads without fully<br/>
		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>
		/// callback, see SDL_AudioSpec.<br/>
		/// Managing the audio spec via 'desired' and 'obtained':<br/>
		/// When filling in the desired audio spec structure:<br/>
		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>
		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>
		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>
		/// frames_ (with stereo output, two samples--left and right--would make a<br/>
		/// single sample frame). This number should be a power of two, and may be<br/>
		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>
		/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>
		/// the application and CPU speed. Smaller values reduce latency, but can<br/>
		/// lead to underflow if the application is doing heavy processing and cannot<br/>
		/// fill the audio buffer in time. Note that the number of sample frames is<br/>
		/// directly related to time by the following formula: `ms =<br/>
		/// (sampleframes*1000)/freq`<br/>
		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->callback` should be set to a function that will be called when<br/>
		/// the audio device is ready for more data. It is passed a pointer to the<br/>
		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>
		/// usually runs in a separate thread, and so you should protect data<br/>
		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>
		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>
		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>
		/// more audio samples to be played (or for capture devices, call<br/>
		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>
		/// - `desired->userdata` is passed as the first parameter to your callback<br/>
		/// function. If you passed a NULL callback, this value is ignored.<br/>
		/// `allowed_changes` can have the following flags OR'd together:<br/>
		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>
		/// These flags specify how SDL should behave when a device cannot offer a<br/>
		/// specific feature. If the application requests a feature that the hardware<br/>
		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>
		/// For example, if you ask for float32 audio format, but the sound card only<br/>
		/// supports int16, SDL will set the hardware to int16. If you had set<br/>
		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>
		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>
		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>
		/// will keep the originally requested format in the `obtained` structure.<br/>
		/// The resulting audio specs, varying depending on hardware and on what<br/>
		/// changes were allowed, will then be written back to `obtained`.<br/>
		/// If your application can only handle one specific data format, pass a zero<br/>
		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>
		/// <br/>
		/// For compatibility with SDL 1.2, this will never return 1, since<br/>
		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenAudioDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID")]
		public static uint SDLOpenAudioDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "const char*")] string device, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "const SDL_AudioSpec*")] SDLAudioSpec* desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec obtained, [NativeName(NativeNameType.Param, "allowed_changes")] [NativeName(NativeNameType.Type, "int")] int allowedChanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (device != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(device);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(device, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (SDLAudioSpec* pobtained = &obtained)
			{
				uint ret = SDLOpenAudioDeviceNative(pStr0, iscapture, desired, (SDLAudioSpec*)pobtained, allowedChanges);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>
		/// this function will never return a 1 so as not to conflict with the legacy<br/>
		/// function.<br/>
		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>
		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>
		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>
		/// Passing in a `device` name of NULL requests the most reasonable default<br/>
		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>
		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>
		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>
		/// hostname/IP address for a remote audio server, or a filename in the<br/>
		/// diskaudio driver.<br/>
		/// An opened audio device starts out paused, and should be enabled for playing<br/>
		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>
		/// callback function to be called. Since the audio driver may modify the<br/>
		/// requested size of the audio buffer, you should allocate any local mixing<br/>
		/// buffers after you open the audio device.<br/>
		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>
		/// race conditions between your callback and other threads without fully<br/>
		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>
		/// callback, see SDL_AudioSpec.<br/>
		/// Managing the audio spec via 'desired' and 'obtained':<br/>
		/// When filling in the desired audio spec structure:<br/>
		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>
		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>
		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>
		/// frames_ (with stereo output, two samples--left and right--would make a<br/>
		/// single sample frame). This number should be a power of two, and may be<br/>
		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>
		/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>
		/// the application and CPU speed. Smaller values reduce latency, but can<br/>
		/// lead to underflow if the application is doing heavy processing and cannot<br/>
		/// fill the audio buffer in time. Note that the number of sample frames is<br/>
		/// directly related to time by the following formula: `ms =<br/>
		/// (sampleframes*1000)/freq`<br/>
		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->callback` should be set to a function that will be called when<br/>
		/// the audio device is ready for more data. It is passed a pointer to the<br/>
		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>
		/// usually runs in a separate thread, and so you should protect data<br/>
		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>
		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>
		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>
		/// more audio samples to be played (or for capture devices, call<br/>
		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>
		/// - `desired->userdata` is passed as the first parameter to your callback<br/>
		/// function. If you passed a NULL callback, this value is ignored.<br/>
		/// `allowed_changes` can have the following flags OR'd together:<br/>
		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>
		/// These flags specify how SDL should behave when a device cannot offer a<br/>
		/// specific feature. If the application requests a feature that the hardware<br/>
		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>
		/// For example, if you ask for float32 audio format, but the sound card only<br/>
		/// supports int16, SDL will set the hardware to int16. If you had set<br/>
		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>
		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>
		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>
		/// will keep the originally requested format in the `obtained` structure.<br/>
		/// The resulting audio specs, varying depending on hardware and on what<br/>
		/// changes were allowed, will then be written back to `obtained`.<br/>
		/// If your application can only handle one specific data format, pass a zero<br/>
		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>
		/// <br/>
		/// For compatibility with SDL 1.2, this will never return 1, since<br/>
		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenAudioDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID")]
		public static uint SDLOpenAudioDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "const char*")] byte* device, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "const SDL_AudioSpec*")] ref SDLAudioSpec desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec obtained, [NativeName(NativeNameType.Param, "allowed_changes")] [NativeName(NativeNameType.Type, "int")] int allowedChanges)
		{
			fixed (SDLAudioSpec* pdesired = &desired)
			{
				fixed (SDLAudioSpec* pobtained = &obtained)
				{
					uint ret = SDLOpenAudioDeviceNative(device, iscapture, (SDLAudioSpec*)pdesired, (SDLAudioSpec*)pobtained, allowedChanges);
					return ret;
				}
			}
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>
		/// this function will never return a 1 so as not to conflict with the legacy<br/>
		/// function.<br/>
		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>
		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>
		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>
		/// Passing in a `device` name of NULL requests the most reasonable default<br/>
		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>
		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>
		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>
		/// hostname/IP address for a remote audio server, or a filename in the<br/>
		/// diskaudio driver.<br/>
		/// An opened audio device starts out paused, and should be enabled for playing<br/>
		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>
		/// callback function to be called. Since the audio driver may modify the<br/>
		/// requested size of the audio buffer, you should allocate any local mixing<br/>
		/// buffers after you open the audio device.<br/>
		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>
		/// race conditions between your callback and other threads without fully<br/>
		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>
		/// callback, see SDL_AudioSpec.<br/>
		/// Managing the audio spec via 'desired' and 'obtained':<br/>
		/// When filling in the desired audio spec structure:<br/>
		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>
		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>
		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>
		/// frames_ (with stereo output, two samples--left and right--would make a<br/>
		/// single sample frame). This number should be a power of two, and may be<br/>
		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>
		/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>
		/// the application and CPU speed. Smaller values reduce latency, but can<br/>
		/// lead to underflow if the application is doing heavy processing and cannot<br/>
		/// fill the audio buffer in time. Note that the number of sample frames is<br/>
		/// directly related to time by the following formula: `ms =<br/>
		/// (sampleframes*1000)/freq`<br/>
		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->callback` should be set to a function that will be called when<br/>
		/// the audio device is ready for more data. It is passed a pointer to the<br/>
		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>
		/// usually runs in a separate thread, and so you should protect data<br/>
		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>
		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>
		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>
		/// more audio samples to be played (or for capture devices, call<br/>
		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>
		/// - `desired->userdata` is passed as the first parameter to your callback<br/>
		/// function. If you passed a NULL callback, this value is ignored.<br/>
		/// `allowed_changes` can have the following flags OR'd together:<br/>
		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>
		/// These flags specify how SDL should behave when a device cannot offer a<br/>
		/// specific feature. If the application requests a feature that the hardware<br/>
		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>
		/// For example, if you ask for float32 audio format, but the sound card only<br/>
		/// supports int16, SDL will set the hardware to int16. If you had set<br/>
		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>
		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>
		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>
		/// will keep the originally requested format in the `obtained` structure.<br/>
		/// The resulting audio specs, varying depending on hardware and on what<br/>
		/// changes were allowed, will then be written back to `obtained`.<br/>
		/// If your application can only handle one specific data format, pass a zero<br/>
		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>
		/// <br/>
		/// For compatibility with SDL 1.2, this will never return 1, since<br/>
		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenAudioDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID")]
		public static uint SDLOpenAudioDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "const char*")] ref byte device, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "const SDL_AudioSpec*")] ref SDLAudioSpec desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec obtained, [NativeName(NativeNameType.Param, "allowed_changes")] [NativeName(NativeNameType.Type, "int")] int allowedChanges)
		{
			fixed (byte* pdevice = &device)
			{
				fixed (SDLAudioSpec* pdesired = &desired)
				{
					fixed (SDLAudioSpec* pobtained = &obtained)
					{
						uint ret = SDLOpenAudioDeviceNative((byte*)pdevice, iscapture, (SDLAudioSpec*)pdesired, (SDLAudioSpec*)pobtained, allowedChanges);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>
		/// this function will never return a 1 so as not to conflict with the legacy<br/>
		/// function.<br/>
		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>
		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>
		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>
		/// Passing in a `device` name of NULL requests the most reasonable default<br/>
		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>
		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>
		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>
		/// hostname/IP address for a remote audio server, or a filename in the<br/>
		/// diskaudio driver.<br/>
		/// An opened audio device starts out paused, and should be enabled for playing<br/>
		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>
		/// callback function to be called. Since the audio driver may modify the<br/>
		/// requested size of the audio buffer, you should allocate any local mixing<br/>
		/// buffers after you open the audio device.<br/>
		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>
		/// race conditions between your callback and other threads without fully<br/>
		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>
		/// callback, see SDL_AudioSpec.<br/>
		/// Managing the audio spec via 'desired' and 'obtained':<br/>
		/// When filling in the desired audio spec structure:<br/>
		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>
		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>
		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>
		/// frames_ (with stereo output, two samples--left and right--would make a<br/>
		/// single sample frame). This number should be a power of two, and may be<br/>
		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>
		/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>
		/// the application and CPU speed. Smaller values reduce latency, but can<br/>
		/// lead to underflow if the application is doing heavy processing and cannot<br/>
		/// fill the audio buffer in time. Note that the number of sample frames is<br/>
		/// directly related to time by the following formula: `ms =<br/>
		/// (sampleframes*1000)/freq`<br/>
		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->callback` should be set to a function that will be called when<br/>
		/// the audio device is ready for more data. It is passed a pointer to the<br/>
		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>
		/// usually runs in a separate thread, and so you should protect data<br/>
		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>
		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>
		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>
		/// more audio samples to be played (or for capture devices, call<br/>
		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>
		/// - `desired->userdata` is passed as the first parameter to your callback<br/>
		/// function. If you passed a NULL callback, this value is ignored.<br/>
		/// `allowed_changes` can have the following flags OR'd together:<br/>
		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>
		/// These flags specify how SDL should behave when a device cannot offer a<br/>
		/// specific feature. If the application requests a feature that the hardware<br/>
		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>
		/// For example, if you ask for float32 audio format, but the sound card only<br/>
		/// supports int16, SDL will set the hardware to int16. If you had set<br/>
		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>
		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>
		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>
		/// will keep the originally requested format in the `obtained` structure.<br/>
		/// The resulting audio specs, varying depending on hardware and on what<br/>
		/// changes were allowed, will then be written back to `obtained`.<br/>
		/// If your application can only handle one specific data format, pass a zero<br/>
		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>
		/// <br/>
		/// For compatibility with SDL 1.2, this will never return 1, since<br/>
		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenAudioDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID")]
		public static uint SDLOpenAudioDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> device, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "const SDL_AudioSpec*")] ref SDLAudioSpec desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec obtained, [NativeName(NativeNameType.Param, "allowed_changes")] [NativeName(NativeNameType.Type, "int")] int allowedChanges)
		{
			fixed (byte* pdevice = device)
			{
				fixed (SDLAudioSpec* pdesired = &desired)
				{
					fixed (SDLAudioSpec* pobtained = &obtained)
					{
						uint ret = SDLOpenAudioDeviceNative((byte*)pdevice, iscapture, (SDLAudioSpec*)pdesired, (SDLAudioSpec*)pobtained, allowedChanges);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>
		/// this function will never return a 1 so as not to conflict with the legacy<br/>
		/// function.<br/>
		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>
		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>
		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>
		/// Passing in a `device` name of NULL requests the most reasonable default<br/>
		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>
		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>
		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>
		/// hostname/IP address for a remote audio server, or a filename in the<br/>
		/// diskaudio driver.<br/>
		/// An opened audio device starts out paused, and should be enabled for playing<br/>
		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>
		/// callback function to be called. Since the audio driver may modify the<br/>
		/// requested size of the audio buffer, you should allocate any local mixing<br/>
		/// buffers after you open the audio device.<br/>
		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>
		/// race conditions between your callback and other threads without fully<br/>
		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>
		/// callback, see SDL_AudioSpec.<br/>
		/// Managing the audio spec via 'desired' and 'obtained':<br/>
		/// When filling in the desired audio spec structure:<br/>
		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>
		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>
		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>
		/// frames_ (with stereo output, two samples--left and right--would make a<br/>
		/// single sample frame). This number should be a power of two, and may be<br/>
		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>
		/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>
		/// the application and CPU speed. Smaller values reduce latency, but can<br/>
		/// lead to underflow if the application is doing heavy processing and cannot<br/>
		/// fill the audio buffer in time. Note that the number of sample frames is<br/>
		/// directly related to time by the following formula: `ms =<br/>
		/// (sampleframes*1000)/freq`<br/>
		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->callback` should be set to a function that will be called when<br/>
		/// the audio device is ready for more data. It is passed a pointer to the<br/>
		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>
		/// usually runs in a separate thread, and so you should protect data<br/>
		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>
		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>
		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>
		/// more audio samples to be played (or for capture devices, call<br/>
		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>
		/// - `desired->userdata` is passed as the first parameter to your callback<br/>
		/// function. If you passed a NULL callback, this value is ignored.<br/>
		/// `allowed_changes` can have the following flags OR'd together:<br/>
		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>
		/// These flags specify how SDL should behave when a device cannot offer a<br/>
		/// specific feature. If the application requests a feature that the hardware<br/>
		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>
		/// For example, if you ask for float32 audio format, but the sound card only<br/>
		/// supports int16, SDL will set the hardware to int16. If you had set<br/>
		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>
		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>
		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>
		/// will keep the originally requested format in the `obtained` structure.<br/>
		/// The resulting audio specs, varying depending on hardware and on what<br/>
		/// changes were allowed, will then be written back to `obtained`.<br/>
		/// If your application can only handle one specific data format, pass a zero<br/>
		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>
		/// <br/>
		/// For compatibility with SDL 1.2, this will never return 1, since<br/>
		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenAudioDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID")]
		public static uint SDLOpenAudioDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "const char*")] string device, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "const SDL_AudioSpec*")] ref SDLAudioSpec desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec obtained, [NativeName(NativeNameType.Param, "allowed_changes")] [NativeName(NativeNameType.Type, "int")] int allowedChanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (device != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(device);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(device, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (SDLAudioSpec* pdesired = &desired)
			{
				fixed (SDLAudioSpec* pobtained = &obtained)
				{
					uint ret = SDLOpenAudioDeviceNative(pStr0, iscapture, (SDLAudioSpec*)pdesired, (SDLAudioSpec*)pobtained, allowedChanges);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// This function is a legacy means of querying the audio device.<br/>
		/// New programs might want to use SDL_GetAudioDeviceStatus() instead. This<br/>
		/// function is equivalent to calling...<br/>
		/// ```c<br/>
		/// SDL_GetAudioDeviceStatus(1);<br/>
		/// ```<br/>
		/// ...and is only useful if you used the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAudioStatus")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioStatus")]
		internal static SDLAudioStatus SDLGetAudioStatusNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAudioStatus>)vt[223])();
			#else
			return (SDLAudioStatus)((delegate* unmanaged[Cdecl]<SDLAudioStatus>)vt[223])();
			#endif
		}

		/// <summary>
		/// This function is a legacy means of querying the audio device.<br/>
		/// New programs might want to use SDL_GetAudioDeviceStatus() instead. This<br/>
		/// function is equivalent to calling...<br/>
		/// ```c<br/>
		/// SDL_GetAudioDeviceStatus(1);<br/>
		/// ```<br/>
		/// ...and is only useful if you used the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAudioStatus")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioStatus")]
		public static SDLAudioStatus SDLGetAudioStatus()
		{
			SDLAudioStatus ret = SDLGetAudioStatusNative();
			return ret;
		}

		/// <summary>
		/// Use this function to get the current audio state of an audio device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAudioDeviceStatus")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioStatus")]
		internal static SDLAudioStatus SDLGetAudioDeviceStatusNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_AudioDeviceID")] uint dev)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, SDLAudioStatus>)vt[224])(dev);
			#else
			return (SDLAudioStatus)((delegate* unmanaged[Cdecl]<uint, SDLAudioStatus>)vt[224])(dev);
			#endif
		}

		/// <summary>
		/// Use this function to get the current audio state of an audio device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAudioDeviceStatus")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioStatus")]
		public static SDLAudioStatus SDLGetAudioDeviceStatus([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_AudioDeviceID")] uint dev)
		{
			SDLAudioStatus ret = SDLGetAudioDeviceStatusNative(dev);
			return ret;
		}

		/// <summary>
		/// This function is a legacy means of pausing the audio device.<br/>
		/// New programs might want to use SDL_PauseAudioDevice() instead. This<br/>
		/// function is equivalent to calling...<br/>
		/// ```c<br/>
		/// SDL_PauseAudioDevice(1, pause_on);<br/>
		/// ```<br/>
		/// ...and is only useful if you used the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PauseAudio")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SDLPauseAudioNative([NativeName(NativeNameType.Param, "pause_on")] [NativeName(NativeNameType.Type, "int")] int pauseOn)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)vt[225])(pauseOn);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)vt[225])(pauseOn);
			#endif
		}

		/// <summary>
		/// This function is a legacy means of pausing the audio device.<br/>
		/// New programs might want to use SDL_PauseAudioDevice() instead. This<br/>
		/// function is equivalent to calling...<br/>
		/// ```c<br/>
		/// SDL_PauseAudioDevice(1, pause_on);<br/>
		/// ```<br/>
		/// ...and is only useful if you used the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PauseAudio")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLPauseAudio([NativeName(NativeNameType.Param, "pause_on")] [NativeName(NativeNameType.Type, "int")] int pauseOn)
		{
			SDLPauseAudioNative(pauseOn);
		}

		/// <summary>
		/// Use this function to pause and unpause audio playback on a specified<br/>
		/// device.<br/>
		/// This function pauses and unpauses the audio callback processing for a given<br/>
		/// device. Newly-opened audio devices start in the paused state, so you must<br/>
		/// call this function with **pause_on**=0 after opening the specified audio<br/>
		/// device to start playing sound. This allows you to safely initialize data<br/>
		/// for your callback function after opening the audio device. Silence will be<br/>
		/// written to the audio device while paused, and the audio callback is<br/>
		/// guaranteed to not be called. Pausing one device does not prevent other<br/>
		/// unpaused devices from running their callbacks.<br/>
		/// Pausing state does not stack; even if you pause a device several times, a<br/>
		/// single unpause will start the device playing again, and vice versa. This is<br/>
		/// different from how SDL_LockAudioDevice() works.<br/>
		/// If you just need to protect a few variables from race conditions vs your<br/>
		/// callback, you shouldn't pause the audio device, as it will lead to dropouts<br/>
		/// in the audio playback. Instead, you should use SDL_LockAudioDevice().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PauseAudioDevice")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SDLPauseAudioDeviceNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_AudioDeviceID")] uint dev, [NativeName(NativeNameType.Param, "pause_on")] [NativeName(NativeNameType.Type, "int")] int pauseOn)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, void>)vt[226])(dev, pauseOn);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, void>)vt[226])(dev, pauseOn);
			#endif
		}

		/// <summary>
		/// Use this function to pause and unpause audio playback on a specified<br/>
		/// device.<br/>
		/// This function pauses and unpauses the audio callback processing for a given<br/>
		/// device. Newly-opened audio devices start in the paused state, so you must<br/>
		/// call this function with **pause_on**=0 after opening the specified audio<br/>
		/// device to start playing sound. This allows you to safely initialize data<br/>
		/// for your callback function after opening the audio device. Silence will be<br/>
		/// written to the audio device while paused, and the audio callback is<br/>
		/// guaranteed to not be called. Pausing one device does not prevent other<br/>
		/// unpaused devices from running their callbacks.<br/>
		/// Pausing state does not stack; even if you pause a device several times, a<br/>
		/// single unpause will start the device playing again, and vice versa. This is<br/>
		/// different from how SDL_LockAudioDevice() works.<br/>
		/// If you just need to protect a few variables from race conditions vs your<br/>
		/// callback, you shouldn't pause the audio device, as it will lead to dropouts<br/>
		/// in the audio playback. Instead, you should use SDL_LockAudioDevice().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PauseAudioDevice")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLPauseAudioDevice([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_AudioDeviceID")] uint dev, [NativeName(NativeNameType.Param, "pause_on")] [NativeName(NativeNameType.Type, "int")] int pauseOn)
		{
			SDLPauseAudioDeviceNative(dev, pauseOn);
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>
		/// freed before the function returns.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>
		/// and the pointer to the audio data allocated by the function is written to<br/>
		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>
		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>
		/// data in the buffer. The `samples` member is set to a sane default and all<br/>
		/// others are set to zero.<br/>
		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>
		/// messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>
		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>
		/// more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioSpec*")]
		internal static SDLAudioSpec* SDLLoadWAVRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8**")] byte** audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32*")] uint* audioLen)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int, SDLAudioSpec*, byte**, uint*, SDLAudioSpec*>)vt[227])(src, freesrc, spec, audioBuf, audioLen);
			#else
			return (SDLAudioSpec*)((delegate* unmanaged[Cdecl]<nint, int, nint, nint, nint, nint>)vt[227])((nint)src, freesrc, (nint)spec, (nint)audioBuf, (nint)audioLen);
			#endif
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>
		/// freed before the function returns.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>
		/// and the pointer to the audio data allocated by the function is written to<br/>
		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>
		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>
		/// data in the buffer. The `samples` member is set to a sane default and all<br/>
		/// others are set to zero.<br/>
		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>
		/// messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>
		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>
		/// more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioSpec*")]
		public static SDLAudioSpec* SDLLoadWAVRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8**")] byte** audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32*")] uint* audioLen)
		{
			SDLAudioSpec* ret = SDLLoadWAVRWNative(src, freesrc, spec, audioBuf, audioLen);
			return ret;
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>
		/// freed before the function returns.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>
		/// and the pointer to the audio data allocated by the function is written to<br/>
		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>
		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>
		/// data in the buffer. The `samples` member is set to a sane default and all<br/>
		/// others are set to zero.<br/>
		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>
		/// messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>
		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>
		/// more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioSpec*")]
		public static SDLAudioSpec* SDLLoadWAVRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8**")] byte** audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32*")] uint* audioLen)
		{
			fixed (SDLRWops* psrc = &src)
			{
				SDLAudioSpec* ret = SDLLoadWAVRWNative((SDLRWops*)psrc, freesrc, spec, audioBuf, audioLen);
				return ret;
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>
		/// freed before the function returns.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>
		/// and the pointer to the audio data allocated by the function is written to<br/>
		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>
		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>
		/// data in the buffer. The `samples` member is set to a sane default and all<br/>
		/// others are set to zero.<br/>
		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>
		/// messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>
		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>
		/// more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioSpec*")]
		public static SDLAudioSpec* SDLLoadWAVRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8**")] byte** audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32*")] uint* audioLen)
		{
			fixed (SDLAudioSpec* pspec = &spec)
			{
				SDLAudioSpec* ret = SDLLoadWAVRWNative(src, freesrc, (SDLAudioSpec*)pspec, audioBuf, audioLen);
				return ret;
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>
		/// freed before the function returns.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>
		/// and the pointer to the audio data allocated by the function is written to<br/>
		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>
		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>
		/// data in the buffer. The `samples` member is set to a sane default and all<br/>
		/// others are set to zero.<br/>
		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>
		/// messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>
		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>
		/// more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioSpec*")]
		public static SDLAudioSpec* SDLLoadWAVRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8**")] byte** audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32*")] uint* audioLen)
		{
			fixed (SDLRWops* psrc = &src)
			{
				fixed (SDLAudioSpec* pspec = &spec)
				{
					SDLAudioSpec* ret = SDLLoadWAVRWNative((SDLRWops*)psrc, freesrc, (SDLAudioSpec*)pspec, audioBuf, audioLen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>
		/// freed before the function returns.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>
		/// and the pointer to the audio data allocated by the function is written to<br/>
		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>
		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>
		/// data in the buffer. The `samples` member is set to a sane default and all<br/>
		/// others are set to zero.<br/>
		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>
		/// messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>
		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>
		/// more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioSpec*")]
		public static SDLAudioSpec* SDLLoadWAVRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8**")] ref byte* audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32*")] uint* audioLen)
		{
			fixed (byte** paudioBuf = &audioBuf)
			{
				SDLAudioSpec* ret = SDLLoadWAVRWNative(src, freesrc, spec, (byte**)paudioBuf, audioLen);
				return ret;
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>
		/// freed before the function returns.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>
		/// and the pointer to the audio data allocated by the function is written to<br/>
		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>
		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>
		/// data in the buffer. The `samples` member is set to a sane default and all<br/>
		/// others are set to zero.<br/>
		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>
		/// messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>
		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>
		/// more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioSpec*")]
		public static SDLAudioSpec* SDLLoadWAVRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8**")] ref byte* audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32*")] uint* audioLen)
		{
			fixed (SDLRWops* psrc = &src)
			{
				fixed (byte** paudioBuf = &audioBuf)
				{
					SDLAudioSpec* ret = SDLLoadWAVRWNative((SDLRWops*)psrc, freesrc, spec, (byte**)paudioBuf, audioLen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>
		/// freed before the function returns.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>
		/// and the pointer to the audio data allocated by the function is written to<br/>
		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>
		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>
		/// data in the buffer. The `samples` member is set to a sane default and all<br/>
		/// others are set to zero.<br/>
		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>
		/// messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>
		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>
		/// more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioSpec*")]
		public static SDLAudioSpec* SDLLoadWAVRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8**")] ref byte* audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32*")] uint* audioLen)
		{
			fixed (SDLAudioSpec* pspec = &spec)
			{
				fixed (byte** paudioBuf = &audioBuf)
				{
					SDLAudioSpec* ret = SDLLoadWAVRWNative(src, freesrc, (SDLAudioSpec*)pspec, (byte**)paudioBuf, audioLen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>
		/// freed before the function returns.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>
		/// and the pointer to the audio data allocated by the function is written to<br/>
		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>
		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>
		/// data in the buffer. The `samples` member is set to a sane default and all<br/>
		/// others are set to zero.<br/>
		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>
		/// messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>
		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>
		/// more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioSpec*")]
		public static SDLAudioSpec* SDLLoadWAVRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8**")] ref byte* audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32*")] uint* audioLen)
		{
			fixed (SDLRWops* psrc = &src)
			{
				fixed (SDLAudioSpec* pspec = &spec)
				{
					fixed (byte** paudioBuf = &audioBuf)
					{
						SDLAudioSpec* ret = SDLLoadWAVRWNative((SDLRWops*)psrc, freesrc, (SDLAudioSpec*)pspec, (byte**)paudioBuf, audioLen);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>
		/// freed before the function returns.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>
		/// and the pointer to the audio data allocated by the function is written to<br/>
		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>
		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>
		/// data in the buffer. The `samples` member is set to a sane default and all<br/>
		/// others are set to zero.<br/>
		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>
		/// messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>
		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>
		/// more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioSpec*")]
		public static SDLAudioSpec* SDLLoadWAVRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8**")] byte** audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint audioLen)
		{
			fixed (uint* paudioLen = &audioLen)
			{
				SDLAudioSpec* ret = SDLLoadWAVRWNative(src, freesrc, spec, audioBuf, (uint*)paudioLen);
				return ret;
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>
		/// freed before the function returns.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>
		/// and the pointer to the audio data allocated by the function is written to<br/>
		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>
		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>
		/// data in the buffer. The `samples` member is set to a sane default and all<br/>
		/// others are set to zero.<br/>
		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>
		/// messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>
		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>
		/// more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioSpec*")]
		public static SDLAudioSpec* SDLLoadWAVRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8**")] byte** audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint audioLen)
		{
			fixed (SDLRWops* psrc = &src)
			{
				fixed (uint* paudioLen = &audioLen)
				{
					SDLAudioSpec* ret = SDLLoadWAVRWNative((SDLRWops*)psrc, freesrc, spec, audioBuf, (uint*)paudioLen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>
		/// freed before the function returns.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>
		/// and the pointer to the audio data allocated by the function is written to<br/>
		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>
		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>
		/// data in the buffer. The `samples` member is set to a sane default and all<br/>
		/// others are set to zero.<br/>
		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>
		/// messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>
		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>
		/// more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioSpec*")]
		public static SDLAudioSpec* SDLLoadWAVRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8**")] byte** audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint audioLen)
		{
			fixed (SDLAudioSpec* pspec = &spec)
			{
				fixed (uint* paudioLen = &audioLen)
				{
					SDLAudioSpec* ret = SDLLoadWAVRWNative(src, freesrc, (SDLAudioSpec*)pspec, audioBuf, (uint*)paudioLen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>
		/// freed before the function returns.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>
		/// and the pointer to the audio data allocated by the function is written to<br/>
		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>
		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>
		/// data in the buffer. The `samples` member is set to a sane default and all<br/>
		/// others are set to zero.<br/>
		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>
		/// messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>
		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>
		/// more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioSpec*")]
		public static SDLAudioSpec* SDLLoadWAVRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8**")] byte** audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint audioLen)
		{
			fixed (SDLRWops* psrc = &src)
			{
				fixed (SDLAudioSpec* pspec = &spec)
				{
					fixed (uint* paudioLen = &audioLen)
					{
						SDLAudioSpec* ret = SDLLoadWAVRWNative((SDLRWops*)psrc, freesrc, (SDLAudioSpec*)pspec, audioBuf, (uint*)paudioLen);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>
		/// freed before the function returns.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>
		/// and the pointer to the audio data allocated by the function is written to<br/>
		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>
		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>
		/// data in the buffer. The `samples` member is set to a sane default and all<br/>
		/// others are set to zero.<br/>
		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>
		/// messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>
		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>
		/// more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioSpec*")]
		public static SDLAudioSpec* SDLLoadWAVRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8**")] ref byte* audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint audioLen)
		{
			fixed (byte** paudioBuf = &audioBuf)
			{
				fixed (uint* paudioLen = &audioLen)
				{
					SDLAudioSpec* ret = SDLLoadWAVRWNative(src, freesrc, spec, (byte**)paudioBuf, (uint*)paudioLen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>
		/// freed before the function returns.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>
		/// and the pointer to the audio data allocated by the function is written to<br/>
		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>
		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>
		/// data in the buffer. The `samples` member is set to a sane default and all<br/>
		/// others are set to zero.<br/>
		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>
		/// messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>
		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>
		/// more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioSpec*")]
		public static SDLAudioSpec* SDLLoadWAVRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8**")] ref byte* audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint audioLen)
		{
			fixed (SDLRWops* psrc = &src)
			{
				fixed (byte** paudioBuf = &audioBuf)
				{
					fixed (uint* paudioLen = &audioLen)
					{
						SDLAudioSpec* ret = SDLLoadWAVRWNative((SDLRWops*)psrc, freesrc, spec, (byte**)paudioBuf, (uint*)paudioLen);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>
		/// freed before the function returns.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>
		/// and the pointer to the audio data allocated by the function is written to<br/>
		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>
		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>
		/// data in the buffer. The `samples` member is set to a sane default and all<br/>
		/// others are set to zero.<br/>
		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>
		/// messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>
		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>
		/// more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioSpec*")]
		public static SDLAudioSpec* SDLLoadWAVRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8**")] ref byte* audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint audioLen)
		{
			fixed (SDLAudioSpec* pspec = &spec)
			{
				fixed (byte** paudioBuf = &audioBuf)
				{
					fixed (uint* paudioLen = &audioLen)
					{
						SDLAudioSpec* ret = SDLLoadWAVRWNative(src, freesrc, (SDLAudioSpec*)pspec, (byte**)paudioBuf, (uint*)paudioLen);
						return ret;
					}
				}
			}
		}
	}
}
