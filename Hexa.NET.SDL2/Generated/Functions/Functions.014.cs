// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL2
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLQueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] uint* format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] ref int access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (int* paccess = &access)
				{
					fixed (int* pw = &w)
					{
						fixed (int* ph = &h)
						{
							int ret = SDLQueryTextureNative((SDLTexture*)ptexture, format, (int*)paccess, (int*)pw, (int*)ph);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLQueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] ref int access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (uint* pformat = &format)
			{
				fixed (int* paccess = &access)
				{
					fixed (int* pw = &w)
					{
						fixed (int* ph = &h)
						{
							int ret = SDLQueryTextureNative(texture, (uint*)pformat, (int*)paccess, (int*)pw, (int*)ph);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLQueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] ref int access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (uint* pformat = &format)
				{
					fixed (int* paccess = &access)
					{
						fixed (int* pw = &w)
						{
							fixed (int* ph = &h)
							{
								int ret = SDLQueryTextureNative((SDLTexture*)ptexture, (uint*)pformat, (int*)paccess, (int*)pw, (int*)ph);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Set an additional color value multiplied into render copy operations.<br/>
		/// When this texture is rendered, during the copy operation each source color<br/>
		/// channel is modulated by the appropriate color value according to the<br/>
		/// following formula:<br/>
		/// `srcC = srcC * (color / 255)`<br/>
		/// Color modulation is not always supported by the renderer; it will return -1<br/>
		/// if color modulation is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLSetTextureColorModNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8")] byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8")] byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8")] byte b)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, byte, byte, byte, int>)vt[735])(texture, r, g, b);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, byte, byte, byte, int>)vt[735])((nint)texture, r, g, b);
			#endif
		}

		/// <summary>
		/// Set an additional color value multiplied into render copy operations.<br/>
		/// When this texture is rendered, during the copy operation each source color<br/>
		/// channel is modulated by the appropriate color value according to the<br/>
		/// following formula:<br/>
		/// `srcC = srcC * (color / 255)`<br/>
		/// Color modulation is not always supported by the renderer; it will return -1<br/>
		/// if color modulation is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetTextureColorMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8")] byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8")] byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8")] byte b)
		{
			int ret = SDLSetTextureColorModNative(texture, r, g, b);
			return ret;
		}

		/// <summary>
		/// Set an additional color value multiplied into render copy operations.<br/>
		/// When this texture is rendered, during the copy operation each source color<br/>
		/// channel is modulated by the appropriate color value according to the<br/>
		/// following formula:<br/>
		/// `srcC = srcC * (color / 255)`<br/>
		/// Color modulation is not always supported by the renderer; it will return -1<br/>
		/// if color modulation is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetTextureColorMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8")] byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8")] byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8")] byte b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SDLSetTextureColorModNative((SDLTexture*)ptexture, r, g, b);
				return ret;
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLGetTextureColorModNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, byte*, byte*, byte*, int>)vt[736])(texture, r, g, b);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, int>)vt[736])((nint)texture, (nint)r, (nint)g, (nint)b);
			#endif
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureColorMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			int ret = SDLGetTextureColorModNative(texture, r, g, b);
			return ret;
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureColorMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SDLGetTextureColorModNative((SDLTexture*)ptexture, r, g, b);
				return ret;
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureColorMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			fixed (byte* pr = &r)
			{
				int ret = SDLGetTextureColorModNative(texture, (byte*)pr, g, b);
				return ret;
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureColorMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pr = &r)
				{
					int ret = SDLGetTextureColorModNative((SDLTexture*)ptexture, (byte*)pr, g, b);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureColorMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			fixed (byte* pg = &g)
			{
				int ret = SDLGetTextureColorModNative(texture, r, (byte*)pg, b);
				return ret;
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureColorMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pg = &g)
				{
					int ret = SDLGetTextureColorModNative((SDLTexture*)ptexture, r, (byte*)pg, b);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureColorMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					int ret = SDLGetTextureColorModNative(texture, (byte*)pr, (byte*)pg, b);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureColorMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						int ret = SDLGetTextureColorModNative((SDLTexture*)ptexture, (byte*)pr, (byte*)pg, b);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureColorMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b)
		{
			fixed (byte* pb = &b)
			{
				int ret = SDLGetTextureColorModNative(texture, r, g, (byte*)pb);
				return ret;
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureColorMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pb = &b)
				{
					int ret = SDLGetTextureColorModNative((SDLTexture*)ptexture, r, g, (byte*)pb);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureColorMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pb = &b)
				{
					int ret = SDLGetTextureColorModNative(texture, (byte*)pr, g, (byte*)pb);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureColorMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pb = &b)
					{
						int ret = SDLGetTextureColorModNative((SDLTexture*)ptexture, (byte*)pr, g, (byte*)pb);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureColorMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b)
		{
			fixed (byte* pg = &g)
			{
				fixed (byte* pb = &b)
				{
					int ret = SDLGetTextureColorModNative(texture, r, (byte*)pg, (byte*)pb);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureColorMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						int ret = SDLGetTextureColorModNative((SDLTexture*)ptexture, r, (byte*)pg, (byte*)pb);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureColorMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						int ret = SDLGetTextureColorModNative(texture, (byte*)pr, (byte*)pg, (byte*)pb);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureColorMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						fixed (byte* pb = &b)
						{
							int ret = SDLGetTextureColorModNative((SDLTexture*)ptexture, (byte*)pr, (byte*)pg, (byte*)pb);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Set an additional alpha value multiplied into render copy operations.<br/>
		/// When this texture is rendered, during the copy operation the source alpha<br/>
		/// value is modulated by this alpha value according to the following formula:<br/>
		/// `srcA = srcA * (alpha / 255)`<br/>
		/// Alpha modulation is not always supported by the renderer; it will return -1<br/>
		/// if alpha modulation is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTextureAlphaMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLSetTextureAlphaModNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8")] byte alpha)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, byte, int>)vt[737])(texture, alpha);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, byte, int>)vt[737])((nint)texture, alpha);
			#endif
		}

		/// <summary>
		/// Set an additional alpha value multiplied into render copy operations.<br/>
		/// When this texture is rendered, during the copy operation the source alpha<br/>
		/// value is modulated by this alpha value according to the following formula:<br/>
		/// `srcA = srcA * (alpha / 255)`<br/>
		/// Alpha modulation is not always supported by the renderer; it will return -1<br/>
		/// if alpha modulation is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTextureAlphaMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetTextureAlphaMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8")] byte alpha)
		{
			int ret = SDLSetTextureAlphaModNative(texture, alpha);
			return ret;
		}

		/// <summary>
		/// Set an additional alpha value multiplied into render copy operations.<br/>
		/// When this texture is rendered, during the copy operation the source alpha<br/>
		/// value is modulated by this alpha value according to the following formula:<br/>
		/// `srcA = srcA * (alpha / 255)`<br/>
		/// Alpha modulation is not always supported by the renderer; it will return -1<br/>
		/// if alpha modulation is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTextureAlphaMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetTextureAlphaMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8")] byte alpha)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SDLSetTextureAlphaModNative((SDLTexture*)ptexture, alpha);
				return ret;
			}
		}

		/// <summary>
		/// Get the additional alpha value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureAlphaMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLGetTextureAlphaModNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8*")] byte* alpha)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, byte*, int>)vt[738])(texture, alpha);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)vt[738])((nint)texture, (nint)alpha);
			#endif
		}

		/// <summary>
		/// Get the additional alpha value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureAlphaMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureAlphaMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8*")] byte* alpha)
		{
			int ret = SDLGetTextureAlphaModNative(texture, alpha);
			return ret;
		}

		/// <summary>
		/// Get the additional alpha value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureAlphaMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureAlphaMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8*")] byte* alpha)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SDLGetTextureAlphaModNative((SDLTexture*)ptexture, alpha);
				return ret;
			}
		}

		/// <summary>
		/// Get the additional alpha value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureAlphaMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureAlphaMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte alpha)
		{
			fixed (byte* palpha = &alpha)
			{
				int ret = SDLGetTextureAlphaModNative(texture, (byte*)palpha);
				return ret;
			}
		}

		/// <summary>
		/// Get the additional alpha value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureAlphaMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureAlphaMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte alpha)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* palpha = &alpha)
				{
					int ret = SDLGetTextureAlphaModNative((SDLTexture*)ptexture, (byte*)palpha);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set the blend mode for a texture, used by SDL_RenderCopy().<br/>
		/// If the blend mode is not supported, the closest supported mode is chosen<br/>
		/// and this function returns -1.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTextureBlendMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLSetTextureBlendModeNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode")] SDLBlendMode blendMode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, SDLBlendMode, int>)vt[739])(texture, blendMode);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, SDLBlendMode, int>)vt[739])((nint)texture, blendMode);
			#endif
		}

		/// <summary>
		/// Set the blend mode for a texture, used by SDL_RenderCopy().<br/>
		/// If the blend mode is not supported, the closest supported mode is chosen<br/>
		/// and this function returns -1.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTextureBlendMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetTextureBlendMode([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode")] SDLBlendMode blendMode)
		{
			int ret = SDLSetTextureBlendModeNative(texture, blendMode);
			return ret;
		}

		/// <summary>
		/// Set the blend mode for a texture, used by SDL_RenderCopy().<br/>
		/// If the blend mode is not supported, the closest supported mode is chosen<br/>
		/// and this function returns -1.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTextureBlendMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetTextureBlendMode([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode")] SDLBlendMode blendMode)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SDLSetTextureBlendModeNative((SDLTexture*)ptexture, blendMode);
				return ret;
			}
		}

		/// <summary>
		/// Get the blend mode used for texture copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureBlendMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLGetTextureBlendModeNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode*")] SDLBlendMode* blendMode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, SDLBlendMode*, int>)vt[740])(texture, blendMode);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)vt[740])((nint)texture, (nint)blendMode);
			#endif
		}

		/// <summary>
		/// Get the blend mode used for texture copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureBlendMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureBlendMode([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode*")] SDLBlendMode* blendMode)
		{
			int ret = SDLGetTextureBlendModeNative(texture, blendMode);
			return ret;
		}

		/// <summary>
		/// Get the blend mode used for texture copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureBlendMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureBlendMode([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode*")] SDLBlendMode* blendMode)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SDLGetTextureBlendModeNative((SDLTexture*)ptexture, blendMode);
				return ret;
			}
		}

		/// <summary>
		/// Get the blend mode used for texture copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureBlendMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureBlendMode([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode*")] ref SDLBlendMode blendMode)
		{
			fixed (SDLBlendMode* pblendMode = &blendMode)
			{
				int ret = SDLGetTextureBlendModeNative(texture, (SDLBlendMode*)pblendMode);
				return ret;
			}
		}

		/// <summary>
		/// Get the blend mode used for texture copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureBlendMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureBlendMode([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode*")] ref SDLBlendMode blendMode)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLBlendMode* pblendMode = &blendMode)
				{
					int ret = SDLGetTextureBlendModeNative((SDLTexture*)ptexture, (SDLBlendMode*)pblendMode);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set the scale mode used for texture scale operations.<br/>
		/// If the scale mode is not supported, the closest supported mode is chosen.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTextureScaleMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLSetTextureScaleModeNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, SDLScaleMode, int>)vt[741])(texture, scaleMode);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, SDLScaleMode, int>)vt[741])((nint)texture, scaleMode);
			#endif
		}

		/// <summary>
		/// Set the scale mode used for texture scale operations.<br/>
		/// If the scale mode is not supported, the closest supported mode is chosen.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTextureScaleMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetTextureScaleMode([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode)
		{
			int ret = SDLSetTextureScaleModeNative(texture, scaleMode);
			return ret;
		}

		/// <summary>
		/// Set the scale mode used for texture scale operations.<br/>
		/// If the scale mode is not supported, the closest supported mode is chosen.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTextureScaleMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetTextureScaleMode([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SDLSetTextureScaleModeNative((SDLTexture*)ptexture, scaleMode);
				return ret;
			}
		}

		/// <summary>
		/// Get the scale mode used for texture scale operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureScaleMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLGetTextureScaleModeNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode*")] SDLScaleMode* scaleMode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, SDLScaleMode*, int>)vt[742])(texture, scaleMode);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)vt[742])((nint)texture, (nint)scaleMode);
			#endif
		}

		/// <summary>
		/// Get the scale mode used for texture scale operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureScaleMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureScaleMode([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode*")] SDLScaleMode* scaleMode)
		{
			int ret = SDLGetTextureScaleModeNative(texture, scaleMode);
			return ret;
		}

		/// <summary>
		/// Get the scale mode used for texture scale operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureScaleMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureScaleMode([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode*")] SDLScaleMode* scaleMode)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SDLGetTextureScaleModeNative((SDLTexture*)ptexture, scaleMode);
				return ret;
			}
		}

		/// <summary>
		/// Get the scale mode used for texture scale operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureScaleMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureScaleMode([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode*")] ref SDLScaleMode scaleMode)
		{
			fixed (SDLScaleMode* pscaleMode = &scaleMode)
			{
				int ret = SDLGetTextureScaleModeNative(texture, (SDLScaleMode*)pscaleMode);
				return ret;
			}
		}

		/// <summary>
		/// Get the scale mode used for texture scale operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureScaleMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureScaleMode([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode*")] ref SDLScaleMode scaleMode)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLScaleMode* pscaleMode = &scaleMode)
				{
					int ret = SDLGetTextureScaleModeNative((SDLTexture*)ptexture, (SDLScaleMode*)pscaleMode);
					return ret;
				}
			}
		}

		/// <summary>
		/// Associate a user-specified pointer with a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTextureUserData")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLSetTextureUserDataNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void*")] void* userdata)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, void*, int>)vt[743])(texture, userdata);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)vt[743])((nint)texture, (nint)userdata);
			#endif
		}

		/// <summary>
		/// Associate a user-specified pointer with a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTextureUserData")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetTextureUserData([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void*")] void* userdata)
		{
			int ret = SDLSetTextureUserDataNative(texture, userdata);
			return ret;
		}

		/// <summary>
		/// Associate a user-specified pointer with a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTextureUserData")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetTextureUserData([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void*")] void* userdata)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SDLSetTextureUserDataNative((SDLTexture*)ptexture, userdata);
				return ret;
			}
		}

		/// <summary>
		/// Get the user-specified pointer associated with a texture<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureUserData")]
		[return: NativeName(NativeNameType.Type, "void*")]
		internal static void* SDLGetTextureUserDataNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, void*>)vt[744])(texture);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint>)vt[744])((nint)texture);
			#endif
		}

		/// <summary>
		/// Get the user-specified pointer associated with a texture<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureUserData")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLGetTextureUserData([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture)
		{
			void* ret = SDLGetTextureUserDataNative(texture);
			return ret;
		}

		/// <summary>
		/// Get the user-specified pointer associated with a texture<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureUserData")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLGetTextureUserData([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				void* ret = SDLGetTextureUserDataNative((SDLTexture*)ptexture);
				return ret;
			}
		}

		/// <summary>
		/// Update the given texture rectangle with new pixel data.<br/>
		/// The pixel data must be in the pixel format of the texture. Use<br/>
		/// SDL_QueryTexture() to query the pixel format of the texture.<br/>
		/// This is a fairly slow function, intended for use with static textures that<br/>
		/// do not change often.<br/>
		/// If the texture is intended to be updated often, it is preferred to create<br/>
		/// the texture as streaming and use the locking functions referenced below.<br/>
		/// While this function will work with streaming textures, for optimization<br/>
		/// reasons you may not get the pixels back if you lock the texture afterward.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLUpdateTextureNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "const void*")] void* pixels, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int")] int pitch)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, SDLRect*, void*, int, int>)vt[745])(texture, rect, pixels, pitch);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, int, int>)vt[745])((nint)texture, (nint)rect, (nint)pixels, pitch);
			#endif
		}

		/// <summary>
		/// Update the given texture rectangle with new pixel data.<br/>
		/// The pixel data must be in the pixel format of the texture. Use<br/>
		/// SDL_QueryTexture() to query the pixel format of the texture.<br/>
		/// This is a fairly slow function, intended for use with static textures that<br/>
		/// do not change often.<br/>
		/// If the texture is intended to be updated often, it is preferred to create<br/>
		/// the texture as streaming and use the locking functions referenced below.<br/>
		/// While this function will work with streaming textures, for optimization<br/>
		/// reasons you may not get the pixels back if you lock the texture afterward.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "const void*")] void* pixels, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int")] int pitch)
		{
			int ret = SDLUpdateTextureNative(texture, rect, pixels, pitch);
			return ret;
		}

		/// <summary>
		/// Update the given texture rectangle with new pixel data.<br/>
		/// The pixel data must be in the pixel format of the texture. Use<br/>
		/// SDL_QueryTexture() to query the pixel format of the texture.<br/>
		/// This is a fairly slow function, intended for use with static textures that<br/>
		/// do not change often.<br/>
		/// If the texture is intended to be updated often, it is preferred to create<br/>
		/// the texture as streaming and use the locking functions referenced below.<br/>
		/// While this function will work with streaming textures, for optimization<br/>
		/// reasons you may not get the pixels back if you lock the texture afterward.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "const void*")] void* pixels, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int")] int pitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SDLUpdateTextureNative((SDLTexture*)ptexture, rect, pixels, pitch);
				return ret;
			}
		}

		/// <summary>
		/// Update the given texture rectangle with new pixel data.<br/>
		/// The pixel data must be in the pixel format of the texture. Use<br/>
		/// SDL_QueryTexture() to query the pixel format of the texture.<br/>
		/// This is a fairly slow function, intended for use with static textures that<br/>
		/// do not change often.<br/>
		/// If the texture is intended to be updated often, it is preferred to create<br/>
		/// the texture as streaming and use the locking functions referenced below.<br/>
		/// While this function will work with streaming textures, for optimization<br/>
		/// reasons you may not get the pixels back if you lock the texture afterward.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "const void*")] void* pixels, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int")] int pitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				int ret = SDLUpdateTextureNative(texture, (SDLRect*)prect, pixels, pitch);
				return ret;
			}
		}

		/// <summary>
		/// Update the given texture rectangle with new pixel data.<br/>
		/// The pixel data must be in the pixel format of the texture. Use<br/>
		/// SDL_QueryTexture() to query the pixel format of the texture.<br/>
		/// This is a fairly slow function, intended for use with static textures that<br/>
		/// do not change often.<br/>
		/// If the texture is intended to be updated often, it is preferred to create<br/>
		/// the texture as streaming and use the locking functions referenced below.<br/>
		/// While this function will work with streaming textures, for optimization<br/>
		/// reasons you may not get the pixels back if you lock the texture afterward.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "const void*")] void* pixels, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int")] int pitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					int ret = SDLUpdateTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, pixels, pitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLUpdateYUVTextureNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, SDLRect*, byte*, int, byte*, int, byte*, int, int>)vt[746])(texture, rect, yplane, ypitch, uplane, upitch, vplane, vpitch);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, int, nint, int, nint, int, int>)vt[746])((nint)texture, (nint)rect, (nint)yplane, ypitch, (nint)uplane, upitch, (nint)vplane, vpitch);
			#endif
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			int ret = SDLUpdateYUVTextureNative(texture, rect, yplane, ypitch, uplane, upitch, vplane, vpitch);
			return ret;
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SDLUpdateYUVTextureNative((SDLTexture*)ptexture, rect, yplane, ypitch, uplane, upitch, vplane, vpitch);
				return ret;
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				int ret = SDLUpdateYUVTextureNative(texture, (SDLRect*)prect, yplane, ypitch, uplane, upitch, vplane, vpitch);
				return ret;
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					int ret = SDLUpdateYUVTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, yplane, ypitch, uplane, upitch, vplane, vpitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (byte* pyplane = &yplane)
			{
				int ret = SDLUpdateYUVTextureNative(texture, rect, (byte*)pyplane, ypitch, uplane, upitch, vplane, vpitch);
				return ret;
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pyplane = &yplane)
				{
					int ret = SDLUpdateYUVTextureNative((SDLTexture*)ptexture, rect, (byte*)pyplane, ypitch, uplane, upitch, vplane, vpitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (byte* pyplane = &yplane)
				{
					int ret = SDLUpdateYUVTextureNative(texture, (SDLRect*)prect, (byte*)pyplane, ypitch, uplane, upitch, vplane, vpitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (byte* pyplane = &yplane)
					{
						int ret = SDLUpdateYUVTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, (byte*)pyplane, ypitch, uplane, upitch, vplane, vpitch);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (byte* puplane = &uplane)
			{
				int ret = SDLUpdateYUVTextureNative(texture, rect, yplane, ypitch, (byte*)puplane, upitch, vplane, vpitch);
				return ret;
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* puplane = &uplane)
				{
					int ret = SDLUpdateYUVTextureNative((SDLTexture*)ptexture, rect, yplane, ypitch, (byte*)puplane, upitch, vplane, vpitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (byte* puplane = &uplane)
				{
					int ret = SDLUpdateYUVTextureNative(texture, (SDLRect*)prect, yplane, ypitch, (byte*)puplane, upitch, vplane, vpitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (byte* puplane = &uplane)
					{
						int ret = SDLUpdateYUVTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, yplane, ypitch, (byte*)puplane, upitch, vplane, vpitch);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (byte* pyplane = &yplane)
			{
				fixed (byte* puplane = &uplane)
				{
					int ret = SDLUpdateYUVTextureNative(texture, rect, (byte*)pyplane, ypitch, (byte*)puplane, upitch, vplane, vpitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pyplane = &yplane)
				{
					fixed (byte* puplane = &uplane)
					{
						int ret = SDLUpdateYUVTextureNative((SDLTexture*)ptexture, rect, (byte*)pyplane, ypitch, (byte*)puplane, upitch, vplane, vpitch);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (byte* pyplane = &yplane)
				{
					fixed (byte* puplane = &uplane)
					{
						int ret = SDLUpdateYUVTextureNative(texture, (SDLRect*)prect, (byte*)pyplane, ypitch, (byte*)puplane, upitch, vplane, vpitch);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (byte* pyplane = &yplane)
					{
						fixed (byte* puplane = &uplane)
						{
							int ret = SDLUpdateYUVTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, (byte*)pyplane, ypitch, (byte*)puplane, upitch, vplane, vpitch);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (byte* pvplane = &vplane)
			{
				int ret = SDLUpdateYUVTextureNative(texture, rect, yplane, ypitch, uplane, upitch, (byte*)pvplane, vpitch);
				return ret;
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pvplane = &vplane)
				{
					int ret = SDLUpdateYUVTextureNative((SDLTexture*)ptexture, rect, yplane, ypitch, uplane, upitch, (byte*)pvplane, vpitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (byte* pvplane = &vplane)
				{
					int ret = SDLUpdateYUVTextureNative(texture, (SDLRect*)prect, yplane, ypitch, uplane, upitch, (byte*)pvplane, vpitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (byte* pvplane = &vplane)
					{
						int ret = SDLUpdateYUVTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, yplane, ypitch, uplane, upitch, (byte*)pvplane, vpitch);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (byte* pyplane = &yplane)
			{
				fixed (byte* pvplane = &vplane)
				{
					int ret = SDLUpdateYUVTextureNative(texture, rect, (byte*)pyplane, ypitch, uplane, upitch, (byte*)pvplane, vpitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pyplane = &yplane)
				{
					fixed (byte* pvplane = &vplane)
					{
						int ret = SDLUpdateYUVTextureNative((SDLTexture*)ptexture, rect, (byte*)pyplane, ypitch, uplane, upitch, (byte*)pvplane, vpitch);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (byte* pyplane = &yplane)
				{
					fixed (byte* pvplane = &vplane)
					{
						int ret = SDLUpdateYUVTextureNative(texture, (SDLRect*)prect, (byte*)pyplane, ypitch, uplane, upitch, (byte*)pvplane, vpitch);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (byte* pyplane = &yplane)
					{
						fixed (byte* pvplane = &vplane)
						{
							int ret = SDLUpdateYUVTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, (byte*)pyplane, ypitch, uplane, upitch, (byte*)pvplane, vpitch);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (byte* puplane = &uplane)
			{
				fixed (byte* pvplane = &vplane)
				{
					int ret = SDLUpdateYUVTextureNative(texture, rect, yplane, ypitch, (byte*)puplane, upitch, (byte*)pvplane, vpitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* puplane = &uplane)
				{
					fixed (byte* pvplane = &vplane)
					{
						int ret = SDLUpdateYUVTextureNative((SDLTexture*)ptexture, rect, yplane, ypitch, (byte*)puplane, upitch, (byte*)pvplane, vpitch);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (byte* puplane = &uplane)
				{
					fixed (byte* pvplane = &vplane)
					{
						int ret = SDLUpdateYUVTextureNative(texture, (SDLRect*)prect, yplane, ypitch, (byte*)puplane, upitch, (byte*)pvplane, vpitch);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (byte* puplane = &uplane)
					{
						fixed (byte* pvplane = &vplane)
						{
							int ret = SDLUpdateYUVTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, yplane, ypitch, (byte*)puplane, upitch, (byte*)pvplane, vpitch);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (byte* pyplane = &yplane)
			{
				fixed (byte* puplane = &uplane)
				{
					fixed (byte* pvplane = &vplane)
					{
						int ret = SDLUpdateYUVTextureNative(texture, rect, (byte*)pyplane, ypitch, (byte*)puplane, upitch, (byte*)pvplane, vpitch);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pyplane = &yplane)
				{
					fixed (byte* puplane = &uplane)
					{
						fixed (byte* pvplane = &vplane)
						{
							int ret = SDLUpdateYUVTextureNative((SDLTexture*)ptexture, rect, (byte*)pyplane, ypitch, (byte*)puplane, upitch, (byte*)pvplane, vpitch);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (byte* pyplane = &yplane)
				{
					fixed (byte* puplane = &uplane)
					{
						fixed (byte* pvplane = &vplane)
						{
							int ret = SDLUpdateYUVTextureNative(texture, (SDLRect*)prect, (byte*)pyplane, ypitch, (byte*)puplane, upitch, (byte*)pvplane, vpitch);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (byte* pyplane = &yplane)
					{
						fixed (byte* puplane = &uplane)
						{
							fixed (byte* pvplane = &vplane)
							{
								int ret = SDLUpdateYUVTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, (byte*)pyplane, ypitch, (byte*)puplane, upitch, (byte*)pvplane, vpitch);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of NV12/21 planes in the proper order, but this function is available<br/>
		/// if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateNVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLUpdateNVTextureNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "UVplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uVplane, [NativeName(NativeNameType.Param, "UVpitch")] [NativeName(NativeNameType.Type, "int")] int uVpitch)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, SDLRect*, byte*, int, byte*, int, int>)vt[747])(texture, rect, yplane, ypitch, uVplane, uVpitch);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, int, nint, int, int>)vt[747])((nint)texture, (nint)rect, (nint)yplane, ypitch, (nint)uVplane, uVpitch);
			#endif
		}

		/// <summary>
		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of NV12/21 planes in the proper order, but this function is available<br/>
		/// if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateNVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateNVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "UVplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uVplane, [NativeName(NativeNameType.Param, "UVpitch")] [NativeName(NativeNameType.Type, "int")] int uVpitch)
		{
			int ret = SDLUpdateNVTextureNative(texture, rect, yplane, ypitch, uVplane, uVpitch);
			return ret;
		}

		/// <summary>
		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of NV12/21 planes in the proper order, but this function is available<br/>
		/// if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateNVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateNVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "UVplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uVplane, [NativeName(NativeNameType.Param, "UVpitch")] [NativeName(NativeNameType.Type, "int")] int uVpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SDLUpdateNVTextureNative((SDLTexture*)ptexture, rect, yplane, ypitch, uVplane, uVpitch);
				return ret;
			}
		}

		/// <summary>
		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of NV12/21 planes in the proper order, but this function is available<br/>
		/// if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateNVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateNVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "UVplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uVplane, [NativeName(NativeNameType.Param, "UVpitch")] [NativeName(NativeNameType.Type, "int")] int uVpitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				int ret = SDLUpdateNVTextureNative(texture, (SDLRect*)prect, yplane, ypitch, uVplane, uVpitch);
				return ret;
			}
		}

		/// <summary>
		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of NV12/21 planes in the proper order, but this function is available<br/>
		/// if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateNVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateNVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "UVplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uVplane, [NativeName(NativeNameType.Param, "UVpitch")] [NativeName(NativeNameType.Type, "int")] int uVpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					int ret = SDLUpdateNVTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, yplane, ypitch, uVplane, uVpitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of NV12/21 planes in the proper order, but this function is available<br/>
		/// if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateNVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateNVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "UVplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uVplane, [NativeName(NativeNameType.Param, "UVpitch")] [NativeName(NativeNameType.Type, "int")] int uVpitch)
		{
			fixed (byte* pyplane = &yplane)
			{
				int ret = SDLUpdateNVTextureNative(texture, rect, (byte*)pyplane, ypitch, uVplane, uVpitch);
				return ret;
			}
		}

		/// <summary>
		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of NV12/21 planes in the proper order, but this function is available<br/>
		/// if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateNVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateNVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "UVplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uVplane, [NativeName(NativeNameType.Param, "UVpitch")] [NativeName(NativeNameType.Type, "int")] int uVpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pyplane = &yplane)
				{
					int ret = SDLUpdateNVTextureNative((SDLTexture*)ptexture, rect, (byte*)pyplane, ypitch, uVplane, uVpitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of NV12/21 planes in the proper order, but this function is available<br/>
		/// if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateNVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateNVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "UVplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uVplane, [NativeName(NativeNameType.Param, "UVpitch")] [NativeName(NativeNameType.Type, "int")] int uVpitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (byte* pyplane = &yplane)
				{
					int ret = SDLUpdateNVTextureNative(texture, (SDLRect*)prect, (byte*)pyplane, ypitch, uVplane, uVpitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of NV12/21 planes in the proper order, but this function is available<br/>
		/// if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateNVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateNVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "UVplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uVplane, [NativeName(NativeNameType.Param, "UVpitch")] [NativeName(NativeNameType.Type, "int")] int uVpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (byte* pyplane = &yplane)
					{
						int ret = SDLUpdateNVTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, (byte*)pyplane, ypitch, uVplane, uVpitch);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of NV12/21 planes in the proper order, but this function is available<br/>
		/// if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateNVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateNVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "UVplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uVplane, [NativeName(NativeNameType.Param, "UVpitch")] [NativeName(NativeNameType.Type, "int")] int uVpitch)
		{
			fixed (byte* puVplane = &uVplane)
			{
				int ret = SDLUpdateNVTextureNative(texture, rect, yplane, ypitch, (byte*)puVplane, uVpitch);
				return ret;
			}
		}

		/// <summary>
		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of NV12/21 planes in the proper order, but this function is available<br/>
		/// if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateNVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateNVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "UVplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uVplane, [NativeName(NativeNameType.Param, "UVpitch")] [NativeName(NativeNameType.Type, "int")] int uVpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* puVplane = &uVplane)
				{
					int ret = SDLUpdateNVTextureNative((SDLTexture*)ptexture, rect, yplane, ypitch, (byte*)puVplane, uVpitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of NV12/21 planes in the proper order, but this function is available<br/>
		/// if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateNVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateNVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "UVplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uVplane, [NativeName(NativeNameType.Param, "UVpitch")] [NativeName(NativeNameType.Type, "int")] int uVpitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (byte* puVplane = &uVplane)
				{
					int ret = SDLUpdateNVTextureNative(texture, (SDLRect*)prect, yplane, ypitch, (byte*)puVplane, uVpitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of NV12/21 planes in the proper order, but this function is available<br/>
		/// if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateNVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateNVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "UVplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uVplane, [NativeName(NativeNameType.Param, "UVpitch")] [NativeName(NativeNameType.Type, "int")] int uVpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (byte* puVplane = &uVplane)
					{
						int ret = SDLUpdateNVTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, yplane, ypitch, (byte*)puVplane, uVpitch);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of NV12/21 planes in the proper order, but this function is available<br/>
		/// if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateNVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateNVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "UVplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uVplane, [NativeName(NativeNameType.Param, "UVpitch")] [NativeName(NativeNameType.Type, "int")] int uVpitch)
		{
			fixed (byte* pyplane = &yplane)
			{
				fixed (byte* puVplane = &uVplane)
				{
					int ret = SDLUpdateNVTextureNative(texture, rect, (byte*)pyplane, ypitch, (byte*)puVplane, uVpitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of NV12/21 planes in the proper order, but this function is available<br/>
		/// if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateNVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateNVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "UVplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uVplane, [NativeName(NativeNameType.Param, "UVpitch")] [NativeName(NativeNameType.Type, "int")] int uVpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pyplane = &yplane)
				{
					fixed (byte* puVplane = &uVplane)
					{
						int ret = SDLUpdateNVTextureNative((SDLTexture*)ptexture, rect, (byte*)pyplane, ypitch, (byte*)puVplane, uVpitch);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of NV12/21 planes in the proper order, but this function is available<br/>
		/// if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateNVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateNVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "UVplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uVplane, [NativeName(NativeNameType.Param, "UVpitch")] [NativeName(NativeNameType.Type, "int")] int uVpitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (byte* pyplane = &yplane)
				{
					fixed (byte* puVplane = &uVplane)
					{
						int ret = SDLUpdateNVTextureNative(texture, (SDLRect*)prect, (byte*)pyplane, ypitch, (byte*)puVplane, uVpitch);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of NV12/21 planes in the proper order, but this function is available<br/>
		/// if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateNVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateNVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "UVplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uVplane, [NativeName(NativeNameType.Param, "UVpitch")] [NativeName(NativeNameType.Type, "int")] int uVpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (byte* pyplane = &yplane)
					{
						fixed (byte* puVplane = &uVplane)
						{
							int ret = SDLUpdateNVTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, (byte*)pyplane, ypitch, (byte*)puVplane, uVpitch);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLLockTextureNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "void**")] void** pixels, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int*")] int* pitch)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, SDLRect*, void**, int*, int>)vt[748])(texture, rect, pixels, pitch);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, int>)vt[748])((nint)texture, (nint)rect, (nint)pixels, (nint)pitch);
			#endif
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLockTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "void**")] void** pixels, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int*")] int* pitch)
		{
			int ret = SDLLockTextureNative(texture, rect, pixels, pitch);
			return ret;
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLockTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "void**")] void** pixels, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int*")] int* pitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SDLLockTextureNative((SDLTexture*)ptexture, rect, pixels, pitch);
				return ret;
			}
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLockTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "void**")] void** pixels, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int*")] int* pitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				int ret = SDLLockTextureNative(texture, (SDLRect*)prect, pixels, pitch);
				return ret;
			}
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLockTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "void**")] void** pixels, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int*")] int* pitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					int ret = SDLLockTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, pixels, pitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLockTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "void**")] void** pixels, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int*")] ref int pitch)
		{
			fixed (int* ppitch = &pitch)
			{
				int ret = SDLLockTextureNative(texture, rect, pixels, (int*)ppitch);
				return ret;
			}
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLockTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "void**")] void** pixels, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int*")] ref int pitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (int* ppitch = &pitch)
				{
					int ret = SDLLockTextureNative((SDLTexture*)ptexture, rect, pixels, (int*)ppitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLockTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "void**")] void** pixels, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int*")] ref int pitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* ppitch = &pitch)
				{
					int ret = SDLLockTextureNative(texture, (SDLRect*)prect, pixels, (int*)ppitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLockTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "void**")] void** pixels, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int*")] ref int pitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (int* ppitch = &pitch)
					{
						int ret = SDLLockTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, pixels, (int*)ppitch);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access, and expose<br/>
		/// it as a SDL surface.<br/>
		/// Besides providing an SDL_Surface instead of raw pixel data, this function<br/>
		/// operates like SDL_LockTexture.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// The returned surface is freed internally after calling SDL_UnlockTexture()<br/>
		/// or SDL_DestroyTexture(). The caller should not free it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockTextureToSurface")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLLockTextureToSurfaceNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface**")] SDLSurface** surface)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, SDLRect*, SDLSurface**, int>)vt[749])(texture, rect, surface);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, int>)vt[749])((nint)texture, (nint)rect, (nint)surface);
			#endif
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access, and expose<br/>
		/// it as a SDL surface.<br/>
		/// Besides providing an SDL_Surface instead of raw pixel data, this function<br/>
		/// operates like SDL_LockTexture.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// The returned surface is freed internally after calling SDL_UnlockTexture()<br/>
		/// or SDL_DestroyTexture(). The caller should not free it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockTextureToSurface")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLockTextureToSurface([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface**")] SDLSurface** surface)
		{
			int ret = SDLLockTextureToSurfaceNative(texture, rect, surface);
			return ret;
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access, and expose<br/>
		/// it as a SDL surface.<br/>
		/// Besides providing an SDL_Surface instead of raw pixel data, this function<br/>
		/// operates like SDL_LockTexture.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// The returned surface is freed internally after calling SDL_UnlockTexture()<br/>
		/// or SDL_DestroyTexture(). The caller should not free it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockTextureToSurface")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLockTextureToSurface([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface**")] SDLSurface** surface)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SDLLockTextureToSurfaceNative((SDLTexture*)ptexture, rect, surface);
				return ret;
			}
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access, and expose<br/>
		/// it as a SDL surface.<br/>
		/// Besides providing an SDL_Surface instead of raw pixel data, this function<br/>
		/// operates like SDL_LockTexture.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// The returned surface is freed internally after calling SDL_UnlockTexture()<br/>
		/// or SDL_DestroyTexture(). The caller should not free it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockTextureToSurface")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLockTextureToSurface([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface**")] SDLSurface** surface)
		{
			fixed (SDLRect* prect = &rect)
			{
				int ret = SDLLockTextureToSurfaceNative(texture, (SDLRect*)prect, surface);
				return ret;
			}
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access, and expose<br/>
		/// it as a SDL surface.<br/>
		/// Besides providing an SDL_Surface instead of raw pixel data, this function<br/>
		/// operates like SDL_LockTexture.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// The returned surface is freed internally after calling SDL_UnlockTexture()<br/>
		/// or SDL_DestroyTexture(). The caller should not free it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockTextureToSurface")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLockTextureToSurface([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface**")] SDLSurface** surface)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					int ret = SDLLockTextureToSurfaceNative((SDLTexture*)ptexture, (SDLRect*)prect, surface);
					return ret;
				}
			}
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access, and expose<br/>
		/// it as a SDL surface.<br/>
		/// Besides providing an SDL_Surface instead of raw pixel data, this function<br/>
		/// operates like SDL_LockTexture.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// The returned surface is freed internally after calling SDL_UnlockTexture()<br/>
		/// or SDL_DestroyTexture(). The caller should not free it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockTextureToSurface")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLockTextureToSurface([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface**")] ref SDLSurface* surface)
		{
			fixed (SDLSurface** psurface = &surface)
			{
				int ret = SDLLockTextureToSurfaceNative(texture, rect, (SDLSurface**)psurface);
				return ret;
			}
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access, and expose<br/>
		/// it as a SDL surface.<br/>
		/// Besides providing an SDL_Surface instead of raw pixel data, this function<br/>
		/// operates like SDL_LockTexture.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// The returned surface is freed internally after calling SDL_UnlockTexture()<br/>
		/// or SDL_DestroyTexture(). The caller should not free it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockTextureToSurface")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLockTextureToSurface([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface**")] ref SDLSurface* surface)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLSurface** psurface = &surface)
				{
					int ret = SDLLockTextureToSurfaceNative((SDLTexture*)ptexture, rect, (SDLSurface**)psurface);
					return ret;
				}
			}
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access, and expose<br/>
		/// it as a SDL surface.<br/>
		/// Besides providing an SDL_Surface instead of raw pixel data, this function<br/>
		/// operates like SDL_LockTexture.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// The returned surface is freed internally after calling SDL_UnlockTexture()<br/>
		/// or SDL_DestroyTexture(). The caller should not free it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockTextureToSurface")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLockTextureToSurface([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface**")] ref SDLSurface* surface)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (SDLSurface** psurface = &surface)
				{
					int ret = SDLLockTextureToSurfaceNative(texture, (SDLRect*)prect, (SDLSurface**)psurface);
					return ret;
				}
			}
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access, and expose<br/>
		/// it as a SDL surface.<br/>
		/// Besides providing an SDL_Surface instead of raw pixel data, this function<br/>
		/// operates like SDL_LockTexture.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// The returned surface is freed internally after calling SDL_UnlockTexture()<br/>
		/// or SDL_DestroyTexture(). The caller should not free it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockTextureToSurface")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLockTextureToSurface([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface**")] ref SDLSurface* surface)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (SDLSurface** psurface = &surface)
					{
						int ret = SDLLockTextureToSurfaceNative((SDLTexture*)ptexture, (SDLRect*)prect, (SDLSurface**)psurface);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Unlock a texture, uploading the changes to video memory, if needed.<br/>
		/// **Warning**: Please note that SDL_LockTexture() is intended to be<br/>
		/// write-only; it will not guarantee the previous contents of the texture will<br/>
		/// be provided. You must fully initialize any area of a texture that you lock<br/>
		/// before unlocking it, as the pixels might otherwise be uninitialized memory.<br/>
		/// Which is to say: locking and immediately unlocking a texture can result in<br/>
		/// corrupted textures, depending on the renderer in use.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnlockTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SDLUnlockTextureNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLTexture*, void>)vt[750])(texture);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[750])((nint)texture);
			#endif
		}

		/// <summary>
		/// Unlock a texture, uploading the changes to video memory, if needed.<br/>
		/// **Warning**: Please note that SDL_LockTexture() is intended to be<br/>
		/// write-only; it will not guarantee the previous contents of the texture will<br/>
		/// be provided. You must fully initialize any area of a texture that you lock<br/>
		/// before unlocking it, as the pixels might otherwise be uninitialized memory.<br/>
		/// Which is to say: locking and immediately unlocking a texture can result in<br/>
		/// corrupted textures, depending on the renderer in use.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnlockTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLUnlockTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture)
		{
			SDLUnlockTextureNative(texture);
		}

		/// <summary>
		/// Unlock a texture, uploading the changes to video memory, if needed.<br/>
		/// **Warning**: Please note that SDL_LockTexture() is intended to be<br/>
		/// write-only; it will not guarantee the previous contents of the texture will<br/>
		/// be provided. You must fully initialize any area of a texture that you lock<br/>
		/// before unlocking it, as the pixels might otherwise be uninitialized memory.<br/>
		/// Which is to say: locking and immediately unlocking a texture can result in<br/>
		/// corrupted textures, depending on the renderer in use.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnlockTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLUnlockTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				SDLUnlockTextureNative((SDLTexture*)ptexture);
			}
		}

		/// <summary>
		/// Determine whether a renderer supports the use of render targets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderTargetSupported")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		internal static SDLBool SDLRenderTargetSupportedNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLBool>)vt[751])(renderer);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, SDLBool>)vt[751])((nint)renderer);
			#endif
		}

		/// <summary>
		/// Determine whether a renderer supports the use of render targets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderTargetSupported")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLRenderTargetSupported([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer)
		{
			SDLBool ret = SDLRenderTargetSupportedNative(renderer);
			return ret;
		}

		/// <summary>
		/// Determine whether a renderer supports the use of render targets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderTargetSupported")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLRenderTargetSupported([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				SDLBool ret = SDLRenderTargetSupportedNative((SDLRenderer*)prenderer);
				return ret;
			}
		}

		/// <summary>
		/// Set a texture as the current rendering target.<br/>
		/// Before using this function, you should check the<br/>
		/// `SDL_RENDERER_TARGETTEXTURE` bit in the flags of SDL_RendererInfo to see if<br/>
		/// render targets are supported.<br/>
		/// The default render target is the window for which the renderer was created.<br/>
		/// To stop rendering to a texture and render to the window again, call this<br/>
		/// function with a NULL `texture`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetRenderTarget")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLSetRenderTargetNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLTexture*, int>)vt[752])(renderer, texture);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)vt[752])((nint)renderer, (nint)texture);
			#endif
		}

		/// <summary>
		/// Set a texture as the current rendering target.<br/>
		/// Before using this function, you should check the<br/>
		/// `SDL_RENDERER_TARGETTEXTURE` bit in the flags of SDL_RendererInfo to see if<br/>
		/// render targets are supported.<br/>
		/// The default render target is the window for which the renderer was created.<br/>
		/// To stop rendering to a texture and render to the window again, call this<br/>
		/// function with a NULL `texture`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetRenderTarget")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetRenderTarget([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture)
		{
			int ret = SDLSetRenderTargetNative(renderer, texture);
			return ret;
		}

		/// <summary>
		/// Set a texture as the current rendering target.<br/>
		/// Before using this function, you should check the<br/>
		/// `SDL_RENDERER_TARGETTEXTURE` bit in the flags of SDL_RendererInfo to see if<br/>
		/// render targets are supported.<br/>
		/// The default render target is the window for which the renderer was created.<br/>
		/// To stop rendering to a texture and render to the window again, call this<br/>
		/// function with a NULL `texture`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetRenderTarget")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetRenderTarget([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = SDLSetRenderTargetNative((SDLRenderer*)prenderer, texture);
				return ret;
			}
		}

		/// <summary>
		/// Set a texture as the current rendering target.<br/>
		/// Before using this function, you should check the<br/>
		/// `SDL_RENDERER_TARGETTEXTURE` bit in the flags of SDL_RendererInfo to see if<br/>
		/// render targets are supported.<br/>
		/// The default render target is the window for which the renderer was created.<br/>
		/// To stop rendering to a texture and render to the window again, call this<br/>
		/// function with a NULL `texture`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetRenderTarget")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetRenderTarget([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SDLSetRenderTargetNative(renderer, (SDLTexture*)ptexture);
				return ret;
			}
		}

		/// <summary>
		/// Set a texture as the current rendering target.<br/>
		/// Before using this function, you should check the<br/>
		/// `SDL_RENDERER_TARGETTEXTURE` bit in the flags of SDL_RendererInfo to see if<br/>
		/// render targets are supported.<br/>
		/// The default render target is the window for which the renderer was created.<br/>
		/// To stop rendering to a texture and render to the window again, call this<br/>
		/// function with a NULL `texture`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetRenderTarget")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetRenderTarget([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					int ret = SDLSetRenderTargetNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the current render target.<br/>
		/// The default render target is the window for which the renderer was created,<br/>
		/// and is reported a NULL here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRenderTarget")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture*")]
		internal static SDLTexture* SDLGetRenderTargetNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLTexture*>)vt[753])(renderer);
			#else
			return (SDLTexture*)((delegate* unmanaged[Cdecl]<nint, nint>)vt[753])((nint)renderer);
			#endif
		}

		/// <summary>
		/// Get the current render target.<br/>
		/// The default render target is the window for which the renderer was created,<br/>
		/// and is reported a NULL here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRenderTarget")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture*")]
		public static SDLTexture* SDLGetRenderTarget([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer)
		{
			SDLTexture* ret = SDLGetRenderTargetNative(renderer);
			return ret;
		}

		/// <summary>
		/// Get the current render target.<br/>
		/// The default render target is the window for which the renderer was created,<br/>
		/// and is reported a NULL here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRenderTarget")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture*")]
		public static SDLTexture* SDLGetRenderTarget([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				SDLTexture* ret = SDLGetRenderTargetNative((SDLRenderer*)prenderer);
				return ret;
			}
		}

		/// <summary>
		/// Set a device independent resolution for rendering.<br/>
		/// This function uses the viewport and scaling functionality to allow a fixed<br/>
		/// logical resolution for rendering, regardless of the actual output<br/>
		/// resolution. If the actual output resolution doesn't have the same aspect<br/>
		/// ratio the output rendering will be centered within the output display.<br/>
		/// If the output display is a window, mouse and touch events in the window<br/>
		/// will be filtered and scaled so they seem to arrive within the logical<br/>
		/// resolution. The SDL_HINT_MOUSE_RELATIVE_SCALING hint controls whether<br/>
		/// relative motion events are also scaled.<br/>
		/// If this function results in scaling or subpixel drawing by the rendering<br/>
		/// backend, it will be handled using the appropriate quality hints.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderSetLogicalSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLRenderSetLogicalSizeNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int")] int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int")] int h)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, int, int, int>)vt[754])(renderer, w, h);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int, int>)vt[754])((nint)renderer, w, h);
			#endif
		}

		/// <summary>
		/// Set a device independent resolution for rendering.<br/>
		/// This function uses the viewport and scaling functionality to allow a fixed<br/>
		/// logical resolution for rendering, regardless of the actual output<br/>
		/// resolution. If the actual output resolution doesn't have the same aspect<br/>
		/// ratio the output rendering will be centered within the output display.<br/>
		/// If the output display is a window, mouse and touch events in the window<br/>
		/// will be filtered and scaled so they seem to arrive within the logical<br/>
		/// resolution. The SDL_HINT_MOUSE_RELATIVE_SCALING hint controls whether<br/>
		/// relative motion events are also scaled.<br/>
		/// If this function results in scaling or subpixel drawing by the rendering<br/>
		/// backend, it will be handled using the appropriate quality hints.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderSetLogicalSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderSetLogicalSize([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int")] int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int")] int h)
		{
			int ret = SDLRenderSetLogicalSizeNative(renderer, w, h);
			return ret;
		}

		/// <summary>
		/// Set a device independent resolution for rendering.<br/>
		/// This function uses the viewport and scaling functionality to allow a fixed<br/>
		/// logical resolution for rendering, regardless of the actual output<br/>
		/// resolution. If the actual output resolution doesn't have the same aspect<br/>
		/// ratio the output rendering will be centered within the output display.<br/>
		/// If the output display is a window, mouse and touch events in the window<br/>
		/// will be filtered and scaled so they seem to arrive within the logical<br/>
		/// resolution. The SDL_HINT_MOUSE_RELATIVE_SCALING hint controls whether<br/>
		/// relative motion events are also scaled.<br/>
		/// If this function results in scaling or subpixel drawing by the rendering<br/>
		/// backend, it will be handled using the appropriate quality hints.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderSetLogicalSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderSetLogicalSize([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int")] int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int")] int h)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = SDLRenderSetLogicalSizeNative((SDLRenderer*)prenderer, w, h);
				return ret;
			}
		}

		/// <summary>
		/// Get device independent resolution for rendering.<br/>
		/// When using the main rendering target (eg no target texture is set): this<br/>
		/// may return 0 for `w` and `h` if the SDL_Renderer has never had its logical<br/>
		/// size set by SDL_RenderSetLogicalSize(). Otherwise it returns the logical<br/>
		/// width and height.<br/>
		/// When using a target texture: Never return 0 for `w` and `h` at first. Then<br/>
		/// it returns the logical width and height that are set.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetLogicalSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SDLRenderGetLogicalSizeNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLRenderer*, int*, int*, void>)vt[755])(renderer, w, h);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)vt[755])((nint)renderer, (nint)w, (nint)h);
			#endif
		}

		/// <summary>
		/// Get device independent resolution for rendering.<br/>
		/// When using the main rendering target (eg no target texture is set): this<br/>
		/// may return 0 for `w` and `h` if the SDL_Renderer has never had its logical<br/>
		/// size set by SDL_RenderSetLogicalSize(). Otherwise it returns the logical<br/>
		/// width and height.<br/>
		/// When using a target texture: Never return 0 for `w` and `h` at first. Then<br/>
		/// it returns the logical width and height that are set.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetLogicalSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderGetLogicalSize([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			SDLRenderGetLogicalSizeNative(renderer, w, h);
		}

		/// <summary>
		/// Get device independent resolution for rendering.<br/>
		/// When using the main rendering target (eg no target texture is set): this<br/>
		/// may return 0 for `w` and `h` if the SDL_Renderer has never had its logical<br/>
		/// size set by SDL_RenderSetLogicalSize(). Otherwise it returns the logical<br/>
		/// width and height.<br/>
		/// When using a target texture: Never return 0 for `w` and `h` at first. Then<br/>
		/// it returns the logical width and height that are set.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetLogicalSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderGetLogicalSize([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				SDLRenderGetLogicalSizeNative((SDLRenderer*)prenderer, w, h);
			}
		}

		/// <summary>
		/// Get device independent resolution for rendering.<br/>
		/// When using the main rendering target (eg no target texture is set): this<br/>
		/// may return 0 for `w` and `h` if the SDL_Renderer has never had its logical<br/>
		/// size set by SDL_RenderSetLogicalSize(). Otherwise it returns the logical<br/>
		/// width and height.<br/>
		/// When using a target texture: Never return 0 for `w` and `h` at first. Then<br/>
		/// it returns the logical width and height that are set.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetLogicalSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderGetLogicalSize([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (int* pw = &w)
			{
				SDLRenderGetLogicalSizeNative(renderer, (int*)pw, h);
			}
		}

		/// <summary>
		/// Get device independent resolution for rendering.<br/>
		/// When using the main rendering target (eg no target texture is set): this<br/>
		/// may return 0 for `w` and `h` if the SDL_Renderer has never had its logical<br/>
		/// size set by SDL_RenderSetLogicalSize(). Otherwise it returns the logical<br/>
		/// width and height.<br/>
		/// When using a target texture: Never return 0 for `w` and `h` at first. Then<br/>
		/// it returns the logical width and height that are set.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetLogicalSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderGetLogicalSize([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (int* pw = &w)
				{
					SDLRenderGetLogicalSizeNative((SDLRenderer*)prenderer, (int*)pw, h);
				}
			}
		}

		/// <summary>
		/// Get device independent resolution for rendering.<br/>
		/// When using the main rendering target (eg no target texture is set): this<br/>
		/// may return 0 for `w` and `h` if the SDL_Renderer has never had its logical<br/>
		/// size set by SDL_RenderSetLogicalSize(). Otherwise it returns the logical<br/>
		/// width and height.<br/>
		/// When using a target texture: Never return 0 for `w` and `h` at first. Then<br/>
		/// it returns the logical width and height that are set.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetLogicalSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderGetLogicalSize([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (int* ph = &h)
			{
				SDLRenderGetLogicalSizeNative(renderer, w, (int*)ph);
			}
		}

		/// <summary>
		/// Get device independent resolution for rendering.<br/>
		/// When using the main rendering target (eg no target texture is set): this<br/>
		/// may return 0 for `w` and `h` if the SDL_Renderer has never had its logical<br/>
		/// size set by SDL_RenderSetLogicalSize(). Otherwise it returns the logical<br/>
		/// width and height.<br/>
		/// When using a target texture: Never return 0 for `w` and `h` at first. Then<br/>
		/// it returns the logical width and height that are set.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetLogicalSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderGetLogicalSize([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (int* ph = &h)
				{
					SDLRenderGetLogicalSizeNative((SDLRenderer*)prenderer, w, (int*)ph);
				}
			}
		}

		/// <summary>
		/// Get device independent resolution for rendering.<br/>
		/// When using the main rendering target (eg no target texture is set): this<br/>
		/// may return 0 for `w` and `h` if the SDL_Renderer has never had its logical<br/>
		/// size set by SDL_RenderSetLogicalSize(). Otherwise it returns the logical<br/>
		/// width and height.<br/>
		/// When using a target texture: Never return 0 for `w` and `h` at first. Then<br/>
		/// it returns the logical width and height that are set.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetLogicalSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderGetLogicalSize([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (int* pw = &w)
			{
				fixed (int* ph = &h)
				{
					SDLRenderGetLogicalSizeNative(renderer, (int*)pw, (int*)ph);
				}
			}
		}

		/// <summary>
		/// Get device independent resolution for rendering.<br/>
		/// When using the main rendering target (eg no target texture is set): this<br/>
		/// may return 0 for `w` and `h` if the SDL_Renderer has never had its logical<br/>
		/// size set by SDL_RenderSetLogicalSize(). Otherwise it returns the logical<br/>
		/// width and height.<br/>
		/// When using a target texture: Never return 0 for `w` and `h` at first. Then<br/>
		/// it returns the logical width and height that are set.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetLogicalSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderGetLogicalSize([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (int* pw = &w)
				{
					fixed (int* ph = &h)
					{
						SDLRenderGetLogicalSizeNative((SDLRenderer*)prenderer, (int*)pw, (int*)ph);
					}
				}
			}
		}

		/// <summary>
		/// Set whether to force integer scales for resolution-independent rendering.<br/>
		/// This function restricts the logical viewport to integer values - that is,<br/>
		/// when a resolution is between two multiples of a logical size, the viewport<br/>
		/// size is rounded down to the lower multiple.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderSetIntegerScale")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLRenderSetIntegerScaleNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "enable")] [NativeName(NativeNameType.Type, "SDL_bool")] SDLBool enable)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLBool, int>)vt[756])(renderer, enable);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, SDLBool, int>)vt[756])((nint)renderer, enable);
			#endif
		}

		/// <summary>
		/// Set whether to force integer scales for resolution-independent rendering.<br/>
		/// This function restricts the logical viewport to integer values - that is,<br/>
		/// when a resolution is between two multiples of a logical size, the viewport<br/>
		/// size is rounded down to the lower multiple.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderSetIntegerScale")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderSetIntegerScale([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "enable")] [NativeName(NativeNameType.Type, "SDL_bool")] SDLBool enable)
		{
			int ret = SDLRenderSetIntegerScaleNative(renderer, enable);
			return ret;
		}

		/// <summary>
		/// Set whether to force integer scales for resolution-independent rendering.<br/>
		/// This function restricts the logical viewport to integer values - that is,<br/>
		/// when a resolution is between two multiples of a logical size, the viewport<br/>
		/// size is rounded down to the lower multiple.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderSetIntegerScale")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderSetIntegerScale([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "enable")] [NativeName(NativeNameType.Type, "SDL_bool")] SDLBool enable)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = SDLRenderSetIntegerScaleNative((SDLRenderer*)prenderer, enable);
				return ret;
			}
		}

		/// <summary>
		/// Get whether integer scales are forced for resolution-independent rendering.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetIntegerScale")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		internal static SDLBool SDLRenderGetIntegerScaleNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLBool>)vt[757])(renderer);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, SDLBool>)vt[757])((nint)renderer);
			#endif
		}

		/// <summary>
		/// Get whether integer scales are forced for resolution-independent rendering.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetIntegerScale")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLRenderGetIntegerScale([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer)
		{
			SDLBool ret = SDLRenderGetIntegerScaleNative(renderer);
			return ret;
		}

		/// <summary>
		/// Get whether integer scales are forced for resolution-independent rendering.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetIntegerScale")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLRenderGetIntegerScale([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				SDLBool ret = SDLRenderGetIntegerScaleNative((SDLRenderer*)prenderer);
				return ret;
			}
		}

		/// <summary>
		/// Set the drawing area for rendering on the current target.<br/>
		/// When the window is resized, the viewport is reset to fill the entire new<br/>
		/// window size.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderSetViewport")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLRenderSetViewportNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLRect*, int>)vt[758])(renderer, rect);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)vt[758])((nint)renderer, (nint)rect);
			#endif
		}

		/// <summary>
		/// Set the drawing area for rendering on the current target.<br/>
		/// When the window is resized, the viewport is reset to fill the entire new<br/>
		/// window size.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderSetViewport")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderSetViewport([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect)
		{
			int ret = SDLRenderSetViewportNative(renderer, rect);
			return ret;
		}

		/// <summary>
		/// Set the drawing area for rendering on the current target.<br/>
		/// When the window is resized, the viewport is reset to fill the entire new<br/>
		/// window size.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderSetViewport")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderSetViewport([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = SDLRenderSetViewportNative((SDLRenderer*)prenderer, rect);
				return ret;
			}
		}

		/// <summary>
		/// Set the drawing area for rendering on the current target.<br/>
		/// When the window is resized, the viewport is reset to fill the entire new<br/>
		/// window size.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderSetViewport")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderSetViewport([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect)
		{
			fixed (SDLRect* prect = &rect)
			{
				int ret = SDLRenderSetViewportNative(renderer, (SDLRect*)prect);
				return ret;
			}
		}

		/// <summary>
		/// Set the drawing area for rendering on the current target.<br/>
		/// When the window is resized, the viewport is reset to fill the entire new<br/>
		/// window size.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderSetViewport")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderSetViewport([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* prect = &rect)
				{
					int ret = SDLRenderSetViewportNative((SDLRenderer*)prenderer, (SDLRect*)prect);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the drawing area for the current target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetViewport")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SDLRenderGetViewportNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* rect)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLRect*, void>)vt[759])(renderer, rect);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)vt[759])((nint)renderer, (nint)rect);
			#endif
		}

		/// <summary>
		/// Get the drawing area for the current target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetViewport")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderGetViewport([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* rect)
		{
			SDLRenderGetViewportNative(renderer, rect);
		}

		/// <summary>
		/// Get the drawing area for the current target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetViewport")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderGetViewport([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				SDLRenderGetViewportNative((SDLRenderer*)prenderer, rect);
			}
		}

		/// <summary>
		/// Get the drawing area for the current target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetViewport")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderGetViewport([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect rect)
		{
			fixed (SDLRect* prect = &rect)
			{
				SDLRenderGetViewportNative(renderer, (SDLRect*)prect);
			}
		}

		/// <summary>
		/// Get the drawing area for the current target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetViewport")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderGetViewport([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* prect = &rect)
				{
					SDLRenderGetViewportNative((SDLRenderer*)prenderer, (SDLRect*)prect);
				}
			}
		}

		/// <summary>
		/// Set the clip rectangle for rendering on the specified target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderSetClipRect")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLRenderSetClipRectNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLRect*, int>)vt[760])(renderer, rect);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)vt[760])((nint)renderer, (nint)rect);
			#endif
		}

		/// <summary>
		/// Set the clip rectangle for rendering on the specified target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderSetClipRect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderSetClipRect([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect)
		{
			int ret = SDLRenderSetClipRectNative(renderer, rect);
			return ret;
		}

		/// <summary>
		/// Set the clip rectangle for rendering on the specified target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderSetClipRect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderSetClipRect([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = SDLRenderSetClipRectNative((SDLRenderer*)prenderer, rect);
				return ret;
			}
		}

		/// <summary>
		/// Set the clip rectangle for rendering on the specified target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderSetClipRect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderSetClipRect([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect)
		{
			fixed (SDLRect* prect = &rect)
			{
				int ret = SDLRenderSetClipRectNative(renderer, (SDLRect*)prect);
				return ret;
			}
		}

		/// <summary>
		/// Set the clip rectangle for rendering on the specified target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderSetClipRect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderSetClipRect([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* prect = &rect)
				{
					int ret = SDLRenderSetClipRectNative((SDLRenderer*)prenderer, (SDLRect*)prect);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the clip rectangle for the current target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetClipRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SDLRenderGetClipRectNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* rect)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLRect*, void>)vt[761])(renderer, rect);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)vt[761])((nint)renderer, (nint)rect);
			#endif
		}

		/// <summary>
		/// Get the clip rectangle for the current target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetClipRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderGetClipRect([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* rect)
		{
			SDLRenderGetClipRectNative(renderer, rect);
		}

		/// <summary>
		/// Get the clip rectangle for the current target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetClipRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderGetClipRect([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				SDLRenderGetClipRectNative((SDLRenderer*)prenderer, rect);
			}
		}

		/// <summary>
		/// Get the clip rectangle for the current target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetClipRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderGetClipRect([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect rect)
		{
			fixed (SDLRect* prect = &rect)
			{
				SDLRenderGetClipRectNative(renderer, (SDLRect*)prect);
			}
		}

		/// <summary>
		/// Get the clip rectangle for the current target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetClipRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderGetClipRect([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* prect = &rect)
				{
					SDLRenderGetClipRectNative((SDLRenderer*)prenderer, (SDLRect*)prect);
				}
			}
		}

		/// <summary>
		/// Get whether clipping is enabled on the given renderer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderIsClipEnabled")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		internal static SDLBool SDLRenderIsClipEnabledNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLBool>)vt[762])(renderer);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, SDLBool>)vt[762])((nint)renderer);
			#endif
		}

		/// <summary>
		/// Get whether clipping is enabled on the given renderer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderIsClipEnabled")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLRenderIsClipEnabled([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer)
		{
			SDLBool ret = SDLRenderIsClipEnabledNative(renderer);
			return ret;
		}

		/// <summary>
		/// Get whether clipping is enabled on the given renderer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderIsClipEnabled")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLRenderIsClipEnabled([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				SDLBool ret = SDLRenderIsClipEnabledNative((SDLRenderer*)prenderer);
				return ret;
			}
		}

		/// <summary>
		/// Set the drawing scale for rendering on the current target.<br/>
		/// The drawing coordinates are scaled by the x/y scaling factors before they<br/>
		/// are used by the renderer. This allows resolution independent drawing with a<br/>
		/// single coordinate system.<br/>
		/// If this results in scaling or subpixel drawing by the rendering backend, it<br/>
		/// will be handled using the appropriate quality hints. For best results use<br/>
		/// integer scaling factors.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderSetScale")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLRenderSetScaleNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "scaleX")] [NativeName(NativeNameType.Type, "float")] float scaleX, [NativeName(NativeNameType.Param, "scaleY")] [NativeName(NativeNameType.Type, "float")] float scaleY)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, float, float, int>)vt[763])(renderer, scaleX, scaleY);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, float, float, int>)vt[763])((nint)renderer, scaleX, scaleY);
			#endif
		}

		/// <summary>
		/// Set the drawing scale for rendering on the current target.<br/>
		/// The drawing coordinates are scaled by the x/y scaling factors before they<br/>
		/// are used by the renderer. This allows resolution independent drawing with a<br/>
		/// single coordinate system.<br/>
		/// If this results in scaling or subpixel drawing by the rendering backend, it<br/>
		/// will be handled using the appropriate quality hints. For best results use<br/>
		/// integer scaling factors.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderSetScale")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderSetScale([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "scaleX")] [NativeName(NativeNameType.Type, "float")] float scaleX, [NativeName(NativeNameType.Param, "scaleY")] [NativeName(NativeNameType.Type, "float")] float scaleY)
		{
			int ret = SDLRenderSetScaleNative(renderer, scaleX, scaleY);
			return ret;
		}

		/// <summary>
		/// Set the drawing scale for rendering on the current target.<br/>
		/// The drawing coordinates are scaled by the x/y scaling factors before they<br/>
		/// are used by the renderer. This allows resolution independent drawing with a<br/>
		/// single coordinate system.<br/>
		/// If this results in scaling or subpixel drawing by the rendering backend, it<br/>
		/// will be handled using the appropriate quality hints. For best results use<br/>
		/// integer scaling factors.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderSetScale")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderSetScale([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "scaleX")] [NativeName(NativeNameType.Type, "float")] float scaleX, [NativeName(NativeNameType.Param, "scaleY")] [NativeName(NativeNameType.Type, "float")] float scaleY)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = SDLRenderSetScaleNative((SDLRenderer*)prenderer, scaleX, scaleY);
				return ret;
			}
		}

		/// <summary>
		/// Get the drawing scale for the current target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetScale")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SDLRenderGetScaleNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "scaleX")] [NativeName(NativeNameType.Type, "float*")] float* scaleX, [NativeName(NativeNameType.Param, "scaleY")] [NativeName(NativeNameType.Type, "float*")] float* scaleY)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLRenderer*, float*, float*, void>)vt[764])(renderer, scaleX, scaleY);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)vt[764])((nint)renderer, (nint)scaleX, (nint)scaleY);
			#endif
		}

		/// <summary>
		/// Get the drawing scale for the current target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetScale")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderGetScale([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "scaleX")] [NativeName(NativeNameType.Type, "float*")] float* scaleX, [NativeName(NativeNameType.Param, "scaleY")] [NativeName(NativeNameType.Type, "float*")] float* scaleY)
		{
			SDLRenderGetScaleNative(renderer, scaleX, scaleY);
		}

		/// <summary>
		/// Get the drawing scale for the current target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetScale")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderGetScale([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "scaleX")] [NativeName(NativeNameType.Type, "float*")] float* scaleX, [NativeName(NativeNameType.Param, "scaleY")] [NativeName(NativeNameType.Type, "float*")] float* scaleY)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				SDLRenderGetScaleNative((SDLRenderer*)prenderer, scaleX, scaleY);
			}
		}

		/// <summary>
		/// Get the drawing scale for the current target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetScale")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderGetScale([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "scaleX")] [NativeName(NativeNameType.Type, "float*")] ref float scaleX, [NativeName(NativeNameType.Param, "scaleY")] [NativeName(NativeNameType.Type, "float*")] float* scaleY)
		{
			fixed (float* pscaleX = &scaleX)
			{
				SDLRenderGetScaleNative(renderer, (float*)pscaleX, scaleY);
			}
		}

		/// <summary>
		/// Get the drawing scale for the current target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetScale")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderGetScale([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "scaleX")] [NativeName(NativeNameType.Type, "float*")] ref float scaleX, [NativeName(NativeNameType.Param, "scaleY")] [NativeName(NativeNameType.Type, "float*")] float* scaleY)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* pscaleX = &scaleX)
				{
					SDLRenderGetScaleNative((SDLRenderer*)prenderer, (float*)pscaleX, scaleY);
				}
			}
		}

		/// <summary>
		/// Get the drawing scale for the current target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetScale")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderGetScale([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "scaleX")] [NativeName(NativeNameType.Type, "float*")] float* scaleX, [NativeName(NativeNameType.Param, "scaleY")] [NativeName(NativeNameType.Type, "float*")] ref float scaleY)
		{
			fixed (float* pscaleY = &scaleY)
			{
				SDLRenderGetScaleNative(renderer, scaleX, (float*)pscaleY);
			}
		}

		/// <summary>
		/// Get the drawing scale for the current target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetScale")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderGetScale([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "scaleX")] [NativeName(NativeNameType.Type, "float*")] float* scaleX, [NativeName(NativeNameType.Param, "scaleY")] [NativeName(NativeNameType.Type, "float*")] ref float scaleY)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* pscaleY = &scaleY)
				{
					SDLRenderGetScaleNative((SDLRenderer*)prenderer, scaleX, (float*)pscaleY);
				}
			}
		}

		/// <summary>
		/// Get the drawing scale for the current target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetScale")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderGetScale([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "scaleX")] [NativeName(NativeNameType.Type, "float*")] ref float scaleX, [NativeName(NativeNameType.Param, "scaleY")] [NativeName(NativeNameType.Type, "float*")] ref float scaleY)
		{
			fixed (float* pscaleX = &scaleX)
			{
				fixed (float* pscaleY = &scaleY)
				{
					SDLRenderGetScaleNative(renderer, (float*)pscaleX, (float*)pscaleY);
				}
			}
		}

		/// <summary>
		/// Get the drawing scale for the current target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetScale")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderGetScale([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "scaleX")] [NativeName(NativeNameType.Type, "float*")] ref float scaleX, [NativeName(NativeNameType.Param, "scaleY")] [NativeName(NativeNameType.Type, "float*")] ref float scaleY)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* pscaleX = &scaleX)
				{
					fixed (float* pscaleY = &scaleY)
					{
						SDLRenderGetScaleNative((SDLRenderer*)prenderer, (float*)pscaleX, (float*)pscaleY);
					}
				}
			}
		}

		/// <summary>
		/// Get logical coordinates of point in renderer when given real coordinates of<br/>
		/// point in window.<br/>
		/// Logical coordinates will differ from real coordinates when render is scaled<br/>
		/// and logical renderer size set<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderWindowToLogical")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SDLRenderWindowToLogicalNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "windowX")] [NativeName(NativeNameType.Type, "int")] int windowX, [NativeName(NativeNameType.Param, "windowY")] [NativeName(NativeNameType.Type, "int")] int windowY, [NativeName(NativeNameType.Param, "logicalX")] [NativeName(NativeNameType.Type, "float*")] float* logicalX, [NativeName(NativeNameType.Param, "logicalY")] [NativeName(NativeNameType.Type, "float*")] float* logicalY)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLRenderer*, int, int, float*, float*, void>)vt[765])(renderer, windowX, windowY, logicalX, logicalY);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, int, nint, nint, void>)vt[765])((nint)renderer, windowX, windowY, (nint)logicalX, (nint)logicalY);
			#endif
		}

		/// <summary>
		/// Get logical coordinates of point in renderer when given real coordinates of<br/>
		/// point in window.<br/>
		/// Logical coordinates will differ from real coordinates when render is scaled<br/>
		/// and logical renderer size set<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderWindowToLogical")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderWindowToLogical([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "windowX")] [NativeName(NativeNameType.Type, "int")] int windowX, [NativeName(NativeNameType.Param, "windowY")] [NativeName(NativeNameType.Type, "int")] int windowY, [NativeName(NativeNameType.Param, "logicalX")] [NativeName(NativeNameType.Type, "float*")] float* logicalX, [NativeName(NativeNameType.Param, "logicalY")] [NativeName(NativeNameType.Type, "float*")] float* logicalY)
		{
			SDLRenderWindowToLogicalNative(renderer, windowX, windowY, logicalX, logicalY);
		}

		/// <summary>
		/// Get logical coordinates of point in renderer when given real coordinates of<br/>
		/// point in window.<br/>
		/// Logical coordinates will differ from real coordinates when render is scaled<br/>
		/// and logical renderer size set<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderWindowToLogical")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderWindowToLogical([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "windowX")] [NativeName(NativeNameType.Type, "int")] int windowX, [NativeName(NativeNameType.Param, "windowY")] [NativeName(NativeNameType.Type, "int")] int windowY, [NativeName(NativeNameType.Param, "logicalX")] [NativeName(NativeNameType.Type, "float*")] float* logicalX, [NativeName(NativeNameType.Param, "logicalY")] [NativeName(NativeNameType.Type, "float*")] float* logicalY)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				SDLRenderWindowToLogicalNative((SDLRenderer*)prenderer, windowX, windowY, logicalX, logicalY);
			}
		}

		/// <summary>
		/// Get logical coordinates of point in renderer when given real coordinates of<br/>
		/// point in window.<br/>
		/// Logical coordinates will differ from real coordinates when render is scaled<br/>
		/// and logical renderer size set<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderWindowToLogical")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderWindowToLogical([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "windowX")] [NativeName(NativeNameType.Type, "int")] int windowX, [NativeName(NativeNameType.Param, "windowY")] [NativeName(NativeNameType.Type, "int")] int windowY, [NativeName(NativeNameType.Param, "logicalX")] [NativeName(NativeNameType.Type, "float*")] ref float logicalX, [NativeName(NativeNameType.Param, "logicalY")] [NativeName(NativeNameType.Type, "float*")] float* logicalY)
		{
			fixed (float* plogicalX = &logicalX)
			{
				SDLRenderWindowToLogicalNative(renderer, windowX, windowY, (float*)plogicalX, logicalY);
			}
		}

		/// <summary>
		/// Get logical coordinates of point in renderer when given real coordinates of<br/>
		/// point in window.<br/>
		/// Logical coordinates will differ from real coordinates when render is scaled<br/>
		/// and logical renderer size set<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderWindowToLogical")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderWindowToLogical([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "windowX")] [NativeName(NativeNameType.Type, "int")] int windowX, [NativeName(NativeNameType.Param, "windowY")] [NativeName(NativeNameType.Type, "int")] int windowY, [NativeName(NativeNameType.Param, "logicalX")] [NativeName(NativeNameType.Type, "float*")] ref float logicalX, [NativeName(NativeNameType.Param, "logicalY")] [NativeName(NativeNameType.Type, "float*")] float* logicalY)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* plogicalX = &logicalX)
				{
					SDLRenderWindowToLogicalNative((SDLRenderer*)prenderer, windowX, windowY, (float*)plogicalX, logicalY);
				}
			}
		}

		/// <summary>
		/// Get logical coordinates of point in renderer when given real coordinates of<br/>
		/// point in window.<br/>
		/// Logical coordinates will differ from real coordinates when render is scaled<br/>
		/// and logical renderer size set<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderWindowToLogical")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderWindowToLogical([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "windowX")] [NativeName(NativeNameType.Type, "int")] int windowX, [NativeName(NativeNameType.Param, "windowY")] [NativeName(NativeNameType.Type, "int")] int windowY, [NativeName(NativeNameType.Param, "logicalX")] [NativeName(NativeNameType.Type, "float*")] float* logicalX, [NativeName(NativeNameType.Param, "logicalY")] [NativeName(NativeNameType.Type, "float*")] ref float logicalY)
		{
			fixed (float* plogicalY = &logicalY)
			{
				SDLRenderWindowToLogicalNative(renderer, windowX, windowY, logicalX, (float*)plogicalY);
			}
		}

		/// <summary>
		/// Get logical coordinates of point in renderer when given real coordinates of<br/>
		/// point in window.<br/>
		/// Logical coordinates will differ from real coordinates when render is scaled<br/>
		/// and logical renderer size set<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderWindowToLogical")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderWindowToLogical([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "windowX")] [NativeName(NativeNameType.Type, "int")] int windowX, [NativeName(NativeNameType.Param, "windowY")] [NativeName(NativeNameType.Type, "int")] int windowY, [NativeName(NativeNameType.Param, "logicalX")] [NativeName(NativeNameType.Type, "float*")] float* logicalX, [NativeName(NativeNameType.Param, "logicalY")] [NativeName(NativeNameType.Type, "float*")] ref float logicalY)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* plogicalY = &logicalY)
				{
					SDLRenderWindowToLogicalNative((SDLRenderer*)prenderer, windowX, windowY, logicalX, (float*)plogicalY);
				}
			}
		}

		/// <summary>
		/// Get logical coordinates of point in renderer when given real coordinates of<br/>
		/// point in window.<br/>
		/// Logical coordinates will differ from real coordinates when render is scaled<br/>
		/// and logical renderer size set<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderWindowToLogical")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderWindowToLogical([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "windowX")] [NativeName(NativeNameType.Type, "int")] int windowX, [NativeName(NativeNameType.Param, "windowY")] [NativeName(NativeNameType.Type, "int")] int windowY, [NativeName(NativeNameType.Param, "logicalX")] [NativeName(NativeNameType.Type, "float*")] ref float logicalX, [NativeName(NativeNameType.Param, "logicalY")] [NativeName(NativeNameType.Type, "float*")] ref float logicalY)
		{
			fixed (float* plogicalX = &logicalX)
			{
				fixed (float* plogicalY = &logicalY)
				{
					SDLRenderWindowToLogicalNative(renderer, windowX, windowY, (float*)plogicalX, (float*)plogicalY);
				}
			}
		}

		/// <summary>
		/// Get logical coordinates of point in renderer when given real coordinates of<br/>
		/// point in window.<br/>
		/// Logical coordinates will differ from real coordinates when render is scaled<br/>
		/// and logical renderer size set<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderWindowToLogical")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderWindowToLogical([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "windowX")] [NativeName(NativeNameType.Type, "int")] int windowX, [NativeName(NativeNameType.Param, "windowY")] [NativeName(NativeNameType.Type, "int")] int windowY, [NativeName(NativeNameType.Param, "logicalX")] [NativeName(NativeNameType.Type, "float*")] ref float logicalX, [NativeName(NativeNameType.Param, "logicalY")] [NativeName(NativeNameType.Type, "float*")] ref float logicalY)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* plogicalX = &logicalX)
				{
					fixed (float* plogicalY = &logicalY)
					{
						SDLRenderWindowToLogicalNative((SDLRenderer*)prenderer, windowX, windowY, (float*)plogicalX, (float*)plogicalY);
					}
				}
			}
		}

		/// <summary>
		/// Get real coordinates of point in window when given logical coordinates of<br/>
		/// point in renderer.<br/>
		/// Logical coordinates will differ from real coordinates when render is scaled<br/>
		/// and logical renderer size set<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderLogicalToWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SDLRenderLogicalToWindowNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "logicalX")] [NativeName(NativeNameType.Type, "float")] float logicalX, [NativeName(NativeNameType.Param, "logicalY")] [NativeName(NativeNameType.Type, "float")] float logicalY, [NativeName(NativeNameType.Param, "windowX")] [NativeName(NativeNameType.Type, "int*")] int* windowX, [NativeName(NativeNameType.Param, "windowY")] [NativeName(NativeNameType.Type, "int*")] int* windowY)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLRenderer*, float, float, int*, int*, void>)vt[766])(renderer, logicalX, logicalY, windowX, windowY);
			#else
			((delegate* unmanaged[Cdecl]<nint, float, float, nint, nint, void>)vt[766])((nint)renderer, logicalX, logicalY, (nint)windowX, (nint)windowY);
			#endif
		}

		/// <summary>
		/// Get real coordinates of point in window when given logical coordinates of<br/>
		/// point in renderer.<br/>
		/// Logical coordinates will differ from real coordinates when render is scaled<br/>
		/// and logical renderer size set<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderLogicalToWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderLogicalToWindow([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "logicalX")] [NativeName(NativeNameType.Type, "float")] float logicalX, [NativeName(NativeNameType.Param, "logicalY")] [NativeName(NativeNameType.Type, "float")] float logicalY, [NativeName(NativeNameType.Param, "windowX")] [NativeName(NativeNameType.Type, "int*")] int* windowX, [NativeName(NativeNameType.Param, "windowY")] [NativeName(NativeNameType.Type, "int*")] int* windowY)
		{
			SDLRenderLogicalToWindowNative(renderer, logicalX, logicalY, windowX, windowY);
		}

		/// <summary>
		/// Get real coordinates of point in window when given logical coordinates of<br/>
		/// point in renderer.<br/>
		/// Logical coordinates will differ from real coordinates when render is scaled<br/>
		/// and logical renderer size set<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderLogicalToWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderLogicalToWindow([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "logicalX")] [NativeName(NativeNameType.Type, "float")] float logicalX, [NativeName(NativeNameType.Param, "logicalY")] [NativeName(NativeNameType.Type, "float")] float logicalY, [NativeName(NativeNameType.Param, "windowX")] [NativeName(NativeNameType.Type, "int*")] int* windowX, [NativeName(NativeNameType.Param, "windowY")] [NativeName(NativeNameType.Type, "int*")] int* windowY)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				SDLRenderLogicalToWindowNative((SDLRenderer*)prenderer, logicalX, logicalY, windowX, windowY);
			}
		}

		/// <summary>
		/// Get real coordinates of point in window when given logical coordinates of<br/>
		/// point in renderer.<br/>
		/// Logical coordinates will differ from real coordinates when render is scaled<br/>
		/// and logical renderer size set<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderLogicalToWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderLogicalToWindow([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "logicalX")] [NativeName(NativeNameType.Type, "float")] float logicalX, [NativeName(NativeNameType.Param, "logicalY")] [NativeName(NativeNameType.Type, "float")] float logicalY, [NativeName(NativeNameType.Param, "windowX")] [NativeName(NativeNameType.Type, "int*")] ref int windowX, [NativeName(NativeNameType.Param, "windowY")] [NativeName(NativeNameType.Type, "int*")] int* windowY)
		{
			fixed (int* pwindowX = &windowX)
			{
				SDLRenderLogicalToWindowNative(renderer, logicalX, logicalY, (int*)pwindowX, windowY);
			}
		}

		/// <summary>
		/// Get real coordinates of point in window when given logical coordinates of<br/>
		/// point in renderer.<br/>
		/// Logical coordinates will differ from real coordinates when render is scaled<br/>
		/// and logical renderer size set<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderLogicalToWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderLogicalToWindow([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "logicalX")] [NativeName(NativeNameType.Type, "float")] float logicalX, [NativeName(NativeNameType.Param, "logicalY")] [NativeName(NativeNameType.Type, "float")] float logicalY, [NativeName(NativeNameType.Param, "windowX")] [NativeName(NativeNameType.Type, "int*")] ref int windowX, [NativeName(NativeNameType.Param, "windowY")] [NativeName(NativeNameType.Type, "int*")] int* windowY)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (int* pwindowX = &windowX)
				{
					SDLRenderLogicalToWindowNative((SDLRenderer*)prenderer, logicalX, logicalY, (int*)pwindowX, windowY);
				}
			}
		}

		/// <summary>
		/// Get real coordinates of point in window when given logical coordinates of<br/>
		/// point in renderer.<br/>
		/// Logical coordinates will differ from real coordinates when render is scaled<br/>
		/// and logical renderer size set<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderLogicalToWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderLogicalToWindow([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "logicalX")] [NativeName(NativeNameType.Type, "float")] float logicalX, [NativeName(NativeNameType.Param, "logicalY")] [NativeName(NativeNameType.Type, "float")] float logicalY, [NativeName(NativeNameType.Param, "windowX")] [NativeName(NativeNameType.Type, "int*")] int* windowX, [NativeName(NativeNameType.Param, "windowY")] [NativeName(NativeNameType.Type, "int*")] ref int windowY)
		{
			fixed (int* pwindowY = &windowY)
			{
				SDLRenderLogicalToWindowNative(renderer, logicalX, logicalY, windowX, (int*)pwindowY);
			}
		}

		/// <summary>
		/// Get real coordinates of point in window when given logical coordinates of<br/>
		/// point in renderer.<br/>
		/// Logical coordinates will differ from real coordinates when render is scaled<br/>
		/// and logical renderer size set<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderLogicalToWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderLogicalToWindow([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "logicalX")] [NativeName(NativeNameType.Type, "float")] float logicalX, [NativeName(NativeNameType.Param, "logicalY")] [NativeName(NativeNameType.Type, "float")] float logicalY, [NativeName(NativeNameType.Param, "windowX")] [NativeName(NativeNameType.Type, "int*")] int* windowX, [NativeName(NativeNameType.Param, "windowY")] [NativeName(NativeNameType.Type, "int*")] ref int windowY)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (int* pwindowY = &windowY)
				{
					SDLRenderLogicalToWindowNative((SDLRenderer*)prenderer, logicalX, logicalY, windowX, (int*)pwindowY);
				}
			}
		}

		/// <summary>
		/// Get real coordinates of point in window when given logical coordinates of<br/>
		/// point in renderer.<br/>
		/// Logical coordinates will differ from real coordinates when render is scaled<br/>
		/// and logical renderer size set<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderLogicalToWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderLogicalToWindow([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "logicalX")] [NativeName(NativeNameType.Type, "float")] float logicalX, [NativeName(NativeNameType.Param, "logicalY")] [NativeName(NativeNameType.Type, "float")] float logicalY, [NativeName(NativeNameType.Param, "windowX")] [NativeName(NativeNameType.Type, "int*")] ref int windowX, [NativeName(NativeNameType.Param, "windowY")] [NativeName(NativeNameType.Type, "int*")] ref int windowY)
		{
			fixed (int* pwindowX = &windowX)
			{
				fixed (int* pwindowY = &windowY)
				{
					SDLRenderLogicalToWindowNative(renderer, logicalX, logicalY, (int*)pwindowX, (int*)pwindowY);
				}
			}
		}

		/// <summary>
		/// Get real coordinates of point in window when given logical coordinates of<br/>
		/// point in renderer.<br/>
		/// Logical coordinates will differ from real coordinates when render is scaled<br/>
		/// and logical renderer size set<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderLogicalToWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderLogicalToWindow([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "logicalX")] [NativeName(NativeNameType.Type, "float")] float logicalX, [NativeName(NativeNameType.Param, "logicalY")] [NativeName(NativeNameType.Type, "float")] float logicalY, [NativeName(NativeNameType.Param, "windowX")] [NativeName(NativeNameType.Type, "int*")] ref int windowX, [NativeName(NativeNameType.Param, "windowY")] [NativeName(NativeNameType.Type, "int*")] ref int windowY)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (int* pwindowX = &windowX)
				{
					fixed (int* pwindowY = &windowY)
					{
						SDLRenderLogicalToWindowNative((SDLRenderer*)prenderer, logicalX, logicalY, (int*)pwindowX, (int*)pwindowY);
					}
				}
			}
		}

		/// <summary>
		/// Set the color used for drawing operations (Rect, Line and Clear).<br/>
		/// Set the color for drawing or filling rectangles, lines, and points, and for<br/>
		/// SDL_RenderClear().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLSetRenderDrawColorNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8")] byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8")] byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8")] byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8")] byte a)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, byte, byte, byte, byte, int>)vt[767])(renderer, r, g, b, a);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, byte, byte, byte, byte, int>)vt[767])((nint)renderer, r, g, b, a);
			#endif
		}

		/// <summary>
		/// Set the color used for drawing operations (Rect, Line and Clear).<br/>
		/// Set the color for drawing or filling rectangles, lines, and points, and for<br/>
		/// SDL_RenderClear().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8")] byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8")] byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8")] byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8")] byte a)
		{
			int ret = SDLSetRenderDrawColorNative(renderer, r, g, b, a);
			return ret;
		}

		/// <summary>
		/// Set the color used for drawing operations (Rect, Line and Clear).<br/>
		/// Set the color for drawing or filling rectangles, lines, and points, and for<br/>
		/// SDL_RenderClear().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8")] byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8")] byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8")] byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8")] byte a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = SDLSetRenderDrawColorNative((SDLRenderer*)prenderer, r, g, b, a);
				return ret;
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLGetRenderDrawColorNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] byte* a)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, byte*, byte*, byte*, byte*, int>)vt[768])(renderer, r, g, b, a);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint, int>)vt[768])((nint)renderer, (nint)r, (nint)g, (nint)b, (nint)a);
			#endif
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] byte* a)
		{
			int ret = SDLGetRenderDrawColorNative(renderer, r, g, b, a);
			return ret;
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] byte* a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = SDLGetRenderDrawColorNative((SDLRenderer*)prenderer, r, g, b, a);
				return ret;
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] byte* a)
		{
			fixed (byte* pr = &r)
			{
				int ret = SDLGetRenderDrawColorNative(renderer, (byte*)pr, g, b, a);
				return ret;
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] byte* a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* pr = &r)
				{
					int ret = SDLGetRenderDrawColorNative((SDLRenderer*)prenderer, (byte*)pr, g, b, a);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] byte* a)
		{
			fixed (byte* pg = &g)
			{
				int ret = SDLGetRenderDrawColorNative(renderer, r, (byte*)pg, b, a);
				return ret;
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] byte* a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* pg = &g)
				{
					int ret = SDLGetRenderDrawColorNative((SDLRenderer*)prenderer, r, (byte*)pg, b, a);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] byte* a)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					int ret = SDLGetRenderDrawColorNative(renderer, (byte*)pr, (byte*)pg, b, a);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] byte* a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						int ret = SDLGetRenderDrawColorNative((SDLRenderer*)prenderer, (byte*)pr, (byte*)pg, b, a);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] byte* a)
		{
			fixed (byte* pb = &b)
			{
				int ret = SDLGetRenderDrawColorNative(renderer, r, g, (byte*)pb, a);
				return ret;
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] byte* a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* pb = &b)
				{
					int ret = SDLGetRenderDrawColorNative((SDLRenderer*)prenderer, r, g, (byte*)pb, a);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] byte* a)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pb = &b)
				{
					int ret = SDLGetRenderDrawColorNative(renderer, (byte*)pr, g, (byte*)pb, a);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] byte* a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pb = &b)
					{
						int ret = SDLGetRenderDrawColorNative((SDLRenderer*)prenderer, (byte*)pr, g, (byte*)pb, a);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] byte* a)
		{
			fixed (byte* pg = &g)
			{
				fixed (byte* pb = &b)
				{
					int ret = SDLGetRenderDrawColorNative(renderer, r, (byte*)pg, (byte*)pb, a);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] byte* a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						int ret = SDLGetRenderDrawColorNative((SDLRenderer*)prenderer, r, (byte*)pg, (byte*)pb, a);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] byte* a)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						int ret = SDLGetRenderDrawColorNative(renderer, (byte*)pr, (byte*)pg, (byte*)pb, a);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] byte* a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						fixed (byte* pb = &b)
						{
							int ret = SDLGetRenderDrawColorNative((SDLRenderer*)prenderer, (byte*)pr, (byte*)pg, (byte*)pb, a);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (byte* pa = &a)
			{
				int ret = SDLGetRenderDrawColorNative(renderer, r, g, b, (byte*)pa);
				return ret;
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* pa = &a)
				{
					int ret = SDLGetRenderDrawColorNative((SDLRenderer*)prenderer, r, g, b, (byte*)pa);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pa = &a)
				{
					int ret = SDLGetRenderDrawColorNative(renderer, (byte*)pr, g, b, (byte*)pa);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pa = &a)
					{
						int ret = SDLGetRenderDrawColorNative((SDLRenderer*)prenderer, (byte*)pr, g, b, (byte*)pa);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (byte* pg = &g)
			{
				fixed (byte* pa = &a)
				{
					int ret = SDLGetRenderDrawColorNative(renderer, r, (byte*)pg, b, (byte*)pa);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pa = &a)
					{
						int ret = SDLGetRenderDrawColorNative((SDLRenderer*)prenderer, r, (byte*)pg, b, (byte*)pa);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pa = &a)
					{
						int ret = SDLGetRenderDrawColorNative(renderer, (byte*)pr, (byte*)pg, b, (byte*)pa);
						return ret;
					}
				}
			}
		}
	}
}
