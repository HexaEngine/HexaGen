// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL2
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Convert a string into SDL_GameControllerAxis enum.<br/>
		/// This function is called internally to translate SDL_GameController mapping<br/>
		/// strings for the underlying joystick device into the consistent<br/>
		/// SDL_GameController mapping. You do not normally need to call this function<br/>
		/// unless you are parsing SDL_GameController mappings in your own code.<br/>
		/// Note specially that "righttrigger" and "lefttrigger" map to<br/>
		/// `SDL_CONTROLLER_AXIS_TRIGGERRIGHT` and `SDL_CONTROLLER_AXIS_TRIGGERLEFT`,<br/>
		/// respectively.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetAxisFromString")]
		[return: NativeName(NativeNameType.Type, "SDL_GameControllerAxis")]
		public static SDLGameControllerAxis SDLGameControllerGetAxisFromString([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> str)
		{
			fixed (byte* pstr = str)
			{
				SDLGameControllerAxis ret = SDLGameControllerGetAxisFromStringNative((byte*)pstr);
				return ret;
			}
		}

		/// <summary>
		/// Convert a string into SDL_GameControllerAxis enum.<br/>
		/// This function is called internally to translate SDL_GameController mapping<br/>
		/// strings for the underlying joystick device into the consistent<br/>
		/// SDL_GameController mapping. You do not normally need to call this function<br/>
		/// unless you are parsing SDL_GameController mappings in your own code.<br/>
		/// Note specially that "righttrigger" and "lefttrigger" map to<br/>
		/// `SDL_CONTROLLER_AXIS_TRIGGERRIGHT` and `SDL_CONTROLLER_AXIS_TRIGGERLEFT`,<br/>
		/// respectively.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetAxisFromString")]
		[return: NativeName(NativeNameType.Type, "SDL_GameControllerAxis")]
		public static SDLGameControllerAxis SDLGameControllerGetAxisFromString([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLGameControllerAxis ret = SDLGameControllerGetAxisFromStringNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Convert from an SDL_GameControllerAxis enum to a string.<br/>
		/// The caller should not SDL_free() the returned string.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetStringForAxis")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		internal static byte* SDLGameControllerGetStringForAxisNative([NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "SDL_GameControllerAxis")] SDLGameControllerAxis axis)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGameControllerAxis, byte*>)vt[583])(axis);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<SDLGameControllerAxis, nint>)vt[583])(axis);
			#endif
		}

		/// <summary>
		/// Convert from an SDL_GameControllerAxis enum to a string.<br/>
		/// The caller should not SDL_free() the returned string.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetStringForAxis")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGameControllerGetStringForAxis([NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "SDL_GameControllerAxis")] SDLGameControllerAxis axis)
		{
			byte* ret = SDLGameControllerGetStringForAxisNative(axis);
			return ret;
		}

		/// <summary>
		/// Convert from an SDL_GameControllerAxis enum to a string.<br/>
		/// The caller should not SDL_free() the returned string.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetStringForAxis")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGameControllerGetStringForAxisS([NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "SDL_GameControllerAxis")] SDLGameControllerAxis axis)
		{
			string ret = Utils.DecodeStringUTF8(SDLGameControllerGetStringForAxisNative(axis));
			return ret;
		}

		/// <summary>
		/// Get the SDL joystick layer binding for a controller axis mapping.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetBindForAxis")]
		[return: NativeName(NativeNameType.Type, "SDL_GameControllerButtonBind")]
		internal static SDLGameControllerButtonBind SDLGameControllerGetBindForAxisNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "SDL_GameControllerAxis")] SDLGameControllerAxis axis)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGameController*, SDLGameControllerAxis, SDLGameControllerButtonBind>)vt[584])(gamecontroller, axis);
			#else
			return (SDLGameControllerButtonBind)((delegate* unmanaged[Cdecl]<nint, SDLGameControllerAxis, SDLGameControllerButtonBind>)vt[584])((nint)gamecontroller, axis);
			#endif
		}

		/// <summary>
		/// Get the SDL joystick layer binding for a controller axis mapping.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetBindForAxis")]
		[return: NativeName(NativeNameType.Type, "SDL_GameControllerButtonBind")]
		public static SDLGameControllerButtonBind SDLGameControllerGetBindForAxis([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "SDL_GameControllerAxis")] SDLGameControllerAxis axis)
		{
			SDLGameControllerButtonBind ret = SDLGameControllerGetBindForAxisNative(gamecontroller, axis);
			return ret;
		}

		/// <summary>
		/// Get the SDL joystick layer binding for a controller axis mapping.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetBindForAxis")]
		[return: NativeName(NativeNameType.Type, "SDL_GameControllerButtonBind")]
		public static SDLGameControllerButtonBind SDLGameControllerGetBindForAxis([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "SDL_GameControllerAxis")] SDLGameControllerAxis axis)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				SDLGameControllerButtonBind ret = SDLGameControllerGetBindForAxisNative((SDLGameController*)pgamecontroller, axis);
				return ret;
			}
		}

		/// <summary>
		/// Query whether a game controller has a given axis.<br/>
		/// This merely reports whether the controller's mapping defined this axis, as<br/>
		/// that is all the information SDL has about the physical device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerHasAxis")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		internal static SDLBool SDLGameControllerHasAxisNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "SDL_GameControllerAxis")] SDLGameControllerAxis axis)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGameController*, SDLGameControllerAxis, SDLBool>)vt[585])(gamecontroller, axis);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, SDLGameControllerAxis, SDLBool>)vt[585])((nint)gamecontroller, axis);
			#endif
		}

		/// <summary>
		/// Query whether a game controller has a given axis.<br/>
		/// This merely reports whether the controller's mapping defined this axis, as<br/>
		/// that is all the information SDL has about the physical device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerHasAxis")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLGameControllerHasAxis([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "SDL_GameControllerAxis")] SDLGameControllerAxis axis)
		{
			SDLBool ret = SDLGameControllerHasAxisNative(gamecontroller, axis);
			return ret;
		}

		/// <summary>
		/// Query whether a game controller has a given axis.<br/>
		/// This merely reports whether the controller's mapping defined this axis, as<br/>
		/// that is all the information SDL has about the physical device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerHasAxis")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLGameControllerHasAxis([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "SDL_GameControllerAxis")] SDLGameControllerAxis axis)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				SDLBool ret = SDLGameControllerHasAxisNative((SDLGameController*)pgamecontroller, axis);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of an axis control on a game controller.<br/>
		/// The axis indices start at index 0.<br/>
		/// For thumbsticks, the state is a value ranging from -32768 (up/left)<br/>
		/// to 32767 (down/right).<br/>
		/// Triggers range from 0 when released to 32767 when fully pressed, and<br/>
		/// never return a negative value. Note that this differs from the value<br/>
		/// reported by the lower-level SDL_GetJoystickAxis(), which normally uses<br/>
		/// the full range.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetAxis")]
		[return: NativeName(NativeNameType.Type, "Sint16")]
		internal static short SDLGameControllerGetAxisNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "SDL_GameControllerAxis")] SDLGameControllerAxis axis)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGameController*, SDLGameControllerAxis, short>)vt[586])(gamecontroller, axis);
			#else
			return (short)((delegate* unmanaged[Cdecl]<nint, SDLGameControllerAxis, short>)vt[586])((nint)gamecontroller, axis);
			#endif
		}

		/// <summary>
		/// Get the current state of an axis control on a game controller.<br/>
		/// The axis indices start at index 0.<br/>
		/// For thumbsticks, the state is a value ranging from -32768 (up/left)<br/>
		/// to 32767 (down/right).<br/>
		/// Triggers range from 0 when released to 32767 when fully pressed, and<br/>
		/// never return a negative value. Note that this differs from the value<br/>
		/// reported by the lower-level SDL_GetJoystickAxis(), which normally uses<br/>
		/// the full range.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetAxis")]
		[return: NativeName(NativeNameType.Type, "Sint16")]
		public static short SDLGameControllerGetAxis([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "SDL_GameControllerAxis")] SDLGameControllerAxis axis)
		{
			short ret = SDLGameControllerGetAxisNative(gamecontroller, axis);
			return ret;
		}

		/// <summary>
		/// Get the current state of an axis control on a game controller.<br/>
		/// The axis indices start at index 0.<br/>
		/// For thumbsticks, the state is a value ranging from -32768 (up/left)<br/>
		/// to 32767 (down/right).<br/>
		/// Triggers range from 0 when released to 32767 when fully pressed, and<br/>
		/// never return a negative value. Note that this differs from the value<br/>
		/// reported by the lower-level SDL_GetJoystickAxis(), which normally uses<br/>
		/// the full range.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetAxis")]
		[return: NativeName(NativeNameType.Type, "Sint16")]
		public static short SDLGameControllerGetAxis([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "SDL_GameControllerAxis")] SDLGameControllerAxis axis)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				short ret = SDLGameControllerGetAxisNative((SDLGameController*)pgamecontroller, axis);
				return ret;
			}
		}

		/// <summary>
		/// Convert a string into an SDL_GameControllerButton enum.<br/>
		/// This function is called internally to translate SDL_GameController mapping<br/>
		/// strings for the underlying joystick device into the consistent<br/>
		/// SDL_GameController mapping. You do not normally need to call this function<br/>
		/// unless you are parsing SDL_GameController mappings in your own code.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetButtonFromString")]
		[return: NativeName(NativeNameType.Type, "SDL_GameControllerButton")]
		internal static SDLGameControllerButton SDLGameControllerGetButtonFromStringNative([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] byte* str)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, SDLGameControllerButton>)vt[587])(str);
			#else
			return (SDLGameControllerButton)((delegate* unmanaged[Cdecl]<nint, SDLGameControllerButton>)vt[587])((nint)str);
			#endif
		}

		/// <summary>
		/// Convert a string into an SDL_GameControllerButton enum.<br/>
		/// This function is called internally to translate SDL_GameController mapping<br/>
		/// strings for the underlying joystick device into the consistent<br/>
		/// SDL_GameController mapping. You do not normally need to call this function<br/>
		/// unless you are parsing SDL_GameController mappings in your own code.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetButtonFromString")]
		[return: NativeName(NativeNameType.Type, "SDL_GameControllerButton")]
		public static SDLGameControllerButton SDLGameControllerGetButtonFromString([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] byte* str)
		{
			SDLGameControllerButton ret = SDLGameControllerGetButtonFromStringNative(str);
			return ret;
		}

		/// <summary>
		/// Convert a string into an SDL_GameControllerButton enum.<br/>
		/// This function is called internally to translate SDL_GameController mapping<br/>
		/// strings for the underlying joystick device into the consistent<br/>
		/// SDL_GameController mapping. You do not normally need to call this function<br/>
		/// unless you are parsing SDL_GameController mappings in your own code.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetButtonFromString")]
		[return: NativeName(NativeNameType.Type, "SDL_GameControllerButton")]
		public static SDLGameControllerButton SDLGameControllerGetButtonFromString([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				SDLGameControllerButton ret = SDLGameControllerGetButtonFromStringNative((byte*)pstr);
				return ret;
			}
		}

		/// <summary>
		/// Convert a string into an SDL_GameControllerButton enum.<br/>
		/// This function is called internally to translate SDL_GameController mapping<br/>
		/// strings for the underlying joystick device into the consistent<br/>
		/// SDL_GameController mapping. You do not normally need to call this function<br/>
		/// unless you are parsing SDL_GameController mappings in your own code.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetButtonFromString")]
		[return: NativeName(NativeNameType.Type, "SDL_GameControllerButton")]
		public static SDLGameControllerButton SDLGameControllerGetButtonFromString([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> str)
		{
			fixed (byte* pstr = str)
			{
				SDLGameControllerButton ret = SDLGameControllerGetButtonFromStringNative((byte*)pstr);
				return ret;
			}
		}

		/// <summary>
		/// Convert a string into an SDL_GameControllerButton enum.<br/>
		/// This function is called internally to translate SDL_GameController mapping<br/>
		/// strings for the underlying joystick device into the consistent<br/>
		/// SDL_GameController mapping. You do not normally need to call this function<br/>
		/// unless you are parsing SDL_GameController mappings in your own code.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetButtonFromString")]
		[return: NativeName(NativeNameType.Type, "SDL_GameControllerButton")]
		public static SDLGameControllerButton SDLGameControllerGetButtonFromString([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLGameControllerButton ret = SDLGameControllerGetButtonFromStringNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Convert from an SDL_GameControllerButton enum to a string.<br/>
		/// The caller should not SDL_free() the returned string.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetStringForButton")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		internal static byte* SDLGameControllerGetStringForButtonNative([NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GameControllerButton")] SDLGameControllerButton button)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGameControllerButton, byte*>)vt[588])(button);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<SDLGameControllerButton, nint>)vt[588])(button);
			#endif
		}

		/// <summary>
		/// Convert from an SDL_GameControllerButton enum to a string.<br/>
		/// The caller should not SDL_free() the returned string.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetStringForButton")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGameControllerGetStringForButton([NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GameControllerButton")] SDLGameControllerButton button)
		{
			byte* ret = SDLGameControllerGetStringForButtonNative(button);
			return ret;
		}

		/// <summary>
		/// Convert from an SDL_GameControllerButton enum to a string.<br/>
		/// The caller should not SDL_free() the returned string.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetStringForButton")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGameControllerGetStringForButtonS([NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GameControllerButton")] SDLGameControllerButton button)
		{
			string ret = Utils.DecodeStringUTF8(SDLGameControllerGetStringForButtonNative(button));
			return ret;
		}

		/// <summary>
		/// Get the SDL joystick layer binding for a controller button mapping.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetBindForButton")]
		[return: NativeName(NativeNameType.Type, "SDL_GameControllerButtonBind")]
		internal static SDLGameControllerButtonBind SDLGameControllerGetBindForButtonNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GameControllerButton")] SDLGameControllerButton button)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGameController*, SDLGameControllerButton, SDLGameControllerButtonBind>)vt[589])(gamecontroller, button);
			#else
			return (SDLGameControllerButtonBind)((delegate* unmanaged[Cdecl]<nint, SDLGameControllerButton, SDLGameControllerButtonBind>)vt[589])((nint)gamecontroller, button);
			#endif
		}

		/// <summary>
		/// Get the SDL joystick layer binding for a controller button mapping.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetBindForButton")]
		[return: NativeName(NativeNameType.Type, "SDL_GameControllerButtonBind")]
		public static SDLGameControllerButtonBind SDLGameControllerGetBindForButton([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GameControllerButton")] SDLGameControllerButton button)
		{
			SDLGameControllerButtonBind ret = SDLGameControllerGetBindForButtonNative(gamecontroller, button);
			return ret;
		}

		/// <summary>
		/// Get the SDL joystick layer binding for a controller button mapping.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetBindForButton")]
		[return: NativeName(NativeNameType.Type, "SDL_GameControllerButtonBind")]
		public static SDLGameControllerButtonBind SDLGameControllerGetBindForButton([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GameControllerButton")] SDLGameControllerButton button)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				SDLGameControllerButtonBind ret = SDLGameControllerGetBindForButtonNative((SDLGameController*)pgamecontroller, button);
				return ret;
			}
		}

		/// <summary>
		/// Query whether a game controller has a given button.<br/>
		/// This merely reports whether the controller's mapping defined this button,<br/>
		/// as that is all the information SDL has about the physical device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerHasButton")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		internal static SDLBool SDLGameControllerHasButtonNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GameControllerButton")] SDLGameControllerButton button)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGameController*, SDLGameControllerButton, SDLBool>)vt[590])(gamecontroller, button);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, SDLGameControllerButton, SDLBool>)vt[590])((nint)gamecontroller, button);
			#endif
		}

		/// <summary>
		/// Query whether a game controller has a given button.<br/>
		/// This merely reports whether the controller's mapping defined this button,<br/>
		/// as that is all the information SDL has about the physical device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerHasButton")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLGameControllerHasButton([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GameControllerButton")] SDLGameControllerButton button)
		{
			SDLBool ret = SDLGameControllerHasButtonNative(gamecontroller, button);
			return ret;
		}

		/// <summary>
		/// Query whether a game controller has a given button.<br/>
		/// This merely reports whether the controller's mapping defined this button,<br/>
		/// as that is all the information SDL has about the physical device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerHasButton")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLGameControllerHasButton([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GameControllerButton")] SDLGameControllerButton button)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				SDLBool ret = SDLGameControllerHasButtonNative((SDLGameController*)pgamecontroller, button);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of a button on a game controller.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetButton")]
		[return: NativeName(NativeNameType.Type, "Uint8")]
		internal static byte SDLGameControllerGetButtonNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GameControllerButton")] SDLGameControllerButton button)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGameController*, SDLGameControllerButton, byte>)vt[591])(gamecontroller, button);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, SDLGameControllerButton, byte>)vt[591])((nint)gamecontroller, button);
			#endif
		}

		/// <summary>
		/// Get the current state of a button on a game controller.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetButton")]
		[return: NativeName(NativeNameType.Type, "Uint8")]
		public static byte SDLGameControllerGetButton([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GameControllerButton")] SDLGameControllerButton button)
		{
			byte ret = SDLGameControllerGetButtonNative(gamecontroller, button);
			return ret;
		}

		/// <summary>
		/// Get the current state of a button on a game controller.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetButton")]
		[return: NativeName(NativeNameType.Type, "Uint8")]
		public static byte SDLGameControllerGetButton([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GameControllerButton")] SDLGameControllerButton button)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				byte ret = SDLGameControllerGetButtonNative((SDLGameController*)pgamecontroller, button);
				return ret;
			}
		}

		/// <summary>
		/// Get the number of touchpads on a game controller.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetNumTouchpads")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLGameControllerGetNumTouchpadsNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGameController*, int>)vt[592])(gamecontroller);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)vt[592])((nint)gamecontroller);
			#endif
		}

		/// <summary>
		/// Get the number of touchpads on a game controller.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetNumTouchpads")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetNumTouchpads([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller)
		{
			int ret = SDLGameControllerGetNumTouchpadsNative(gamecontroller);
			return ret;
		}

		/// <summary>
		/// Get the number of touchpads on a game controller.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetNumTouchpads")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetNumTouchpads([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				int ret = SDLGameControllerGetNumTouchpadsNative((SDLGameController*)pgamecontroller);
				return ret;
			}
		}

		/// <summary>
		/// Get the number of supported simultaneous fingers on a touchpad on a game<br/>
		/// controller.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetNumTouchpadFingers")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLGameControllerGetNumTouchpadFingersNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGameController*, int, int>)vt[593])(gamecontroller, touchpad);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int>)vt[593])((nint)gamecontroller, touchpad);
			#endif
		}

		/// <summary>
		/// Get the number of supported simultaneous fingers on a touchpad on a game<br/>
		/// controller.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetNumTouchpadFingers")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetNumTouchpadFingers([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad)
		{
			int ret = SDLGameControllerGetNumTouchpadFingersNative(gamecontroller, touchpad);
			return ret;
		}

		/// <summary>
		/// Get the number of supported simultaneous fingers on a touchpad on a game<br/>
		/// controller.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetNumTouchpadFingers")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetNumTouchpadFingers([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				int ret = SDLGameControllerGetNumTouchpadFingersNative((SDLGameController*)pgamecontroller, touchpad);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a game controller.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLGameControllerGetTouchpadFingerNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] byte* state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] float* pressure)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGameController*, int, int, byte*, float*, float*, float*, int>)vt[594])(gamecontroller, touchpad, finger, state, x, y, pressure);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int, nint, nint, nint, nint, int>)vt[594])((nint)gamecontroller, touchpad, finger, (nint)state, (nint)x, (nint)y, (nint)pressure);
			#endif
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a game controller.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] byte* state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] float* pressure)
		{
			int ret = SDLGameControllerGetTouchpadFingerNative(gamecontroller, touchpad, finger, state, x, y, pressure);
			return ret;
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a game controller.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] byte* state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] float* pressure)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				int ret = SDLGameControllerGetTouchpadFingerNative((SDLGameController*)pgamecontroller, touchpad, finger, state, x, y, pressure);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a game controller.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] float* pressure)
		{
			fixed (byte* pstate = &state)
			{
				int ret = SDLGameControllerGetTouchpadFingerNative(gamecontroller, touchpad, finger, (byte*)pstate, x, y, pressure);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a game controller.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] float* pressure)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				fixed (byte* pstate = &state)
				{
					int ret = SDLGameControllerGetTouchpadFingerNative((SDLGameController*)pgamecontroller, touchpad, finger, (byte*)pstate, x, y, pressure);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a game controller.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] byte* state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] float* pressure)
		{
			fixed (float* px = &x)
			{
				int ret = SDLGameControllerGetTouchpadFingerNative(gamecontroller, touchpad, finger, state, (float*)px, y, pressure);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a game controller.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] byte* state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] float* pressure)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				fixed (float* px = &x)
				{
					int ret = SDLGameControllerGetTouchpadFingerNative((SDLGameController*)pgamecontroller, touchpad, finger, state, (float*)px, y, pressure);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a game controller.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] float* pressure)
		{
			fixed (byte* pstate = &state)
			{
				fixed (float* px = &x)
				{
					int ret = SDLGameControllerGetTouchpadFingerNative(gamecontroller, touchpad, finger, (byte*)pstate, (float*)px, y, pressure);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a game controller.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] float* pressure)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				fixed (byte* pstate = &state)
				{
					fixed (float* px = &x)
					{
						int ret = SDLGameControllerGetTouchpadFingerNative((SDLGameController*)pgamecontroller, touchpad, finger, (byte*)pstate, (float*)px, y, pressure);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a game controller.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] byte* state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] float* pressure)
		{
			fixed (float* py = &y)
			{
				int ret = SDLGameControllerGetTouchpadFingerNative(gamecontroller, touchpad, finger, state, x, (float*)py, pressure);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a game controller.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] byte* state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] float* pressure)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				fixed (float* py = &y)
				{
					int ret = SDLGameControllerGetTouchpadFingerNative((SDLGameController*)pgamecontroller, touchpad, finger, state, x, (float*)py, pressure);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a game controller.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] float* pressure)
		{
			fixed (byte* pstate = &state)
			{
				fixed (float* py = &y)
				{
					int ret = SDLGameControllerGetTouchpadFingerNative(gamecontroller, touchpad, finger, (byte*)pstate, x, (float*)py, pressure);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a game controller.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] float* pressure)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				fixed (byte* pstate = &state)
				{
					fixed (float* py = &y)
					{
						int ret = SDLGameControllerGetTouchpadFingerNative((SDLGameController*)pgamecontroller, touchpad, finger, (byte*)pstate, x, (float*)py, pressure);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a game controller.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] byte* state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] float* pressure)
		{
			fixed (float* px = &x)
			{
				fixed (float* py = &y)
				{
					int ret = SDLGameControllerGetTouchpadFingerNative(gamecontroller, touchpad, finger, state, (float*)px, (float*)py, pressure);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a game controller.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] byte* state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] float* pressure)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				fixed (float* px = &x)
				{
					fixed (float* py = &y)
					{
						int ret = SDLGameControllerGetTouchpadFingerNative((SDLGameController*)pgamecontroller, touchpad, finger, state, (float*)px, (float*)py, pressure);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a game controller.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] float* pressure)
		{
			fixed (byte* pstate = &state)
			{
				fixed (float* px = &x)
				{
					fixed (float* py = &y)
					{
						int ret = SDLGameControllerGetTouchpadFingerNative(gamecontroller, touchpad, finger, (byte*)pstate, (float*)px, (float*)py, pressure);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a game controller.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] float* pressure)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				fixed (byte* pstate = &state)
				{
					fixed (float* px = &x)
					{
						fixed (float* py = &y)
						{
							int ret = SDLGameControllerGetTouchpadFingerNative((SDLGameController*)pgamecontroller, touchpad, finger, (byte*)pstate, (float*)px, (float*)py, pressure);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a game controller.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] byte* state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] ref float pressure)
		{
			fixed (float* ppressure = &pressure)
			{
				int ret = SDLGameControllerGetTouchpadFingerNative(gamecontroller, touchpad, finger, state, x, y, (float*)ppressure);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a game controller.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] byte* state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] ref float pressure)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				fixed (float* ppressure = &pressure)
				{
					int ret = SDLGameControllerGetTouchpadFingerNative((SDLGameController*)pgamecontroller, touchpad, finger, state, x, y, (float*)ppressure);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a game controller.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] ref float pressure)
		{
			fixed (byte* pstate = &state)
			{
				fixed (float* ppressure = &pressure)
				{
					int ret = SDLGameControllerGetTouchpadFingerNative(gamecontroller, touchpad, finger, (byte*)pstate, x, y, (float*)ppressure);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a game controller.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] ref float pressure)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				fixed (byte* pstate = &state)
				{
					fixed (float* ppressure = &pressure)
					{
						int ret = SDLGameControllerGetTouchpadFingerNative((SDLGameController*)pgamecontroller, touchpad, finger, (byte*)pstate, x, y, (float*)ppressure);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a game controller.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] byte* state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] ref float pressure)
		{
			fixed (float* px = &x)
			{
				fixed (float* ppressure = &pressure)
				{
					int ret = SDLGameControllerGetTouchpadFingerNative(gamecontroller, touchpad, finger, state, (float*)px, y, (float*)ppressure);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a game controller.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] byte* state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] ref float pressure)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				fixed (float* px = &x)
				{
					fixed (float* ppressure = &pressure)
					{
						int ret = SDLGameControllerGetTouchpadFingerNative((SDLGameController*)pgamecontroller, touchpad, finger, state, (float*)px, y, (float*)ppressure);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a game controller.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] ref float pressure)
		{
			fixed (byte* pstate = &state)
			{
				fixed (float* px = &x)
				{
					fixed (float* ppressure = &pressure)
					{
						int ret = SDLGameControllerGetTouchpadFingerNative(gamecontroller, touchpad, finger, (byte*)pstate, (float*)px, y, (float*)ppressure);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a game controller.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] ref float pressure)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				fixed (byte* pstate = &state)
				{
					fixed (float* px = &x)
					{
						fixed (float* ppressure = &pressure)
						{
							int ret = SDLGameControllerGetTouchpadFingerNative((SDLGameController*)pgamecontroller, touchpad, finger, (byte*)pstate, (float*)px, y, (float*)ppressure);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a game controller.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] byte* state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] ref float pressure)
		{
			fixed (float* py = &y)
			{
				fixed (float* ppressure = &pressure)
				{
					int ret = SDLGameControllerGetTouchpadFingerNative(gamecontroller, touchpad, finger, state, x, (float*)py, (float*)ppressure);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a game controller.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] byte* state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] ref float pressure)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				fixed (float* py = &y)
				{
					fixed (float* ppressure = &pressure)
					{
						int ret = SDLGameControllerGetTouchpadFingerNative((SDLGameController*)pgamecontroller, touchpad, finger, state, x, (float*)py, (float*)ppressure);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a game controller.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] ref float pressure)
		{
			fixed (byte* pstate = &state)
			{
				fixed (float* py = &y)
				{
					fixed (float* ppressure = &pressure)
					{
						int ret = SDLGameControllerGetTouchpadFingerNative(gamecontroller, touchpad, finger, (byte*)pstate, x, (float*)py, (float*)ppressure);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a game controller.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] ref float pressure)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				fixed (byte* pstate = &state)
				{
					fixed (float* py = &y)
					{
						fixed (float* ppressure = &pressure)
						{
							int ret = SDLGameControllerGetTouchpadFingerNative((SDLGameController*)pgamecontroller, touchpad, finger, (byte*)pstate, x, (float*)py, (float*)ppressure);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a game controller.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] byte* state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] ref float pressure)
		{
			fixed (float* px = &x)
			{
				fixed (float* py = &y)
				{
					fixed (float* ppressure = &pressure)
					{
						int ret = SDLGameControllerGetTouchpadFingerNative(gamecontroller, touchpad, finger, state, (float*)px, (float*)py, (float*)ppressure);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a game controller.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] byte* state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] ref float pressure)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				fixed (float* px = &x)
				{
					fixed (float* py = &y)
					{
						fixed (float* ppressure = &pressure)
						{
							int ret = SDLGameControllerGetTouchpadFingerNative((SDLGameController*)pgamecontroller, touchpad, finger, state, (float*)px, (float*)py, (float*)ppressure);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a game controller.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] ref float pressure)
		{
			fixed (byte* pstate = &state)
			{
				fixed (float* px = &x)
				{
					fixed (float* py = &y)
					{
						fixed (float* ppressure = &pressure)
						{
							int ret = SDLGameControllerGetTouchpadFingerNative(gamecontroller, touchpad, finger, (byte*)pstate, (float*)px, (float*)py, (float*)ppressure);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a game controller.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] ref float pressure)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				fixed (byte* pstate = &state)
				{
					fixed (float* px = &x)
					{
						fixed (float* py = &y)
						{
							fixed (float* ppressure = &pressure)
							{
								int ret = SDLGameControllerGetTouchpadFingerNative((SDLGameController*)pgamecontroller, touchpad, finger, (byte*)pstate, (float*)px, (float*)py, (float*)ppressure);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Return whether a game controller has a particular sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerHasSensor")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		internal static SDLBool SDLGameControllerHasSensorNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGameController*, SDLSensorType, SDLBool>)vt[595])(gamecontroller, type);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, SDLSensorType, SDLBool>)vt[595])((nint)gamecontroller, type);
			#endif
		}

		/// <summary>
		/// Return whether a game controller has a particular sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerHasSensor")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLGameControllerHasSensor([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type)
		{
			SDLBool ret = SDLGameControllerHasSensorNative(gamecontroller, type);
			return ret;
		}

		/// <summary>
		/// Return whether a game controller has a particular sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerHasSensor")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLGameControllerHasSensor([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				SDLBool ret = SDLGameControllerHasSensorNative((SDLGameController*)pgamecontroller, type);
				return ret;
			}
		}

		/// <summary>
		/// Set whether data reporting for a game controller sensor is enabled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerSetSensorEnabled")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLGameControllerSetSensorEnabledNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "enabled")] [NativeName(NativeNameType.Type, "SDL_bool")] SDLBool enabled)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGameController*, SDLSensorType, SDLBool, int>)vt[596])(gamecontroller, type, enabled);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, SDLSensorType, SDLBool, int>)vt[596])((nint)gamecontroller, type, enabled);
			#endif
		}

		/// <summary>
		/// Set whether data reporting for a game controller sensor is enabled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerSetSensorEnabled")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerSetSensorEnabled([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "enabled")] [NativeName(NativeNameType.Type, "SDL_bool")] SDLBool enabled)
		{
			int ret = SDLGameControllerSetSensorEnabledNative(gamecontroller, type, enabled);
			return ret;
		}

		/// <summary>
		/// Set whether data reporting for a game controller sensor is enabled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerSetSensorEnabled")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerSetSensorEnabled([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "enabled")] [NativeName(NativeNameType.Type, "SDL_bool")] SDLBool enabled)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				int ret = SDLGameControllerSetSensorEnabledNative((SDLGameController*)pgamecontroller, type, enabled);
				return ret;
			}
		}

		/// <summary>
		/// Query whether sensor data reporting is enabled for a game controller.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerIsSensorEnabled")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		internal static SDLBool SDLGameControllerIsSensorEnabledNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGameController*, SDLSensorType, SDLBool>)vt[597])(gamecontroller, type);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, SDLSensorType, SDLBool>)vt[597])((nint)gamecontroller, type);
			#endif
		}

		/// <summary>
		/// Query whether sensor data reporting is enabled for a game controller.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerIsSensorEnabled")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLGameControllerIsSensorEnabled([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type)
		{
			SDLBool ret = SDLGameControllerIsSensorEnabledNative(gamecontroller, type);
			return ret;
		}

		/// <summary>
		/// Query whether sensor data reporting is enabled for a game controller.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerIsSensorEnabled")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLGameControllerIsSensorEnabled([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				SDLBool ret = SDLGameControllerIsSensorEnabledNative((SDLGameController*)pgamecontroller, type);
				return ret;
			}
		}

		/// <summary>
		/// Get the data rate (number of events per second) of a game controller<br/>
		/// sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetSensorDataRate")]
		[return: NativeName(NativeNameType.Type, "float")]
		internal static float SDLGameControllerGetSensorDataRateNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGameController*, SDLSensorType, float>)vt[598])(gamecontroller, type);
			#else
			return (float)((delegate* unmanaged[Cdecl]<nint, SDLSensorType, float>)vt[598])((nint)gamecontroller, type);
			#endif
		}

		/// <summary>
		/// Get the data rate (number of events per second) of a game controller<br/>
		/// sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetSensorDataRate")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float SDLGameControllerGetSensorDataRate([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type)
		{
			float ret = SDLGameControllerGetSensorDataRateNative(gamecontroller, type);
			return ret;
		}

		/// <summary>
		/// Get the data rate (number of events per second) of a game controller<br/>
		/// sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetSensorDataRate")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float SDLGameControllerGetSensorDataRate([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				float ret = SDLGameControllerGetSensorDataRateNative((SDLGameController*)pgamecontroller, type);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of a game controller sensor.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// See SDL_sensor.h for the details for each type of sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetSensorData")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLGameControllerGetSensorDataNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float*")] float* data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGameController*, SDLSensorType, float*, int, int>)vt[599])(gamecontroller, type, data, numValues);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, SDLSensorType, nint, int, int>)vt[599])((nint)gamecontroller, type, (nint)data, numValues);
			#endif
		}

		/// <summary>
		/// Get the current state of a game controller sensor.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// See SDL_sensor.h for the details for each type of sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetSensorData")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetSensorData([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float*")] float* data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			int ret = SDLGameControllerGetSensorDataNative(gamecontroller, type, data, numValues);
			return ret;
		}

		/// <summary>
		/// Get the current state of a game controller sensor.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// See SDL_sensor.h for the details for each type of sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetSensorData")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetSensorData([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float*")] float* data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				int ret = SDLGameControllerGetSensorDataNative((SDLGameController*)pgamecontroller, type, data, numValues);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of a game controller sensor.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// See SDL_sensor.h for the details for each type of sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetSensorData")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetSensorData([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float*")] ref float data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			fixed (float* pdata = &data)
			{
				int ret = SDLGameControllerGetSensorDataNative(gamecontroller, type, (float*)pdata, numValues);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of a game controller sensor.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// See SDL_sensor.h for the details for each type of sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetSensorData")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetSensorData([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float*")] ref float data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				fixed (float* pdata = &data)
				{
					int ret = SDLGameControllerGetSensorDataNative((SDLGameController*)pgamecontroller, type, (float*)pdata, numValues);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the current state of a game controller sensor with the timestamp of the<br/>
		/// last update.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// See SDL_sensor.h for the details for each type of sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetSensorDataWithTimestamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLGameControllerGetSensorDataWithTimestampNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "timestamp")] [NativeName(NativeNameType.Type, "Uint64*")] ulong* timestamp, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float*")] float* data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGameController*, SDLSensorType, ulong*, float*, int, int>)vt[600])(gamecontroller, type, timestamp, data, numValues);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, SDLSensorType, nint, nint, int, int>)vt[600])((nint)gamecontroller, type, (nint)timestamp, (nint)data, numValues);
			#endif
		}

		/// <summary>
		/// Get the current state of a game controller sensor with the timestamp of the<br/>
		/// last update.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// See SDL_sensor.h for the details for each type of sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetSensorDataWithTimestamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetSensorDataWithTimestamp([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "timestamp")] [NativeName(NativeNameType.Type, "Uint64*")] ulong* timestamp, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float*")] float* data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			int ret = SDLGameControllerGetSensorDataWithTimestampNative(gamecontroller, type, timestamp, data, numValues);
			return ret;
		}

		/// <summary>
		/// Get the current state of a game controller sensor with the timestamp of the<br/>
		/// last update.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// See SDL_sensor.h for the details for each type of sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetSensorDataWithTimestamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetSensorDataWithTimestamp([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "timestamp")] [NativeName(NativeNameType.Type, "Uint64*")] ulong* timestamp, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float*")] float* data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				int ret = SDLGameControllerGetSensorDataWithTimestampNative((SDLGameController*)pgamecontroller, type, timestamp, data, numValues);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of a game controller sensor with the timestamp of the<br/>
		/// last update.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// See SDL_sensor.h for the details for each type of sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetSensorDataWithTimestamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetSensorDataWithTimestamp([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "timestamp")] [NativeName(NativeNameType.Type, "Uint64*")] ref ulong timestamp, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float*")] float* data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			fixed (ulong* ptimestamp = &timestamp)
			{
				int ret = SDLGameControllerGetSensorDataWithTimestampNative(gamecontroller, type, (ulong*)ptimestamp, data, numValues);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of a game controller sensor with the timestamp of the<br/>
		/// last update.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// See SDL_sensor.h for the details for each type of sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetSensorDataWithTimestamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetSensorDataWithTimestamp([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "timestamp")] [NativeName(NativeNameType.Type, "Uint64*")] ref ulong timestamp, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float*")] float* data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				fixed (ulong* ptimestamp = &timestamp)
				{
					int ret = SDLGameControllerGetSensorDataWithTimestampNative((SDLGameController*)pgamecontroller, type, (ulong*)ptimestamp, data, numValues);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the current state of a game controller sensor with the timestamp of the<br/>
		/// last update.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// See SDL_sensor.h for the details for each type of sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetSensorDataWithTimestamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetSensorDataWithTimestamp([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "timestamp")] [NativeName(NativeNameType.Type, "Uint64*")] ulong* timestamp, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float*")] ref float data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			fixed (float* pdata = &data)
			{
				int ret = SDLGameControllerGetSensorDataWithTimestampNative(gamecontroller, type, timestamp, (float*)pdata, numValues);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of a game controller sensor with the timestamp of the<br/>
		/// last update.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// See SDL_sensor.h for the details for each type of sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetSensorDataWithTimestamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetSensorDataWithTimestamp([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "timestamp")] [NativeName(NativeNameType.Type, "Uint64*")] ulong* timestamp, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float*")] ref float data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				fixed (float* pdata = &data)
				{
					int ret = SDLGameControllerGetSensorDataWithTimestampNative((SDLGameController*)pgamecontroller, type, timestamp, (float*)pdata, numValues);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the current state of a game controller sensor with the timestamp of the<br/>
		/// last update.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// See SDL_sensor.h for the details for each type of sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetSensorDataWithTimestamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetSensorDataWithTimestamp([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "timestamp")] [NativeName(NativeNameType.Type, "Uint64*")] ref ulong timestamp, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float*")] ref float data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			fixed (ulong* ptimestamp = &timestamp)
			{
				fixed (float* pdata = &data)
				{
					int ret = SDLGameControllerGetSensorDataWithTimestampNative(gamecontroller, type, (ulong*)ptimestamp, (float*)pdata, numValues);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the current state of a game controller sensor with the timestamp of the<br/>
		/// last update.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// See SDL_sensor.h for the details for each type of sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetSensorDataWithTimestamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetSensorDataWithTimestamp([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "timestamp")] [NativeName(NativeNameType.Type, "Uint64*")] ref ulong timestamp, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float*")] ref float data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				fixed (ulong* ptimestamp = &timestamp)
				{
					fixed (float* pdata = &data)
					{
						int ret = SDLGameControllerGetSensorDataWithTimestampNative((SDLGameController*)pgamecontroller, type, (ulong*)ptimestamp, (float*)pdata, numValues);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Start a rumble effect on a game controller.<br/>
		/// Each call to this function cancels any previous rumble effect, and calling<br/>
		/// it with 0 intensity stops any rumbling.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerRumble")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLGameControllerRumbleNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "low_frequency_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort lowFrequencyRumble, [NativeName(NativeNameType.Param, "high_frequency_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort highFrequencyRumble, [NativeName(NativeNameType.Param, "duration_ms")] [NativeName(NativeNameType.Type, "Uint32")] uint durationMs)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGameController*, ushort, ushort, uint, int>)vt[601])(gamecontroller, lowFrequencyRumble, highFrequencyRumble, durationMs);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, ushort, ushort, uint, int>)vt[601])((nint)gamecontroller, lowFrequencyRumble, highFrequencyRumble, durationMs);
			#endif
		}

		/// <summary>
		/// Start a rumble effect on a game controller.<br/>
		/// Each call to this function cancels any previous rumble effect, and calling<br/>
		/// it with 0 intensity stops any rumbling.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerRumble")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerRumble([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "low_frequency_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort lowFrequencyRumble, [NativeName(NativeNameType.Param, "high_frequency_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort highFrequencyRumble, [NativeName(NativeNameType.Param, "duration_ms")] [NativeName(NativeNameType.Type, "Uint32")] uint durationMs)
		{
			int ret = SDLGameControllerRumbleNative(gamecontroller, lowFrequencyRumble, highFrequencyRumble, durationMs);
			return ret;
		}

		/// <summary>
		/// Start a rumble effect on a game controller.<br/>
		/// Each call to this function cancels any previous rumble effect, and calling<br/>
		/// it with 0 intensity stops any rumbling.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerRumble")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerRumble([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "low_frequency_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort lowFrequencyRumble, [NativeName(NativeNameType.Param, "high_frequency_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort highFrequencyRumble, [NativeName(NativeNameType.Param, "duration_ms")] [NativeName(NativeNameType.Type, "Uint32")] uint durationMs)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				int ret = SDLGameControllerRumbleNative((SDLGameController*)pgamecontroller, lowFrequencyRumble, highFrequencyRumble, durationMs);
				return ret;
			}
		}

		/// <summary>
		/// Start a rumble effect in the game controller's triggers.<br/>
		/// Each call to this function cancels any previous trigger rumble effect, and<br/>
		/// calling it with 0 intensity stops any rumbling.<br/>
		/// Note that this is rumbling of the _triggers_ and not the game controller as<br/>
		/// a whole. This is currently only supported on Xbox One controllers. If you<br/>
		/// want the (more common) whole-controller rumble, use<br/>
		/// SDL_GameControllerRumble() instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerRumbleTriggers")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLGameControllerRumbleTriggersNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "left_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort leftRumble, [NativeName(NativeNameType.Param, "right_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort rightRumble, [NativeName(NativeNameType.Param, "duration_ms")] [NativeName(NativeNameType.Type, "Uint32")] uint durationMs)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGameController*, ushort, ushort, uint, int>)vt[602])(gamecontroller, leftRumble, rightRumble, durationMs);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, ushort, ushort, uint, int>)vt[602])((nint)gamecontroller, leftRumble, rightRumble, durationMs);
			#endif
		}

		/// <summary>
		/// Start a rumble effect in the game controller's triggers.<br/>
		/// Each call to this function cancels any previous trigger rumble effect, and<br/>
		/// calling it with 0 intensity stops any rumbling.<br/>
		/// Note that this is rumbling of the _triggers_ and not the game controller as<br/>
		/// a whole. This is currently only supported on Xbox One controllers. If you<br/>
		/// want the (more common) whole-controller rumble, use<br/>
		/// SDL_GameControllerRumble() instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerRumbleTriggers")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerRumbleTriggers([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "left_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort leftRumble, [NativeName(NativeNameType.Param, "right_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort rightRumble, [NativeName(NativeNameType.Param, "duration_ms")] [NativeName(NativeNameType.Type, "Uint32")] uint durationMs)
		{
			int ret = SDLGameControllerRumbleTriggersNative(gamecontroller, leftRumble, rightRumble, durationMs);
			return ret;
		}

		/// <summary>
		/// Start a rumble effect in the game controller's triggers.<br/>
		/// Each call to this function cancels any previous trigger rumble effect, and<br/>
		/// calling it with 0 intensity stops any rumbling.<br/>
		/// Note that this is rumbling of the _triggers_ and not the game controller as<br/>
		/// a whole. This is currently only supported on Xbox One controllers. If you<br/>
		/// want the (more common) whole-controller rumble, use<br/>
		/// SDL_GameControllerRumble() instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerRumbleTriggers")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerRumbleTriggers([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "left_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort leftRumble, [NativeName(NativeNameType.Param, "right_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort rightRumble, [NativeName(NativeNameType.Param, "duration_ms")] [NativeName(NativeNameType.Type, "Uint32")] uint durationMs)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				int ret = SDLGameControllerRumbleTriggersNative((SDLGameController*)pgamecontroller, leftRumble, rightRumble, durationMs);
				return ret;
			}
		}

		/// <summary>
		/// Query whether a game controller has an LED.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerHasLED")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		internal static SDLBool SDLGameControllerHasLEDNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGameController*, SDLBool>)vt[603])(gamecontroller);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, SDLBool>)vt[603])((nint)gamecontroller);
			#endif
		}

		/// <summary>
		/// Query whether a game controller has an LED.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerHasLED")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLGameControllerHasLED([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller)
		{
			SDLBool ret = SDLGameControllerHasLEDNative(gamecontroller);
			return ret;
		}

		/// <summary>
		/// Query whether a game controller has an LED.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerHasLED")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLGameControllerHasLED([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				SDLBool ret = SDLGameControllerHasLEDNative((SDLGameController*)pgamecontroller);
				return ret;
			}
		}

		/// <summary>
		/// Query whether a game controller has rumble support.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerHasRumble")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		internal static SDLBool SDLGameControllerHasRumbleNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGameController*, SDLBool>)vt[604])(gamecontroller);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, SDLBool>)vt[604])((nint)gamecontroller);
			#endif
		}

		/// <summary>
		/// Query whether a game controller has rumble support.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerHasRumble")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLGameControllerHasRumble([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller)
		{
			SDLBool ret = SDLGameControllerHasRumbleNative(gamecontroller);
			return ret;
		}

		/// <summary>
		/// Query whether a game controller has rumble support.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerHasRumble")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLGameControllerHasRumble([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				SDLBool ret = SDLGameControllerHasRumbleNative((SDLGameController*)pgamecontroller);
				return ret;
			}
		}

		/// <summary>
		/// Query whether a game controller has rumble support on triggers.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerHasRumbleTriggers")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		internal static SDLBool SDLGameControllerHasRumbleTriggersNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGameController*, SDLBool>)vt[605])(gamecontroller);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, SDLBool>)vt[605])((nint)gamecontroller);
			#endif
		}

		/// <summary>
		/// Query whether a game controller has rumble support on triggers.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerHasRumbleTriggers")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLGameControllerHasRumbleTriggers([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller)
		{
			SDLBool ret = SDLGameControllerHasRumbleTriggersNative(gamecontroller);
			return ret;
		}

		/// <summary>
		/// Query whether a game controller has rumble support on triggers.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerHasRumbleTriggers")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLGameControllerHasRumbleTriggers([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				SDLBool ret = SDLGameControllerHasRumbleTriggersNative((SDLGameController*)pgamecontroller);
				return ret;
			}
		}

		/// <summary>
		/// Update a game controller's LED color.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerSetLED")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLGameControllerSetLEDNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "Uint8")] byte red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "Uint8")] byte green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "Uint8")] byte blue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGameController*, byte, byte, byte, int>)vt[606])(gamecontroller, red, green, blue);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, byte, byte, byte, int>)vt[606])((nint)gamecontroller, red, green, blue);
			#endif
		}

		/// <summary>
		/// Update a game controller's LED color.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerSetLED")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerSetLED([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "Uint8")] byte red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "Uint8")] byte green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "Uint8")] byte blue)
		{
			int ret = SDLGameControllerSetLEDNative(gamecontroller, red, green, blue);
			return ret;
		}

		/// <summary>
		/// Update a game controller's LED color.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerSetLED")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerSetLED([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "Uint8")] byte red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "Uint8")] byte green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "Uint8")] byte blue)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				int ret = SDLGameControllerSetLEDNative((SDLGameController*)pgamecontroller, red, green, blue);
				return ret;
			}
		}

		/// <summary>
		/// Send a controller specific effect packet<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerSendEffect")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLGameControllerSendEffectNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "const void*")] void* data, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "int")] int size)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGameController*, void*, int, int>)vt[607])(gamecontroller, data, size);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int, int>)vt[607])((nint)gamecontroller, (nint)data, size);
			#endif
		}

		/// <summary>
		/// Send a controller specific effect packet<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerSendEffect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerSendEffect([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "const void*")] void* data, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "int")] int size)
		{
			int ret = SDLGameControllerSendEffectNative(gamecontroller, data, size);
			return ret;
		}

		/// <summary>
		/// Send a controller specific effect packet<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerSendEffect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerSendEffect([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "const void*")] void* data, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "int")] int size)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				int ret = SDLGameControllerSendEffectNative((SDLGameController*)pgamecontroller, data, size);
				return ret;
			}
		}

		/// <summary>
		/// Close a game controller previously opened with SDL_GameControllerOpen().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerClose")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SDLGameControllerCloseNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGameController*, void>)vt[608])(gamecontroller);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[608])((nint)gamecontroller);
			#endif
		}

		/// <summary>
		/// Close a game controller previously opened with SDL_GameControllerOpen().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerClose")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGameControllerClose([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller)
		{
			SDLGameControllerCloseNative(gamecontroller);
		}

		/// <summary>
		/// Close a game controller previously opened with SDL_GameControllerOpen().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerClose")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGameControllerClose([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				SDLGameControllerCloseNative((SDLGameController*)pgamecontroller);
			}
		}

		/// <summary>
		/// Return the sfSymbolsName for a given button on a game controller on Apple<br/>
		/// platforms.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetAppleSFSymbolsNameForButton")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		internal static byte* SDLGameControllerGetAppleSFSymbolsNameForButtonNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GameControllerButton")] SDLGameControllerButton button)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGameController*, SDLGameControllerButton, byte*>)vt[609])(gamecontroller, button);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, SDLGameControllerButton, nint>)vt[609])((nint)gamecontroller, button);
			#endif
		}

		/// <summary>
		/// Return the sfSymbolsName for a given button on a game controller on Apple<br/>
		/// platforms.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetAppleSFSymbolsNameForButton")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGameControllerGetAppleSFSymbolsNameForButton([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GameControllerButton")] SDLGameControllerButton button)
		{
			byte* ret = SDLGameControllerGetAppleSFSymbolsNameForButtonNative(gamecontroller, button);
			return ret;
		}

		/// <summary>
		/// Return the sfSymbolsName for a given button on a game controller on Apple<br/>
		/// platforms.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetAppleSFSymbolsNameForButton")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGameControllerGetAppleSFSymbolsNameForButtonS([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GameControllerButton")] SDLGameControllerButton button)
		{
			string ret = Utils.DecodeStringUTF8(SDLGameControllerGetAppleSFSymbolsNameForButtonNative(gamecontroller, button));
			return ret;
		}

		/// <summary>
		/// Return the sfSymbolsName for a given button on a game controller on Apple<br/>
		/// platforms.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetAppleSFSymbolsNameForButton")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGameControllerGetAppleSFSymbolsNameForButton([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GameControllerButton")] SDLGameControllerButton button)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				byte* ret = SDLGameControllerGetAppleSFSymbolsNameForButtonNative((SDLGameController*)pgamecontroller, button);
				return ret;
			}
		}

		/// <summary>
		/// Return the sfSymbolsName for a given button on a game controller on Apple<br/>
		/// platforms.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetAppleSFSymbolsNameForButton")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGameControllerGetAppleSFSymbolsNameForButtonS([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GameControllerButton")] SDLGameControllerButton button)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				string ret = Utils.DecodeStringUTF8(SDLGameControllerGetAppleSFSymbolsNameForButtonNative((SDLGameController*)pgamecontroller, button));
				return ret;
			}
		}

		/// <summary>
		/// Return the sfSymbolsName for a given axis on a game controller on Apple<br/>
		/// platforms.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetAppleSFSymbolsNameForAxis")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		internal static byte* SDLGameControllerGetAppleSFSymbolsNameForAxisNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "SDL_GameControllerAxis")] SDLGameControllerAxis axis)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGameController*, SDLGameControllerAxis, byte*>)vt[610])(gamecontroller, axis);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, SDLGameControllerAxis, nint>)vt[610])((nint)gamecontroller, axis);
			#endif
		}

		/// <summary>
		/// Return the sfSymbolsName for a given axis on a game controller on Apple<br/>
		/// platforms.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetAppleSFSymbolsNameForAxis")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGameControllerGetAppleSFSymbolsNameForAxis([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "SDL_GameControllerAxis")] SDLGameControllerAxis axis)
		{
			byte* ret = SDLGameControllerGetAppleSFSymbolsNameForAxisNative(gamecontroller, axis);
			return ret;
		}

		/// <summary>
		/// Return the sfSymbolsName for a given axis on a game controller on Apple<br/>
		/// platforms.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetAppleSFSymbolsNameForAxis")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGameControllerGetAppleSFSymbolsNameForAxisS([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "SDL_GameControllerAxis")] SDLGameControllerAxis axis)
		{
			string ret = Utils.DecodeStringUTF8(SDLGameControllerGetAppleSFSymbolsNameForAxisNative(gamecontroller, axis));
			return ret;
		}

		/// <summary>
		/// Return the sfSymbolsName for a given axis on a game controller on Apple<br/>
		/// platforms.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetAppleSFSymbolsNameForAxis")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGameControllerGetAppleSFSymbolsNameForAxis([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "SDL_GameControllerAxis")] SDLGameControllerAxis axis)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				byte* ret = SDLGameControllerGetAppleSFSymbolsNameForAxisNative((SDLGameController*)pgamecontroller, axis);
				return ret;
			}
		}

		/// <summary>
		/// Return the sfSymbolsName for a given axis on a game controller on Apple<br/>
		/// platforms.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetAppleSFSymbolsNameForAxis")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGameControllerGetAppleSFSymbolsNameForAxisS([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "SDL_GameControllerAxis")] SDLGameControllerAxis axis)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				string ret = Utils.DecodeStringUTF8(SDLGameControllerGetAppleSFSymbolsNameForAxisNative((SDLGameController*)pgamecontroller, axis));
				return ret;
			}
		}

		/// <summary>
		/// Get the number of registered touch devices.<br/>
		/// On some platforms SDL first sees the touch device if it was actually used.<br/>
		/// Therefore SDL_GetNumTouchDevices() may return 0 although devices are<br/>
		/// available. After using all devices at least once the number will be<br/>
		/// correct.<br/>
		/// This was fixed for Android in SDL 2.0.1.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumTouchDevices")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLGetNumTouchDevicesNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)vt[611])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)vt[611])();
			#endif
		}

		/// <summary>
		/// Get the number of registered touch devices.<br/>
		/// On some platforms SDL first sees the touch device if it was actually used.<br/>
		/// Therefore SDL_GetNumTouchDevices() may return 0 although devices are<br/>
		/// available. After using all devices at least once the number will be<br/>
		/// correct.<br/>
		/// This was fixed for Android in SDL 2.0.1.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumTouchDevices")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetNumTouchDevices()
		{
			int ret = SDLGetNumTouchDevicesNative();
			return ret;
		}

		/// <summary>
		/// Get the touch ID with the given index.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTouchDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_TouchID")]
		internal static long SDLGetTouchDeviceNative([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, long>)vt[612])(index);
			#else
			return (long)((delegate* unmanaged[Cdecl]<int, long>)vt[612])(index);
			#endif
		}

		/// <summary>
		/// Get the touch ID with the given index.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTouchDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_TouchID")]
		public static long SDLGetTouchDevice([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index)
		{
			long ret = SDLGetTouchDeviceNative(index);
			return ret;
		}

		/// <summary>
		/// Get the touch device name as reported from the driver or NULL if the index<br/>
		/// is invalid.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTouchName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		internal static byte* SDLGetTouchNameNative([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*>)vt[613])(index);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint>)vt[613])(index);
			#endif
		}

		/// <summary>
		/// Get the touch device name as reported from the driver or NULL if the index<br/>
		/// is invalid.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTouchName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGetTouchName([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index)
		{
			byte* ret = SDLGetTouchNameNative(index);
			return ret;
		}

		/// <summary>
		/// Get the touch device name as reported from the driver or NULL if the index<br/>
		/// is invalid.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTouchName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGetTouchNameS([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index)
		{
			string ret = Utils.DecodeStringUTF8(SDLGetTouchNameNative(index));
			return ret;
		}

		/// <summary>
		/// Get the type of the given touch device.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTouchDeviceType")]
		[return: NativeName(NativeNameType.Type, "SDL_TouchDeviceType")]
		internal static SDLTouchDeviceType SDLGetTouchDeviceTypeNative([NativeName(NativeNameType.Param, "touchID")] [NativeName(NativeNameType.Type, "SDL_TouchID")] long touchID)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<long, SDLTouchDeviceType>)vt[614])(touchID);
			#else
			return (SDLTouchDeviceType)((delegate* unmanaged[Cdecl]<long, SDLTouchDeviceType>)vt[614])(touchID);
			#endif
		}

		/// <summary>
		/// Get the type of the given touch device.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTouchDeviceType")]
		[return: NativeName(NativeNameType.Type, "SDL_TouchDeviceType")]
		public static SDLTouchDeviceType SDLGetTouchDeviceType([NativeName(NativeNameType.Param, "touchID")] [NativeName(NativeNameType.Type, "SDL_TouchID")] long touchID)
		{
			SDLTouchDeviceType ret = SDLGetTouchDeviceTypeNative(touchID);
			return ret;
		}

		/// <summary>
		/// Get the number of active fingers for a given touch device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumTouchFingers")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLGetNumTouchFingersNative([NativeName(NativeNameType.Param, "touchID")] [NativeName(NativeNameType.Type, "SDL_TouchID")] long touchID)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<long, int>)vt[615])(touchID);
			#else
			return (int)((delegate* unmanaged[Cdecl]<long, int>)vt[615])(touchID);
			#endif
		}

		/// <summary>
		/// Get the number of active fingers for a given touch device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumTouchFingers")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetNumTouchFingers([NativeName(NativeNameType.Param, "touchID")] [NativeName(NativeNameType.Type, "SDL_TouchID")] long touchID)
		{
			int ret = SDLGetNumTouchFingersNative(touchID);
			return ret;
		}

		/// <summary>
		/// Get the finger object for specified touch device ID and finger index.<br/>
		/// The returned resource is owned by SDL and should not be deallocated.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTouchFinger")]
		[return: NativeName(NativeNameType.Type, "SDL_Finger*")]
		internal static SDLFinger* SDLGetTouchFingerNative([NativeName(NativeNameType.Param, "touchID")] [NativeName(NativeNameType.Type, "SDL_TouchID")] long touchID, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<long, int, SDLFinger*>)vt[616])(touchID, index);
			#else
			return (SDLFinger*)((delegate* unmanaged[Cdecl]<long, int, nint>)vt[616])(touchID, index);
			#endif
		}

		/// <summary>
		/// Get the finger object for specified touch device ID and finger index.<br/>
		/// The returned resource is owned by SDL and should not be deallocated.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTouchFinger")]
		[return: NativeName(NativeNameType.Type, "SDL_Finger*")]
		public static SDLFinger* SDLGetTouchFinger([NativeName(NativeNameType.Param, "touchID")] [NativeName(NativeNameType.Type, "SDL_TouchID")] long touchID, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index)
		{
			SDLFinger* ret = SDLGetTouchFingerNative(touchID, index);
			return ret;
		}

		/// <summary>
		/// Begin recording a gesture on a specified touch device or all touch devices.<br/>
		/// If the parameter `touchId` is -1 (i.e., all devices), this function will<br/>
		/// always return 1, regardless of whether there actually are any devices.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RecordGesture")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLRecordGestureNative([NativeName(NativeNameType.Param, "touchId")] [NativeName(NativeNameType.Type, "SDL_TouchID")] long touchId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<long, int>)vt[617])(touchId);
			#else
			return (int)((delegate* unmanaged[Cdecl]<long, int>)vt[617])(touchId);
			#endif
		}

		/// <summary>
		/// Begin recording a gesture on a specified touch device or all touch devices.<br/>
		/// If the parameter `touchId` is -1 (i.e., all devices), this function will<br/>
		/// always return 1, regardless of whether there actually are any devices.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RecordGesture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRecordGesture([NativeName(NativeNameType.Param, "touchId")] [NativeName(NativeNameType.Type, "SDL_TouchID")] long touchId)
		{
			int ret = SDLRecordGestureNative(touchId);
			return ret;
		}

		/// <summary>
		/// Save all currently loaded Dollar Gesture templates.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SaveAllDollarTemplates")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLSaveAllDollarTemplatesNative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int>)vt[618])(dst);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)vt[618])((nint)dst);
			#endif
		}

		/// <summary>
		/// Save all currently loaded Dollar Gesture templates.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SaveAllDollarTemplates")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSaveAllDollarTemplates([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst)
		{
			int ret = SDLSaveAllDollarTemplatesNative(dst);
			return ret;
		}

		/// <summary>
		/// Save all currently loaded Dollar Gesture templates.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SaveAllDollarTemplates")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSaveAllDollarTemplates([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops dst)
		{
			fixed (SDLRWops* pdst = &dst)
			{
				int ret = SDLSaveAllDollarTemplatesNative((SDLRWops*)pdst);
				return ret;
			}
		}

		/// <summary>
		/// Save a currently loaded Dollar Gesture template.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SaveDollarTemplate")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLSaveDollarTemplateNative([NativeName(NativeNameType.Param, "gestureId")] [NativeName(NativeNameType.Type, "SDL_GestureID")] long gestureId, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<long, SDLRWops*, int>)vt[619])(gestureId, dst);
			#else
			return (int)((delegate* unmanaged[Cdecl]<long, nint, int>)vt[619])(gestureId, (nint)dst);
			#endif
		}

		/// <summary>
		/// Save a currently loaded Dollar Gesture template.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SaveDollarTemplate")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSaveDollarTemplate([NativeName(NativeNameType.Param, "gestureId")] [NativeName(NativeNameType.Type, "SDL_GestureID")] long gestureId, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst)
		{
			int ret = SDLSaveDollarTemplateNative(gestureId, dst);
			return ret;
		}

		/// <summary>
		/// Save a currently loaded Dollar Gesture template.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SaveDollarTemplate")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSaveDollarTemplate([NativeName(NativeNameType.Param, "gestureId")] [NativeName(NativeNameType.Type, "SDL_GestureID")] long gestureId, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops dst)
		{
			fixed (SDLRWops* pdst = &dst)
			{
				int ret = SDLSaveDollarTemplateNative(gestureId, (SDLRWops*)pdst);
				return ret;
			}
		}

		/// <summary>
		/// Load Dollar Gesture templates from a file.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadDollarTemplates")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLLoadDollarTemplatesNative([NativeName(NativeNameType.Param, "touchId")] [NativeName(NativeNameType.Type, "SDL_TouchID")] long touchId, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<long, SDLRWops*, int>)vt[620])(touchId, src);
			#else
			return (int)((delegate* unmanaged[Cdecl]<long, nint, int>)vt[620])(touchId, (nint)src);
			#endif
		}

		/// <summary>
		/// Load Dollar Gesture templates from a file.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadDollarTemplates")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLoadDollarTemplates([NativeName(NativeNameType.Param, "touchId")] [NativeName(NativeNameType.Type, "SDL_TouchID")] long touchId, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			int ret = SDLLoadDollarTemplatesNative(touchId, src);
			return ret;
		}

		/// <summary>
		/// Load Dollar Gesture templates from a file.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadDollarTemplates")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLoadDollarTemplates([NativeName(NativeNameType.Param, "touchId")] [NativeName(NativeNameType.Type, "SDL_TouchID")] long touchId, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				int ret = SDLLoadDollarTemplatesNative(touchId, (SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Pump the event loop, gathering events from the input devices.<br/>
		/// This function updates the event queue and internal input device state.<br/>
		/// **WARNING**: This should only be run in the thread that initialized the<br/>
		/// video subsystem, and for extra safety, you should consider only doing those<br/>
		/// things on the main thread in any case.<br/>
		/// SDL_PumpEvents() gathers all the pending input information from devices and<br/>
		/// places it in the event queue. Without calls to SDL_PumpEvents() no events<br/>
		/// would ever be placed on the queue. Often the need for calls to<br/>
		/// SDL_PumpEvents() is hidden from the user since SDL_PollEvent() and<br/>
		/// SDL_WaitEvent() implicitly call SDL_PumpEvents(). However, if you are not<br/>
		/// polling or waiting for events (e.g. you are filtering them), then you must<br/>
		/// call SDL_PumpEvents() to force an event queue update.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PumpEvents")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SDLPumpEventsNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[621])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[621])();
			#endif
		}

		/// <summary>
		/// Pump the event loop, gathering events from the input devices.<br/>
		/// This function updates the event queue and internal input device state.<br/>
		/// **WARNING**: This should only be run in the thread that initialized the<br/>
		/// video subsystem, and for extra safety, you should consider only doing those<br/>
		/// things on the main thread in any case.<br/>
		/// SDL_PumpEvents() gathers all the pending input information from devices and<br/>
		/// places it in the event queue. Without calls to SDL_PumpEvents() no events<br/>
		/// would ever be placed on the queue. Often the need for calls to<br/>
		/// SDL_PumpEvents() is hidden from the user since SDL_PollEvent() and<br/>
		/// SDL_WaitEvent() implicitly call SDL_PumpEvents(). However, if you are not<br/>
		/// polling or waiting for events (e.g. you are filtering them), then you must<br/>
		/// call SDL_PumpEvents() to force an event queue update.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PumpEvents")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLPumpEvents()
		{
			SDLPumpEventsNative();
		}

		/// <summary>
		/// Check the event queue for messages and optionally return them.<br/>
		/// `action` may be any of the following:<br/>
		/// - `SDL_ADDEVENT`: up to `numevents` events will be added to the back of the<br/>
		/// event queue.<br/>
		/// - `SDL_PEEKEVENT`: `numevents` events at the front of the event queue,<br/>
		/// within the specified minimum and maximum type, will be returned to the<br/>
		/// caller and will _not_ be removed from the queue.<br/>
		/// - `SDL_GETEVENT`: up to `numevents` events at the front of the event queue,<br/>
		/// within the specified minimum and maximum type, will be returned to the<br/>
		/// caller and will be removed from the queue.<br/>
		/// You may have to call SDL_PumpEvents() before calling this function.<br/>
		/// Otherwise, the events may not be ready to be filtered when you call<br/>
		/// SDL_PeepEvents().<br/>
		/// This function is thread-safe.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PeepEvents")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLPeepEventsNative([NativeName(NativeNameType.Param, "events")] [NativeName(NativeNameType.Type, "SDL_Event*")] SDLEvent* events, [NativeName(NativeNameType.Param, "numevents")] [NativeName(NativeNameType.Type, "int")] int numevents, [NativeName(NativeNameType.Param, "action")] [NativeName(NativeNameType.Type, "SDL_eventaction")] SDLEventaction action, [NativeName(NativeNameType.Param, "minType")] [NativeName(NativeNameType.Type, "Uint32")] uint minType, [NativeName(NativeNameType.Param, "maxType")] [NativeName(NativeNameType.Type, "Uint32")] uint maxType)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLEvent*, int, SDLEventaction, uint, uint, int>)vt[622])(events, numevents, action, minType, maxType);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, SDLEventaction, uint, uint, int>)vt[622])((nint)events, numevents, action, minType, maxType);
			#endif
		}

		/// <summary>
		/// Check the event queue for messages and optionally return them.<br/>
		/// `action` may be any of the following:<br/>
		/// - `SDL_ADDEVENT`: up to `numevents` events will be added to the back of the<br/>
		/// event queue.<br/>
		/// - `SDL_PEEKEVENT`: `numevents` events at the front of the event queue,<br/>
		/// within the specified minimum and maximum type, will be returned to the<br/>
		/// caller and will _not_ be removed from the queue.<br/>
		/// - `SDL_GETEVENT`: up to `numevents` events at the front of the event queue,<br/>
		/// within the specified minimum and maximum type, will be returned to the<br/>
		/// caller and will be removed from the queue.<br/>
		/// You may have to call SDL_PumpEvents() before calling this function.<br/>
		/// Otherwise, the events may not be ready to be filtered when you call<br/>
		/// SDL_PeepEvents().<br/>
		/// This function is thread-safe.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PeepEvents")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLPeepEvents([NativeName(NativeNameType.Param, "events")] [NativeName(NativeNameType.Type, "SDL_Event*")] SDLEvent* events, [NativeName(NativeNameType.Param, "numevents")] [NativeName(NativeNameType.Type, "int")] int numevents, [NativeName(NativeNameType.Param, "action")] [NativeName(NativeNameType.Type, "SDL_eventaction")] SDLEventaction action, [NativeName(NativeNameType.Param, "minType")] [NativeName(NativeNameType.Type, "Uint32")] uint minType, [NativeName(NativeNameType.Param, "maxType")] [NativeName(NativeNameType.Type, "Uint32")] uint maxType)
		{
			int ret = SDLPeepEventsNative(events, numevents, action, minType, maxType);
			return ret;
		}

		/// <summary>
		/// Check the event queue for messages and optionally return them.<br/>
		/// `action` may be any of the following:<br/>
		/// - `SDL_ADDEVENT`: up to `numevents` events will be added to the back of the<br/>
		/// event queue.<br/>
		/// - `SDL_PEEKEVENT`: `numevents` events at the front of the event queue,<br/>
		/// within the specified minimum and maximum type, will be returned to the<br/>
		/// caller and will _not_ be removed from the queue.<br/>
		/// - `SDL_GETEVENT`: up to `numevents` events at the front of the event queue,<br/>
		/// within the specified minimum and maximum type, will be returned to the<br/>
		/// caller and will be removed from the queue.<br/>
		/// You may have to call SDL_PumpEvents() before calling this function.<br/>
		/// Otherwise, the events may not be ready to be filtered when you call<br/>
		/// SDL_PeepEvents().<br/>
		/// This function is thread-safe.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PeepEvents")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLPeepEvents([NativeName(NativeNameType.Param, "events")] [NativeName(NativeNameType.Type, "SDL_Event*")] ref SDLEvent events, [NativeName(NativeNameType.Param, "numevents")] [NativeName(NativeNameType.Type, "int")] int numevents, [NativeName(NativeNameType.Param, "action")] [NativeName(NativeNameType.Type, "SDL_eventaction")] SDLEventaction action, [NativeName(NativeNameType.Param, "minType")] [NativeName(NativeNameType.Type, "Uint32")] uint minType, [NativeName(NativeNameType.Param, "maxType")] [NativeName(NativeNameType.Type, "Uint32")] uint maxType)
		{
			fixed (SDLEvent* pevents = &events)
			{
				int ret = SDLPeepEventsNative((SDLEvent*)pevents, numevents, action, minType, maxType);
				return ret;
			}
		}

		/// <summary>
		/// Check for the existence of a certain event type in the event queue.<br/>
		/// If you need to check for a range of event types, use SDL_HasEvents()<br/>
		/// instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasEvent")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		internal static SDLBool SDLHasEventNative([NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "Uint32")] uint type)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, SDLBool>)vt[623])(type);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<uint, SDLBool>)vt[623])(type);
			#endif
		}

		/// <summary>
		/// Check for the existence of a certain event type in the event queue.<br/>
		/// If you need to check for a range of event types, use SDL_HasEvents()<br/>
		/// instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasEvent")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLHasEvent([NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "Uint32")] uint type)
		{
			SDLBool ret = SDLHasEventNative(type);
			return ret;
		}

		/// <summary>
		/// Check for the existence of certain event types in the event queue.<br/>
		/// If you need to check for a single event type, use SDL_HasEvent() instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasEvents")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		internal static SDLBool SDLHasEventsNative([NativeName(NativeNameType.Param, "minType")] [NativeName(NativeNameType.Type, "Uint32")] uint minType, [NativeName(NativeNameType.Param, "maxType")] [NativeName(NativeNameType.Type, "Uint32")] uint maxType)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, uint, SDLBool>)vt[624])(minType, maxType);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<uint, uint, SDLBool>)vt[624])(minType, maxType);
			#endif
		}

		/// <summary>
		/// Check for the existence of certain event types in the event queue.<br/>
		/// If you need to check for a single event type, use SDL_HasEvent() instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasEvents")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLHasEvents([NativeName(NativeNameType.Param, "minType")] [NativeName(NativeNameType.Type, "Uint32")] uint minType, [NativeName(NativeNameType.Param, "maxType")] [NativeName(NativeNameType.Type, "Uint32")] uint maxType)
		{
			SDLBool ret = SDLHasEventsNative(minType, maxType);
			return ret;
		}

		/// <summary>
		/// Clear events of a specific type from the event queue.<br/>
		/// This will unconditionally remove any events from the queue that match<br/>
		/// `type`. If you need to remove a range of event types, use SDL_FlushEvents()<br/>
		/// instead.<br/>
		/// It's also normal to just ignore events you don't care about in your event<br/>
		/// loop without calling this function.<br/>
		/// This function only affects currently queued events. If you want to make<br/>
		/// sure that all pending OS events are flushed, you can call SDL_PumpEvents()<br/>
		/// on the main thread immediately before the flush call.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FlushEvent")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SDLFlushEventNative([NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "Uint32")] uint type)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)vt[625])(type);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)vt[625])(type);
			#endif
		}

		/// <summary>
		/// Clear events of a specific type from the event queue.<br/>
		/// This will unconditionally remove any events from the queue that match<br/>
		/// `type`. If you need to remove a range of event types, use SDL_FlushEvents()<br/>
		/// instead.<br/>
		/// It's also normal to just ignore events you don't care about in your event<br/>
		/// loop without calling this function.<br/>
		/// This function only affects currently queued events. If you want to make<br/>
		/// sure that all pending OS events are flushed, you can call SDL_PumpEvents()<br/>
		/// on the main thread immediately before the flush call.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FlushEvent")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLFlushEvent([NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "Uint32")] uint type)
		{
			SDLFlushEventNative(type);
		}

		/// <summary>
		/// Clear events of a range of types from the event queue.<br/>
		/// This will unconditionally remove any events from the queue that are in the<br/>
		/// range of `minType` to `maxType`, inclusive. If you need to remove a single<br/>
		/// event type, use SDL_FlushEvent() instead.<br/>
		/// It's also normal to just ignore events you don't care about in your event<br/>
		/// loop without calling this function.<br/>
		/// This function only affects currently queued events. If you want to make<br/>
		/// sure that all pending OS events are flushed, you can call SDL_PumpEvents()<br/>
		/// on the main thread immediately before the flush call.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FlushEvents")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SDLFlushEventsNative([NativeName(NativeNameType.Param, "minType")] [NativeName(NativeNameType.Type, "Uint32")] uint minType, [NativeName(NativeNameType.Param, "maxType")] [NativeName(NativeNameType.Type, "Uint32")] uint maxType)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)vt[626])(minType, maxType);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)vt[626])(minType, maxType);
			#endif
		}

		/// <summary>
		/// Clear events of a range of types from the event queue.<br/>
		/// This will unconditionally remove any events from the queue that are in the<br/>
		/// range of `minType` to `maxType`, inclusive. If you need to remove a single<br/>
		/// event type, use SDL_FlushEvent() instead.<br/>
		/// It's also normal to just ignore events you don't care about in your event<br/>
		/// loop without calling this function.<br/>
		/// This function only affects currently queued events. If you want to make<br/>
		/// sure that all pending OS events are flushed, you can call SDL_PumpEvents()<br/>
		/// on the main thread immediately before the flush call.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FlushEvents")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLFlushEvents([NativeName(NativeNameType.Param, "minType")] [NativeName(NativeNameType.Type, "Uint32")] uint minType, [NativeName(NativeNameType.Param, "maxType")] [NativeName(NativeNameType.Type, "Uint32")] uint maxType)
		{
			SDLFlushEventsNative(minType, maxType);
		}

		/// <summary>
		/// Poll for currently pending events.<br/>
		/// If `event` is not NULL, the next event is removed from the queue and stored<br/>
		/// in the SDL_Event structure pointed to by `event`. The 1 returned refers to<br/>
		/// this event, immediately stored in the SDL Event structure -- not an event<br/>
		/// to follow.<br/>
		/// If `event` is NULL, it simply returns 1 if there is an event in the queue,<br/>
		/// but will not remove it from the queue.<br/>
		/// As this function may implicitly call SDL_PumpEvents(), you can only call<br/>
		/// this function in the thread that set the video mode.<br/>
		/// SDL_PollEvent() is the favored way of receiving system events since it can<br/>
		/// be done from the main loop and does not suspend the main loop while waiting<br/>
		/// on an event to be posted.<br/>
		/// The common practice is to fully process the event queue once every frame,<br/>
		/// usually as a first step before updating the game's state:<br/>
		/// ```c<br/>
		/// while (game_is_still_running) {<br/>
		/// SDL_Event event;<br/>
		/// while (SDL_PollEvent(<br/>
		/// &event<br/>
		/// )) {  // poll until all events are handled!<br/>
		/// // decide what to do with this event.<br/>
		/// }<br/>
		/// // update game state, draw the current frame<br/>
		/// }<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PollEvent")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLPollEventNative([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event*")] SDLEvent* evnt)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLEvent*, int>)vt[627])(evnt);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)vt[627])((nint)evnt);
			#endif
		}

		/// <summary>
		/// Poll for currently pending events.<br/>
		/// If `event` is not NULL, the next event is removed from the queue and stored<br/>
		/// in the SDL_Event structure pointed to by `event`. The 1 returned refers to<br/>
		/// this event, immediately stored in the SDL Event structure -- not an event<br/>
		/// to follow.<br/>
		/// If `event` is NULL, it simply returns 1 if there is an event in the queue,<br/>
		/// but will not remove it from the queue.<br/>
		/// As this function may implicitly call SDL_PumpEvents(), you can only call<br/>
		/// this function in the thread that set the video mode.<br/>
		/// SDL_PollEvent() is the favored way of receiving system events since it can<br/>
		/// be done from the main loop and does not suspend the main loop while waiting<br/>
		/// on an event to be posted.<br/>
		/// The common practice is to fully process the event queue once every frame,<br/>
		/// usually as a first step before updating the game's state:<br/>
		/// ```c<br/>
		/// while (game_is_still_running) {<br/>
		/// SDL_Event event;<br/>
		/// while (SDL_PollEvent(<br/>
		/// &event<br/>
		/// )) {  // poll until all events are handled!<br/>
		/// // decide what to do with this event.<br/>
		/// }<br/>
		/// // update game state, draw the current frame<br/>
		/// }<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PollEvent")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLPollEvent([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event*")] SDLEvent* evnt)
		{
			int ret = SDLPollEventNative(evnt);
			return ret;
		}

		/// <summary>
		/// Poll for currently pending events.<br/>
		/// If `event` is not NULL, the next event is removed from the queue and stored<br/>
		/// in the SDL_Event structure pointed to by `event`. The 1 returned refers to<br/>
		/// this event, immediately stored in the SDL Event structure -- not an event<br/>
		/// to follow.<br/>
		/// If `event` is NULL, it simply returns 1 if there is an event in the queue,<br/>
		/// but will not remove it from the queue.<br/>
		/// As this function may implicitly call SDL_PumpEvents(), you can only call<br/>
		/// this function in the thread that set the video mode.<br/>
		/// SDL_PollEvent() is the favored way of receiving system events since it can<br/>
		/// be done from the main loop and does not suspend the main loop while waiting<br/>
		/// on an event to be posted.<br/>
		/// The common practice is to fully process the event queue once every frame,<br/>
		/// usually as a first step before updating the game's state:<br/>
		/// ```c<br/>
		/// while (game_is_still_running) {<br/>
		/// SDL_Event event;<br/>
		/// while (SDL_PollEvent(<br/>
		/// &event<br/>
		/// )) {  // poll until all events are handled!<br/>
		/// // decide what to do with this event.<br/>
		/// }<br/>
		/// // update game state, draw the current frame<br/>
		/// }<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PollEvent")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLPollEvent([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event*")] ref SDLEvent evnt)
		{
			fixed (SDLEvent* pevnt = &evnt)
			{
				int ret = SDLPollEventNative((SDLEvent*)pevnt);
				return ret;
			}
		}

		/// <summary>
		/// Wait indefinitely for the next available event.<br/>
		/// If `event` is not NULL, the next event is removed from the queue and stored<br/>
		/// in the SDL_Event structure pointed to by `event`.<br/>
		/// As this function may implicitly call SDL_PumpEvents(), you can only call<br/>
		/// this function in the thread that initialized the video subsystem.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitEvent")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLWaitEventNative([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event*")] SDLEvent* evnt)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLEvent*, int>)vt[628])(evnt);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)vt[628])((nint)evnt);
			#endif
		}

		/// <summary>
		/// Wait indefinitely for the next available event.<br/>
		/// If `event` is not NULL, the next event is removed from the queue and stored<br/>
		/// in the SDL_Event structure pointed to by `event`.<br/>
		/// As this function may implicitly call SDL_PumpEvents(), you can only call<br/>
		/// this function in the thread that initialized the video subsystem.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitEvent")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLWaitEvent([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event*")] SDLEvent* evnt)
		{
			int ret = SDLWaitEventNative(evnt);
			return ret;
		}

		/// <summary>
		/// Wait indefinitely for the next available event.<br/>
		/// If `event` is not NULL, the next event is removed from the queue and stored<br/>
		/// in the SDL_Event structure pointed to by `event`.<br/>
		/// As this function may implicitly call SDL_PumpEvents(), you can only call<br/>
		/// this function in the thread that initialized the video subsystem.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitEvent")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLWaitEvent([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event*")] ref SDLEvent evnt)
		{
			fixed (SDLEvent* pevnt = &evnt)
			{
				int ret = SDLWaitEventNative((SDLEvent*)pevnt);
				return ret;
			}
		}

		/// <summary>
		/// Wait until the specified timeout (in milliseconds) for the next available<br/>
		/// event.<br/>
		/// If `event` is not NULL, the next event is removed from the queue and stored<br/>
		/// in the SDL_Event structure pointed to by `event`.<br/>
		/// As this function may implicitly call SDL_PumpEvents(), you can only call<br/>
		/// this function in the thread that initialized the video subsystem.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitEventTimeout")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLWaitEventTimeoutNative([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event*")] SDLEvent* evnt, [NativeName(NativeNameType.Param, "timeout")] [NativeName(NativeNameType.Type, "int")] int timeout)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLEvent*, int, int>)vt[629])(evnt, timeout);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int>)vt[629])((nint)evnt, timeout);
			#endif
		}

		/// <summary>
		/// Wait until the specified timeout (in milliseconds) for the next available<br/>
		/// event.<br/>
		/// If `event` is not NULL, the next event is removed from the queue and stored<br/>
		/// in the SDL_Event structure pointed to by `event`.<br/>
		/// As this function may implicitly call SDL_PumpEvents(), you can only call<br/>
		/// this function in the thread that initialized the video subsystem.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitEventTimeout")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLWaitEventTimeout([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event*")] SDLEvent* evnt, [NativeName(NativeNameType.Param, "timeout")] [NativeName(NativeNameType.Type, "int")] int timeout)
		{
			int ret = SDLWaitEventTimeoutNative(evnt, timeout);
			return ret;
		}

		/// <summary>
		/// Wait until the specified timeout (in milliseconds) for the next available<br/>
		/// event.<br/>
		/// If `event` is not NULL, the next event is removed from the queue and stored<br/>
		/// in the SDL_Event structure pointed to by `event`.<br/>
		/// As this function may implicitly call SDL_PumpEvents(), you can only call<br/>
		/// this function in the thread that initialized the video subsystem.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitEventTimeout")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLWaitEventTimeout([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event*")] ref SDLEvent evnt, [NativeName(NativeNameType.Param, "timeout")] [NativeName(NativeNameType.Type, "int")] int timeout)
		{
			fixed (SDLEvent* pevnt = &evnt)
			{
				int ret = SDLWaitEventTimeoutNative((SDLEvent*)pevnt, timeout);
				return ret;
			}
		}

		/// <summary>
		/// Add an event to the event queue.<br/>
		/// The event queue can actually be used as a two way communication channel.<br/>
		/// Not only can events be read from the queue, but the user can also push<br/>
		/// their own events onto it. `event` is a pointer to the event structure you<br/>
		/// wish to push onto the queue. The event is copied into the queue, and the<br/>
		/// caller may dispose of the memory pointed to after SDL_PushEvent() returns.<br/>
		/// Note: Pushing device input events onto the queue doesn't modify the state<br/>
		/// of the device within SDL.<br/>
		/// This function is thread-safe, and can be called from other threads safely.<br/>
		/// Note: Events pushed onto the queue with SDL_PushEvent() get passed through<br/>
		/// the event filter but events added with SDL_PeepEvents() do not.<br/>
		/// For pushing application-specific events, please use SDL_RegisterEvents() to<br/>
		/// get an event type that does not conflict with other code that also wants<br/>
		/// its own custom event types.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PushEvent")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLPushEventNative([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event*")] SDLEvent* evnt)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLEvent*, int>)vt[630])(evnt);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)vt[630])((nint)evnt);
			#endif
		}

		/// <summary>
		/// Add an event to the event queue.<br/>
		/// The event queue can actually be used as a two way communication channel.<br/>
		/// Not only can events be read from the queue, but the user can also push<br/>
		/// their own events onto it. `event` is a pointer to the event structure you<br/>
		/// wish to push onto the queue. The event is copied into the queue, and the<br/>
		/// caller may dispose of the memory pointed to after SDL_PushEvent() returns.<br/>
		/// Note: Pushing device input events onto the queue doesn't modify the state<br/>
		/// of the device within SDL.<br/>
		/// This function is thread-safe, and can be called from other threads safely.<br/>
		/// Note: Events pushed onto the queue with SDL_PushEvent() get passed through<br/>
		/// the event filter but events added with SDL_PeepEvents() do not.<br/>
		/// For pushing application-specific events, please use SDL_RegisterEvents() to<br/>
		/// get an event type that does not conflict with other code that also wants<br/>
		/// its own custom event types.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PushEvent")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLPushEvent([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event*")] SDLEvent* evnt)
		{
			int ret = SDLPushEventNative(evnt);
			return ret;
		}

		/// <summary>
		/// Add an event to the event queue.<br/>
		/// The event queue can actually be used as a two way communication channel.<br/>
		/// Not only can events be read from the queue, but the user can also push<br/>
		/// their own events onto it. `event` is a pointer to the event structure you<br/>
		/// wish to push onto the queue. The event is copied into the queue, and the<br/>
		/// caller may dispose of the memory pointed to after SDL_PushEvent() returns.<br/>
		/// Note: Pushing device input events onto the queue doesn't modify the state<br/>
		/// of the device within SDL.<br/>
		/// This function is thread-safe, and can be called from other threads safely.<br/>
		/// Note: Events pushed onto the queue with SDL_PushEvent() get passed through<br/>
		/// the event filter but events added with SDL_PeepEvents() do not.<br/>
		/// For pushing application-specific events, please use SDL_RegisterEvents() to<br/>
		/// get an event type that does not conflict with other code that also wants<br/>
		/// its own custom event types.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PushEvent")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLPushEvent([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event*")] ref SDLEvent evnt)
		{
			fixed (SDLEvent* pevnt = &evnt)
			{
				int ret = SDLPushEventNative((SDLEvent*)pevnt);
				return ret;
			}
		}

		/// <summary>
		/// Set up a filter to process all events before they change internal state and<br/>
		/// are posted to the internal event queue.<br/>
		/// If the filter function returns 1 when called, then the event will be added<br/>
		/// to the internal queue. If it returns 0, then the event will be dropped from<br/>
		/// the queue, but the internal state will still be updated. This allows<br/>
		/// selective filtering of dynamically arriving events.<br/>
		/// **WARNING**: Be very careful of what you do in the event filter function,<br/>
		/// as it may run in a different thread!<br/>
		/// On platforms that support it, if the quit event is generated by an<br/>
		/// interrupt signal (e.g. pressing Ctrl-C), it will be delivered to the<br/>
		/// application at the next event poll.<br/>
		/// There is one caveat when dealing with the ::SDL_QuitEvent event type. The<br/>
		/// event filter is only called when the window manager desires to close the<br/>
		/// application window. If the event filter returns 1, then the window will be<br/>
		/// closed, otherwise the window will remain open if possible.<br/>
		/// Note: Disabled events never make it to the event filter function; see<br/>
		/// SDL_EventState().<br/>
		/// Note: If you just want to inspect events without filtering, you should use<br/>
		/// SDL_AddEventWatch() instead.<br/>
		/// Note: Events pushed onto the queue with SDL_PushEvent() get passed through<br/>
		/// the event filter, but events pushed onto the queue with SDL_PeepEvents() do<br/>
		/// not.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetEventFilter")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SDLSetEventFilterNative([NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "SDL_EventFilter")] SDLEventFilter filter, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void*")] void* userdata)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<delegate*<void*, SDLEvent*, int>, void*, void>)vt[631])((delegate*<void*, SDLEvent*, int>)Utils.GetFunctionPointerForDelegate(filter), userdata);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)vt[631])((nint)Utils.GetFunctionPointerForDelegate(filter), (nint)userdata);
			#endif
		}

		/// <summary>
		/// Set up a filter to process all events before they change internal state and<br/>
		/// are posted to the internal event queue.<br/>
		/// If the filter function returns 1 when called, then the event will be added<br/>
		/// to the internal queue. If it returns 0, then the event will be dropped from<br/>
		/// the queue, but the internal state will still be updated. This allows<br/>
		/// selective filtering of dynamically arriving events.<br/>
		/// **WARNING**: Be very careful of what you do in the event filter function,<br/>
		/// as it may run in a different thread!<br/>
		/// On platforms that support it, if the quit event is generated by an<br/>
		/// interrupt signal (e.g. pressing Ctrl-C), it will be delivered to the<br/>
		/// application at the next event poll.<br/>
		/// There is one caveat when dealing with the ::SDL_QuitEvent event type. The<br/>
		/// event filter is only called when the window manager desires to close the<br/>
		/// application window. If the event filter returns 1, then the window will be<br/>
		/// closed, otherwise the window will remain open if possible.<br/>
		/// Note: Disabled events never make it to the event filter function; see<br/>
		/// SDL_EventState().<br/>
		/// Note: If you just want to inspect events without filtering, you should use<br/>
		/// SDL_AddEventWatch() instead.<br/>
		/// Note: Events pushed onto the queue with SDL_PushEvent() get passed through<br/>
		/// the event filter, but events pushed onto the queue with SDL_PeepEvents() do<br/>
		/// not.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetEventFilter")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLSetEventFilter([NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "SDL_EventFilter")] SDLEventFilter filter, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void*")] void* userdata)
		{
			SDLSetEventFilterNative(filter, userdata);
		}

		/// <summary>
		/// Query the current event filter.<br/>
		/// This function can be used to "chain" filters, by saving the existing filter<br/>
		/// before replacing it with a function that will call that saved filter.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetEventFilter")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		internal static SDLBool SDLGetEventFilterNative([NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "SDL_EventFilter*")] delegate*<void*, SDLEvent*, int>* filter, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void**")] void** userdata)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<delegate*<void*, SDLEvent*, int>*, void**, SDLBool>)vt[632])(filter, userdata);
			#else
			return (SDLBool)((delegate* unmanaged[Cdecl]<nint, nint, SDLBool>)vt[632])((nint)filter, (nint)userdata);
			#endif
		}

		/// <summary>
		/// Query the current event filter.<br/>
		/// This function can be used to "chain" filters, by saving the existing filter<br/>
		/// before replacing it with a function that will call that saved filter.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetEventFilter")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLGetEventFilter([NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "SDL_EventFilter*")] delegate*<void*, SDLEvent*, int>* filter, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void**")] void** userdata)
		{
			SDLBool ret = SDLGetEventFilterNative(filter, userdata);
			return ret;
		}

		/// <summary>
		/// Add a callback to be triggered when an event is added to the event queue.<br/>
		/// `filter` will be called when an event happens, and its return value is<br/>
		/// ignored.<br/>
		/// **WARNING**: Be very careful of what you do in the event filter function,<br/>
		/// as it may run in a different thread!<br/>
		/// If the quit event is generated by a signal (e.g. SIGINT), it will bypass<br/>
		/// the internal queue and be delivered to the watch callback immediately, and<br/>
		/// arrive at the next event poll.<br/>
		/// Note: the callback is called for events posted by the user through<br/>
		/// SDL_PushEvent(), but not for disabled events, nor for events by a filter<br/>
		/// callback set with SDL_SetEventFilter(), nor for events posted by the user<br/>
		/// through SDL_PeepEvents().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AddEventWatch")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SDLAddEventWatchNative([NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "SDL_EventFilter")] SDLEventFilter filter, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void*")] void* userdata)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<delegate*<void*, SDLEvent*, int>, void*, void>)vt[633])((delegate*<void*, SDLEvent*, int>)Utils.GetFunctionPointerForDelegate(filter), userdata);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)vt[633])((nint)Utils.GetFunctionPointerForDelegate(filter), (nint)userdata);
			#endif
		}

		/// <summary>
		/// Add a callback to be triggered when an event is added to the event queue.<br/>
		/// `filter` will be called when an event happens, and its return value is<br/>
		/// ignored.<br/>
		/// **WARNING**: Be very careful of what you do in the event filter function,<br/>
		/// as it may run in a different thread!<br/>
		/// If the quit event is generated by a signal (e.g. SIGINT), it will bypass<br/>
		/// the internal queue and be delivered to the watch callback immediately, and<br/>
		/// arrive at the next event poll.<br/>
		/// Note: the callback is called for events posted by the user through<br/>
		/// SDL_PushEvent(), but not for disabled events, nor for events by a filter<br/>
		/// callback set with SDL_SetEventFilter(), nor for events posted by the user<br/>
		/// through SDL_PeepEvents().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AddEventWatch")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLAddEventWatch([NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "SDL_EventFilter")] SDLEventFilter filter, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void*")] void* userdata)
		{
			SDLAddEventWatchNative(filter, userdata);
		}

		/// <summary>
		/// Remove an event watch callback added with SDL_AddEventWatch().<br/>
		/// This function takes the same input as SDL_AddEventWatch() to identify and<br/>
		/// delete the corresponding callback.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DelEventWatch")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SDLDelEventWatchNative([NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "SDL_EventFilter")] SDLEventFilter filter, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void*")] void* userdata)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<delegate*<void*, SDLEvent*, int>, void*, void>)vt[634])((delegate*<void*, SDLEvent*, int>)Utils.GetFunctionPointerForDelegate(filter), userdata);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)vt[634])((nint)Utils.GetFunctionPointerForDelegate(filter), (nint)userdata);
			#endif
		}

		/// <summary>
		/// Remove an event watch callback added with SDL_AddEventWatch().<br/>
		/// This function takes the same input as SDL_AddEventWatch() to identify and<br/>
		/// delete the corresponding callback.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DelEventWatch")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLDelEventWatch([NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "SDL_EventFilter")] SDLEventFilter filter, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void*")] void* userdata)
		{
			SDLDelEventWatchNative(filter, userdata);
		}

		/// <summary>
		/// Run a specific filter function on the current event queue, removing any<br/>
		/// events for which the filter returns 0.<br/>
		/// See SDL_SetEventFilter() for more information. Unlike SDL_SetEventFilter(),<br/>
		/// this function does not change the filter permanently, it only uses the<br/>
		/// supplied filter until this function returns.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FilterEvents")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SDLFilterEventsNative([NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "SDL_EventFilter")] SDLEventFilter filter, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void*")] void* userdata)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<delegate*<void*, SDLEvent*, int>, void*, void>)vt[635])((delegate*<void*, SDLEvent*, int>)Utils.GetFunctionPointerForDelegate(filter), userdata);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)vt[635])((nint)Utils.GetFunctionPointerForDelegate(filter), (nint)userdata);
			#endif
		}

		/// <summary>
		/// Run a specific filter function on the current event queue, removing any<br/>
		/// events for which the filter returns 0.<br/>
		/// See SDL_SetEventFilter() for more information. Unlike SDL_SetEventFilter(),<br/>
		/// this function does not change the filter permanently, it only uses the<br/>
		/// supplied filter until this function returns.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FilterEvents")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLFilterEvents([NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "SDL_EventFilter")] SDLEventFilter filter, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void*")] void* userdata)
		{
			SDLFilterEventsNative(filter, userdata);
		}

		/// <summary>
		/// Set the state of processing events by type.<br/>
		/// `state` may be any of the following:<br/>
		/// - `SDL_QUERY`: returns the current processing state of the specified event<br/>
		/// - `SDL_IGNORE` (aka `SDL_DISABLE`): the event will automatically be dropped<br/>
		/// from the event queue and will not be filtered<br/>
		/// - `SDL_ENABLE`: the event will be processed normally<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EventState")]
		[return: NativeName(NativeNameType.Type, "Uint8")]
		internal static byte SDLEventStateNative([NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "Uint32")] uint type, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "int")] int state)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, int, byte>)vt[636])(type, state);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, int, byte>)vt[636])(type, state);
			#endif
		}

		/// <summary>
		/// Set the state of processing events by type.<br/>
		/// `state` may be any of the following:<br/>
		/// - `SDL_QUERY`: returns the current processing state of the specified event<br/>
		/// - `SDL_IGNORE` (aka `SDL_DISABLE`): the event will automatically be dropped<br/>
		/// from the event queue and will not be filtered<br/>
		/// - `SDL_ENABLE`: the event will be processed normally<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EventState")]
		[return: NativeName(NativeNameType.Type, "Uint8")]
		public static byte SDLEventState([NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "Uint32")] uint type, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "int")] int state)
		{
			byte ret = SDLEventStateNative(type, state);
			return ret;
		}

		/// <summary>
		/// Allocate a set of user-defined events, and return the beginning event<br/>
		/// number for that set of events.<br/>
		/// Calling this function with `numevents` <br/>
		/// <<br/>
		/// = 0 is an error and will return<br/>
		/// (Uint32)-1.<br/>
		/// Note, (Uint32)-1 means the maximum unsigned 32-bit integer value (or<br/>
		/// 0xFFFFFFFF), but is clearer to write.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RegisterEvents")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		internal static uint SDLRegisterEventsNative([NativeName(NativeNameType.Param, "numevents")] [NativeName(NativeNameType.Type, "int")] int numevents)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, uint>)vt[637])(numevents);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<int, uint>)vt[637])(numevents);
			#endif
		}

		/// <summary>
		/// Allocate a set of user-defined events, and return the beginning event<br/>
		/// number for that set of events.<br/>
		/// Calling this function with `numevents` <br/>
		/// <<br/>
		/// = 0 is an error and will return<br/>
		/// (Uint32)-1.<br/>
		/// Note, (Uint32)-1 means the maximum unsigned 32-bit integer value (or<br/>
		/// 0xFFFFFFFF), but is clearer to write.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RegisterEvents")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLRegisterEvents([NativeName(NativeNameType.Param, "numevents")] [NativeName(NativeNameType.Type, "int")] int numevents)
		{
			uint ret = SDLRegisterEventsNative(numevents);
			return ret;
		}

		/// <summary>
		/// Get the directory where the application was run from.<br/>
		/// This is not necessarily a fast call, so you should call this once near<br/>
		/// startup and save the string if you need it.<br/>
		/// **Mac OS X and iOS Specific Functionality**: If the application is in a<br/>
		/// ".app" bundle, this function returns the Resource directory (e.g.<br/>
		/// MyApp.app/Contents/Resources/). This behaviour can be overridden by adding<br/>
		/// a property to the Info.plist file. Adding a string key with the name<br/>
		/// SDL_FILESYSTEM_BASE_DIR_TYPE with a supported value will change the<br/>
		/// behaviour.<br/>
		/// Supported values for the SDL_FILESYSTEM_BASE_DIR_TYPE property (Given an<br/>
		/// application in /Applications/SDLApp/MyApp.app):<br/>
		/// - `resource`: bundle resource directory (the default). For example:<br/>
		/// `/Applications/SDLApp/MyApp.app/Contents/Resources`<br/>
		/// - `bundle`: the Bundle directory. For example:<br/>
		/// `/Applications/SDLApp/MyApp.app/`<br/>
		/// - `parent`: the containing directory of the bundle. For example:<br/>
		/// `/Applications/SDLApp/`<br/>
		/// **Nintendo 3DS Specific Functionality**: This function returns "romfs"<br/>
		/// directory of the application as it is uncommon to store resources outside<br/>
		/// the executable. As such it is not a writable directory.<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// The pointer returned is owned by the caller. Please call SDL_free() on the<br/>
		/// pointer when done with it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetBasePath")]
		[return: NativeName(NativeNameType.Type, "char*")]
		internal static byte* SDLGetBasePathNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*>)vt[638])();
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint>)vt[638])();
			#endif
		}

		/// <summary>
		/// Get the directory where the application was run from.<br/>
		/// This is not necessarily a fast call, so you should call this once near<br/>
		/// startup and save the string if you need it.<br/>
		/// **Mac OS X and iOS Specific Functionality**: If the application is in a<br/>
		/// ".app" bundle, this function returns the Resource directory (e.g.<br/>
		/// MyApp.app/Contents/Resources/). This behaviour can be overridden by adding<br/>
		/// a property to the Info.plist file. Adding a string key with the name<br/>
		/// SDL_FILESYSTEM_BASE_DIR_TYPE with a supported value will change the<br/>
		/// behaviour.<br/>
		/// Supported values for the SDL_FILESYSTEM_BASE_DIR_TYPE property (Given an<br/>
		/// application in /Applications/SDLApp/MyApp.app):<br/>
		/// - `resource`: bundle resource directory (the default). For example:<br/>
		/// `/Applications/SDLApp/MyApp.app/Contents/Resources`<br/>
		/// - `bundle`: the Bundle directory. For example:<br/>
		/// `/Applications/SDLApp/MyApp.app/`<br/>
		/// - `parent`: the containing directory of the bundle. For example:<br/>
		/// `/Applications/SDLApp/`<br/>
		/// **Nintendo 3DS Specific Functionality**: This function returns "romfs"<br/>
		/// directory of the application as it is uncommon to store resources outside<br/>
		/// the executable. As such it is not a writable directory.<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// The pointer returned is owned by the caller. Please call SDL_free() on the<br/>
		/// pointer when done with it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetBasePath")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLGetBasePath()
		{
			byte* ret = SDLGetBasePathNative();
			return ret;
		}

		/// <summary>
		/// Get the directory where the application was run from.<br/>
		/// This is not necessarily a fast call, so you should call this once near<br/>
		/// startup and save the string if you need it.<br/>
		/// **Mac OS X and iOS Specific Functionality**: If the application is in a<br/>
		/// ".app" bundle, this function returns the Resource directory (e.g.<br/>
		/// MyApp.app/Contents/Resources/). This behaviour can be overridden by adding<br/>
		/// a property to the Info.plist file. Adding a string key with the name<br/>
		/// SDL_FILESYSTEM_BASE_DIR_TYPE with a supported value will change the<br/>
		/// behaviour.<br/>
		/// Supported values for the SDL_FILESYSTEM_BASE_DIR_TYPE property (Given an<br/>
		/// application in /Applications/SDLApp/MyApp.app):<br/>
		/// - `resource`: bundle resource directory (the default). For example:<br/>
		/// `/Applications/SDLApp/MyApp.app/Contents/Resources`<br/>
		/// - `bundle`: the Bundle directory. For example:<br/>
		/// `/Applications/SDLApp/MyApp.app/`<br/>
		/// - `parent`: the containing directory of the bundle. For example:<br/>
		/// `/Applications/SDLApp/`<br/>
		/// **Nintendo 3DS Specific Functionality**: This function returns "romfs"<br/>
		/// directory of the application as it is uncommon to store resources outside<br/>
		/// the executable. As such it is not a writable directory.<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// The pointer returned is owned by the caller. Please call SDL_free() on the<br/>
		/// pointer when done with it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetBasePath")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLGetBasePathS()
		{
			string ret = Utils.DecodeStringUTF8(SDLGetBasePathNative());
			return ret;
		}

		/// <summary>
		/// Get the user-and-app-specific path where files can be written.<br/>
		/// Get the "pref dir". This is meant to be where users can write personal<br/>
		/// files (preferences and save games, etc) that are specific to your<br/>
		/// application. This directory is unique per user, per application.<br/>
		/// This function will decide the appropriate location in the native<br/>
		/// filesystem, create the directory if necessary, and return a string of the<br/>
		/// absolute path to the directory in UTF-8 encoding.<br/>
		/// On Windows, the string might look like:<br/>
		/// `C:<br/>
		/// \<br/>
		/// Users<br/>
		/// \<br/>
		/// bob<br/>
		/// \<br/>
		/// AppData<br/>
		/// \<br/>
		/// Roaming<br/>
		/// \<br/>
		/// My Company<br/>
		/// \<br/>
		/// My Program Name<br/>
		/// \<br/>
		/// `<br/>
		/// On Linux, the string might look like:<br/>
		/// `/home/bob/.local/share/My Program Name/`<br/>
		/// On Mac OS X, the string might look like:<br/>
		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>
		/// You should assume the path returned by this function is the only safe place<br/>
		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>
		/// even the parent of the returned path, isn't where you should be writing<br/>
		/// things).<br/>
		/// Both the org and app strings may become part of a directory name, so please<br/>
		/// follow these rules:<br/>
		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>
		/// your applications that use this function.<br/>
		/// - Always use a unique app string for each one, and make sure it never<br/>
		/// changes for an app once you've decided on it.<br/>
		/// - Unicode characters are legal, as long as it's UTF-8 encoded, but...<br/>
		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>
		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// The pointer returned is owned by the caller. Please call SDL_free() on the<br/>
		/// pointer when done with it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char*")]
		internal static byte* SDLGetPrefPathNative([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "const char*")] byte* org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "const char*")] byte* app)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, byte*>)vt[639])(org, app);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)vt[639])((nint)org, (nint)app);
			#endif
		}

		/// <summary>
		/// Get the user-and-app-specific path where files can be written.<br/>
		/// Get the "pref dir". This is meant to be where users can write personal<br/>
		/// files (preferences and save games, etc) that are specific to your<br/>
		/// application. This directory is unique per user, per application.<br/>
		/// This function will decide the appropriate location in the native<br/>
		/// filesystem, create the directory if necessary, and return a string of the<br/>
		/// absolute path to the directory in UTF-8 encoding.<br/>
		/// On Windows, the string might look like:<br/>
		/// `C:<br/>
		/// \<br/>
		/// Users<br/>
		/// \<br/>
		/// bob<br/>
		/// \<br/>
		/// AppData<br/>
		/// \<br/>
		/// Roaming<br/>
		/// \<br/>
		/// My Company<br/>
		/// \<br/>
		/// My Program Name<br/>
		/// \<br/>
		/// `<br/>
		/// On Linux, the string might look like:<br/>
		/// `/home/bob/.local/share/My Program Name/`<br/>
		/// On Mac OS X, the string might look like:<br/>
		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>
		/// You should assume the path returned by this function is the only safe place<br/>
		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>
		/// even the parent of the returned path, isn't where you should be writing<br/>
		/// things).<br/>
		/// Both the org and app strings may become part of a directory name, so please<br/>
		/// follow these rules:<br/>
		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>
		/// your applications that use this function.<br/>
		/// - Always use a unique app string for each one, and make sure it never<br/>
		/// changes for an app once you've decided on it.<br/>
		/// - Unicode characters are legal, as long as it's UTF-8 encoded, but...<br/>
		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>
		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// The pointer returned is owned by the caller. Please call SDL_free() on the<br/>
		/// pointer when done with it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLGetPrefPath([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "const char*")] byte* org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "const char*")] byte* app)
		{
			byte* ret = SDLGetPrefPathNative(org, app);
			return ret;
		}

		/// <summary>
		/// Get the user-and-app-specific path where files can be written.<br/>
		/// Get the "pref dir". This is meant to be where users can write personal<br/>
		/// files (preferences and save games, etc) that are specific to your<br/>
		/// application. This directory is unique per user, per application.<br/>
		/// This function will decide the appropriate location in the native<br/>
		/// filesystem, create the directory if necessary, and return a string of the<br/>
		/// absolute path to the directory in UTF-8 encoding.<br/>
		/// On Windows, the string might look like:<br/>
		/// `C:<br/>
		/// \<br/>
		/// Users<br/>
		/// \<br/>
		/// bob<br/>
		/// \<br/>
		/// AppData<br/>
		/// \<br/>
		/// Roaming<br/>
		/// \<br/>
		/// My Company<br/>
		/// \<br/>
		/// My Program Name<br/>
		/// \<br/>
		/// `<br/>
		/// On Linux, the string might look like:<br/>
		/// `/home/bob/.local/share/My Program Name/`<br/>
		/// On Mac OS X, the string might look like:<br/>
		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>
		/// You should assume the path returned by this function is the only safe place<br/>
		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>
		/// even the parent of the returned path, isn't where you should be writing<br/>
		/// things).<br/>
		/// Both the org and app strings may become part of a directory name, so please<br/>
		/// follow these rules:<br/>
		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>
		/// your applications that use this function.<br/>
		/// - Always use a unique app string for each one, and make sure it never<br/>
		/// changes for an app once you've decided on it.<br/>
		/// - Unicode characters are legal, as long as it's UTF-8 encoded, but...<br/>
		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>
		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// The pointer returned is owned by the caller. Please call SDL_free() on the<br/>
		/// pointer when done with it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLGetPrefPathS([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "const char*")] byte* org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "const char*")] byte* app)
		{
			string ret = Utils.DecodeStringUTF8(SDLGetPrefPathNative(org, app));
			return ret;
		}

		/// <summary>
		/// Get the user-and-app-specific path where files can be written.<br/>
		/// Get the "pref dir". This is meant to be where users can write personal<br/>
		/// files (preferences and save games, etc) that are specific to your<br/>
		/// application. This directory is unique per user, per application.<br/>
		/// This function will decide the appropriate location in the native<br/>
		/// filesystem, create the directory if necessary, and return a string of the<br/>
		/// absolute path to the directory in UTF-8 encoding.<br/>
		/// On Windows, the string might look like:<br/>
		/// `C:<br/>
		/// \<br/>
		/// Users<br/>
		/// \<br/>
		/// bob<br/>
		/// \<br/>
		/// AppData<br/>
		/// \<br/>
		/// Roaming<br/>
		/// \<br/>
		/// My Company<br/>
		/// \<br/>
		/// My Program Name<br/>
		/// \<br/>
		/// `<br/>
		/// On Linux, the string might look like:<br/>
		/// `/home/bob/.local/share/My Program Name/`<br/>
		/// On Mac OS X, the string might look like:<br/>
		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>
		/// You should assume the path returned by this function is the only safe place<br/>
		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>
		/// even the parent of the returned path, isn't where you should be writing<br/>
		/// things).<br/>
		/// Both the org and app strings may become part of a directory name, so please<br/>
		/// follow these rules:<br/>
		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>
		/// your applications that use this function.<br/>
		/// - Always use a unique app string for each one, and make sure it never<br/>
		/// changes for an app once you've decided on it.<br/>
		/// - Unicode characters are legal, as long as it's UTF-8 encoded, but...<br/>
		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>
		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// The pointer returned is owned by the caller. Please call SDL_free() on the<br/>
		/// pointer when done with it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLGetPrefPath([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "const char*")] ref byte org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "const char*")] byte* app)
		{
			fixed (byte* porg = &org)
			{
				byte* ret = SDLGetPrefPathNative((byte*)porg, app);
				return ret;
			}
		}

		/// <summary>
		/// Get the user-and-app-specific path where files can be written.<br/>
		/// Get the "pref dir". This is meant to be where users can write personal<br/>
		/// files (preferences and save games, etc) that are specific to your<br/>
		/// application. This directory is unique per user, per application.<br/>
		/// This function will decide the appropriate location in the native<br/>
		/// filesystem, create the directory if necessary, and return a string of the<br/>
		/// absolute path to the directory in UTF-8 encoding.<br/>
		/// On Windows, the string might look like:<br/>
		/// `C:<br/>
		/// \<br/>
		/// Users<br/>
		/// \<br/>
		/// bob<br/>
		/// \<br/>
		/// AppData<br/>
		/// \<br/>
		/// Roaming<br/>
		/// \<br/>
		/// My Company<br/>
		/// \<br/>
		/// My Program Name<br/>
		/// \<br/>
		/// `<br/>
		/// On Linux, the string might look like:<br/>
		/// `/home/bob/.local/share/My Program Name/`<br/>
		/// On Mac OS X, the string might look like:<br/>
		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>
		/// You should assume the path returned by this function is the only safe place<br/>
		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>
		/// even the parent of the returned path, isn't where you should be writing<br/>
		/// things).<br/>
		/// Both the org and app strings may become part of a directory name, so please<br/>
		/// follow these rules:<br/>
		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>
		/// your applications that use this function.<br/>
		/// - Always use a unique app string for each one, and make sure it never<br/>
		/// changes for an app once you've decided on it.<br/>
		/// - Unicode characters are legal, as long as it's UTF-8 encoded, but...<br/>
		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>
		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// The pointer returned is owned by the caller. Please call SDL_free() on the<br/>
		/// pointer when done with it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLGetPrefPathS([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "const char*")] ref byte org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "const char*")] byte* app)
		{
			fixed (byte* porg = &org)
			{
				string ret = Utils.DecodeStringUTF8(SDLGetPrefPathNative((byte*)porg, app));
				return ret;
			}
		}

		/// <summary>
		/// Get the user-and-app-specific path where files can be written.<br/>
		/// Get the "pref dir". This is meant to be where users can write personal<br/>
		/// files (preferences and save games, etc) that are specific to your<br/>
		/// application. This directory is unique per user, per application.<br/>
		/// This function will decide the appropriate location in the native<br/>
		/// filesystem, create the directory if necessary, and return a string of the<br/>
		/// absolute path to the directory in UTF-8 encoding.<br/>
		/// On Windows, the string might look like:<br/>
		/// `C:<br/>
		/// \<br/>
		/// Users<br/>
		/// \<br/>
		/// bob<br/>
		/// \<br/>
		/// AppData<br/>
		/// \<br/>
		/// Roaming<br/>
		/// \<br/>
		/// My Company<br/>
		/// \<br/>
		/// My Program Name<br/>
		/// \<br/>
		/// `<br/>
		/// On Linux, the string might look like:<br/>
		/// `/home/bob/.local/share/My Program Name/`<br/>
		/// On Mac OS X, the string might look like:<br/>
		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>
		/// You should assume the path returned by this function is the only safe place<br/>
		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>
		/// even the parent of the returned path, isn't where you should be writing<br/>
		/// things).<br/>
		/// Both the org and app strings may become part of a directory name, so please<br/>
		/// follow these rules:<br/>
		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>
		/// your applications that use this function.<br/>
		/// - Always use a unique app string for each one, and make sure it never<br/>
		/// changes for an app once you've decided on it.<br/>
		/// - Unicode characters are legal, as long as it's UTF-8 encoded, but...<br/>
		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>
		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// The pointer returned is owned by the caller. Please call SDL_free() on the<br/>
		/// pointer when done with it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLGetPrefPath([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "const char*")] byte* app)
		{
			fixed (byte* porg = org)
			{
				byte* ret = SDLGetPrefPathNative((byte*)porg, app);
				return ret;
			}
		}

		/// <summary>
		/// Get the user-and-app-specific path where files can be written.<br/>
		/// Get the "pref dir". This is meant to be where users can write personal<br/>
		/// files (preferences and save games, etc) that are specific to your<br/>
		/// application. This directory is unique per user, per application.<br/>
		/// This function will decide the appropriate location in the native<br/>
		/// filesystem, create the directory if necessary, and return a string of the<br/>
		/// absolute path to the directory in UTF-8 encoding.<br/>
		/// On Windows, the string might look like:<br/>
		/// `C:<br/>
		/// \<br/>
		/// Users<br/>
		/// \<br/>
		/// bob<br/>
		/// \<br/>
		/// AppData<br/>
		/// \<br/>
		/// Roaming<br/>
		/// \<br/>
		/// My Company<br/>
		/// \<br/>
		/// My Program Name<br/>
		/// \<br/>
		/// `<br/>
		/// On Linux, the string might look like:<br/>
		/// `/home/bob/.local/share/My Program Name/`<br/>
		/// On Mac OS X, the string might look like:<br/>
		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>
		/// You should assume the path returned by this function is the only safe place<br/>
		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>
		/// even the parent of the returned path, isn't where you should be writing<br/>
		/// things).<br/>
		/// Both the org and app strings may become part of a directory name, so please<br/>
		/// follow these rules:<br/>
		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>
		/// your applications that use this function.<br/>
		/// - Always use a unique app string for each one, and make sure it never<br/>
		/// changes for an app once you've decided on it.<br/>
		/// - Unicode characters are legal, as long as it's UTF-8 encoded, but...<br/>
		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>
		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// The pointer returned is owned by the caller. Please call SDL_free() on the<br/>
		/// pointer when done with it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLGetPrefPathS([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "const char*")] byte* app)
		{
			fixed (byte* porg = org)
			{
				string ret = Utils.DecodeStringUTF8(SDLGetPrefPathNative((byte*)porg, app));
				return ret;
			}
		}

		/// <summary>
		/// Get the user-and-app-specific path where files can be written.<br/>
		/// Get the "pref dir". This is meant to be where users can write personal<br/>
		/// files (preferences and save games, etc) that are specific to your<br/>
		/// application. This directory is unique per user, per application.<br/>
		/// This function will decide the appropriate location in the native<br/>
		/// filesystem, create the directory if necessary, and return a string of the<br/>
		/// absolute path to the directory in UTF-8 encoding.<br/>
		/// On Windows, the string might look like:<br/>
		/// `C:<br/>
		/// \<br/>
		/// Users<br/>
		/// \<br/>
		/// bob<br/>
		/// \<br/>
		/// AppData<br/>
		/// \<br/>
		/// Roaming<br/>
		/// \<br/>
		/// My Company<br/>
		/// \<br/>
		/// My Program Name<br/>
		/// \<br/>
		/// `<br/>
		/// On Linux, the string might look like:<br/>
		/// `/home/bob/.local/share/My Program Name/`<br/>
		/// On Mac OS X, the string might look like:<br/>
		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>
		/// You should assume the path returned by this function is the only safe place<br/>
		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>
		/// even the parent of the returned path, isn't where you should be writing<br/>
		/// things).<br/>
		/// Both the org and app strings may become part of a directory name, so please<br/>
		/// follow these rules:<br/>
		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>
		/// your applications that use this function.<br/>
		/// - Always use a unique app string for each one, and make sure it never<br/>
		/// changes for an app once you've decided on it.<br/>
		/// - Unicode characters are legal, as long as it's UTF-8 encoded, but...<br/>
		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>
		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// The pointer returned is owned by the caller. Please call SDL_free() on the<br/>
		/// pointer when done with it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLGetPrefPath([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "const char*")] string org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "const char*")] byte* app)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (org != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(org);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(org, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = SDLGetPrefPathNative(pStr0, app);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get the user-and-app-specific path where files can be written.<br/>
		/// Get the "pref dir". This is meant to be where users can write personal<br/>
		/// files (preferences and save games, etc) that are specific to your<br/>
		/// application. This directory is unique per user, per application.<br/>
		/// This function will decide the appropriate location in the native<br/>
		/// filesystem, create the directory if necessary, and return a string of the<br/>
		/// absolute path to the directory in UTF-8 encoding.<br/>
		/// On Windows, the string might look like:<br/>
		/// `C:<br/>
		/// \<br/>
		/// Users<br/>
		/// \<br/>
		/// bob<br/>
		/// \<br/>
		/// AppData<br/>
		/// \<br/>
		/// Roaming<br/>
		/// \<br/>
		/// My Company<br/>
		/// \<br/>
		/// My Program Name<br/>
		/// \<br/>
		/// `<br/>
		/// On Linux, the string might look like:<br/>
		/// `/home/bob/.local/share/My Program Name/`<br/>
		/// On Mac OS X, the string might look like:<br/>
		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>
		/// You should assume the path returned by this function is the only safe place<br/>
		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>
		/// even the parent of the returned path, isn't where you should be writing<br/>
		/// things).<br/>
		/// Both the org and app strings may become part of a directory name, so please<br/>
		/// follow these rules:<br/>
		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>
		/// your applications that use this function.<br/>
		/// - Always use a unique app string for each one, and make sure it never<br/>
		/// changes for an app once you've decided on it.<br/>
		/// - Unicode characters are legal, as long as it's UTF-8 encoded, but...<br/>
		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>
		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// The pointer returned is owned by the caller. Please call SDL_free() on the<br/>
		/// pointer when done with it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLGetPrefPathS([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "const char*")] string org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "const char*")] byte* app)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (org != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(org);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(org, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(SDLGetPrefPathNative(pStr0, app));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get the user-and-app-specific path where files can be written.<br/>
		/// Get the "pref dir". This is meant to be where users can write personal<br/>
		/// files (preferences and save games, etc) that are specific to your<br/>
		/// application. This directory is unique per user, per application.<br/>
		/// This function will decide the appropriate location in the native<br/>
		/// filesystem, create the directory if necessary, and return a string of the<br/>
		/// absolute path to the directory in UTF-8 encoding.<br/>
		/// On Windows, the string might look like:<br/>
		/// `C:<br/>
		/// \<br/>
		/// Users<br/>
		/// \<br/>
		/// bob<br/>
		/// \<br/>
		/// AppData<br/>
		/// \<br/>
		/// Roaming<br/>
		/// \<br/>
		/// My Company<br/>
		/// \<br/>
		/// My Program Name<br/>
		/// \<br/>
		/// `<br/>
		/// On Linux, the string might look like:<br/>
		/// `/home/bob/.local/share/My Program Name/`<br/>
		/// On Mac OS X, the string might look like:<br/>
		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>
		/// You should assume the path returned by this function is the only safe place<br/>
		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>
		/// even the parent of the returned path, isn't where you should be writing<br/>
		/// things).<br/>
		/// Both the org and app strings may become part of a directory name, so please<br/>
		/// follow these rules:<br/>
		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>
		/// your applications that use this function.<br/>
		/// - Always use a unique app string for each one, and make sure it never<br/>
		/// changes for an app once you've decided on it.<br/>
		/// - Unicode characters are legal, as long as it's UTF-8 encoded, but...<br/>
		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>
		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// The pointer returned is owned by the caller. Please call SDL_free() on the<br/>
		/// pointer when done with it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLGetPrefPath([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "const char*")] byte* org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "const char*")] ref byte app)
		{
			fixed (byte* papp = &app)
			{
				byte* ret = SDLGetPrefPathNative(org, (byte*)papp);
				return ret;
			}
		}

		/// <summary>
		/// Get the user-and-app-specific path where files can be written.<br/>
		/// Get the "pref dir". This is meant to be where users can write personal<br/>
		/// files (preferences and save games, etc) that are specific to your<br/>
		/// application. This directory is unique per user, per application.<br/>
		/// This function will decide the appropriate location in the native<br/>
		/// filesystem, create the directory if necessary, and return a string of the<br/>
		/// absolute path to the directory in UTF-8 encoding.<br/>
		/// On Windows, the string might look like:<br/>
		/// `C:<br/>
		/// \<br/>
		/// Users<br/>
		/// \<br/>
		/// bob<br/>
		/// \<br/>
		/// AppData<br/>
		/// \<br/>
		/// Roaming<br/>
		/// \<br/>
		/// My Company<br/>
		/// \<br/>
		/// My Program Name<br/>
		/// \<br/>
		/// `<br/>
		/// On Linux, the string might look like:<br/>
		/// `/home/bob/.local/share/My Program Name/`<br/>
		/// On Mac OS X, the string might look like:<br/>
		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>
		/// You should assume the path returned by this function is the only safe place<br/>
		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>
		/// even the parent of the returned path, isn't where you should be writing<br/>
		/// things).<br/>
		/// Both the org and app strings may become part of a directory name, so please<br/>
		/// follow these rules:<br/>
		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>
		/// your applications that use this function.<br/>
		/// - Always use a unique app string for each one, and make sure it never<br/>
		/// changes for an app once you've decided on it.<br/>
		/// - Unicode characters are legal, as long as it's UTF-8 encoded, but...<br/>
		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>
		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// The pointer returned is owned by the caller. Please call SDL_free() on the<br/>
		/// pointer when done with it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLGetPrefPathS([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "const char*")] byte* org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "const char*")] ref byte app)
		{
			fixed (byte* papp = &app)
			{
				string ret = Utils.DecodeStringUTF8(SDLGetPrefPathNative(org, (byte*)papp));
				return ret;
			}
		}

		/// <summary>
		/// Get the user-and-app-specific path where files can be written.<br/>
		/// Get the "pref dir". This is meant to be where users can write personal<br/>
		/// files (preferences and save games, etc) that are specific to your<br/>
		/// application. This directory is unique per user, per application.<br/>
		/// This function will decide the appropriate location in the native<br/>
		/// filesystem, create the directory if necessary, and return a string of the<br/>
		/// absolute path to the directory in UTF-8 encoding.<br/>
		/// On Windows, the string might look like:<br/>
		/// `C:<br/>
		/// \<br/>
		/// Users<br/>
		/// \<br/>
		/// bob<br/>
		/// \<br/>
		/// AppData<br/>
		/// \<br/>
		/// Roaming<br/>
		/// \<br/>
		/// My Company<br/>
		/// \<br/>
		/// My Program Name<br/>
		/// \<br/>
		/// `<br/>
		/// On Linux, the string might look like:<br/>
		/// `/home/bob/.local/share/My Program Name/`<br/>
		/// On Mac OS X, the string might look like:<br/>
		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>
		/// You should assume the path returned by this function is the only safe place<br/>
		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>
		/// even the parent of the returned path, isn't where you should be writing<br/>
		/// things).<br/>
		/// Both the org and app strings may become part of a directory name, so please<br/>
		/// follow these rules:<br/>
		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>
		/// your applications that use this function.<br/>
		/// - Always use a unique app string for each one, and make sure it never<br/>
		/// changes for an app once you've decided on it.<br/>
		/// - Unicode characters are legal, as long as it's UTF-8 encoded, but...<br/>
		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>
		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// The pointer returned is owned by the caller. Please call SDL_free() on the<br/>
		/// pointer when done with it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLGetPrefPath([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "const char*")] byte* org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> app)
		{
			fixed (byte* papp = app)
			{
				byte* ret = SDLGetPrefPathNative(org, (byte*)papp);
				return ret;
			}
		}

		/// <summary>
		/// Get the user-and-app-specific path where files can be written.<br/>
		/// Get the "pref dir". This is meant to be where users can write personal<br/>
		/// files (preferences and save games, etc) that are specific to your<br/>
		/// application. This directory is unique per user, per application.<br/>
		/// This function will decide the appropriate location in the native<br/>
		/// filesystem, create the directory if necessary, and return a string of the<br/>
		/// absolute path to the directory in UTF-8 encoding.<br/>
		/// On Windows, the string might look like:<br/>
		/// `C:<br/>
		/// \<br/>
		/// Users<br/>
		/// \<br/>
		/// bob<br/>
		/// \<br/>
		/// AppData<br/>
		/// \<br/>
		/// Roaming<br/>
		/// \<br/>
		/// My Company<br/>
		/// \<br/>
		/// My Program Name<br/>
		/// \<br/>
		/// `<br/>
		/// On Linux, the string might look like:<br/>
		/// `/home/bob/.local/share/My Program Name/`<br/>
		/// On Mac OS X, the string might look like:<br/>
		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>
		/// You should assume the path returned by this function is the only safe place<br/>
		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>
		/// even the parent of the returned path, isn't where you should be writing<br/>
		/// things).<br/>
		/// Both the org and app strings may become part of a directory name, so please<br/>
		/// follow these rules:<br/>
		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>
		/// your applications that use this function.<br/>
		/// - Always use a unique app string for each one, and make sure it never<br/>
		/// changes for an app once you've decided on it.<br/>
		/// - Unicode characters are legal, as long as it's UTF-8 encoded, but...<br/>
		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>
		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// The pointer returned is owned by the caller. Please call SDL_free() on the<br/>
		/// pointer when done with it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLGetPrefPathS([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "const char*")] byte* org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> app)
		{
			fixed (byte* papp = app)
			{
				string ret = Utils.DecodeStringUTF8(SDLGetPrefPathNative(org, (byte*)papp));
				return ret;
			}
		}

		/// <summary>
		/// Get the user-and-app-specific path where files can be written.<br/>
		/// Get the "pref dir". This is meant to be where users can write personal<br/>
		/// files (preferences and save games, etc) that are specific to your<br/>
		/// application. This directory is unique per user, per application.<br/>
		/// This function will decide the appropriate location in the native<br/>
		/// filesystem, create the directory if necessary, and return a string of the<br/>
		/// absolute path to the directory in UTF-8 encoding.<br/>
		/// On Windows, the string might look like:<br/>
		/// `C:<br/>
		/// \<br/>
		/// Users<br/>
		/// \<br/>
		/// bob<br/>
		/// \<br/>
		/// AppData<br/>
		/// \<br/>
		/// Roaming<br/>
		/// \<br/>
		/// My Company<br/>
		/// \<br/>
		/// My Program Name<br/>
		/// \<br/>
		/// `<br/>
		/// On Linux, the string might look like:<br/>
		/// `/home/bob/.local/share/My Program Name/`<br/>
		/// On Mac OS X, the string might look like:<br/>
		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>
		/// You should assume the path returned by this function is the only safe place<br/>
		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>
		/// even the parent of the returned path, isn't where you should be writing<br/>
		/// things).<br/>
		/// Both the org and app strings may become part of a directory name, so please<br/>
		/// follow these rules:<br/>
		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>
		/// your applications that use this function.<br/>
		/// - Always use a unique app string for each one, and make sure it never<br/>
		/// changes for an app once you've decided on it.<br/>
		/// - Unicode characters are legal, as long as it's UTF-8 encoded, but...<br/>
		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>
		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// The pointer returned is owned by the caller. Please call SDL_free() on the<br/>
		/// pointer when done with it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLGetPrefPath([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "const char*")] byte* org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "const char*")] string app)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (app != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(app);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(app, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = SDLGetPrefPathNative(org, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get the user-and-app-specific path where files can be written.<br/>
		/// Get the "pref dir". This is meant to be where users can write personal<br/>
		/// files (preferences and save games, etc) that are specific to your<br/>
		/// application. This directory is unique per user, per application.<br/>
		/// This function will decide the appropriate location in the native<br/>
		/// filesystem, create the directory if necessary, and return a string of the<br/>
		/// absolute path to the directory in UTF-8 encoding.<br/>
		/// On Windows, the string might look like:<br/>
		/// `C:<br/>
		/// \<br/>
		/// Users<br/>
		/// \<br/>
		/// bob<br/>
		/// \<br/>
		/// AppData<br/>
		/// \<br/>
		/// Roaming<br/>
		/// \<br/>
		/// My Company<br/>
		/// \<br/>
		/// My Program Name<br/>
		/// \<br/>
		/// `<br/>
		/// On Linux, the string might look like:<br/>
		/// `/home/bob/.local/share/My Program Name/`<br/>
		/// On Mac OS X, the string might look like:<br/>
		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>
		/// You should assume the path returned by this function is the only safe place<br/>
		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>
		/// even the parent of the returned path, isn't where you should be writing<br/>
		/// things).<br/>
		/// Both the org and app strings may become part of a directory name, so please<br/>
		/// follow these rules:<br/>
		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>
		/// your applications that use this function.<br/>
		/// - Always use a unique app string for each one, and make sure it never<br/>
		/// changes for an app once you've decided on it.<br/>
		/// - Unicode characters are legal, as long as it's UTF-8 encoded, but...<br/>
		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>
		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// The pointer returned is owned by the caller. Please call SDL_free() on the<br/>
		/// pointer when done with it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLGetPrefPathS([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "const char*")] byte* org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "const char*")] string app)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (app != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(app);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(app, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(SDLGetPrefPathNative(org, pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get the user-and-app-specific path where files can be written.<br/>
		/// Get the "pref dir". This is meant to be where users can write personal<br/>
		/// files (preferences and save games, etc) that are specific to your<br/>
		/// application. This directory is unique per user, per application.<br/>
		/// This function will decide the appropriate location in the native<br/>
		/// filesystem, create the directory if necessary, and return a string of the<br/>
		/// absolute path to the directory in UTF-8 encoding.<br/>
		/// On Windows, the string might look like:<br/>
		/// `C:<br/>
		/// \<br/>
		/// Users<br/>
		/// \<br/>
		/// bob<br/>
		/// \<br/>
		/// AppData<br/>
		/// \<br/>
		/// Roaming<br/>
		/// \<br/>
		/// My Company<br/>
		/// \<br/>
		/// My Program Name<br/>
		/// \<br/>
		/// `<br/>
		/// On Linux, the string might look like:<br/>
		/// `/home/bob/.local/share/My Program Name/`<br/>
		/// On Mac OS X, the string might look like:<br/>
		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>
		/// You should assume the path returned by this function is the only safe place<br/>
		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>
		/// even the parent of the returned path, isn't where you should be writing<br/>
		/// things).<br/>
		/// Both the org and app strings may become part of a directory name, so please<br/>
		/// follow these rules:<br/>
		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>
		/// your applications that use this function.<br/>
		/// - Always use a unique app string for each one, and make sure it never<br/>
		/// changes for an app once you've decided on it.<br/>
		/// - Unicode characters are legal, as long as it's UTF-8 encoded, but...<br/>
		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>
		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// The pointer returned is owned by the caller. Please call SDL_free() on the<br/>
		/// pointer when done with it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLGetPrefPath([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "const char*")] ref byte org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "const char*")] ref byte app)
		{
			fixed (byte* porg = &org)
			{
				fixed (byte* papp = &app)
				{
					byte* ret = SDLGetPrefPathNative((byte*)porg, (byte*)papp);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the user-and-app-specific path where files can be written.<br/>
		/// Get the "pref dir". This is meant to be where users can write personal<br/>
		/// files (preferences and save games, etc) that are specific to your<br/>
		/// application. This directory is unique per user, per application.<br/>
		/// This function will decide the appropriate location in the native<br/>
		/// filesystem, create the directory if necessary, and return a string of the<br/>
		/// absolute path to the directory in UTF-8 encoding.<br/>
		/// On Windows, the string might look like:<br/>
		/// `C:<br/>
		/// \<br/>
		/// Users<br/>
		/// \<br/>
		/// bob<br/>
		/// \<br/>
		/// AppData<br/>
		/// \<br/>
		/// Roaming<br/>
		/// \<br/>
		/// My Company<br/>
		/// \<br/>
		/// My Program Name<br/>
		/// \<br/>
		/// `<br/>
		/// On Linux, the string might look like:<br/>
		/// `/home/bob/.local/share/My Program Name/`<br/>
		/// On Mac OS X, the string might look like:<br/>
		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>
		/// You should assume the path returned by this function is the only safe place<br/>
		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>
		/// even the parent of the returned path, isn't where you should be writing<br/>
		/// things).<br/>
		/// Both the org and app strings may become part of a directory name, so please<br/>
		/// follow these rules:<br/>
		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>
		/// your applications that use this function.<br/>
		/// - Always use a unique app string for each one, and make sure it never<br/>
		/// changes for an app once you've decided on it.<br/>
		/// - Unicode characters are legal, as long as it's UTF-8 encoded, but...<br/>
		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>
		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// The pointer returned is owned by the caller. Please call SDL_free() on the<br/>
		/// pointer when done with it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLGetPrefPathS([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "const char*")] ref byte org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "const char*")] ref byte app)
		{
			fixed (byte* porg = &org)
			{
				fixed (byte* papp = &app)
				{
					string ret = Utils.DecodeStringUTF8(SDLGetPrefPathNative((byte*)porg, (byte*)papp));
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the user-and-app-specific path where files can be written.<br/>
		/// Get the "pref dir". This is meant to be where users can write personal<br/>
		/// files (preferences and save games, etc) that are specific to your<br/>
		/// application. This directory is unique per user, per application.<br/>
		/// This function will decide the appropriate location in the native<br/>
		/// filesystem, create the directory if necessary, and return a string of the<br/>
		/// absolute path to the directory in UTF-8 encoding.<br/>
		/// On Windows, the string might look like:<br/>
		/// `C:<br/>
		/// \<br/>
		/// Users<br/>
		/// \<br/>
		/// bob<br/>
		/// \<br/>
		/// AppData<br/>
		/// \<br/>
		/// Roaming<br/>
		/// \<br/>
		/// My Company<br/>
		/// \<br/>
		/// My Program Name<br/>
		/// \<br/>
		/// `<br/>
		/// On Linux, the string might look like:<br/>
		/// `/home/bob/.local/share/My Program Name/`<br/>
		/// On Mac OS X, the string might look like:<br/>
		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>
		/// You should assume the path returned by this function is the only safe place<br/>
		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>
		/// even the parent of the returned path, isn't where you should be writing<br/>
		/// things).<br/>
		/// Both the org and app strings may become part of a directory name, so please<br/>
		/// follow these rules:<br/>
		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>
		/// your applications that use this function.<br/>
		/// - Always use a unique app string for each one, and make sure it never<br/>
		/// changes for an app once you've decided on it.<br/>
		/// - Unicode characters are legal, as long as it's UTF-8 encoded, but...<br/>
		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>
		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// The pointer returned is owned by the caller. Please call SDL_free() on the<br/>
		/// pointer when done with it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLGetPrefPath([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> app)
		{
			fixed (byte* porg = org)
			{
				fixed (byte* papp = app)
				{
					byte* ret = SDLGetPrefPathNative((byte*)porg, (byte*)papp);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the user-and-app-specific path where files can be written.<br/>
		/// Get the "pref dir". This is meant to be where users can write personal<br/>
		/// files (preferences and save games, etc) that are specific to your<br/>
		/// application. This directory is unique per user, per application.<br/>
		/// This function will decide the appropriate location in the native<br/>
		/// filesystem, create the directory if necessary, and return a string of the<br/>
		/// absolute path to the directory in UTF-8 encoding.<br/>
		/// On Windows, the string might look like:<br/>
		/// `C:<br/>
		/// \<br/>
		/// Users<br/>
		/// \<br/>
		/// bob<br/>
		/// \<br/>
		/// AppData<br/>
		/// \<br/>
		/// Roaming<br/>
		/// \<br/>
		/// My Company<br/>
		/// \<br/>
		/// My Program Name<br/>
		/// \<br/>
		/// `<br/>
		/// On Linux, the string might look like:<br/>
		/// `/home/bob/.local/share/My Program Name/`<br/>
		/// On Mac OS X, the string might look like:<br/>
		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>
		/// You should assume the path returned by this function is the only safe place<br/>
		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>
		/// even the parent of the returned path, isn't where you should be writing<br/>
		/// things).<br/>
		/// Both the org and app strings may become part of a directory name, so please<br/>
		/// follow these rules:<br/>
		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>
		/// your applications that use this function.<br/>
		/// - Always use a unique app string for each one, and make sure it never<br/>
		/// changes for an app once you've decided on it.<br/>
		/// - Unicode characters are legal, as long as it's UTF-8 encoded, but...<br/>
		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>
		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// The pointer returned is owned by the caller. Please call SDL_free() on the<br/>
		/// pointer when done with it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLGetPrefPathS([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> app)
		{
			fixed (byte* porg = org)
			{
				fixed (byte* papp = app)
				{
					string ret = Utils.DecodeStringUTF8(SDLGetPrefPathNative((byte*)porg, (byte*)papp));
					return ret;
				}
			}
		}
	}
}
