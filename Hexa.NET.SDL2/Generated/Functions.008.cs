// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL2
{
	public unsafe partial class SDL
	{

		/// <summary>/// Get the gamma ramp for a given window's display.<br/>/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>/// entire display, not an individual window. A window is considered to be<br/>/// owned by the display that contains the window's center pixel. (The index of<br/>/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowGammaRamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowGammaRamp([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* blue)
		{
			fixed (ushort* pred = &red)
			{
				int ret = SDLGetWindowGammaRampNative(window, (ushort*)pred, green, blue);
				return ret;
			}
		}

		/// <summary>/// Get the gamma ramp for a given window's display.<br/>/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>/// entire display, not an individual window. A window is considered to be<br/>/// owned by the display that contains the window's center pixel. (The index of<br/>/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowGammaRamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowGammaRamp([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (ushort* pred = &red)
				{
					int ret = SDLGetWindowGammaRampNative((SDLWindow*)pwindow, (ushort*)pred, green, blue);
					return ret;
				}
			}
		}

		/// <summary>/// Get the gamma ramp for a given window's display.<br/>/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>/// entire display, not an individual window. A window is considered to be<br/>/// owned by the display that contains the window's center pixel. (The index of<br/>/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowGammaRamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowGammaRamp([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* blue)
		{
			fixed (ushort* pgreen = &green)
			{
				int ret = SDLGetWindowGammaRampNative(window, red, (ushort*)pgreen, blue);
				return ret;
			}
		}

		/// <summary>/// Get the gamma ramp for a given window's display.<br/>/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>/// entire display, not an individual window. A window is considered to be<br/>/// owned by the display that contains the window's center pixel. (The index of<br/>/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowGammaRamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowGammaRamp([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (ushort* pgreen = &green)
				{
					int ret = SDLGetWindowGammaRampNative((SDLWindow*)pwindow, red, (ushort*)pgreen, blue);
					return ret;
				}
			}
		}

		/// <summary>/// Get the gamma ramp for a given window's display.<br/>/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>/// entire display, not an individual window. A window is considered to be<br/>/// owned by the display that contains the window's center pixel. (The index of<br/>/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowGammaRamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowGammaRamp([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* blue)
		{
			fixed (ushort* pred = &red)
			{
				fixed (ushort* pgreen = &green)
				{
					int ret = SDLGetWindowGammaRampNative(window, (ushort*)pred, (ushort*)pgreen, blue);
					return ret;
				}
			}
		}

		/// <summary>/// Get the gamma ramp for a given window's display.<br/>/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>/// entire display, not an individual window. A window is considered to be<br/>/// owned by the display that contains the window's center pixel. (The index of<br/>/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowGammaRamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowGammaRamp([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (ushort* pred = &red)
				{
					fixed (ushort* pgreen = &green)
					{
						int ret = SDLGetWindowGammaRampNative((SDLWindow*)pwindow, (ushort*)pred, (ushort*)pgreen, blue);
						return ret;
					}
				}
			}
		}

		/// <summary>/// Get the gamma ramp for a given window's display.<br/>/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>/// entire display, not an individual window. A window is considered to be<br/>/// owned by the display that contains the window's center pixel. (The index of<br/>/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowGammaRamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowGammaRamp([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort blue)
		{
			fixed (ushort* pblue = &blue)
			{
				int ret = SDLGetWindowGammaRampNative(window, red, green, (ushort*)pblue);
				return ret;
			}
		}

		/// <summary>/// Get the gamma ramp for a given window's display.<br/>/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>/// entire display, not an individual window. A window is considered to be<br/>/// owned by the display that contains the window's center pixel. (The index of<br/>/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowGammaRamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowGammaRamp([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (ushort* pblue = &blue)
				{
					int ret = SDLGetWindowGammaRampNative((SDLWindow*)pwindow, red, green, (ushort*)pblue);
					return ret;
				}
			}
		}

		/// <summary>/// Get the gamma ramp for a given window's display.<br/>/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>/// entire display, not an individual window. A window is considered to be<br/>/// owned by the display that contains the window's center pixel. (The index of<br/>/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowGammaRamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowGammaRamp([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort blue)
		{
			fixed (ushort* pred = &red)
			{
				fixed (ushort* pblue = &blue)
				{
					int ret = SDLGetWindowGammaRampNative(window, (ushort*)pred, green, (ushort*)pblue);
					return ret;
				}
			}
		}

		/// <summary>/// Get the gamma ramp for a given window's display.<br/>/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>/// entire display, not an individual window. A window is considered to be<br/>/// owned by the display that contains the window's center pixel. (The index of<br/>/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowGammaRamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowGammaRamp([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (ushort* pred = &red)
				{
					fixed (ushort* pblue = &blue)
					{
						int ret = SDLGetWindowGammaRampNative((SDLWindow*)pwindow, (ushort*)pred, green, (ushort*)pblue);
						return ret;
					}
				}
			}
		}

		/// <summary>/// Get the gamma ramp for a given window's display.<br/>/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>/// entire display, not an individual window. A window is considered to be<br/>/// owned by the display that contains the window's center pixel. (The index of<br/>/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowGammaRamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowGammaRamp([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort blue)
		{
			fixed (ushort* pgreen = &green)
			{
				fixed (ushort* pblue = &blue)
				{
					int ret = SDLGetWindowGammaRampNative(window, red, (ushort*)pgreen, (ushort*)pblue);
					return ret;
				}
			}
		}

		/// <summary>/// Get the gamma ramp for a given window's display.<br/>/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>/// entire display, not an individual window. A window is considered to be<br/>/// owned by the display that contains the window's center pixel. (The index of<br/>/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowGammaRamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowGammaRamp([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (ushort* pgreen = &green)
				{
					fixed (ushort* pblue = &blue)
					{
						int ret = SDLGetWindowGammaRampNative((SDLWindow*)pwindow, red, (ushort*)pgreen, (ushort*)pblue);
						return ret;
					}
				}
			}
		}

		/// <summary>/// Get the gamma ramp for a given window's display.<br/>/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>/// entire display, not an individual window. A window is considered to be<br/>/// owned by the display that contains the window's center pixel. (The index of<br/>/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowGammaRamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowGammaRamp([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort blue)
		{
			fixed (ushort* pred = &red)
			{
				fixed (ushort* pgreen = &green)
				{
					fixed (ushort* pblue = &blue)
					{
						int ret = SDLGetWindowGammaRampNative(window, (ushort*)pred, (ushort*)pgreen, (ushort*)pblue);
						return ret;
					}
				}
			}
		}

		/// <summary>/// Get the gamma ramp for a given window's display.<br/>/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>/// entire display, not an individual window. A window is considered to be<br/>/// owned by the display that contains the window's center pixel. (The index of<br/>/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowGammaRamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowGammaRamp([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (ushort* pred = &red)
				{
					fixed (ushort* pgreen = &green)
					{
						fixed (ushort* pblue = &blue)
						{
							int ret = SDLGetWindowGammaRampNative((SDLWindow*)pwindow, (ushort*)pred, (ushort*)pgreen, (ushort*)pblue);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Provide a callback that decides if a window region has special properties.<br/>
		/// Normally windows are dragged and resized by decorations provided by the<br/>
		/// system window manager (a title bar, borders, etc), but for some apps, it<br/>
		/// makes sense to drag them from somewhere else inside the window itself; for<br/>
		/// example, one might have a borderless window that wants to be draggable from<br/>
		/// any part, or simulate its own title bar, etc.<br/>
		/// This function lets the app provide a callback that designates pieces of a<br/>
		/// given window as special. This callback is run during event processing if we<br/>
		/// need to tell the OS to treat a region of the window specially; the use of<br/>
		/// this callback is known as "hit testing."<br/>
		/// Mouse input may not be delivered to your application if it is within a<br/>
		/// special area; the OS will often apply that input to moving the window or<br/>
		/// resizing the window and not deliver it to the application.<br/>
		/// Specifying NULL for a callback disables hit-testing. Hit-testing is<br/>
		/// disabled by default.<br/>
		/// Platforms that don't support this functionality will return -1<br/>
		/// unconditionally, even if you're attempting to disable hit-testing.<br/>
		/// Your callback may fire at any time, and its firing does not indicate any<br/>
		/// specific behavior (for example, on Windows, this certainly might fire when<br/>
		/// the OS is deciding whether to drag your window, but it fires for lots of<br/>
		/// other reasons, too, some unrelated to anything you probably care about _and<br/>
		/// when the mouse isn't actually at the location it is testing_). Since this<br/>
		/// can fire at any time, you should try to keep your callback efficient,<br/>
		/// devoid of allocations, etc.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowHitTest")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLSetWindowHitTestNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_HitTest")] delegate*<SDLWindow*, SDLPoint*, void*, SDLHitTestResult> callback, [NativeName(NativeNameType.Param, "callback_data")] [NativeName(NativeNameType.Type, "void*")] void* callbackData)
		{
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, delegate*<SDLWindow*, SDLPoint*, void*, SDLHitTestResult>, void*, int>)vt[418])(window, callback, callbackData);
		}
		/// <summary>/// Provide a callback that decides if a window region has special properties.<br/>/// Normally windows are dragged and resized by decorations provided by the<br/>/// system window manager (a title bar, borders, etc), but for some apps, it<br/>/// makes sense to drag them from somewhere else inside the window itself; for<br/>/// example, one might have a borderless window that wants to be draggable from<br/>/// any part, or simulate its own title bar, etc.<br/>/// This function lets the app provide a callback that designates pieces of a<br/>/// given window as special. This callback is run during event processing if we<br/>/// need to tell the OS to treat a region of the window specially; the use of<br/>/// this callback is known as "hit testing."<br/>/// Mouse input may not be delivered to your application if it is within a<br/>/// special area; the OS will often apply that input to moving the window or<br/>/// resizing the window and not deliver it to the application.<br/>/// Specifying NULL for a callback disables hit-testing. Hit-testing is<br/>/// disabled by default.<br/>/// Platforms that don't support this functionality will return -1<br/>/// unconditionally, even if you're attempting to disable hit-testing.<br/>/// Your callback may fire at any time, and its firing does not indicate any<br/>/// specific behavior (for example, on Windows, this certainly might fire when<br/>/// the OS is deciding whether to drag your window, but it fires for lots of<br/>/// other reasons, too, some unrelated to anything you probably care about _and<br/>/// when the mouse isn't actually at the location it is testing_). Since this<br/>/// can fire at any time, you should try to keep your callback efficient,<br/>/// devoid of allocations, etc.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowHitTest")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetWindowHitTest([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_HitTest")] delegate*<SDLWindow*, SDLPoint*, void*, SDLHitTestResult> callback, [NativeName(NativeNameType.Param, "callback_data")] [NativeName(NativeNameType.Type, "void*")] void* callbackData)
		{
			int ret = SDLSetWindowHitTestNative(window, callback, callbackData);
			return ret;
		}

		/// <summary>/// Provide a callback that decides if a window region has special properties.<br/>/// Normally windows are dragged and resized by decorations provided by the<br/>/// system window manager (a title bar, borders, etc), but for some apps, it<br/>/// makes sense to drag them from somewhere else inside the window itself; for<br/>/// example, one might have a borderless window that wants to be draggable from<br/>/// any part, or simulate its own title bar, etc.<br/>/// This function lets the app provide a callback that designates pieces of a<br/>/// given window as special. This callback is run during event processing if we<br/>/// need to tell the OS to treat a region of the window specially; the use of<br/>/// this callback is known as "hit testing."<br/>/// Mouse input may not be delivered to your application if it is within a<br/>/// special area; the OS will often apply that input to moving the window or<br/>/// resizing the window and not deliver it to the application.<br/>/// Specifying NULL for a callback disables hit-testing. Hit-testing is<br/>/// disabled by default.<br/>/// Platforms that don't support this functionality will return -1<br/>/// unconditionally, even if you're attempting to disable hit-testing.<br/>/// Your callback may fire at any time, and its firing does not indicate any<br/>/// specific behavior (for example, on Windows, this certainly might fire when<br/>/// the OS is deciding whether to drag your window, but it fires for lots of<br/>/// other reasons, too, some unrelated to anything you probably care about _and<br/>/// when the mouse isn't actually at the location it is testing_). Since this<br/>/// can fire at any time, you should try to keep your callback efficient,<br/>/// devoid of allocations, etc.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowHitTest")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetWindowHitTest([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_HitTest")] delegate*<SDLWindow*, SDLPoint*, void*, SDLHitTestResult> callback, [NativeName(NativeNameType.Param, "callback_data")] [NativeName(NativeNameType.Type, "void*")] void* callbackData)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = SDLSetWindowHitTestNative((SDLWindow*)pwindow, callback, callbackData);
				return ret;
			}
		}

		/// <summary>
		/// Request a window to demand attention from the user.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FlashWindow")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLFlashWindowNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "operation")] [NativeName(NativeNameType.Type, "SDL_FlashOperation")] SDLFlashOperation operation)
		{
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLFlashOperation, int>)vt[419])(window, operation);
		}
		/// <summary>/// Request a window to demand attention from the user.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_FlashWindow")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLFlashWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "operation")] [NativeName(NativeNameType.Type, "SDL_FlashOperation")] SDLFlashOperation operation)
		{
			int ret = SDLFlashWindowNative(window, operation);
			return ret;
		}

		/// <summary>/// Request a window to demand attention from the user.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_FlashWindow")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLFlashWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "operation")] [NativeName(NativeNameType.Type, "SDL_FlashOperation")] SDLFlashOperation operation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = SDLFlashWindowNative((SDLWindow*)pwindow, operation);
				return ret;
			}
		}

		/// <summary>
		/// Destroy a window.<br/>
		/// If `window` is NULL, this function will return immediately after setting<br/>
		/// the SDL error message to "Invalid window". See SDL_GetError().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SDLDestroyWindowNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window)
		{
			((delegate* unmanaged[Cdecl]<SDLWindow*, void>)vt[420])(window);
		}
		/// <summary>/// Destroy a window.<br/>/// If `window` is NULL, this function will return immediately after setting<br/>/// the SDL error message to "Invalid window". See SDL_GetError().<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_DestroyWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLDestroyWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window)
		{
			SDLDestroyWindowNative(window);
		}

		/// <summary>/// Destroy a window.<br/>/// If `window` is NULL, this function will return immediately after setting<br/>/// the SDL error message to "Invalid window". See SDL_GetError().<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_DestroyWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLDestroyWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLDestroyWindowNative((SDLWindow*)pwindow);
			}
		}

		/// <summary>
		/// Check whether the screensaver is currently enabled.<br/>
		/// The screensaver is disabled by default since SDL 2.0.2. Before SDL 2.0.2<br/>
		/// the screensaver was enabled by default.<br/>
		/// The default can also be changed using `SDL_HINT_VIDEO_ALLOW_SCREENSAVER`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IsScreenSaverEnabled")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		internal static SDLBool SDLIsScreenSaverEnabledNative()
		{
			return ((delegate* unmanaged[Cdecl]<SDLBool>)vt[421])();
		}
		/// <summary>/// Check whether the screensaver is currently enabled.<br/>/// The screensaver is disabled by default since SDL 2.0.2. Before SDL 2.0.2<br/>/// the screensaver was enabled by default.<br/>/// The default can also be changed using `SDL_HINT_VIDEO_ALLOW_SCREENSAVER`.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_IsScreenSaverEnabled")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIsScreenSaverEnabled()
		{
			SDLBool ret = SDLIsScreenSaverEnabledNative();
			return ret;
		}

		/// <summary>
		/// Allow the screen to be blanked by a screen saver.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnableScreenSaver")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SDLEnableScreenSaverNative()
		{
			((delegate* unmanaged[Cdecl]<void>)vt[422])();
		}
		/// <summary>/// Allow the screen to be blanked by a screen saver.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_EnableScreenSaver")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLEnableScreenSaver()
		{
			SDLEnableScreenSaverNative();
		}

		/// <summary>
		/// Prevent the screen from being blanked by a screen saver.<br/>
		/// If you disable the screensaver, it is automatically re-enabled when SDL<br/>
		/// quits.<br/>
		/// The screensaver is disabled by default since SDL 2.0.2. Before SDL 2.0.2<br/>
		/// the screensaver was enabled by default.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DisableScreenSaver")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SDLDisableScreenSaverNative()
		{
			((delegate* unmanaged[Cdecl]<void>)vt[423])();
		}
		/// <summary>/// Prevent the screen from being blanked by a screen saver.<br/>/// If you disable the screensaver, it is automatically re-enabled when SDL<br/>/// quits.<br/>/// The screensaver is disabled by default since SDL 2.0.2. Before SDL 2.0.2<br/>/// the screensaver was enabled by default.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_DisableScreenSaver")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLDisableScreenSaver()
		{
			SDLDisableScreenSaverNative();
		}

		/// <summary>
		/// Dynamically load an OpenGL library.<br/>
		/// This should be done after initializing the video driver, but before<br/>
		/// creating any OpenGL windows. If no OpenGL library is loaded, the default<br/>
		/// library will be loaded upon creation of the first OpenGL window.<br/>
		/// If you do this, you need to retrieve all of the GL functions used in your<br/>
		/// program from the dynamic library using SDL_GL_GetProcAddress().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_LoadLibrary")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLGLLoadLibraryNative([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "const char*")] byte* path)
		{
			return ((delegate* unmanaged[Cdecl]<byte*, int>)vt[424])(path);
		}
		/// <summary>/// Dynamically load an OpenGL library.<br/>/// This should be done after initializing the video driver, but before<br/>/// creating any OpenGL windows. If no OpenGL library is loaded, the default<br/>/// library will be loaded upon creation of the first OpenGL window.<br/>/// If you do this, you need to retrieve all of the GL functions used in your<br/>/// program from the dynamic library using SDL_GL_GetProcAddress().<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_LoadLibrary")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGLLoadLibrary([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "const char*")] byte* path)
		{
			int ret = SDLGLLoadLibraryNative(path);
			return ret;
		}

		/// <summary>/// Dynamically load an OpenGL library.<br/>/// This should be done after initializing the video driver, but before<br/>/// creating any OpenGL windows. If no OpenGL library is loaded, the default<br/>/// library will be loaded upon creation of the first OpenGL window.<br/>/// If you do this, you need to retrieve all of the GL functions used in your<br/>/// program from the dynamic library using SDL_GL_GetProcAddress().<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_LoadLibrary")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGLLoadLibrary([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "const char*")] ref byte path)
		{
			fixed (byte* ppath = &path)
			{
				int ret = SDLGLLoadLibraryNative((byte*)ppath);
				return ret;
			}
		}

		/// <summary>/// Dynamically load an OpenGL library.<br/>/// This should be done after initializing the video driver, but before<br/>/// creating any OpenGL windows. If no OpenGL library is loaded, the default<br/>/// library will be loaded upon creation of the first OpenGL window.<br/>/// If you do this, you need to retrieve all of the GL functions used in your<br/>/// program from the dynamic library using SDL_GL_GetProcAddress().<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_LoadLibrary")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGLLoadLibrary([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "const char*")] string path)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (path != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(path);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(path, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SDLGLLoadLibraryNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get an OpenGL function by name.<br/>
		/// If the GL library is loaded at runtime with SDL_GL_LoadLibrary(), then all<br/>
		/// GL functions must be retrieved this way. Usually this is used to retrieve<br/>
		/// function pointers to OpenGL extensions.<br/>
		/// There are some quirks to looking up OpenGL functions that require some<br/>
		/// extra care from the application. If you code carefully, you can handle<br/>
		/// these quirks without any platform-specific code, though:<br/>
		/// - On Windows, function pointers are specific to the current GL context;<br/>
		/// this means you need to have created a GL context and made it current<br/>
		/// before calling SDL_GL_GetProcAddress(). If you recreate your context or<br/>
		/// create a second context, you should assume that any existing function<br/>
		/// pointers aren't valid to use with it. This is (currently) a<br/>
		/// Windows-specific limitation, and in practice lots of drivers don't suffer<br/>
		/// this limitation, but it is still the way the wgl API is documented to<br/>
		/// work and you should expect crashes if you don't respect it. Store a copy<br/>
		/// of the function pointers that comes and goes with context lifespan.<br/>
		/// - On X11, function pointers returned by this function are valid for any<br/>
		/// context, and can even be looked up before a context is created at all.<br/>
		/// This means that, for at least some common OpenGL implementations, if you<br/>
		/// look up a function that doesn't exist, you'll get a non-NULL result that<br/>
		/// is _NOT_ safe to call. You must always make sure the function is actually<br/>
		/// available for a given GL context before calling it, by checking for the<br/>
		/// existence of the appropriate extension with SDL_GL_ExtensionSupported(),<br/>
		/// or verifying that the version of OpenGL you're using offers the function<br/>
		/// as core functionality.<br/>
		/// - Some OpenGL drivers, on all platforms, *will* return NULL if a function<br/>
		/// isn't supported, but you can't count on this behavior. Check for<br/>
		/// extensions you use, and if you get a NULL anyway, act as if that<br/>
		/// extension wasn't available. This is probably a bug in the driver, but you<br/>
		/// can code defensively for this scenario anyhow.<br/>
		/// - Just because you're on Linux/Unix, don't assume you'll be using X11.<br/>
		/// Next-gen display servers are waiting to replace it, and may or may not<br/>
		/// make the same promises about function pointers.<br/>
		/// - OpenGL function pointers must be declared `APIENTRY` as in the example<br/>
		/// code. This will ensure the proper calling convention is followed on<br/>
		/// platforms where this matters (Win32) thereby avoiding stack corruption.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_GetProcAddress")]
		[return: NativeName(NativeNameType.Type, "void*")]
		internal static void* SDLGLGetProcAddressNative([NativeName(NativeNameType.Param, "proc")] [NativeName(NativeNameType.Type, "const char*")] byte* proc)
		{
			return ((delegate* unmanaged[Cdecl]<byte*, void*>)vt[425])(proc);
		}
		/// <summary>/// Get an OpenGL function by name.<br/>/// If the GL library is loaded at runtime with SDL_GL_LoadLibrary(), then all<br/>/// GL functions must be retrieved this way. Usually this is used to retrieve<br/>/// function pointers to OpenGL extensions.<br/>/// There are some quirks to looking up OpenGL functions that require some<br/>/// extra care from the application. If you code carefully, you can handle<br/>/// these quirks without any platform-specific code, though:<br/>/// - On Windows, function pointers are specific to the current GL context;<br/>/// this means you need to have created a GL context and made it current<br/>/// before calling SDL_GL_GetProcAddress(). If you recreate your context or<br/>/// create a second context, you should assume that any existing function<br/>/// pointers aren't valid to use with it. This is (currently) a<br/>/// Windows-specific limitation, and in practice lots of drivers don't suffer<br/>/// this limitation, but it is still the way the wgl API is documented to<br/>/// work and you should expect crashes if you don't respect it. Store a copy<br/>/// of the function pointers that comes and goes with context lifespan.<br/>/// - On X11, function pointers returned by this function are valid for any<br/>/// context, and can even be looked up before a context is created at all.<br/>/// This means that, for at least some common OpenGL implementations, if you<br/>/// look up a function that doesn't exist, you'll get a non-NULL result that<br/>/// is _NOT_ safe to call. You must always make sure the function is actually<br/>/// available for a given GL context before calling it, by checking for the<br/>/// existence of the appropriate extension with SDL_GL_ExtensionSupported(),<br/>/// or verifying that the version of OpenGL you're using offers the function<br/>/// as core functionality.<br/>/// - Some OpenGL drivers, on all platforms, *will* return NULL if a function<br/>/// isn't supported, but you can't count on this behavior. Check for<br/>/// extensions you use, and if you get a NULL anyway, act as if that<br/>/// extension wasn't available. This is probably a bug in the driver, but you<br/>/// can code defensively for this scenario anyhow.<br/>/// - Just because you're on Linux/Unix, don't assume you'll be using X11.<br/>/// Next-gen display servers are waiting to replace it, and may or may not<br/>/// make the same promises about function pointers.<br/>/// - OpenGL function pointers must be declared `APIENTRY` as in the example<br/>/// code. This will ensure the proper calling convention is followed on<br/>/// platforms where this matters (Win32) thereby avoiding stack corruption.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_GetProcAddress")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLGLGetProcAddress([NativeName(NativeNameType.Param, "proc")] [NativeName(NativeNameType.Type, "const char*")] byte* proc)
		{
			void* ret = SDLGLGetProcAddressNative(proc);
			return ret;
		}

		/// <summary>/// Get an OpenGL function by name.<br/>/// If the GL library is loaded at runtime with SDL_GL_LoadLibrary(), then all<br/>/// GL functions must be retrieved this way. Usually this is used to retrieve<br/>/// function pointers to OpenGL extensions.<br/>/// There are some quirks to looking up OpenGL functions that require some<br/>/// extra care from the application. If you code carefully, you can handle<br/>/// these quirks without any platform-specific code, though:<br/>/// - On Windows, function pointers are specific to the current GL context;<br/>/// this means you need to have created a GL context and made it current<br/>/// before calling SDL_GL_GetProcAddress(). If you recreate your context or<br/>/// create a second context, you should assume that any existing function<br/>/// pointers aren't valid to use with it. This is (currently) a<br/>/// Windows-specific limitation, and in practice lots of drivers don't suffer<br/>/// this limitation, but it is still the way the wgl API is documented to<br/>/// work and you should expect crashes if you don't respect it. Store a copy<br/>/// of the function pointers that comes and goes with context lifespan.<br/>/// - On X11, function pointers returned by this function are valid for any<br/>/// context, and can even be looked up before a context is created at all.<br/>/// This means that, for at least some common OpenGL implementations, if you<br/>/// look up a function that doesn't exist, you'll get a non-NULL result that<br/>/// is _NOT_ safe to call. You must always make sure the function is actually<br/>/// available for a given GL context before calling it, by checking for the<br/>/// existence of the appropriate extension with SDL_GL_ExtensionSupported(),<br/>/// or verifying that the version of OpenGL you're using offers the function<br/>/// as core functionality.<br/>/// - Some OpenGL drivers, on all platforms, *will* return NULL if a function<br/>/// isn't supported, but you can't count on this behavior. Check for<br/>/// extensions you use, and if you get a NULL anyway, act as if that<br/>/// extension wasn't available. This is probably a bug in the driver, but you<br/>/// can code defensively for this scenario anyhow.<br/>/// - Just because you're on Linux/Unix, don't assume you'll be using X11.<br/>/// Next-gen display servers are waiting to replace it, and may or may not<br/>/// make the same promises about function pointers.<br/>/// - OpenGL function pointers must be declared `APIENTRY` as in the example<br/>/// code. This will ensure the proper calling convention is followed on<br/>/// platforms where this matters (Win32) thereby avoiding stack corruption.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_GetProcAddress")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLGLGetProcAddress([NativeName(NativeNameType.Param, "proc")] [NativeName(NativeNameType.Type, "const char*")] ref byte proc)
		{
			fixed (byte* pproc = &proc)
			{
				void* ret = SDLGLGetProcAddressNative((byte*)pproc);
				return ret;
			}
		}

		/// <summary>/// Get an OpenGL function by name.<br/>/// If the GL library is loaded at runtime with SDL_GL_LoadLibrary(), then all<br/>/// GL functions must be retrieved this way. Usually this is used to retrieve<br/>/// function pointers to OpenGL extensions.<br/>/// There are some quirks to looking up OpenGL functions that require some<br/>/// extra care from the application. If you code carefully, you can handle<br/>/// these quirks without any platform-specific code, though:<br/>/// - On Windows, function pointers are specific to the current GL context;<br/>/// this means you need to have created a GL context and made it current<br/>/// before calling SDL_GL_GetProcAddress(). If you recreate your context or<br/>/// create a second context, you should assume that any existing function<br/>/// pointers aren't valid to use with it. This is (currently) a<br/>/// Windows-specific limitation, and in practice lots of drivers don't suffer<br/>/// this limitation, but it is still the way the wgl API is documented to<br/>/// work and you should expect crashes if you don't respect it. Store a copy<br/>/// of the function pointers that comes and goes with context lifespan.<br/>/// - On X11, function pointers returned by this function are valid for any<br/>/// context, and can even be looked up before a context is created at all.<br/>/// This means that, for at least some common OpenGL implementations, if you<br/>/// look up a function that doesn't exist, you'll get a non-NULL result that<br/>/// is _NOT_ safe to call. You must always make sure the function is actually<br/>/// available for a given GL context before calling it, by checking for the<br/>/// existence of the appropriate extension with SDL_GL_ExtensionSupported(),<br/>/// or verifying that the version of OpenGL you're using offers the function<br/>/// as core functionality.<br/>/// - Some OpenGL drivers, on all platforms, *will* return NULL if a function<br/>/// isn't supported, but you can't count on this behavior. Check for<br/>/// extensions you use, and if you get a NULL anyway, act as if that<br/>/// extension wasn't available. This is probably a bug in the driver, but you<br/>/// can code defensively for this scenario anyhow.<br/>/// - Just because you're on Linux/Unix, don't assume you'll be using X11.<br/>/// Next-gen display servers are waiting to replace it, and may or may not<br/>/// make the same promises about function pointers.<br/>/// - OpenGL function pointers must be declared `APIENTRY` as in the example<br/>/// code. This will ensure the proper calling convention is followed on<br/>/// platforms where this matters (Win32) thereby avoiding stack corruption.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_GetProcAddress")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLGLGetProcAddress([NativeName(NativeNameType.Param, "proc")] [NativeName(NativeNameType.Type, "const char*")] string proc)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (proc != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(proc);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(proc, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			void* ret = SDLGLGetProcAddressNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Unload the OpenGL library previously loaded by SDL_GL_LoadLibrary().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_UnloadLibrary")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SDLGLUnloadLibraryNative()
		{
			((delegate* unmanaged[Cdecl]<void>)vt[426])();
		}
		/// <summary>/// Unload the OpenGL library previously loaded by SDL_GL_LoadLibrary().<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_UnloadLibrary")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGLUnloadLibrary()
		{
			SDLGLUnloadLibraryNative();
		}

		/// <summary>
		/// Check if an OpenGL extension is supported for the current context.<br/>
		/// This function operates on the current GL context; you must have created a<br/>
		/// context and it must be current before calling this function. Do not assume<br/>
		/// that all contexts you create will have the same set of extensions<br/>
		/// available, or that recreating an existing context will offer the same<br/>
		/// extensions again.<br/>
		/// While it's probably not a massive overhead, this function is not an O(1)<br/>
		/// operation. Check the extensions you care about after creating the GL<br/>
		/// context and save that information somewhere instead of calling the function<br/>
		/// every time you need to know.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_ExtensionSupported")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		internal static SDLBool SDLGLExtensionSupportedNative([NativeName(NativeNameType.Param, "extension")] [NativeName(NativeNameType.Type, "const char*")] byte* extension)
		{
			return ((delegate* unmanaged[Cdecl]<byte*, SDLBool>)vt[427])(extension);
		}
		/// <summary>/// Check if an OpenGL extension is supported for the current context.<br/>/// This function operates on the current GL context; you must have created a<br/>/// context and it must be current before calling this function. Do not assume<br/>/// that all contexts you create will have the same set of extensions<br/>/// available, or that recreating an existing context will offer the same<br/>/// extensions again.<br/>/// While it's probably not a massive overhead, this function is not an O(1)<br/>/// operation. Check the extensions you care about after creating the GL<br/>/// context and save that information somewhere instead of calling the function<br/>/// every time you need to know.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_ExtensionSupported")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLGLExtensionSupported([NativeName(NativeNameType.Param, "extension")] [NativeName(NativeNameType.Type, "const char*")] byte* extension)
		{
			SDLBool ret = SDLGLExtensionSupportedNative(extension);
			return ret;
		}

		/// <summary>/// Check if an OpenGL extension is supported for the current context.<br/>/// This function operates on the current GL context; you must have created a<br/>/// context and it must be current before calling this function. Do not assume<br/>/// that all contexts you create will have the same set of extensions<br/>/// available, or that recreating an existing context will offer the same<br/>/// extensions again.<br/>/// While it's probably not a massive overhead, this function is not an O(1)<br/>/// operation. Check the extensions you care about after creating the GL<br/>/// context and save that information somewhere instead of calling the function<br/>/// every time you need to know.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_ExtensionSupported")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLGLExtensionSupported([NativeName(NativeNameType.Param, "extension")] [NativeName(NativeNameType.Type, "const char*")] ref byte extension)
		{
			fixed (byte* pextension = &extension)
			{
				SDLBool ret = SDLGLExtensionSupportedNative((byte*)pextension);
				return ret;
			}
		}

		/// <summary>/// Check if an OpenGL extension is supported for the current context.<br/>/// This function operates on the current GL context; you must have created a<br/>/// context and it must be current before calling this function. Do not assume<br/>/// that all contexts you create will have the same set of extensions<br/>/// available, or that recreating an existing context will offer the same<br/>/// extensions again.<br/>/// While it's probably not a massive overhead, this function is not an O(1)<br/>/// operation. Check the extensions you care about after creating the GL<br/>/// context and save that information somewhere instead of calling the function<br/>/// every time you need to know.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_ExtensionSupported")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLGLExtensionSupported([NativeName(NativeNameType.Param, "extension")] [NativeName(NativeNameType.Type, "const char*")] string extension)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (extension != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(extension);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(extension, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLBool ret = SDLGLExtensionSupportedNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Reset all previously set OpenGL context attributes to their default values.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_ResetAttributes")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SDLGLResetAttributesNative()
		{
			((delegate* unmanaged[Cdecl]<void>)vt[428])();
		}
		/// <summary>/// Reset all previously set OpenGL context attributes to their default values.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_ResetAttributes")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGLResetAttributes()
		{
			SDLGLResetAttributesNative();
		}

		/// <summary>
		/// Set an OpenGL window attribute before window creation.<br/>
		/// This function sets the OpenGL attribute `attr` to `value`. The requested<br/>
		/// attributes should be set before creating an OpenGL window. You should use<br/>
		/// SDL_GL_GetAttribute() to check the values after creating the OpenGL<br/>
		/// context, since the values obtained can differ from the requested ones.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_SetAttribute")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLGLSetAttributeNative([NativeName(NativeNameType.Param, "attr")] [NativeName(NativeNameType.Type, "SDL_GLattr")] SDLGLattr attr, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "int")] int value)
		{
			return ((delegate* unmanaged[Cdecl]<SDLGLattr, int, int>)vt[429])(attr, value);
		}
		/// <summary>/// Set an OpenGL window attribute before window creation.<br/>/// This function sets the OpenGL attribute `attr` to `value`. The requested<br/>/// attributes should be set before creating an OpenGL window. You should use<br/>/// SDL_GL_GetAttribute() to check the values after creating the OpenGL<br/>/// context, since the values obtained can differ from the requested ones.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_SetAttribute")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGLSetAttribute([NativeName(NativeNameType.Param, "attr")] [NativeName(NativeNameType.Type, "SDL_GLattr")] SDLGLattr attr, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "int")] int value)
		{
			int ret = SDLGLSetAttributeNative(attr, value);
			return ret;
		}

		/// <summary>
		/// Get the actual value for an attribute from the current context.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_GetAttribute")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLGLGetAttributeNative([NativeName(NativeNameType.Param, "attr")] [NativeName(NativeNameType.Type, "SDL_GLattr")] SDLGLattr attr, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "int*")] int* value)
		{
			return ((delegate* unmanaged[Cdecl]<SDLGLattr, int*, int>)vt[430])(attr, value);
		}
		/// <summary>/// Get the actual value for an attribute from the current context.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_GetAttribute")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGLGetAttribute([NativeName(NativeNameType.Param, "attr")] [NativeName(NativeNameType.Type, "SDL_GLattr")] SDLGLattr attr, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "int*")] int* value)
		{
			int ret = SDLGLGetAttributeNative(attr, value);
			return ret;
		}

		/// <summary>/// Get the actual value for an attribute from the current context.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_GetAttribute")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGLGetAttribute([NativeName(NativeNameType.Param, "attr")] [NativeName(NativeNameType.Type, "SDL_GLattr")] SDLGLattr attr, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "int*")] ref int value)
		{
			fixed (int* pvalue = &value)
			{
				int ret = SDLGLGetAttributeNative(attr, (int*)pvalue);
				return ret;
			}
		}

		/// <summary>
		/// Create an OpenGL context for an OpenGL window, and make it current.<br/>
		/// Windows users new to OpenGL should note that, for historical reasons, GL<br/>
		/// functions added after OpenGL version 1.1 are not available by default.<br/>
		/// Those functions must be loaded at run-time, either with an OpenGL<br/>
		/// extension-handling library or with SDL_GL_GetProcAddress() and its related<br/>
		/// functions.<br/>
		/// SDL_GLContext is an alias for `void *`. It's opaque to the application.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_CreateContext")]
		[return: NativeName(NativeNameType.Type, "SDL_GLContext")]
		internal static SDLGLContext SDLGLCreateContextNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window)
		{
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLGLContext>)vt[431])(window);
		}
		/// <summary>/// Create an OpenGL context for an OpenGL window, and make it current.<br/>/// Windows users new to OpenGL should note that, for historical reasons, GL<br/>/// functions added after OpenGL version 1.1 are not available by default.<br/>/// Those functions must be loaded at run-time, either with an OpenGL<br/>/// extension-handling library or with SDL_GL_GetProcAddress() and its related<br/>/// functions.<br/>/// SDL_GLContext is an alias for `void *`. It's opaque to the application.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_CreateContext")]
		[return: NativeName(NativeNameType.Type, "SDL_GLContext")]
		public static SDLGLContext SDLGLCreateContext([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window)
		{
			SDLGLContext ret = SDLGLCreateContextNative(window);
			return ret;
		}

		/// <summary>/// Create an OpenGL context for an OpenGL window, and make it current.<br/>/// Windows users new to OpenGL should note that, for historical reasons, GL<br/>/// functions added after OpenGL version 1.1 are not available by default.<br/>/// Those functions must be loaded at run-time, either with an OpenGL<br/>/// extension-handling library or with SDL_GL_GetProcAddress() and its related<br/>/// functions.<br/>/// SDL_GLContext is an alias for `void *`. It's opaque to the application.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_CreateContext")]
		[return: NativeName(NativeNameType.Type, "SDL_GLContext")]
		public static SDLGLContext SDLGLCreateContext([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLGLContext ret = SDLGLCreateContextNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Set up an OpenGL context for rendering into an OpenGL window.<br/>
		/// The context must have been created with a compatible window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_MakeCurrent")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLGLMakeCurrentNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_GLContext")] SDLGLContext context)
		{
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLGLContext, int>)vt[432])(window, context);
		}
		/// <summary>/// Set up an OpenGL context for rendering into an OpenGL window.<br/>/// The context must have been created with a compatible window.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_MakeCurrent")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGLMakeCurrent([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_GLContext")] SDLGLContext context)
		{
			int ret = SDLGLMakeCurrentNative(window, context);
			return ret;
		}

		/// <summary>/// Set up an OpenGL context for rendering into an OpenGL window.<br/>/// The context must have been created with a compatible window.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_MakeCurrent")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGLMakeCurrent([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_GLContext")] SDLGLContext context)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = SDLGLMakeCurrentNative((SDLWindow*)pwindow, context);
				return ret;
			}
		}

		/// <summary>
		/// Get the currently active OpenGL window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_GetCurrentWindow")]
		[return: NativeName(NativeNameType.Type, "SDL_Window*")]
		internal static SDLWindow* SDLGLGetCurrentWindowNative()
		{
			return ((delegate* unmanaged[Cdecl]<SDLWindow*>)vt[433])();
		}
		/// <summary>/// Get the currently active OpenGL window.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_GetCurrentWindow")]
		[return: NativeName(NativeNameType.Type, "SDL_Window*")]
		public static SDLWindow* SDLGLGetCurrentWindow()
		{
			SDLWindow* ret = SDLGLGetCurrentWindowNative();
			return ret;
		}

		/// <summary>
		/// Get the currently active OpenGL context.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_GetCurrentContext")]
		[return: NativeName(NativeNameType.Type, "SDL_GLContext")]
		internal static SDLGLContext SDLGLGetCurrentContextNative()
		{
			return ((delegate* unmanaged[Cdecl]<SDLGLContext>)vt[434])();
		}
		/// <summary>/// Get the currently active OpenGL context.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_GetCurrentContext")]
		[return: NativeName(NativeNameType.Type, "SDL_GLContext")]
		public static SDLGLContext SDLGLGetCurrentContext()
		{
			SDLGLContext ret = SDLGLGetCurrentContextNative();
			return ret;
		}

		/// <summary>
		/// Get the size of a window's underlying drawable in pixels.<br/>
		/// This returns info useful for calling glViewport().<br/>
		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>
		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>
		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>
		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_GetDrawableSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SDLGLGetDrawableSizeNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			((delegate* unmanaged[Cdecl]<SDLWindow*, int*, int*, void>)vt[435])(window, w, h);
		}
		/// <summary>/// Get the size of a window's underlying drawable in pixels.<br/>/// This returns info useful for calling glViewport().<br/>/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_GetDrawableSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGLGetDrawableSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			SDLGLGetDrawableSizeNative(window, w, h);
		}

		/// <summary>/// Get the size of a window's underlying drawable in pixels.<br/>/// This returns info useful for calling glViewport().<br/>/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_GetDrawableSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGLGetDrawableSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLGLGetDrawableSizeNative((SDLWindow*)pwindow, w, h);
			}
		}

		/// <summary>/// Get the size of a window's underlying drawable in pixels.<br/>/// This returns info useful for calling glViewport().<br/>/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_GetDrawableSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGLGetDrawableSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (int* pw = &w)
			{
				SDLGLGetDrawableSizeNative(window, (int*)pw, h);
			}
		}

		/// <summary>/// Get the size of a window's underlying drawable in pixels.<br/>/// This returns info useful for calling glViewport().<br/>/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_GetDrawableSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGLGetDrawableSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					SDLGLGetDrawableSizeNative((SDLWindow*)pwindow, (int*)pw, h);
				}
			}
		}

		/// <summary>/// Get the size of a window's underlying drawable in pixels.<br/>/// This returns info useful for calling glViewport().<br/>/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_GetDrawableSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGLGetDrawableSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (int* ph = &h)
			{
				SDLGLGetDrawableSizeNative(window, w, (int*)ph);
			}
		}

		/// <summary>/// Get the size of a window's underlying drawable in pixels.<br/>/// This returns info useful for calling glViewport().<br/>/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_GetDrawableSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGLGetDrawableSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ph = &h)
				{
					SDLGLGetDrawableSizeNative((SDLWindow*)pwindow, w, (int*)ph);
				}
			}
		}

		/// <summary>/// Get the size of a window's underlying drawable in pixels.<br/>/// This returns info useful for calling glViewport().<br/>/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_GetDrawableSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGLGetDrawableSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (int* pw = &w)
			{
				fixed (int* ph = &h)
				{
					SDLGLGetDrawableSizeNative(window, (int*)pw, (int*)ph);
				}
			}
		}

		/// <summary>/// Get the size of a window's underlying drawable in pixels.<br/>/// This returns info useful for calling glViewport().<br/>/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_GetDrawableSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGLGetDrawableSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					fixed (int* ph = &h)
					{
						SDLGLGetDrawableSizeNative((SDLWindow*)pwindow, (int*)pw, (int*)ph);
					}
				}
			}
		}

		/// <summary>
		/// Set the swap interval for the current OpenGL context.<br/>
		/// Some systems allow specifying -1 for the interval, to enable adaptive<br/>
		/// vsync. Adaptive vsync works the same as vsync, but if you've already missed<br/>
		/// the vertical retrace for a given frame, it swaps buffers immediately, which<br/>
		/// might be less jarring for the user during occasional framerate drops. If an<br/>
		/// application requests adaptive vsync and the system does not support it,<br/>
		/// this function will fail and return -1. In such a case, you should probably<br/>
		/// retry the call with 1 for the interval.<br/>
		/// Adaptive vsync is implemented for some glX drivers with<br/>
		/// GLX_EXT_swap_control_tear, and for some Windows drivers with<br/>
		/// WGL_EXT_swap_control_tear.<br/>
		/// Read more on the Khronos wiki:<br/>
		/// https://www.khronos.org/opengl/wiki/Swap_Interval#Adaptive_Vsync<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_SetSwapInterval")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLGLSetSwapIntervalNative([NativeName(NativeNameType.Param, "interval")] [NativeName(NativeNameType.Type, "int")] int interval)
		{
			return ((delegate* unmanaged[Cdecl]<int, int>)vt[436])(interval);
		}
		/// <summary>/// Set the swap interval for the current OpenGL context.<br/>/// Some systems allow specifying -1 for the interval, to enable adaptive<br/>/// vsync. Adaptive vsync works the same as vsync, but if you've already missed<br/>/// the vertical retrace for a given frame, it swaps buffers immediately, which<br/>/// might be less jarring for the user during occasional framerate drops. If an<br/>/// application requests adaptive vsync and the system does not support it,<br/>/// this function will fail and return -1. In such a case, you should probably<br/>/// retry the call with 1 for the interval.<br/>/// Adaptive vsync is implemented for some glX drivers with<br/>/// GLX_EXT_swap_control_tear, and for some Windows drivers with<br/>/// WGL_EXT_swap_control_tear.<br/>/// Read more on the Khronos wiki:<br/>/// https://www.khronos.org/opengl/wiki/Swap_Interval#Adaptive_Vsync<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_SetSwapInterval")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGLSetSwapInterval([NativeName(NativeNameType.Param, "interval")] [NativeName(NativeNameType.Type, "int")] int interval)
		{
			int ret = SDLGLSetSwapIntervalNative(interval);
			return ret;
		}

		/// <summary>
		/// Get the swap interval for the current OpenGL context.<br/>
		/// If the system can't determine the swap interval, or there isn't a valid<br/>
		/// current context, this function will return 0 as a safe default.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_GetSwapInterval")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLGLGetSwapIntervalNative()
		{
			return ((delegate* unmanaged[Cdecl]<int>)vt[437])();
		}
		/// <summary>/// Get the swap interval for the current OpenGL context.<br/>/// If the system can't determine the swap interval, or there isn't a valid<br/>/// current context, this function will return 0 as a safe default.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_GetSwapInterval")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGLGetSwapInterval()
		{
			int ret = SDLGLGetSwapIntervalNative();
			return ret;
		}

		/// <summary>
		/// Update a window with OpenGL rendering.<br/>
		/// This is used with double-buffered OpenGL contexts, which are the default.<br/>
		/// On macOS, make sure you bind 0 to the draw framebuffer before swapping the<br/>
		/// window, otherwise nothing will happen. If you aren't using<br/>
		/// glBindFramebuffer(), this is the default and you won't have to do anything<br/>
		/// extra.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_SwapWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SDLGLSwapWindowNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window)
		{
			((delegate* unmanaged[Cdecl]<SDLWindow*, void>)vt[438])(window);
		}
		/// <summary>/// Update a window with OpenGL rendering.<br/>/// This is used with double-buffered OpenGL contexts, which are the default.<br/>/// On macOS, make sure you bind 0 to the draw framebuffer before swapping the<br/>/// window, otherwise nothing will happen. If you aren't using<br/>/// glBindFramebuffer(), this is the default and you won't have to do anything<br/>/// extra.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_SwapWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGLSwapWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window)
		{
			SDLGLSwapWindowNative(window);
		}

		/// <summary>/// Update a window with OpenGL rendering.<br/>/// This is used with double-buffered OpenGL contexts, which are the default.<br/>/// On macOS, make sure you bind 0 to the draw framebuffer before swapping the<br/>/// window, otherwise nothing will happen. If you aren't using<br/>/// glBindFramebuffer(), this is the default and you won't have to do anything<br/>/// extra.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_SwapWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGLSwapWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLGLSwapWindowNative((SDLWindow*)pwindow);
			}
		}

		/// <summary>
		/// Delete an OpenGL context.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_DeleteContext")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SDLGLDeleteContextNative([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_GLContext")] SDLGLContext context)
		{
			((delegate* unmanaged[Cdecl]<SDLGLContext, void>)vt[439])(context);
		}
		/// <summary>/// Delete an OpenGL context.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_DeleteContext")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGLDeleteContext([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_GLContext")] SDLGLContext context)
		{
			SDLGLDeleteContextNative(context);
		}

		/// <summary>
		/// Query the window which currently has keyboard focus.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetKeyboardFocus")]
		[return: NativeName(NativeNameType.Type, "SDL_Window*")]
		internal static SDLWindow* SDLGetKeyboardFocusNative()
		{
			return ((delegate* unmanaged[Cdecl]<SDLWindow*>)vt[440])();
		}
		/// <summary>/// Query the window which currently has keyboard focus.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetKeyboardFocus")]
		[return: NativeName(NativeNameType.Type, "SDL_Window*")]
		public static SDLWindow* SDLGetKeyboardFocus()
		{
			SDLWindow* ret = SDLGetKeyboardFocusNative();
			return ret;
		}

		/// <summary>
		/// Get a snapshot of the current state of the keyboard.<br/>
		/// The pointer returned is a pointer to an internal SDL array. It will be<br/>
		/// valid for the whole lifetime of the application and should not be freed by<br/>
		/// the caller.<br/>
		/// A array element with a value of 1 means that the key is pressed and a value<br/>
		/// of 0 means that it is not. Indexes into this array are obtained by using<br/>
		/// SDL_Scancode values.<br/>
		/// Use SDL_PumpEvents() to update the state array.<br/>
		/// This function gives you the current state after all events have been<br/>
		/// processed, so if a key or button has been pressed and released before you<br/>
		/// process events, then the pressed state will never show up in the<br/>
		/// SDL_GetKeyboardState() calls.<br/>
		/// Note: This function doesn't take into account whether shift has been<br/>
		/// pressed or not.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetKeyboardState")]
		[return: NativeName(NativeNameType.Type, "const Uint8*")]
		internal static byte* SDLGetKeyboardStateNative([NativeName(NativeNameType.Param, "numkeys")] [NativeName(NativeNameType.Type, "int*")] int* numkeys)
		{
			return ((delegate* unmanaged[Cdecl]<int*, byte*>)vt[441])(numkeys);
		}
		/// <summary>/// Get a snapshot of the current state of the keyboard.<br/>/// The pointer returned is a pointer to an internal SDL array. It will be<br/>/// valid for the whole lifetime of the application and should not be freed by<br/>/// the caller.<br/>/// A array element with a value of 1 means that the key is pressed and a value<br/>/// of 0 means that it is not. Indexes into this array are obtained by using<br/>/// SDL_Scancode values.<br/>/// Use SDL_PumpEvents() to update the state array.<br/>/// This function gives you the current state after all events have been<br/>/// processed, so if a key or button has been pressed and released before you<br/>/// process events, then the pressed state will never show up in the<br/>/// SDL_GetKeyboardState() calls.<br/>/// Note: This function doesn't take into account whether shift has been<br/>/// pressed or not.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetKeyboardState")]
		[return: NativeName(NativeNameType.Type, "const Uint8*")]
		public static byte* SDLGetKeyboardState([NativeName(NativeNameType.Param, "numkeys")] [NativeName(NativeNameType.Type, "int*")] int* numkeys)
		{
			byte* ret = SDLGetKeyboardStateNative(numkeys);
			return ret;
		}

		/// <summary>/// Get a snapshot of the current state of the keyboard.<br/>/// The pointer returned is a pointer to an internal SDL array. It will be<br/>/// valid for the whole lifetime of the application and should not be freed by<br/>/// the caller.<br/>/// A array element with a value of 1 means that the key is pressed and a value<br/>/// of 0 means that it is not. Indexes into this array are obtained by using<br/>/// SDL_Scancode values.<br/>/// Use SDL_PumpEvents() to update the state array.<br/>/// This function gives you the current state after all events have been<br/>/// processed, so if a key or button has been pressed and released before you<br/>/// process events, then the pressed state will never show up in the<br/>/// SDL_GetKeyboardState() calls.<br/>/// Note: This function doesn't take into account whether shift has been<br/>/// pressed or not.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetKeyboardState")]
		[return: NativeName(NativeNameType.Type, "const Uint8*")]
		public static byte* SDLGetKeyboardState([NativeName(NativeNameType.Param, "numkeys")] [NativeName(NativeNameType.Type, "int*")] ref int numkeys)
		{
			fixed (int* pnumkeys = &numkeys)
			{
				byte* ret = SDLGetKeyboardStateNative((int*)pnumkeys);
				return ret;
			}
		}

		/// <summary>
		/// Clear the state of the keyboard<br/>
		/// This function will generate key up events for all pressed keys.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ResetKeyboard")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SDLResetKeyboardNative()
		{
			((delegate* unmanaged[Cdecl]<void>)vt[442])();
		}
		/// <summary>/// Clear the state of the keyboard<br/>/// This function will generate key up events for all pressed keys.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_ResetKeyboard")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLResetKeyboard()
		{
			SDLResetKeyboardNative();
		}

		/// <summary>
		/// Get the current key modifier state for the keyboard.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetModState")]
		[return: NativeName(NativeNameType.Type, "SDL_Keymod")]
		internal static SDLKeymod SDLGetModStateNative()
		{
			return ((delegate* unmanaged[Cdecl]<SDLKeymod>)vt[443])();
		}
		/// <summary>/// Get the current key modifier state for the keyboard.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetModState")]
		[return: NativeName(NativeNameType.Type, "SDL_Keymod")]
		public static SDLKeymod SDLGetModState()
		{
			SDLKeymod ret = SDLGetModStateNative();
			return ret;
		}

		/// <summary>
		/// Set the current key modifier state for the keyboard.<br/>
		/// The inverse of SDL_GetModState(), SDL_SetModState() allows you to impose<br/>
		/// modifier key states on your application. Simply pass your desired modifier<br/>
		/// states into `modstate`. This value may be a bitwise, OR'd combination of<br/>
		/// SDL_Keymod values.<br/>
		/// This does not change the keyboard state, only the key modifier flags that<br/>
		/// SDL reports.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetModState")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SDLSetModStateNative([NativeName(NativeNameType.Param, "modstate")] [NativeName(NativeNameType.Type, "SDL_Keymod")] SDLKeymod modstate)
		{
			((delegate* unmanaged[Cdecl]<SDLKeymod, void>)vt[444])(modstate);
		}
		/// <summary>/// Set the current key modifier state for the keyboard.<br/>/// The inverse of SDL_GetModState(), SDL_SetModState() allows you to impose<br/>/// modifier key states on your application. Simply pass your desired modifier<br/>/// states into `modstate`. This value may be a bitwise, OR'd combination of<br/>/// SDL_Keymod values.<br/>/// This does not change the keyboard state, only the key modifier flags that<br/>/// SDL reports.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetModState")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLSetModState([NativeName(NativeNameType.Param, "modstate")] [NativeName(NativeNameType.Type, "SDL_Keymod")] SDLKeymod modstate)
		{
			SDLSetModStateNative(modstate);
		}

		/// <summary>
		/// Get the key code corresponding to the given scancode according to the<br/>
		/// current keyboard layout.<br/>
		/// See SDL_Keycode for details.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetKeyFromScancode")]
		[return: NativeName(NativeNameType.Type, "SDL_Keycode")]
		internal static int SDLGetKeyFromScancodeNative([NativeName(NativeNameType.Param, "scancode")] [NativeName(NativeNameType.Type, "SDL_Scancode")] SDLScancode scancode)
		{
			return ((delegate* unmanaged[Cdecl]<SDLScancode, int>)vt[445])(scancode);
		}
		/// <summary>/// Get the key code corresponding to the given scancode according to the<br/>/// current keyboard layout.<br/>/// See SDL_Keycode for details.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetKeyFromScancode")]
		[return: NativeName(NativeNameType.Type, "SDL_Keycode")]
		public static int SDLGetKeyFromScancode([NativeName(NativeNameType.Param, "scancode")] [NativeName(NativeNameType.Type, "SDL_Scancode")] SDLScancode scancode)
		{
			int ret = SDLGetKeyFromScancodeNative(scancode);
			return ret;
		}

		/// <summary>
		/// Get the scancode corresponding to the given key code according to the<br/>
		/// current keyboard layout.<br/>
		/// See SDL_Scancode for details.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetScancodeFromKey")]
		[return: NativeName(NativeNameType.Type, "SDL_Scancode")]
		internal static SDLScancode SDLGetScancodeFromKeyNative([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "SDL_Keycode")] int key)
		{
			return ((delegate* unmanaged[Cdecl]<int, SDLScancode>)vt[446])(key);
		}
		/// <summary>/// Get the scancode corresponding to the given key code according to the<br/>/// current keyboard layout.<br/>/// See SDL_Scancode for details.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetScancodeFromKey")]
		[return: NativeName(NativeNameType.Type, "SDL_Scancode")]
		public static SDLScancode SDLGetScancodeFromKey([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "SDL_Keycode")] int key)
		{
			SDLScancode ret = SDLGetScancodeFromKeyNative(key);
			return ret;
		}

		/// <summary>
		/// Get a human-readable name for a scancode.<br/>
		/// See SDL_Scancode for details.<br/>
		/// **Warning**: The returned name is by design not stable across platforms,<br/>
		/// e.g. the name for `SDL_SCANCODE_LGUI` is "Left GUI" under Linux but "Left<br/>
		/// Windows" under Microsoft Windows, and some scancodes like<br/>
		/// `SDL_SCANCODE_NONUSBACKSLASH` don't have any name at all. There are even<br/>
		/// scancodes that share names, e.g. `SDL_SCANCODE_RETURN` and<br/>
		/// `SDL_SCANCODE_RETURN2` (both called "Return"). This function is therefore<br/>
		/// unsuitable for creating a stable cross-platform two-way mapping between<br/>
		/// strings and scancodes.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetScancodeName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		internal static byte* SDLGetScancodeNameNative([NativeName(NativeNameType.Param, "scancode")] [NativeName(NativeNameType.Type, "SDL_Scancode")] SDLScancode scancode)
		{
			return ((delegate* unmanaged[Cdecl]<SDLScancode, byte*>)vt[447])(scancode);
		}
		/// <summary>/// Get a human-readable name for a scancode.<br/>/// See SDL_Scancode for details.<br/>/// **Warning**: The returned name is by design not stable across platforms,<br/>/// e.g. the name for `SDL_SCANCODE_LGUI` is "Left GUI" under Linux but "Left<br/>/// Windows" under Microsoft Windows, and some scancodes like<br/>/// `SDL_SCANCODE_NONUSBACKSLASH` don't have any name at all. There are even<br/>/// scancodes that share names, e.g. `SDL_SCANCODE_RETURN` and<br/>/// `SDL_SCANCODE_RETURN2` (both called "Return"). This function is therefore<br/>/// unsuitable for creating a stable cross-platform two-way mapping between<br/>/// strings and scancodes.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetScancodeName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGetScancodeName([NativeName(NativeNameType.Param, "scancode")] [NativeName(NativeNameType.Type, "SDL_Scancode")] SDLScancode scancode)
		{
			byte* ret = SDLGetScancodeNameNative(scancode);
			return ret;
		}

		/// <summary>/// Get a human-readable name for a scancode.<br/>/// See SDL_Scancode for details.<br/>/// **Warning**: The returned name is by design not stable across platforms,<br/>/// e.g. the name for `SDL_SCANCODE_LGUI` is "Left GUI" under Linux but "Left<br/>/// Windows" under Microsoft Windows, and some scancodes like<br/>/// `SDL_SCANCODE_NONUSBACKSLASH` don't have any name at all. There are even<br/>/// scancodes that share names, e.g. `SDL_SCANCODE_RETURN` and<br/>/// `SDL_SCANCODE_RETURN2` (both called "Return"). This function is therefore<br/>/// unsuitable for creating a stable cross-platform two-way mapping between<br/>/// strings and scancodes.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetScancodeName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGetScancodeNameS([NativeName(NativeNameType.Param, "scancode")] [NativeName(NativeNameType.Type, "SDL_Scancode")] SDLScancode scancode)
		{
			string ret = Utils.DecodeStringUTF8(SDLGetScancodeNameNative(scancode));
			return ret;
		}

		/// <summary>
		/// Get a scancode from a human-readable name.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetScancodeFromName")]
		[return: NativeName(NativeNameType.Type, "SDL_Scancode")]
		internal static SDLScancode SDLGetScancodeFromNameNative([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name)
		{
			return ((delegate* unmanaged[Cdecl]<byte*, SDLScancode>)vt[448])(name);
		}
		/// <summary>/// Get a scancode from a human-readable name.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetScancodeFromName")]
		[return: NativeName(NativeNameType.Type, "SDL_Scancode")]
		public static SDLScancode SDLGetScancodeFromName([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name)
		{
			SDLScancode ret = SDLGetScancodeFromNameNative(name);
			return ret;
		}

		/// <summary>/// Get a scancode from a human-readable name.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetScancodeFromName")]
		[return: NativeName(NativeNameType.Type, "SDL_Scancode")]
		public static SDLScancode SDLGetScancodeFromName([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] ref byte name)
		{
			fixed (byte* pname = &name)
			{
				SDLScancode ret = SDLGetScancodeFromNameNative((byte*)pname);
				return ret;
			}
		}

		/// <summary>/// Get a scancode from a human-readable name.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetScancodeFromName")]
		[return: NativeName(NativeNameType.Type, "SDL_Scancode")]
		public static SDLScancode SDLGetScancodeFromName([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLScancode ret = SDLGetScancodeFromNameNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get a human-readable name for a key.<br/>
		/// See SDL_Scancode and SDL_Keycode for details.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetKeyName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		internal static byte* SDLGetKeyNameNative([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "SDL_Keycode")] int key)
		{
			return ((delegate* unmanaged[Cdecl]<int, byte*>)vt[449])(key);
		}
		/// <summary>/// Get a human-readable name for a key.<br/>/// See SDL_Scancode and SDL_Keycode for details.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetKeyName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGetKeyName([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "SDL_Keycode")] int key)
		{
			byte* ret = SDLGetKeyNameNative(key);
			return ret;
		}

		/// <summary>/// Get a human-readable name for a key.<br/>/// See SDL_Scancode and SDL_Keycode for details.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetKeyName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGetKeyNameS([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "SDL_Keycode")] int key)
		{
			string ret = Utils.DecodeStringUTF8(SDLGetKeyNameNative(key));
			return ret;
		}

		/// <summary>
		/// Get a key code from a human-readable name.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetKeyFromName")]
		[return: NativeName(NativeNameType.Type, "SDL_Keycode")]
		internal static int SDLGetKeyFromNameNative([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name)
		{
			return ((delegate* unmanaged[Cdecl]<byte*, int>)vt[450])(name);
		}
		/// <summary>/// Get a key code from a human-readable name.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetKeyFromName")]
		[return: NativeName(NativeNameType.Type, "SDL_Keycode")]
		public static int SDLGetKeyFromName([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name)
		{
			int ret = SDLGetKeyFromNameNative(name);
			return ret;
		}

		/// <summary>/// Get a key code from a human-readable name.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetKeyFromName")]
		[return: NativeName(NativeNameType.Type, "SDL_Keycode")]
		public static int SDLGetKeyFromName([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] ref byte name)
		{
			fixed (byte* pname = &name)
			{
				int ret = SDLGetKeyFromNameNative((byte*)pname);
				return ret;
			}
		}

		/// <summary>/// Get a key code from a human-readable name.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetKeyFromName")]
		[return: NativeName(NativeNameType.Type, "SDL_Keycode")]
		public static int SDLGetKeyFromName([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SDLGetKeyFromNameNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Start accepting Unicode text input events.<br/>
		/// This function will start accepting Unicode text input events in the focused<br/>
		/// SDL window, and start emitting SDL_TextInputEvent (SDL_TEXTINPUT) and<br/>
		/// SDL_TextEditingEvent (SDL_TEXTEDITING) events. Please use this function in<br/>
		/// pair with SDL_StopTextInput().<br/>
		/// On some platforms using this function activates the screen keyboard.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StartTextInput")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SDLStartTextInputNative()
		{
			((delegate* unmanaged[Cdecl]<void>)vt[451])();
		}
		/// <summary>/// Start accepting Unicode text input events.<br/>/// This function will start accepting Unicode text input events in the focused<br/>/// SDL window, and start emitting SDL_TextInputEvent (SDL_TEXTINPUT) and<br/>/// SDL_TextEditingEvent (SDL_TEXTEDITING) events. Please use this function in<br/>/// pair with SDL_StopTextInput().<br/>/// On some platforms using this function activates the screen keyboard.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_StartTextInput")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLStartTextInput()
		{
			SDLStartTextInputNative();
		}

		/// <summary>
		/// Check whether or not Unicode text input events are enabled.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IsTextInputActive")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		internal static SDLBool SDLIsTextInputActiveNative()
		{
			return ((delegate* unmanaged[Cdecl]<SDLBool>)vt[452])();
		}
		/// <summary>/// Check whether or not Unicode text input events are enabled.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_IsTextInputActive")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIsTextInputActive()
		{
			SDLBool ret = SDLIsTextInputActiveNative();
			return ret;
		}

		/// <summary>
		/// Stop receiving any text input events.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StopTextInput")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SDLStopTextInputNative()
		{
			((delegate* unmanaged[Cdecl]<void>)vt[453])();
		}
		/// <summary>/// Stop receiving any text input events.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_StopTextInput")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLStopTextInput()
		{
			SDLStopTextInputNative();
		}

		/// <summary>
		/// Dismiss the composition window/IME without disabling the subsystem.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ClearComposition")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SDLClearCompositionNative()
		{
			((delegate* unmanaged[Cdecl]<void>)vt[454])();
		}
		/// <summary>/// Dismiss the composition window/IME without disabling the subsystem.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_ClearComposition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLClearComposition()
		{
			SDLClearCompositionNative();
		}

		/// <summary>
		/// Returns if an IME Composite or Candidate window is currently shown.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IsTextInputShown")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		internal static SDLBool SDLIsTextInputShownNative()
		{
			return ((delegate* unmanaged[Cdecl]<SDLBool>)vt[455])();
		}
		/// <summary>/// Returns if an IME Composite or Candidate window is currently shown.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_IsTextInputShown")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIsTextInputShown()
		{
			SDLBool ret = SDLIsTextInputShownNative();
			return ret;
		}

		/// <summary>
		/// Set the rectangle used to type Unicode text inputs. Native input methods<br/>
		/// will place a window with word suggestions near it, without covering the<br/>
		/// text being inputted.<br/>
		/// To start text input in a given location, this function is intended to be<br/>
		/// called before SDL_StartTextInput, although some platforms support moving<br/>
		/// the rectangle even while text input (and a composition) is active.<br/>
		/// Note: If you want to use the system native IME window, try setting hint<br/>
		/// **SDL_HINT_IME_SHOW_UI** to **1**, otherwise this function won't give you<br/>
		/// any feedback.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTextInputRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SDLSetTextInputRectNative([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect)
		{
			((delegate* unmanaged[Cdecl]<SDLRect*, void>)vt[456])(rect);
		}
		/// <summary>/// Set the rectangle used to type Unicode text inputs. Native input methods<br/>/// will place a window with word suggestions near it, without covering the<br/>/// text being inputted.<br/>/// To start text input in a given location, this function is intended to be<br/>/// called before SDL_StartTextInput, although some platforms support moving<br/>/// the rectangle even while text input (and a composition) is active.<br/>/// Note: If you want to use the system native IME window, try setting hint<br/>/// **SDL_HINT_IME_SHOW_UI** to **1**, otherwise this function won't give you<br/>/// any feedback.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetTextInputRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLSetTextInputRect([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect)
		{
			SDLSetTextInputRectNative(rect);
		}

		/// <summary>/// Set the rectangle used to type Unicode text inputs. Native input methods<br/>/// will place a window with word suggestions near it, without covering the<br/>/// text being inputted.<br/>/// To start text input in a given location, this function is intended to be<br/>/// called before SDL_StartTextInput, although some platforms support moving<br/>/// the rectangle even while text input (and a composition) is active.<br/>/// Note: If you want to use the system native IME window, try setting hint<br/>/// **SDL_HINT_IME_SHOW_UI** to **1**, otherwise this function won't give you<br/>/// any feedback.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetTextInputRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLSetTextInputRect([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect)
		{
			fixed (SDLRect* prect = &rect)
			{
				SDLSetTextInputRectNative((SDLRect*)prect);
			}
		}

		/// <summary>
		/// Check whether the platform has screen keyboard support.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasScreenKeyboardSupport")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		internal static SDLBool SDLHasScreenKeyboardSupportNative()
		{
			return ((delegate* unmanaged[Cdecl]<SDLBool>)vt[457])();
		}
		/// <summary>/// Check whether the platform has screen keyboard support.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_HasScreenKeyboardSupport")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLHasScreenKeyboardSupport()
		{
			SDLBool ret = SDLHasScreenKeyboardSupportNative();
			return ret;
		}

		/// <summary>
		/// Check whether the screen keyboard is shown for given window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IsScreenKeyboardShown")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		internal static SDLBool SDLIsScreenKeyboardShownNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window)
		{
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLBool>)vt[458])(window);
		}
		/// <summary>/// Check whether the screen keyboard is shown for given window.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_IsScreenKeyboardShown")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIsScreenKeyboardShown([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window)
		{
			SDLBool ret = SDLIsScreenKeyboardShownNative(window);
			return ret;
		}

		/// <summary>/// Check whether the screen keyboard is shown for given window.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_IsScreenKeyboardShown")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIsScreenKeyboardShown([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLBool ret = SDLIsScreenKeyboardShownNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Get the window which currently has mouse focus.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMouseFocus")]
		[return: NativeName(NativeNameType.Type, "SDL_Window*")]
		internal static SDLWindow* SDLGetMouseFocusNative()
		{
			return ((delegate* unmanaged[Cdecl]<SDLWindow*>)vt[459])();
		}
		/// <summary>/// Get the window which currently has mouse focus.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetMouseFocus")]
		[return: NativeName(NativeNameType.Type, "SDL_Window*")]
		public static SDLWindow* SDLGetMouseFocus()
		{
			SDLWindow* ret = SDLGetMouseFocusNative();
			return ret;
		}

		/// <summary>
		/// Retrieve the current state of the mouse.<br/>
		/// The current button state is returned as a button bitmask, which can be<br/>
		/// tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the<br/>
		/// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the<br/>
		/// mouse cursor position relative to the focus window. You can pass NULL for<br/>
		/// either `x` or `y`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMouseState")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		internal static uint SDLGetMouseStateNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int*")] int* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int*")] int* y)
		{
			return ((delegate* unmanaged[Cdecl]<int*, int*, uint>)vt[460])(x, y);
		}
		/// <summary>/// Retrieve the current state of the mouse.<br/>/// The current button state is returned as a button bitmask, which can be<br/>/// tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the<br/>/// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the<br/>/// mouse cursor position relative to the focus window. You can pass NULL for<br/>/// either `x` or `y`.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetMouseState")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLGetMouseState([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int*")] int* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int*")] int* y)
		{
			uint ret = SDLGetMouseStateNative(x, y);
			return ret;
		}

		/// <summary>/// Retrieve the current state of the mouse.<br/>/// The current button state is returned as a button bitmask, which can be<br/>/// tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the<br/>/// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the<br/>/// mouse cursor position relative to the focus window. You can pass NULL for<br/>/// either `x` or `y`.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetMouseState")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLGetMouseState([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int*")] ref int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int*")] int* y)
		{
			fixed (int* px = &x)
			{
				uint ret = SDLGetMouseStateNative((int*)px, y);
				return ret;
			}
		}

		/// <summary>/// Retrieve the current state of the mouse.<br/>/// The current button state is returned as a button bitmask, which can be<br/>/// tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the<br/>/// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the<br/>/// mouse cursor position relative to the focus window. You can pass NULL for<br/>/// either `x` or `y`.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetMouseState")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLGetMouseState([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int*")] int* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int*")] ref int y)
		{
			fixed (int* py = &y)
			{
				uint ret = SDLGetMouseStateNative(x, (int*)py);
				return ret;
			}
		}

		/// <summary>/// Retrieve the current state of the mouse.<br/>/// The current button state is returned as a button bitmask, which can be<br/>/// tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the<br/>/// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the<br/>/// mouse cursor position relative to the focus window. You can pass NULL for<br/>/// either `x` or `y`.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetMouseState")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLGetMouseState([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int*")] ref int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int*")] ref int y)
		{
			fixed (int* px = &x)
			{
				fixed (int* py = &y)
				{
					uint ret = SDLGetMouseStateNative((int*)px, (int*)py);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the current state of the mouse in relation to the desktop.<br/>
		/// This works similarly to SDL_GetMouseState(), but the coordinates will be<br/>
		/// reported relative to the top-left of the desktop. This can be useful if you<br/>
		/// need to track the mouse outside of a specific window and SDL_CaptureMouse()<br/>
		/// doesn't fit your needs. For example, it could be useful if you need to<br/>
		/// track the mouse while dragging a window, where coordinates relative to a<br/>
		/// window might not be in sync at all times.<br/>
		/// Note: SDL_GetMouseState() returns the mouse position as SDL understands it<br/>
		/// from the last pump of the event queue. This function, however, queries the<br/>
		/// OS for the current mouse position, and as such, might be a slightly less<br/>
		/// efficient function. Unless you know what you're doing and have a good<br/>
		/// reason to use this function, you probably want SDL_GetMouseState() instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGlobalMouseState")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		internal static uint SDLGetGlobalMouseStateNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int*")] int* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int*")] int* y)
		{
			return ((delegate* unmanaged[Cdecl]<int*, int*, uint>)vt[461])(x, y);
		}
		/// <summary>/// Get the current state of the mouse in relation to the desktop.<br/>/// This works similarly to SDL_GetMouseState(), but the coordinates will be<br/>/// reported relative to the top-left of the desktop. This can be useful if you<br/>/// need to track the mouse outside of a specific window and SDL_CaptureMouse()<br/>/// doesn't fit your needs. For example, it could be useful if you need to<br/>/// track the mouse while dragging a window, where coordinates relative to a<br/>/// window might not be in sync at all times.<br/>/// Note: SDL_GetMouseState() returns the mouse position as SDL understands it<br/>/// from the last pump of the event queue. This function, however, queries the<br/>/// OS for the current mouse position, and as such, might be a slightly less<br/>/// efficient function. Unless you know what you're doing and have a good<br/>/// reason to use this function, you probably want SDL_GetMouseState() instead.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetGlobalMouseState")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLGetGlobalMouseState([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int*")] int* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int*")] int* y)
		{
			uint ret = SDLGetGlobalMouseStateNative(x, y);
			return ret;
		}

		/// <summary>/// Get the current state of the mouse in relation to the desktop.<br/>/// This works similarly to SDL_GetMouseState(), but the coordinates will be<br/>/// reported relative to the top-left of the desktop. This can be useful if you<br/>/// need to track the mouse outside of a specific window and SDL_CaptureMouse()<br/>/// doesn't fit your needs. For example, it could be useful if you need to<br/>/// track the mouse while dragging a window, where coordinates relative to a<br/>/// window might not be in sync at all times.<br/>/// Note: SDL_GetMouseState() returns the mouse position as SDL understands it<br/>/// from the last pump of the event queue. This function, however, queries the<br/>/// OS for the current mouse position, and as such, might be a slightly less<br/>/// efficient function. Unless you know what you're doing and have a good<br/>/// reason to use this function, you probably want SDL_GetMouseState() instead.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetGlobalMouseState")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLGetGlobalMouseState([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int*")] ref int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int*")] int* y)
		{
			fixed (int* px = &x)
			{
				uint ret = SDLGetGlobalMouseStateNative((int*)px, y);
				return ret;
			}
		}

		/// <summary>/// Get the current state of the mouse in relation to the desktop.<br/>/// This works similarly to SDL_GetMouseState(), but the coordinates will be<br/>/// reported relative to the top-left of the desktop. This can be useful if you<br/>/// need to track the mouse outside of a specific window and SDL_CaptureMouse()<br/>/// doesn't fit your needs. For example, it could be useful if you need to<br/>/// track the mouse while dragging a window, where coordinates relative to a<br/>/// window might not be in sync at all times.<br/>/// Note: SDL_GetMouseState() returns the mouse position as SDL understands it<br/>/// from the last pump of the event queue. This function, however, queries the<br/>/// OS for the current mouse position, and as such, might be a slightly less<br/>/// efficient function. Unless you know what you're doing and have a good<br/>/// reason to use this function, you probably want SDL_GetMouseState() instead.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetGlobalMouseState")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLGetGlobalMouseState([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int*")] int* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int*")] ref int y)
		{
			fixed (int* py = &y)
			{
				uint ret = SDLGetGlobalMouseStateNative(x, (int*)py);
				return ret;
			}
		}

		/// <summary>/// Get the current state of the mouse in relation to the desktop.<br/>/// This works similarly to SDL_GetMouseState(), but the coordinates will be<br/>/// reported relative to the top-left of the desktop. This can be useful if you<br/>/// need to track the mouse outside of a specific window and SDL_CaptureMouse()<br/>/// doesn't fit your needs. For example, it could be useful if you need to<br/>/// track the mouse while dragging a window, where coordinates relative to a<br/>/// window might not be in sync at all times.<br/>/// Note: SDL_GetMouseState() returns the mouse position as SDL understands it<br/>/// from the last pump of the event queue. This function, however, queries the<br/>/// OS for the current mouse position, and as such, might be a slightly less<br/>/// efficient function. Unless you know what you're doing and have a good<br/>/// reason to use this function, you probably want SDL_GetMouseState() instead.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetGlobalMouseState")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLGetGlobalMouseState([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int*")] ref int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int*")] ref int y)
		{
			fixed (int* px = &x)
			{
				fixed (int* py = &y)
				{
					uint ret = SDLGetGlobalMouseStateNative((int*)px, (int*)py);
					return ret;
				}
			}
		}

		/// <summary>
		/// Retrieve the relative state of the mouse.<br/>
		/// The current button state is returned as a button bitmask, which can be<br/>
		/// tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the<br/>
		/// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the<br/>
		/// mouse deltas since the last call to SDL_GetRelativeMouseState() or since<br/>
		/// event initialization. You can pass NULL for either `x` or `y`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRelativeMouseState")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		internal static uint SDLGetRelativeMouseStateNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int*")] int* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int*")] int* y)
		{
			return ((delegate* unmanaged[Cdecl]<int*, int*, uint>)vt[462])(x, y);
		}
		/// <summary>/// Retrieve the relative state of the mouse.<br/>/// The current button state is returned as a button bitmask, which can be<br/>/// tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the<br/>/// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the<br/>/// mouse deltas since the last call to SDL_GetRelativeMouseState() or since<br/>/// event initialization. You can pass NULL for either `x` or `y`.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRelativeMouseState")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLGetRelativeMouseState([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int*")] int* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int*")] int* y)
		{
			uint ret = SDLGetRelativeMouseStateNative(x, y);
			return ret;
		}

		/// <summary>/// Retrieve the relative state of the mouse.<br/>/// The current button state is returned as a button bitmask, which can be<br/>/// tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the<br/>/// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the<br/>/// mouse deltas since the last call to SDL_GetRelativeMouseState() or since<br/>/// event initialization. You can pass NULL for either `x` or `y`.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRelativeMouseState")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLGetRelativeMouseState([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int*")] ref int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int*")] int* y)
		{
			fixed (int* px = &x)
			{
				uint ret = SDLGetRelativeMouseStateNative((int*)px, y);
				return ret;
			}
		}

		/// <summary>/// Retrieve the relative state of the mouse.<br/>/// The current button state is returned as a button bitmask, which can be<br/>/// tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the<br/>/// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the<br/>/// mouse deltas since the last call to SDL_GetRelativeMouseState() or since<br/>/// event initialization. You can pass NULL for either `x` or `y`.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRelativeMouseState")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLGetRelativeMouseState([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int*")] int* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int*")] ref int y)
		{
			fixed (int* py = &y)
			{
				uint ret = SDLGetRelativeMouseStateNative(x, (int*)py);
				return ret;
			}
		}

		/// <summary>/// Retrieve the relative state of the mouse.<br/>/// The current button state is returned as a button bitmask, which can be<br/>/// tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the<br/>/// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the<br/>/// mouse deltas since the last call to SDL_GetRelativeMouseState() or since<br/>/// event initialization. You can pass NULL for either `x` or `y`.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRelativeMouseState")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLGetRelativeMouseState([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int*")] ref int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int*")] ref int y)
		{
			fixed (int* px = &x)
			{
				fixed (int* py = &y)
				{
					uint ret = SDLGetRelativeMouseStateNative((int*)px, (int*)py);
					return ret;
				}
			}
		}

		/// <summary>
		/// Move the mouse cursor to the given position within the window.<br/>
		/// This function generates a mouse motion event if relative mode is not<br/>
		/// enabled. If relative mode is enabled, you can force mouse events for the<br/>
		/// warp by setting the SDL_HINT_MOUSE_RELATIVE_WARP_MOTION hint.<br/>
		/// Note that this function will appear to succeed, but not actually move the<br/>
		/// mouse when used over Microsoft Remote Desktop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WarpMouseInWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SDLWarpMouseInWindowNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y)
		{
			((delegate* unmanaged[Cdecl]<SDLWindow*, int, int, void>)vt[463])(window, x, y);
		}
		/// <summary>/// Move the mouse cursor to the given position within the window.<br/>/// This function generates a mouse motion event if relative mode is not<br/>/// enabled. If relative mode is enabled, you can force mouse events for the<br/>/// warp by setting the SDL_HINT_MOUSE_RELATIVE_WARP_MOTION hint.<br/>/// Note that this function will appear to succeed, but not actually move the<br/>/// mouse when used over Microsoft Remote Desktop.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_WarpMouseInWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLWarpMouseInWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y)
		{
			SDLWarpMouseInWindowNative(window, x, y);
		}

		/// <summary>/// Move the mouse cursor to the given position within the window.<br/>/// This function generates a mouse motion event if relative mode is not<br/>/// enabled. If relative mode is enabled, you can force mouse events for the<br/>/// warp by setting the SDL_HINT_MOUSE_RELATIVE_WARP_MOTION hint.<br/>/// Note that this function will appear to succeed, but not actually move the<br/>/// mouse when used over Microsoft Remote Desktop.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_WarpMouseInWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLWarpMouseInWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLWarpMouseInWindowNative((SDLWindow*)pwindow, x, y);
			}
		}

		/// <summary>
		/// Move the mouse to the given position in global screen space.<br/>
		/// This function generates a mouse motion event.<br/>
		/// A failure of this function usually means that it is unsupported by a<br/>
		/// platform.<br/>
		/// Note that this function will appear to succeed, but not actually move the<br/>
		/// mouse when used over Microsoft Remote Desktop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WarpMouseGlobal")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLWarpMouseGlobalNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y)
		{
			return ((delegate* unmanaged[Cdecl]<int, int, int>)vt[464])(x, y);
		}
		/// <summary>/// Move the mouse to the given position in global screen space.<br/>/// This function generates a mouse motion event.<br/>/// A failure of this function usually means that it is unsupported by a<br/>/// platform.<br/>/// Note that this function will appear to succeed, but not actually move the<br/>/// mouse when used over Microsoft Remote Desktop.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_WarpMouseGlobal")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLWarpMouseGlobal([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y)
		{
			int ret = SDLWarpMouseGlobalNative(x, y);
			return ret;
		}

		/// <summary>
		/// Set relative mouse mode.<br/>
		/// While the mouse is in relative mode, the cursor is hidden, the mouse<br/>
		/// position is constrained to the window, and SDL will report continuous<br/>
		/// relative mouse motion even if the mouse is at the edge of the window.<br/>
		/// This function will flush any pending mouse motion.<br/>
		/// <br/>
		/// If relative mode is not supported, this returns -1.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetRelativeMouseMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLSetRelativeMouseModeNative([NativeName(NativeNameType.Param, "enabled")] [NativeName(NativeNameType.Type, "SDL_bool")] SDLBool enabled)
		{
			return ((delegate* unmanaged[Cdecl]<SDLBool, int>)vt[465])(enabled);
		}
		/// <summary>/// Set relative mouse mode.<br/>/// While the mouse is in relative mode, the cursor is hidden, the mouse<br/>/// position is constrained to the window, and SDL will report continuous<br/>/// relative mouse motion even if the mouse is at the edge of the window.<br/>/// This function will flush any pending mouse motion.<br/>/// <br/>/// If relative mode is not supported, this returns -1.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetRelativeMouseMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetRelativeMouseMode([NativeName(NativeNameType.Param, "enabled")] [NativeName(NativeNameType.Type, "SDL_bool")] SDLBool enabled)
		{
			int ret = SDLSetRelativeMouseModeNative(enabled);
			return ret;
		}

		/// <summary>
		/// Capture the mouse and to track input outside an SDL window.<br/>
		/// Capturing enables your app to obtain mouse events globally, instead of just<br/>
		/// within your window. Not all video targets support this function. When<br/>
		/// capturing is enabled, the current window will get all mouse events, but<br/>
		/// unlike relative mode, no change is made to the cursor and it is not<br/>
		/// restrained to your window.<br/>
		/// This function may also deny mouse input to other windows--both those in<br/>
		/// your application and others on the system--so you should use this function<br/>
		/// sparingly, and in small bursts. For example, you might want to track the<br/>
		/// mouse while the user is dragging something, until the user releases a mouse<br/>
		/// button. It is not recommended that you capture the mouse for long periods<br/>
		/// of time, such as the entire time your app is running. For that, you should<br/>
		/// probably use SDL_SetRelativeMouseMode() or SDL_SetWindowGrab(), depending<br/>
		/// on your goals.<br/>
		/// While captured, mouse events still report coordinates relative to the<br/>
		/// current (foreground) window, but those coordinates may be outside the<br/>
		/// bounds of the window (including negative values). Capturing is only allowed<br/>
		/// for the foreground window. If the window loses focus while capturing, the<br/>
		/// capture will be disabled automatically.<br/>
		/// While capturing is enabled, the current window will have the<br/>
		/// `SDL_WINDOW_MOUSE_CAPTURE` flag set.<br/>
		/// Please note that as of SDL 2.0.22, SDL will attempt to "auto capture" the<br/>
		/// mouse while the user is pressing a button; this is to try and make mouse<br/>
		/// behavior more consistent between platforms, and deal with the common case<br/>
		/// of a user dragging the mouse outside of the window. This means that if you<br/>
		/// are calling SDL_CaptureMouse() only to deal with this situation, you no<br/>
		/// longer have to (although it is safe to do so). If this causes problems for<br/>
		/// your app, you can disable auto capture by setting the<br/>
		/// `SDL_HINT_MOUSE_AUTO_CAPTURE` hint to zero.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CaptureMouse")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLCaptureMouseNative([NativeName(NativeNameType.Param, "enabled")] [NativeName(NativeNameType.Type, "SDL_bool")] SDLBool enabled)
		{
			return ((delegate* unmanaged[Cdecl]<SDLBool, int>)vt[466])(enabled);
		}
		/// <summary>/// Capture the mouse and to track input outside an SDL window.<br/>/// Capturing enables your app to obtain mouse events globally, instead of just<br/>/// within your window. Not all video targets support this function. When<br/>/// capturing is enabled, the current window will get all mouse events, but<br/>/// unlike relative mode, no change is made to the cursor and it is not<br/>/// restrained to your window.<br/>/// This function may also deny mouse input to other windows--both those in<br/>/// your application and others on the system--so you should use this function<br/>/// sparingly, and in small bursts. For example, you might want to track the<br/>/// mouse while the user is dragging something, until the user releases a mouse<br/>/// button. It is not recommended that you capture the mouse for long periods<br/>/// of time, such as the entire time your app is running. For that, you should<br/>/// probably use SDL_SetRelativeMouseMode() or SDL_SetWindowGrab(), depending<br/>/// on your goals.<br/>/// While captured, mouse events still report coordinates relative to the<br/>/// current (foreground) window, but those coordinates may be outside the<br/>/// bounds of the window (including negative values). Capturing is only allowed<br/>/// for the foreground window. If the window loses focus while capturing, the<br/>/// capture will be disabled automatically.<br/>/// While capturing is enabled, the current window will have the<br/>/// `SDL_WINDOW_MOUSE_CAPTURE` flag set.<br/>/// Please note that as of SDL 2.0.22, SDL will attempt to "auto capture" the<br/>/// mouse while the user is pressing a button; this is to try and make mouse<br/>/// behavior more consistent between platforms, and deal with the common case<br/>/// of a user dragging the mouse outside of the window. This means that if you<br/>/// are calling SDL_CaptureMouse() only to deal with this situation, you no<br/>/// longer have to (although it is safe to do so). If this causes problems for<br/>/// your app, you can disable auto capture by setting the<br/>/// `SDL_HINT_MOUSE_AUTO_CAPTURE` hint to zero.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_CaptureMouse")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLCaptureMouse([NativeName(NativeNameType.Param, "enabled")] [NativeName(NativeNameType.Type, "SDL_bool")] SDLBool enabled)
		{
			int ret = SDLCaptureMouseNative(enabled);
			return ret;
		}

		/// <summary>
		/// Query whether relative mouse mode is enabled.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRelativeMouseMode")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		internal static SDLBool SDLGetRelativeMouseModeNative()
		{
			return ((delegate* unmanaged[Cdecl]<SDLBool>)vt[467])();
		}
		/// <summary>/// Query whether relative mouse mode is enabled.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRelativeMouseMode")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLGetRelativeMouseMode()
		{
			SDLBool ret = SDLGetRelativeMouseModeNative();
			return ret;
		}

		/// <summary>
		/// Create a cursor using the specified bitmap data and mask (in MSB format).<br/>
		/// `mask` has to be in MSB (Most Significant Bit) format.<br/>
		/// The cursor width (`w`) must be a multiple of 8 bits.<br/>
		/// The cursor is created in black and white according to the following:<br/>
		/// - data=0, mask=1: white<br/>
		/// - data=1, mask=1: black<br/>
		/// - data=0, mask=0: transparent<br/>
		/// - data=1, mask=0: inverted color if possible, black if not.<br/>
		/// Cursors created with this function must be freed with SDL_FreeCursor().<br/>
		/// If you want to have a color cursor, or create your cursor from an<br/>
		/// SDL_Surface, you should use SDL_CreateColorCursor(). Alternately, you can<br/>
		/// hide the cursor and draw your own as part of your game's rendering, but it<br/>
		/// will be bound to the framerate.<br/>
		/// Also, since SDL 2.0.0, SDL_CreateSystemCursor() is available, which<br/>
		/// provides twelve readily available system cursors to pick from.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor*")]
		internal static SDLCursor* SDLCreateCursorNative([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* data, [NativeName(NativeNameType.Param, "mask")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* mask, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int")] int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int")] int h, [NativeName(NativeNameType.Param, "hot_x")] [NativeName(NativeNameType.Type, "int")] int hotX, [NativeName(NativeNameType.Param, "hot_y")] [NativeName(NativeNameType.Type, "int")] int hotY)
		{
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, int, int, int, int, SDLCursor*>)vt[468])(data, mask, w, h, hotX, hotY);
		}
		/// <summary>/// Create a cursor using the specified bitmap data and mask (in MSB format).<br/>/// `mask` has to be in MSB (Most Significant Bit) format.<br/>/// The cursor width (`w`) must be a multiple of 8 bits.<br/>/// The cursor is created in black and white according to the following:<br/>/// - data=0, mask=1: white<br/>/// - data=1, mask=1: black<br/>/// - data=0, mask=0: transparent<br/>/// - data=1, mask=0: inverted color if possible, black if not.<br/>/// Cursors created with this function must be freed with SDL_FreeCursor().<br/>/// If you want to have a color cursor, or create your cursor from an<br/>/// SDL_Surface, you should use SDL_CreateColorCursor(). Alternately, you can<br/>/// hide the cursor and draw your own as part of your game's rendering, but it<br/>/// will be bound to the framerate.<br/>/// Also, since SDL 2.0.0, SDL_CreateSystemCursor() is available, which<br/>/// provides twelve readily available system cursors to pick from.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_CreateCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor*")]
		public static SDLCursor* SDLCreateCursor([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* data, [NativeName(NativeNameType.Param, "mask")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* mask, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int")] int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int")] int h, [NativeName(NativeNameType.Param, "hot_x")] [NativeName(NativeNameType.Type, "int")] int hotX, [NativeName(NativeNameType.Param, "hot_y")] [NativeName(NativeNameType.Type, "int")] int hotY)
		{
			SDLCursor* ret = SDLCreateCursorNative(data, mask, w, h, hotX, hotY);
			return ret;
		}

		/// <summary>/// Create a cursor using the specified bitmap data and mask (in MSB format).<br/>/// `mask` has to be in MSB (Most Significant Bit) format.<br/>/// The cursor width (`w`) must be a multiple of 8 bits.<br/>/// The cursor is created in black and white according to the following:<br/>/// - data=0, mask=1: white<br/>/// - data=1, mask=1: black<br/>/// - data=0, mask=0: transparent<br/>/// - data=1, mask=0: inverted color if possible, black if not.<br/>/// Cursors created with this function must be freed with SDL_FreeCursor().<br/>/// If you want to have a color cursor, or create your cursor from an<br/>/// SDL_Surface, you should use SDL_CreateColorCursor(). Alternately, you can<br/>/// hide the cursor and draw your own as part of your game's rendering, but it<br/>/// will be bound to the framerate.<br/>/// Also, since SDL 2.0.0, SDL_CreateSystemCursor() is available, which<br/>/// provides twelve readily available system cursors to pick from.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_CreateCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor*")]
		public static SDLCursor* SDLCreateCursor([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte data, [NativeName(NativeNameType.Param, "mask")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* mask, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int")] int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int")] int h, [NativeName(NativeNameType.Param, "hot_x")] [NativeName(NativeNameType.Type, "int")] int hotX, [NativeName(NativeNameType.Param, "hot_y")] [NativeName(NativeNameType.Type, "int")] int hotY)
		{
			fixed (byte* pdata = &data)
			{
				SDLCursor* ret = SDLCreateCursorNative((byte*)pdata, mask, w, h, hotX, hotY);
				return ret;
			}
		}

		/// <summary>/// Create a cursor using the specified bitmap data and mask (in MSB format).<br/>/// `mask` has to be in MSB (Most Significant Bit) format.<br/>/// The cursor width (`w`) must be a multiple of 8 bits.<br/>/// The cursor is created in black and white according to the following:<br/>/// - data=0, mask=1: white<br/>/// - data=1, mask=1: black<br/>/// - data=0, mask=0: transparent<br/>/// - data=1, mask=0: inverted color if possible, black if not.<br/>/// Cursors created with this function must be freed with SDL_FreeCursor().<br/>/// If you want to have a color cursor, or create your cursor from an<br/>/// SDL_Surface, you should use SDL_CreateColorCursor(). Alternately, you can<br/>/// hide the cursor and draw your own as part of your game's rendering, but it<br/>/// will be bound to the framerate.<br/>/// Also, since SDL 2.0.0, SDL_CreateSystemCursor() is available, which<br/>/// provides twelve readily available system cursors to pick from.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_CreateCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor*")]
		public static SDLCursor* SDLCreateCursor([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* data, [NativeName(NativeNameType.Param, "mask")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte mask, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int")] int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int")] int h, [NativeName(NativeNameType.Param, "hot_x")] [NativeName(NativeNameType.Type, "int")] int hotX, [NativeName(NativeNameType.Param, "hot_y")] [NativeName(NativeNameType.Type, "int")] int hotY)
		{
			fixed (byte* pmask = &mask)
			{
				SDLCursor* ret = SDLCreateCursorNative(data, (byte*)pmask, w, h, hotX, hotY);
				return ret;
			}
		}

		/// <summary>/// Create a cursor using the specified bitmap data and mask (in MSB format).<br/>/// `mask` has to be in MSB (Most Significant Bit) format.<br/>/// The cursor width (`w`) must be a multiple of 8 bits.<br/>/// The cursor is created in black and white according to the following:<br/>/// - data=0, mask=1: white<br/>/// - data=1, mask=1: black<br/>/// - data=0, mask=0: transparent<br/>/// - data=1, mask=0: inverted color if possible, black if not.<br/>/// Cursors created with this function must be freed with SDL_FreeCursor().<br/>/// If you want to have a color cursor, or create your cursor from an<br/>/// SDL_Surface, you should use SDL_CreateColorCursor(). Alternately, you can<br/>/// hide the cursor and draw your own as part of your game's rendering, but it<br/>/// will be bound to the framerate.<br/>/// Also, since SDL 2.0.0, SDL_CreateSystemCursor() is available, which<br/>/// provides twelve readily available system cursors to pick from.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_CreateCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor*")]
		public static SDLCursor* SDLCreateCursor([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte data, [NativeName(NativeNameType.Param, "mask")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte mask, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int")] int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int")] int h, [NativeName(NativeNameType.Param, "hot_x")] [NativeName(NativeNameType.Type, "int")] int hotX, [NativeName(NativeNameType.Param, "hot_y")] [NativeName(NativeNameType.Type, "int")] int hotY)
		{
			fixed (byte* pdata = &data)
			{
				fixed (byte* pmask = &mask)
				{
					SDLCursor* ret = SDLCreateCursorNative((byte*)pdata, (byte*)pmask, w, h, hotX, hotY);
					return ret;
				}
			}
		}

		/// <summary>
		/// Create a color cursor.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateColorCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor*")]
		internal static SDLCursor* SDLCreateColorCursorNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "hot_x")] [NativeName(NativeNameType.Type, "int")] int hotX, [NativeName(NativeNameType.Param, "hot_y")] [NativeName(NativeNameType.Type, "int")] int hotY)
		{
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, int, int, SDLCursor*>)vt[469])(surface, hotX, hotY);
		}
		/// <summary>/// Create a color cursor.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_CreateColorCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor*")]
		public static SDLCursor* SDLCreateColorCursor([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "hot_x")] [NativeName(NativeNameType.Type, "int")] int hotX, [NativeName(NativeNameType.Param, "hot_y")] [NativeName(NativeNameType.Type, "int")] int hotY)
		{
			SDLCursor* ret = SDLCreateColorCursorNative(surface, hotX, hotY);
			return ret;
		}

		/// <summary>/// Create a color cursor.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_CreateColorCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor*")]
		public static SDLCursor* SDLCreateColorCursor([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "hot_x")] [NativeName(NativeNameType.Type, "int")] int hotX, [NativeName(NativeNameType.Param, "hot_y")] [NativeName(NativeNameType.Type, "int")] int hotY)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				SDLCursor* ret = SDLCreateColorCursorNative((SDLSurface*)psurface, hotX, hotY);
				return ret;
			}
		}

		/// <summary>
		/// Create a system cursor.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateSystemCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor*")]
		internal static SDLCursor* SDLCreateSystemCursorNative([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "SDL_SystemCursor")] SDLSystemCursor id)
		{
			return ((delegate* unmanaged[Cdecl]<SDLSystemCursor, SDLCursor*>)vt[470])(id);
		}
		/// <summary>/// Create a system cursor.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_CreateSystemCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor*")]
		public static SDLCursor* SDLCreateSystemCursor([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "SDL_SystemCursor")] SDLSystemCursor id)
		{
			SDLCursor* ret = SDLCreateSystemCursorNative(id);
			return ret;
		}

		/// <summary>
		/// Set the active cursor.<br/>
		/// This function sets the currently active cursor to the specified one. If the<br/>
		/// cursor is currently visible, the change will be immediately represented on<br/>
		/// the display. SDL_SetCursor(NULL) can be used to force cursor redraw, if<br/>
		/// this is desired for any reason.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetCursor")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SDLSetCursorNative([NativeName(NativeNameType.Param, "cursor")] [NativeName(NativeNameType.Type, "SDL_Cursor*")] SDLCursor* cursor)
		{
			((delegate* unmanaged[Cdecl]<SDLCursor*, void>)vt[471])(cursor);
		}
		/// <summary>/// Set the active cursor.<br/>/// This function sets the currently active cursor to the specified one. If the<br/>/// cursor is currently visible, the change will be immediately represented on<br/>/// the display. SDL_SetCursor(NULL) can be used to force cursor redraw, if<br/>/// this is desired for any reason.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetCursor")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLSetCursor([NativeName(NativeNameType.Param, "cursor")] [NativeName(NativeNameType.Type, "SDL_Cursor*")] SDLCursor* cursor)
		{
			SDLSetCursorNative(cursor);
		}

		/// <summary>/// Set the active cursor.<br/>/// This function sets the currently active cursor to the specified one. If the<br/>/// cursor is currently visible, the change will be immediately represented on<br/>/// the display. SDL_SetCursor(NULL) can be used to force cursor redraw, if<br/>/// this is desired for any reason.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetCursor")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLSetCursor([NativeName(NativeNameType.Param, "cursor")] [NativeName(NativeNameType.Type, "SDL_Cursor*")] ref SDLCursor cursor)
		{
			fixed (SDLCursor* pcursor = &cursor)
			{
				SDLSetCursorNative((SDLCursor*)pcursor);
			}
		}

		/// <summary>
		/// Get the active cursor.<br/>
		/// This function returns a pointer to the current cursor which is owned by the<br/>
		/// library. It is not necessary to free the cursor with SDL_FreeCursor().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor*")]
		internal static SDLCursor* SDLGetCursorNative()
		{
			return ((delegate* unmanaged[Cdecl]<SDLCursor*>)vt[472])();
		}
		/// <summary>/// Get the active cursor.<br/>/// This function returns a pointer to the current cursor which is owned by the<br/>/// library. It is not necessary to free the cursor with SDL_FreeCursor().<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor*")]
		public static SDLCursor* SDLGetCursor()
		{
			SDLCursor* ret = SDLGetCursorNative();
			return ret;
		}

		/// <summary>
		/// Get the default cursor.<br/>
		/// You do not have to call SDL_FreeCursor() on the return value, but it is<br/>
		/// safe to do so.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetDefaultCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor*")]
		internal static SDLCursor* SDLGetDefaultCursorNative()
		{
			return ((delegate* unmanaged[Cdecl]<SDLCursor*>)vt[473])();
		}
		/// <summary>/// Get the default cursor.<br/>/// You do not have to call SDL_FreeCursor() on the return value, but it is<br/>/// safe to do so.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetDefaultCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor*")]
		public static SDLCursor* SDLGetDefaultCursor()
		{
			SDLCursor* ret = SDLGetDefaultCursorNative();
			return ret;
		}

		/// <summary>
		/// Free a previously-created cursor.<br/>
		/// Use this function to free cursor resources created with SDL_CreateCursor(),<br/>
		/// SDL_CreateColorCursor() or SDL_CreateSystemCursor().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FreeCursor")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SDLFreeCursorNative([NativeName(NativeNameType.Param, "cursor")] [NativeName(NativeNameType.Type, "SDL_Cursor*")] SDLCursor* cursor)
		{
			((delegate* unmanaged[Cdecl]<SDLCursor*, void>)vt[474])(cursor);
		}
		/// <summary>/// Free a previously-created cursor.<br/>/// Use this function to free cursor resources created with SDL_CreateCursor(),<br/>/// SDL_CreateColorCursor() or SDL_CreateSystemCursor().<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_FreeCursor")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLFreeCursor([NativeName(NativeNameType.Param, "cursor")] [NativeName(NativeNameType.Type, "SDL_Cursor*")] SDLCursor* cursor)
		{
			SDLFreeCursorNative(cursor);
		}

		/// <summary>/// Free a previously-created cursor.<br/>/// Use this function to free cursor resources created with SDL_CreateCursor(),<br/>/// SDL_CreateColorCursor() or SDL_CreateSystemCursor().<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_FreeCursor")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLFreeCursor([NativeName(NativeNameType.Param, "cursor")] [NativeName(NativeNameType.Type, "SDL_Cursor*")] ref SDLCursor cursor)
		{
			fixed (SDLCursor* pcursor = &cursor)
			{
				SDLFreeCursorNative((SDLCursor*)pcursor);
			}
		}

		/// <summary>
		/// Toggle whether or not the cursor is shown.<br/>
		/// The cursor starts off displayed but can be turned off. Passing `SDL_ENABLE`<br/>
		/// displays the cursor and passing `SDL_DISABLE` hides it.<br/>
		/// The current state of the mouse cursor can be queried by passing<br/>
		/// `SDL_QUERY`; either `SDL_DISABLE` or `SDL_ENABLE` will be returned.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowCursor")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLShowCursorNative([NativeName(NativeNameType.Param, "toggle")] [NativeName(NativeNameType.Type, "int")] int toggle)
		{
			return ((delegate* unmanaged[Cdecl]<int, int>)vt[475])(toggle);
		}
		/// <summary>/// Toggle whether or not the cursor is shown.<br/>/// The cursor starts off displayed but can be turned off. Passing `SDL_ENABLE`<br/>/// displays the cursor and passing `SDL_DISABLE` hides it.<br/>/// The current state of the mouse cursor can be queried by passing<br/>/// `SDL_QUERY`; either `SDL_DISABLE` or `SDL_ENABLE` will be returned.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_ShowCursor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLShowCursor([NativeName(NativeNameType.Param, "toggle")] [NativeName(NativeNameType.Type, "int")] int toggle)
		{
			int ret = SDLShowCursorNative(toggle);
			return ret;
		}

		/// <summary>
		/// Get an ASCII string representation for a given ::SDL_GUID.<br/>
		/// You should supply at least 33 bytes for pszGUID.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GUIDToString")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SDLGUIDToStringNative([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_GUID")] SdlGuid guid, [NativeName(NativeNameType.Param, "pszGUID")] [NativeName(NativeNameType.Type, "char*")] byte* pszGUID, [NativeName(NativeNameType.Param, "cbGUID")] [NativeName(NativeNameType.Type, "int")] int cbGUID)
		{
			((delegate* unmanaged[Cdecl]<SdlGuid, byte*, int, void>)vt[476])(guid, pszGUID, cbGUID);
		}
		/// <summary>/// Get an ASCII string representation for a given ::SDL_GUID.<br/>/// You should supply at least 33 bytes for pszGUID.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GUIDToString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGUIDToString([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_GUID")] SdlGuid guid, [NativeName(NativeNameType.Param, "pszGUID")] [NativeName(NativeNameType.Type, "char*")] byte* pszGUID, [NativeName(NativeNameType.Param, "cbGUID")] [NativeName(NativeNameType.Type, "int")] int cbGUID)
		{
			SDLGUIDToStringNative(guid, pszGUID, cbGUID);
		}

		/// <summary>/// Get an ASCII string representation for a given ::SDL_GUID.<br/>/// You should supply at least 33 bytes for pszGUID.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GUIDToString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGUIDToString([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_GUID")] SdlGuid guid, [NativeName(NativeNameType.Param, "pszGUID")] [NativeName(NativeNameType.Type, "char*")] ref byte pszGUID, [NativeName(NativeNameType.Param, "cbGUID")] [NativeName(NativeNameType.Type, "int")] int cbGUID)
		{
			fixed (byte* ppszGUID = &pszGUID)
			{
				SDLGUIDToStringNative(guid, (byte*)ppszGUID, cbGUID);
			}
		}

		/// <summary>/// Get an ASCII string representation for a given ::SDL_GUID.<br/>/// You should supply at least 33 bytes for pszGUID.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GUIDToString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGUIDToString([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_GUID")] SdlGuid guid, [NativeName(NativeNameType.Param, "pszGUID")] [NativeName(NativeNameType.Type, "char*")] ref string pszGUID, [NativeName(NativeNameType.Param, "cbGUID")] [NativeName(NativeNameType.Type, "int")] int cbGUID)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pszGUID != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pszGUID);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pszGUID, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLGUIDToStringNative(guid, pStr0, cbGUID);
			pszGUID = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Convert a GUID string into a ::SDL_GUID structure.<br/>
		/// Performs no error checking. If this function is given a string containing<br/>
		/// an invalid GUID, the function will silently succeed, but the GUID generated<br/>
		/// will not be useful.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GUIDFromString")]
		[return: NativeName(NativeNameType.Type, "SDL_GUID")]
		internal static SdlGuid SDLGUIDFromStringNative([NativeName(NativeNameType.Param, "pchGUID")] [NativeName(NativeNameType.Type, "const char*")] byte* pchGUID)
		{
			return ((delegate* unmanaged[Cdecl]<byte*, SdlGuid>)vt[477])(pchGUID);
		}
		/// <summary>/// Convert a GUID string into a ::SDL_GUID structure.<br/>/// Performs no error checking. If this function is given a string containing<br/>/// an invalid GUID, the function will silently succeed, but the GUID generated<br/>/// will not be useful.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GUIDFromString")]
		[return: NativeName(NativeNameType.Type, "SDL_GUID")]
		public static SdlGuid SDLGUIDFromString([NativeName(NativeNameType.Param, "pchGUID")] [NativeName(NativeNameType.Type, "const char*")] byte* pchGUID)
		{
			SdlGuid ret = SDLGUIDFromStringNative(pchGUID);
			return ret;
		}

		/// <summary>/// Convert a GUID string into a ::SDL_GUID structure.<br/>/// Performs no error checking. If this function is given a string containing<br/>/// an invalid GUID, the function will silently succeed, but the GUID generated<br/>/// will not be useful.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GUIDFromString")]
		[return: NativeName(NativeNameType.Type, "SDL_GUID")]
		public static SdlGuid SDLGUIDFromString([NativeName(NativeNameType.Param, "pchGUID")] [NativeName(NativeNameType.Type, "const char*")] ref byte pchGUID)
		{
			fixed (byte* ppchGUID = &pchGUID)
			{
				SdlGuid ret = SDLGUIDFromStringNative((byte*)ppchGUID);
				return ret;
			}
		}

		/// <summary>/// Convert a GUID string into a ::SDL_GUID structure.<br/>/// Performs no error checking. If this function is given a string containing<br/>/// an invalid GUID, the function will silently succeed, but the GUID generated<br/>/// will not be useful.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_GUIDFromString")]
		[return: NativeName(NativeNameType.Type, "SDL_GUID")]
		public static SdlGuid SDLGUIDFromString([NativeName(NativeNameType.Param, "pchGUID")] [NativeName(NativeNameType.Type, "const char*")] string pchGUID)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pchGUID != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pchGUID);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pchGUID, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SdlGuid ret = SDLGUIDFromStringNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Locking for multi-threaded access to the joystick API<br/>
		/// If you are using the joystick API or handling events from multiple threads<br/>
		/// you should use these locking functions to protect access to the joysticks.<br/>
		/// In particular, you are guaranteed that the joystick list won't change, so<br/>
		/// the API functions that take a joystick index will be valid, and joystick<br/>
		/// and game controller events will not be delivered.<br/>
		/// As of SDL 2.26.0, you can take the joystick lock around reinitializing the<br/>
		/// joystick subsystem, to prevent other threads from seeing joysticks in an<br/>
		/// uninitialized state. However, all open joysticks will be closed and SDL<br/>
		/// functions called with them will fail.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockJoysticks")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SDLLockJoysticksNative()
		{
			((delegate* unmanaged[Cdecl]<void>)vt[478])();
		}
		/// <summary>/// Locking for multi-threaded access to the joystick API<br/>/// If you are using the joystick API or handling events from multiple threads<br/>/// you should use these locking functions to protect access to the joysticks.<br/>/// In particular, you are guaranteed that the joystick list won't change, so<br/>/// the API functions that take a joystick index will be valid, and joystick<br/>/// and game controller events will not be delivered.<br/>/// As of SDL 2.26.0, you can take the joystick lock around reinitializing the<br/>/// joystick subsystem, to prevent other threads from seeing joysticks in an<br/>/// uninitialized state. However, all open joysticks will be closed and SDL<br/>/// functions called with them will fail.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_LockJoysticks")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLLockJoysticks()
		{
			SDLLockJoysticksNative();
		}

		/// <summary>
		/// Unlocking for multi-threaded access to the joystick API<br/>
		/// If you are using the joystick API or handling events from multiple threads<br/>
		/// you should use these locking functions to protect access to the joysticks.<br/>
		/// In particular, you are guaranteed that the joystick list won't change, so<br/>
		/// the API functions that take a joystick index will be valid, and joystick<br/>
		/// and game controller events will not be delivered.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnlockJoysticks")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SDLUnlockJoysticksNative()
		{
			((delegate* unmanaged[Cdecl]<void>)vt[479])();
		}
		/// <summary>/// Unlocking for multi-threaded access to the joystick API<br/>/// If you are using the joystick API or handling events from multiple threads<br/>/// you should use these locking functions to protect access to the joysticks.<br/>/// In particular, you are guaranteed that the joystick list won't change, so<br/>/// the API functions that take a joystick index will be valid, and joystick<br/>/// and game controller events will not be delivered.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_UnlockJoysticks")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLUnlockJoysticks()
		{
			SDLUnlockJoysticksNative();
		}

		/// <summary>
		/// Count the number of joysticks attached to the system.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_NumJoysticks")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLNumJoysticksNative()
		{
			return ((delegate* unmanaged[Cdecl]<int>)vt[480])();
		}
		/// <summary>/// Count the number of joysticks attached to the system.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_NumJoysticks")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLNumJoysticks()
		{
			int ret = SDLNumJoysticksNative();
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickNameForIndex")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		internal static byte* SDLJoystickNameForIndexNative([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex)
		{
			return ((delegate* unmanaged[Cdecl]<int, byte*>)vt[481])(deviceIndex);
		}
		/// <summary>/// Get the implementation dependent name of a joystick.<br/>/// This can be called before any joysticks are opened.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickNameForIndex")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLJoystickNameForIndex([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex)
		{
			byte* ret = SDLJoystickNameForIndexNative(deviceIndex);
			return ret;
		}

		/// <summary>/// Get the implementation dependent name of a joystick.<br/>/// This can be called before any joysticks are opened.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickNameForIndex")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLJoystickNameForIndexS([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex)
		{
			string ret = Utils.DecodeStringUTF8(SDLJoystickNameForIndexNative(deviceIndex));
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent path of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickPathForIndex")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		internal static byte* SDLJoystickPathForIndexNative([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex)
		{
			return ((delegate* unmanaged[Cdecl]<int, byte*>)vt[482])(deviceIndex);
		}
		/// <summary>/// Get the implementation dependent path of a joystick.<br/>/// This can be called before any joysticks are opened.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickPathForIndex")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLJoystickPathForIndex([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex)
		{
			byte* ret = SDLJoystickPathForIndexNative(deviceIndex);
			return ret;
		}

		/// <summary>/// Get the implementation dependent path of a joystick.<br/>/// This can be called before any joysticks are opened.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickPathForIndex")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLJoystickPathForIndexS([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex)
		{
			string ret = Utils.DecodeStringUTF8(SDLJoystickPathForIndexNative(deviceIndex));
			return ret;
		}

		/// <summary>
		/// Get the player index of a joystick, or -1 if it's not available This can be<br/>
		/// called before any joysticks are opened.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickGetDevicePlayerIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLJoystickGetDevicePlayerIndexNative([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex)
		{
			return ((delegate* unmanaged[Cdecl]<int, int>)vt[483])(deviceIndex);
		}
		/// <summary>/// Get the player index of a joystick, or -1 if it's not available This can be<br/>/// called before any joysticks are opened.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetDevicePlayerIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLJoystickGetDevicePlayerIndex([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex)
		{
			int ret = SDLJoystickGetDevicePlayerIndexNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Get the implementation-dependent GUID for the joystick at a given device<br/>
		/// index.<br/>
		/// This function can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickGetDeviceGUID")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickGUID")]
		internal static Guid SDLJoystickGetDeviceGUIDNative([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex)
		{
			return ((delegate* unmanaged[Cdecl]<int, Guid>)vt[484])(deviceIndex);
		}
		/// <summary>/// Get the implementation-dependent GUID for the joystick at a given device<br/>/// index.<br/>/// This function can be called before any joysticks are opened.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetDeviceGUID")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickGUID")]
		public static Guid SDLJoystickGetDeviceGUID([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex)
		{
			Guid ret = SDLJoystickGetDeviceGUIDNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Get the USB vendor ID of a joystick, if available.<br/>
		/// This can be called before any joysticks are opened. If the vendor ID isn't<br/>
		/// available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickGetDeviceVendor")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		internal static ushort SDLJoystickGetDeviceVendorNative([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex)
		{
			return ((delegate* unmanaged[Cdecl]<int, ushort>)vt[485])(deviceIndex);
		}
		/// <summary>/// Get the USB vendor ID of a joystick, if available.<br/>/// This can be called before any joysticks are opened. If the vendor ID isn't<br/>/// available this function returns 0.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetDeviceVendor")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort SDLJoystickGetDeviceVendor([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex)
		{
			ushort ret = SDLJoystickGetDeviceVendorNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Get the USB product ID of a joystick, if available.<br/>
		/// This can be called before any joysticks are opened. If the product ID isn't<br/>
		/// available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickGetDeviceProduct")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		internal static ushort SDLJoystickGetDeviceProductNative([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex)
		{
			return ((delegate* unmanaged[Cdecl]<int, ushort>)vt[486])(deviceIndex);
		}
		/// <summary>/// Get the USB product ID of a joystick, if available.<br/>/// This can be called before any joysticks are opened. If the product ID isn't<br/>/// available this function returns 0.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetDeviceProduct")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort SDLJoystickGetDeviceProduct([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex)
		{
			ushort ret = SDLJoystickGetDeviceProductNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Get the product version of a joystick, if available.<br/>
		/// This can be called before any joysticks are opened. If the product version<br/>
		/// isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickGetDeviceProductVersion")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		internal static ushort SDLJoystickGetDeviceProductVersionNative([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex)
		{
			return ((delegate* unmanaged[Cdecl]<int, ushort>)vt[487])(deviceIndex);
		}
		/// <summary>/// Get the product version of a joystick, if available.<br/>/// This can be called before any joysticks are opened. If the product version<br/>/// isn't available this function returns 0.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetDeviceProductVersion")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort SDLJoystickGetDeviceProductVersion([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex)
		{
			ushort ret = SDLJoystickGetDeviceProductVersionNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Get the type of a joystick, if available.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickGetDeviceType")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickType")]
		internal static SDLJoystickType SDLJoystickGetDeviceTypeNative([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex)
		{
			return ((delegate* unmanaged[Cdecl]<int, SDLJoystickType>)vt[488])(deviceIndex);
		}
		/// <summary>/// Get the type of a joystick, if available.<br/>/// This can be called before any joysticks are opened.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetDeviceType")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickType")]
		public static SDLJoystickType SDLJoystickGetDeviceType([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex)
		{
			SDLJoystickType ret = SDLJoystickGetDeviceTypeNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Get the instance ID of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickGetDeviceInstanceID")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickID")]
		internal static int SDLJoystickGetDeviceInstanceIDNative([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex)
		{
			return ((delegate* unmanaged[Cdecl]<int, int>)vt[489])(deviceIndex);
		}
		/// <summary>/// Get the instance ID of a joystick.<br/>/// This can be called before any joysticks are opened.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetDeviceInstanceID")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickID")]
		public static int SDLJoystickGetDeviceInstanceID([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex)
		{
			int ret = SDLJoystickGetDeviceInstanceIDNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Open a joystick for use.<br/>
		/// The `device_index` argument refers to the N'th joystick presently<br/>
		/// recognized by SDL on the system. It is **NOT** the same as the instance ID<br/>
		/// used to identify the joystick in future events. See<br/>
		/// SDL_JoystickInstanceID() for more details about instance IDs.<br/>
		/// The joystick subsystem must be initialized before a joystick can be opened<br/>
		/// for use.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickOpen")]
		[return: NativeName(NativeNameType.Type, "SDL_Joystick*")]
		internal static SDLJoystick* SDLJoystickOpenNative([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex)
		{
			return ((delegate* unmanaged[Cdecl]<int, SDLJoystick*>)vt[490])(deviceIndex);
		}
		/// <summary>/// Open a joystick for use.<br/>/// The `device_index` argument refers to the N'th joystick presently<br/>/// recognized by SDL on the system. It is **NOT** the same as the instance ID<br/>/// used to identify the joystick in future events. See<br/>/// SDL_JoystickInstanceID() for more details about instance IDs.<br/>/// The joystick subsystem must be initialized before a joystick can be opened<br/>/// for use.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickOpen")]
		[return: NativeName(NativeNameType.Type, "SDL_Joystick*")]
		public static SDLJoystick* SDLJoystickOpen([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex)
		{
			SDLJoystick* ret = SDLJoystickOpenNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Get the SDL_Joystick associated with an instance id.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickFromInstanceID")]
		[return: NativeName(NativeNameType.Type, "SDL_Joystick*")]
		internal static SDLJoystick* SDLJoystickFromInstanceIDNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			return ((delegate* unmanaged[Cdecl]<int, SDLJoystick*>)vt[491])(instanceId);
		}
		/// <summary>/// Get the SDL_Joystick associated with an instance id.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickFromInstanceID")]
		[return: NativeName(NativeNameType.Type, "SDL_Joystick*")]
		public static SDLJoystick* SDLJoystickFromInstanceID([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			SDLJoystick* ret = SDLJoystickFromInstanceIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the SDL_Joystick associated with a player index.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickFromPlayerIndex")]
		[return: NativeName(NativeNameType.Type, "SDL_Joystick*")]
		internal static SDLJoystick* SDLJoystickFromPlayerIndexNative([NativeName(NativeNameType.Param, "player_index")] [NativeName(NativeNameType.Type, "int")] int playerIndex)
		{
			return ((delegate* unmanaged[Cdecl]<int, SDLJoystick*>)vt[492])(playerIndex);
		}
		/// <summary>/// Get the SDL_Joystick associated with a player index.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickFromPlayerIndex")]
		[return: NativeName(NativeNameType.Type, "SDL_Joystick*")]
		public static SDLJoystick* SDLJoystickFromPlayerIndex([NativeName(NativeNameType.Param, "player_index")] [NativeName(NativeNameType.Type, "int")] int playerIndex)
		{
			SDLJoystick* ret = SDLJoystickFromPlayerIndexNative(playerIndex);
			return ret;
		}

		/// <summary>
		/// Attach a new virtual joystick.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickAttachVirtual")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLJoystickAttachVirtualNative([NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_JoystickType")] SDLJoystickType type, [NativeName(NativeNameType.Param, "naxes")] [NativeName(NativeNameType.Type, "int")] int naxes, [NativeName(NativeNameType.Param, "nbuttons")] [NativeName(NativeNameType.Type, "int")] int nbuttons, [NativeName(NativeNameType.Param, "nhats")] [NativeName(NativeNameType.Type, "int")] int nhats)
		{
			return ((delegate* unmanaged[Cdecl]<SDLJoystickType, int, int, int, int>)vt[493])(type, naxes, nbuttons, nhats);
		}
		/// <summary>/// Attach a new virtual joystick.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickAttachVirtual")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLJoystickAttachVirtual([NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_JoystickType")] SDLJoystickType type, [NativeName(NativeNameType.Param, "naxes")] [NativeName(NativeNameType.Type, "int")] int naxes, [NativeName(NativeNameType.Param, "nbuttons")] [NativeName(NativeNameType.Type, "int")] int nbuttons, [NativeName(NativeNameType.Param, "nhats")] [NativeName(NativeNameType.Type, "int")] int nhats)
		{
			int ret = SDLJoystickAttachVirtualNative(type, naxes, nbuttons, nhats);
			return ret;
		}

		/// <summary>
		/// Attach a new virtual joystick with extended properties.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickAttachVirtualEx")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLJoystickAttachVirtualExNative([NativeName(NativeNameType.Param, "desc")] [NativeName(NativeNameType.Type, "const SDL_VirtualJoystickDesc*")] SDLVirtualJoystickDesc* desc)
		{
			return ((delegate* unmanaged[Cdecl]<SDLVirtualJoystickDesc*, int>)vt[494])(desc);
		}
		/// <summary>/// Attach a new virtual joystick with extended properties.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickAttachVirtualEx")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLJoystickAttachVirtualEx([NativeName(NativeNameType.Param, "desc")] [NativeName(NativeNameType.Type, "const SDL_VirtualJoystickDesc*")] SDLVirtualJoystickDesc* desc)
		{
			int ret = SDLJoystickAttachVirtualExNative(desc);
			return ret;
		}

		/// <summary>/// Attach a new virtual joystick with extended properties.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickAttachVirtualEx")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLJoystickAttachVirtualEx([NativeName(NativeNameType.Param, "desc")] [NativeName(NativeNameType.Type, "const SDL_VirtualJoystickDesc*")] ref SDLVirtualJoystickDesc desc)
		{
			fixed (SDLVirtualJoystickDesc* pdesc = &desc)
			{
				int ret = SDLJoystickAttachVirtualExNative((SDLVirtualJoystickDesc*)pdesc);
				return ret;
			}
		}

		/// <summary>
		/// Detach a virtual joystick.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickDetachVirtual")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLJoystickDetachVirtualNative([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex)
		{
			return ((delegate* unmanaged[Cdecl]<int, int>)vt[495])(deviceIndex);
		}
		/// <summary>/// Detach a virtual joystick.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickDetachVirtual")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLJoystickDetachVirtual([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex)
		{
			int ret = SDLJoystickDetachVirtualNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Query whether or not the joystick at a given device index is virtual.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickIsVirtual")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		internal static SDLBool SDLJoystickIsVirtualNative([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex)
		{
			return ((delegate* unmanaged[Cdecl]<int, SDLBool>)vt[496])(deviceIndex);
		}
		/// <summary>/// Query whether or not the joystick at a given device index is virtual.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickIsVirtual")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLJoystickIsVirtual([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex)
		{
			SDLBool ret = SDLJoystickIsVirtualNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Set values on an opened, virtual-joystick's axis.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_JoystickUpdate, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// Note that when sending trigger axes, you should scale the value to the full<br/>
		/// range of Sint16. For example, a trigger at rest would have the value of<br/>
		/// `SDL_JOYSTICK_AXIS_MIN`.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickSetVirtualAxis")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLJoystickSetVirtualAxisNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "int")] int axis, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint16")] short value)
		{
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int, short, int>)vt[497])(joystick, axis, value);
		}
		/// <summary>/// Set values on an opened, virtual-joystick's axis.<br/>/// Please note that values set here will not be applied until the next call to<br/>/// SDL_JoystickUpdate, which can either be called directly, or can be called<br/>/// indirectly through various other SDL APIs, including, but not limited to<br/>/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>/// SDL_WaitEvent.<br/>/// Note that when sending trigger axes, you should scale the value to the full<br/>/// range of Sint16. For example, a trigger at rest would have the value of<br/>/// `SDL_JOYSTICK_AXIS_MIN`.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickSetVirtualAxis")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLJoystickSetVirtualAxis([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "int")] int axis, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint16")] short value)
		{
			int ret = SDLJoystickSetVirtualAxisNative(joystick, axis, value);
			return ret;
		}

		/// <summary>/// Set values on an opened, virtual-joystick's axis.<br/>/// Please note that values set here will not be applied until the next call to<br/>/// SDL_JoystickUpdate, which can either be called directly, or can be called<br/>/// indirectly through various other SDL APIs, including, but not limited to<br/>/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>/// SDL_WaitEvent.<br/>/// Note that when sending trigger axes, you should scale the value to the full<br/>/// range of Sint16. For example, a trigger at rest would have the value of<br/>/// `SDL_JOYSTICK_AXIS_MIN`.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickSetVirtualAxis")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLJoystickSetVirtualAxis([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "int")] int axis, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint16")] short value)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = SDLJoystickSetVirtualAxisNative((SDLJoystick*)pjoystick, axis, value);
				return ret;
			}
		}

		/// <summary>
		/// Set values on an opened, virtual-joystick's button.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_JoystickUpdate, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickSetVirtualButton")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLJoystickSetVirtualButtonNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "int")] int button, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint8")] byte value)
		{
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int, byte, int>)vt[498])(joystick, button, value);
		}
		/// <summary>/// Set values on an opened, virtual-joystick's button.<br/>/// Please note that values set here will not be applied until the next call to<br/>/// SDL_JoystickUpdate, which can either be called directly, or can be called<br/>/// indirectly through various other SDL APIs, including, but not limited to<br/>/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>/// SDL_WaitEvent.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickSetVirtualButton")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLJoystickSetVirtualButton([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "int")] int button, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint8")] byte value)
		{
			int ret = SDLJoystickSetVirtualButtonNative(joystick, button, value);
			return ret;
		}

		/// <summary>/// Set values on an opened, virtual-joystick's button.<br/>/// Please note that values set here will not be applied until the next call to<br/>/// SDL_JoystickUpdate, which can either be called directly, or can be called<br/>/// indirectly through various other SDL APIs, including, but not limited to<br/>/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>/// SDL_WaitEvent.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickSetVirtualButton")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLJoystickSetVirtualButton([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "int")] int button, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint8")] byte value)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = SDLJoystickSetVirtualButtonNative((SDLJoystick*)pjoystick, button, value);
				return ret;
			}
		}

		/// <summary>
		/// Set values on an opened, virtual-joystick's hat.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_JoystickUpdate, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickSetVirtualHat")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLJoystickSetVirtualHatNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "hat")] [NativeName(NativeNameType.Type, "int")] int hat, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint8")] byte value)
		{
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int, byte, int>)vt[499])(joystick, hat, value);
		}
		/// <summary>/// Set values on an opened, virtual-joystick's hat.<br/>/// Please note that values set here will not be applied until the next call to<br/>/// SDL_JoystickUpdate, which can either be called directly, or can be called<br/>/// indirectly through various other SDL APIs, including, but not limited to<br/>/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>/// SDL_WaitEvent.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickSetVirtualHat")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLJoystickSetVirtualHat([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "hat")] [NativeName(NativeNameType.Type, "int")] int hat, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint8")] byte value)
		{
			int ret = SDLJoystickSetVirtualHatNative(joystick, hat, value);
			return ret;
		}

		/// <summary>/// Set values on an opened, virtual-joystick's hat.<br/>/// Please note that values set here will not be applied until the next call to<br/>/// SDL_JoystickUpdate, which can either be called directly, or can be called<br/>/// indirectly through various other SDL APIs, including, but not limited to<br/>/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>/// SDL_WaitEvent.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickSetVirtualHat")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLJoystickSetVirtualHat([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick, [NativeName(NativeNameType.Param, "hat")] [NativeName(NativeNameType.Type, "int")] int hat, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint8")] byte value)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = SDLJoystickSetVirtualHatNative((SDLJoystick*)pjoystick, hat, value);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation dependent name of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		internal static byte* SDLJoystickNameNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick)
		{
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, byte*>)vt[500])(joystick);
		}
		/// <summary>/// Get the implementation dependent name of a joystick.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLJoystickName([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick)
		{
			byte* ret = SDLJoystickNameNative(joystick);
			return ret;
		}

		/// <summary>/// Get the implementation dependent name of a joystick.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLJoystickNameS([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick)
		{
			string ret = Utils.DecodeStringUTF8(SDLJoystickNameNative(joystick));
			return ret;
		}

		/// <summary>/// Get the implementation dependent name of a joystick.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLJoystickName([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				byte* ret = SDLJoystickNameNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>/// Get the implementation dependent name of a joystick.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLJoystickNameS([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				string ret = Utils.DecodeStringUTF8(SDLJoystickNameNative((SDLJoystick*)pjoystick));
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation dependent path of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickPath")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		internal static byte* SDLJoystickPathNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick)
		{
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, byte*>)vt[501])(joystick);
		}
		/// <summary>/// Get the implementation dependent path of a joystick.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickPath")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLJoystickPath([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick)
		{
			byte* ret = SDLJoystickPathNative(joystick);
			return ret;
		}

		/// <summary>/// Get the implementation dependent path of a joystick.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickPath")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLJoystickPathS([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick)
		{
			string ret = Utils.DecodeStringUTF8(SDLJoystickPathNative(joystick));
			return ret;
		}

		/// <summary>/// Get the implementation dependent path of a joystick.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickPath")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLJoystickPath([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				byte* ret = SDLJoystickPathNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>/// Get the implementation dependent path of a joystick.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickPath")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLJoystickPathS([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				string ret = Utils.DecodeStringUTF8(SDLJoystickPathNative((SDLJoystick*)pjoystick));
				return ret;
			}
		}

		/// <summary>
		/// Get the player index of an opened joystick.<br/>
		/// For XInput controllers this returns the XInput user index. Many joysticks<br/>
		/// will not be able to supply this information.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickGetPlayerIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int SDLJoystickGetPlayerIndexNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick)
		{
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int>)vt[502])(joystick);
		}
		/// <summary>/// Get the player index of an opened joystick.<br/>/// For XInput controllers this returns the XInput user index. Many joysticks<br/>/// will not be able to supply this information.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetPlayerIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLJoystickGetPlayerIndex([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick)
		{
			int ret = SDLJoystickGetPlayerIndexNative(joystick);
			return ret;
		}

		/// <summary>/// Get the player index of an opened joystick.<br/>/// For XInput controllers this returns the XInput user index. Many joysticks<br/>/// will not be able to supply this information.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetPlayerIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLJoystickGetPlayerIndex([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = SDLJoystickGetPlayerIndexNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Set the player index of an opened joystick.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickSetPlayerIndex")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SDLJoystickSetPlayerIndexNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "player_index")] [NativeName(NativeNameType.Type, "int")] int playerIndex)
		{
			((delegate* unmanaged[Cdecl]<SDLJoystick*, int, void>)vt[503])(joystick, playerIndex);
		}
		/// <summary>/// Set the player index of an opened joystick.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickSetPlayerIndex")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLJoystickSetPlayerIndex([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "player_index")] [NativeName(NativeNameType.Type, "int")] int playerIndex)
		{
			SDLJoystickSetPlayerIndexNative(joystick, playerIndex);
		}

		/// <summary>/// Set the player index of an opened joystick.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickSetPlayerIndex")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLJoystickSetPlayerIndex([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick, [NativeName(NativeNameType.Param, "player_index")] [NativeName(NativeNameType.Type, "int")] int playerIndex)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				SDLJoystickSetPlayerIndexNative((SDLJoystick*)pjoystick, playerIndex);
			}
		}

		/// <summary>
		/// Get the implementation-dependent GUID for the joystick.<br/>
		/// This function requires an open joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickGetGUID")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickGUID")]
		internal static Guid SDLJoystickGetGUIDNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick)
		{
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, Guid>)vt[504])(joystick);
		}
		/// <summary>/// Get the implementation-dependent GUID for the joystick.<br/>/// This function requires an open joystick.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetGUID")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickGUID")]
		public static Guid SDLJoystickGetGUID([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick)
		{
			Guid ret = SDLJoystickGetGUIDNative(joystick);
			return ret;
		}

		/// <summary>/// Get the implementation-dependent GUID for the joystick.<br/>/// This function requires an open joystick.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetGUID")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickGUID")]
		public static Guid SDLJoystickGetGUID([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				Guid ret = SDLJoystickGetGUIDNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the USB vendor ID of an opened joystick, if available.<br/>
		/// If the vendor ID isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickGetVendor")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		internal static ushort SDLJoystickGetVendorNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick)
		{
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, ushort>)vt[505])(joystick);
		}
		/// <summary>/// Get the USB vendor ID of an opened joystick, if available.<br/>/// If the vendor ID isn't available this function returns 0.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetVendor")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort SDLJoystickGetVendor([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick)
		{
			ushort ret = SDLJoystickGetVendorNative(joystick);
			return ret;
		}

		/// <summary>/// Get the USB vendor ID of an opened joystick, if available.<br/>/// If the vendor ID isn't available this function returns 0.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetVendor")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort SDLJoystickGetVendor([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				ushort ret = SDLJoystickGetVendorNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the USB product ID of an opened joystick, if available.<br/>
		/// If the product ID isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickGetProduct")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		internal static ushort SDLJoystickGetProductNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick)
		{
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, ushort>)vt[506])(joystick);
		}
		/// <summary>/// Get the USB product ID of an opened joystick, if available.<br/>/// If the product ID isn't available this function returns 0.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetProduct")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort SDLJoystickGetProduct([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick)
		{
			ushort ret = SDLJoystickGetProductNative(joystick);
			return ret;
		}

		/// <summary>/// Get the USB product ID of an opened joystick, if available.<br/>/// If the product ID isn't available this function returns 0.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetProduct")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort SDLJoystickGetProduct([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				ushort ret = SDLJoystickGetProductNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the product version of an opened joystick, if available.<br/>
		/// If the product version isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickGetProductVersion")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		internal static ushort SDLJoystickGetProductVersionNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick)
		{
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, ushort>)vt[507])(joystick);
		}
		/// <summary>/// Get the product version of an opened joystick, if available.<br/>/// If the product version isn't available this function returns 0.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetProductVersion")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort SDLJoystickGetProductVersion([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick)
		{
			ushort ret = SDLJoystickGetProductVersionNative(joystick);
			return ret;
		}

		/// <summary>/// Get the product version of an opened joystick, if available.<br/>/// If the product version isn't available this function returns 0.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetProductVersion")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort SDLJoystickGetProductVersion([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				ushort ret = SDLJoystickGetProductVersionNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the firmware version of an opened joystick, if available.<br/>
		/// If the firmware version isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickGetFirmwareVersion")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		internal static ushort SDLJoystickGetFirmwareVersionNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick)
		{
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, ushort>)vt[508])(joystick);
		}
		/// <summary>/// Get the firmware version of an opened joystick, if available.<br/>/// If the firmware version isn't available this function returns 0.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetFirmwareVersion")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort SDLJoystickGetFirmwareVersion([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick)
		{
			ushort ret = SDLJoystickGetFirmwareVersionNative(joystick);
			return ret;
		}

		/// <summary>/// Get the firmware version of an opened joystick, if available.<br/>/// If the firmware version isn't available this function returns 0.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetFirmwareVersion")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort SDLJoystickGetFirmwareVersion([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				ushort ret = SDLJoystickGetFirmwareVersionNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the serial number of an opened joystick, if available.<br/>
		/// Returns the serial number of the joystick, or NULL if it is not available.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickGetSerial")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		internal static byte* SDLJoystickGetSerialNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick)
		{
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, byte*>)vt[509])(joystick);
		}
		/// <summary>/// Get the serial number of an opened joystick, if available.<br/>/// Returns the serial number of the joystick, or NULL if it is not available.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetSerial")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLJoystickGetSerial([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick)
		{
			byte* ret = SDLJoystickGetSerialNative(joystick);
			return ret;
		}

		/// <summary>/// Get the serial number of an opened joystick, if available.<br/>/// Returns the serial number of the joystick, or NULL if it is not available.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetSerial")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLJoystickGetSerialS([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick)
		{
			string ret = Utils.DecodeStringUTF8(SDLJoystickGetSerialNative(joystick));
			return ret;
		}

		/// <summary>/// Get the serial number of an opened joystick, if available.<br/>/// Returns the serial number of the joystick, or NULL if it is not available.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetSerial")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLJoystickGetSerial([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				byte* ret = SDLJoystickGetSerialNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>/// Get the serial number of an opened joystick, if available.<br/>/// Returns the serial number of the joystick, or NULL if it is not available.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetSerial")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLJoystickGetSerialS([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				string ret = Utils.DecodeStringUTF8(SDLJoystickGetSerialNative((SDLJoystick*)pjoystick));
				return ret;
			}
		}

		/// <summary>
		/// Get the type of an opened joystick.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickGetType")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickType")]
		internal static SDLJoystickType SDLJoystickGetTypeNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick)
		{
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, SDLJoystickType>)vt[510])(joystick);
		}
		/// <summary>/// Get the type of an opened joystick.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetType")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickType")]
		public static SDLJoystickType SDLJoystickGetType([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick)
		{
			SDLJoystickType ret = SDLJoystickGetTypeNative(joystick);
			return ret;
		}

		/// <summary>/// Get the type of an opened joystick.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetType")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickType")]
		public static SDLJoystickType SDLJoystickGetType([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				SDLJoystickType ret = SDLJoystickGetTypeNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get an ASCII string representation for a given SDL_JoystickGUID.<br/>
		/// You should supply at least 33 bytes for pszGUID.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickGetGUIDString")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SDLJoystickGetGUIDStringNative([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_JoystickGUID")] Guid guid, [NativeName(NativeNameType.Param, "pszGUID")] [NativeName(NativeNameType.Type, "char*")] byte* pszGUID, [NativeName(NativeNameType.Param, "cbGUID")] [NativeName(NativeNameType.Type, "int")] int cbGUID)
		{
			((delegate* unmanaged[Cdecl]<Guid, byte*, int, void>)vt[511])(guid, pszGUID, cbGUID);
		}
		/// <summary>/// Get an ASCII string representation for a given SDL_JoystickGUID.<br/>/// You should supply at least 33 bytes for pszGUID.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetGUIDString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLJoystickGetGUIDString([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_JoystickGUID")] Guid guid, [NativeName(NativeNameType.Param, "pszGUID")] [NativeName(NativeNameType.Type, "char*")] byte* pszGUID, [NativeName(NativeNameType.Param, "cbGUID")] [NativeName(NativeNameType.Type, "int")] int cbGUID)
		{
			SDLJoystickGetGUIDStringNative(guid, pszGUID, cbGUID);
		}

		/// <summary>/// Get an ASCII string representation for a given SDL_JoystickGUID.<br/>/// You should supply at least 33 bytes for pszGUID.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetGUIDString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLJoystickGetGUIDString([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_JoystickGUID")] Guid guid, [NativeName(NativeNameType.Param, "pszGUID")] [NativeName(NativeNameType.Type, "char*")] ref byte pszGUID, [NativeName(NativeNameType.Param, "cbGUID")] [NativeName(NativeNameType.Type, "int")] int cbGUID)
		{
			fixed (byte* ppszGUID = &pszGUID)
			{
				SDLJoystickGetGUIDStringNative(guid, (byte*)ppszGUID, cbGUID);
			}
		}
	}
}
