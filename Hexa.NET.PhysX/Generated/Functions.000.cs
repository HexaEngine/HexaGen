// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Hexa.NET.PhysX
{
	public unsafe partial class PhysX
	{
		internal const string LibName = "shaderc_shared";

		/// <summary>
		/// The foundation class is needed to initialize higher level SDKs. There may be only one instance per process.<br/>
		/// Calling this method after an instance has been created already will result in an error message and NULL will be<br/>
		/// returned.<br/>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxCreateFoundation")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial PxFoundation* PxCreateFoundationNative(uint version, PxAllocatorCallback* allocator, PxErrorCallback* errorCallback);

		/// <summary>/// The foundation class is needed to initialize higher level SDKs. There may be only one instance per process.<br/>/// Calling this method after an instance has been created already will result in an error message and NULL will be<br/>/// returned.<br/>/// </summary>		public static PxFoundation* PxCreateFoundation( uint version,  PxAllocatorCallback* allocator,  PxErrorCallback* errorCallback)
		{
			PxFoundation* ret = PxCreateFoundationNative(version, allocator, errorCallback);
			return ret;
		}

		/// <summary>/// The foundation class is needed to initialize higher level SDKs. There may be only one instance per process.<br/>/// Calling this method after an instance has been created already will result in an error message and NULL will be<br/>/// returned.<br/>/// </summary>		public static PxFoundation* PxCreateFoundation( uint version,  ref PxAllocatorCallback allocator,  PxErrorCallback* errorCallback)
		{
			fixed (PxAllocatorCallback* pallocator = &allocator)
			{
				PxFoundation* ret = PxCreateFoundationNative(version, (PxAllocatorCallback*)pallocator, errorCallback);
				return ret;
			}
		}

		/// <summary>/// The foundation class is needed to initialize higher level SDKs. There may be only one instance per process.<br/>/// Calling this method after an instance has been created already will result in an error message and NULL will be<br/>/// returned.<br/>/// </summary>		public static PxFoundation* PxCreateFoundation( uint version,  PxAllocatorCallback* allocator,  ref PxErrorCallback errorCallback)
		{
			fixed (PxErrorCallback* perrorCallback = &errorCallback)
			{
				PxFoundation* ret = PxCreateFoundationNative(version, allocator, (PxErrorCallback*)perrorCallback);
				return ret;
			}
		}

		/// <summary>/// The foundation class is needed to initialize higher level SDKs. There may be only one instance per process.<br/>/// Calling this method after an instance has been created already will result in an error message and NULL will be<br/>/// returned.<br/>/// </summary>		public static PxFoundation* PxCreateFoundation( uint version,  ref PxAllocatorCallback allocator,  ref PxErrorCallback errorCallback)
		{
			fixed (PxAllocatorCallback* pallocator = &allocator)
			{
				fixed (PxErrorCallback* perrorCallback = &errorCallback)
				{
					PxFoundation* ret = PxCreateFoundationNative(version, (PxAllocatorCallback*)pallocator, (PxErrorCallback*)perrorCallback);
					return ret;
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "PxSetFoundationInstance")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PxSetFoundationInstanceNative(PxFoundation* foundation);

		public static void PxSetFoundationInstance( PxFoundation* foundation)
		{
			PxSetFoundationInstanceNative(foundation);
		}

		[LibraryImport(LibName, EntryPoint = "PxGetFoundation")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial PxFoundation* PxGetFoundationNative();

		public static PxFoundation* PxGetFoundation()
		{
			PxFoundation* ret = PxGetFoundationNative();
			return ret;
		}

		/// <summary>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxGetProfilerCallback")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial PxProfilerCallback* PxGetProfilerCallbackNative();

		/// <summary>/// </summary>		public static PxProfilerCallback* PxGetProfilerCallback()
		{
			PxProfilerCallback* ret = PxGetProfilerCallbackNative();
			return ret;
		}

		/// <summary>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxSetProfilerCallback")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PxSetProfilerCallbackNative(PxProfilerCallback* profiler);

		/// <summary>/// </summary>		public static void PxSetProfilerCallback( PxProfilerCallback* profiler)
		{
			PxSetProfilerCallbackNative(profiler);
		}

		/// <summary>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxGetAllocatorCallback")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial PxAllocatorCallback* PxGetAllocatorCallbackNative();

		/// <summary>/// </summary>		public static PxAllocatorCallback* PxGetAllocatorCallback()
		{
			PxAllocatorCallback* ret = PxGetAllocatorCallbackNative();
			return ret;
		}

		/// <summary>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxGetBroadcastAllocator")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial PxAllocatorCallback* PxGetBroadcastAllocatorNative();

		/// <summary>/// </summary>		public static PxAllocatorCallback* PxGetBroadcastAllocator()
		{
			PxAllocatorCallback* ret = PxGetBroadcastAllocatorNative();
			return ret;
		}

		/// <summary>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxGetErrorCallback")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial PxErrorCallback* PxGetErrorCallbackNative();

		/// <summary>/// </summary>		public static PxErrorCallback* PxGetErrorCallback()
		{
			PxErrorCallback* ret = PxGetErrorCallbackNative();
			return ret;
		}

		/// <summary>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxGetBroadcastError")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial PxErrorCallback* PxGetBroadcastErrorNative();

		/// <summary>/// </summary>		public static PxErrorCallback* PxGetBroadcastError()
		{
			PxErrorCallback* ret = PxGetBroadcastErrorNative();
			return ret;
		}

		/// <summary>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxGetWarnOnceTimeStamp")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial uint PxGetWarnOnceTimeStampNative();

		/// <summary>/// </summary>		public static uint PxGetWarnOnceTimeStamp()
		{
			uint ret = PxGetWarnOnceTimeStampNative();
			return ret;
		}

		/// <summary>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxDecFoundationRefCount")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PxDecFoundationRefCountNative();

		/// <summary>/// </summary>		public static void PxDecFoundationRefCount()
		{
			PxDecFoundationRefCountNative();
		}

		/// <summary>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxIncFoundationRefCount")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PxIncFoundationRefCountNative();

		/// <summary>/// </summary>		public static void PxIncFoundationRefCount()
		{
			PxIncFoundationRefCountNative();
		}

		/// <summary>
		/// Objects can only be serialized or deserialized through a collection.<br/>
		/// For serialization, users must add objects to the collection and serialize the collection as a whole.<br/>
		/// For deserialization, the system gives back a collection of deserialized objects to users.<br/>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxCreateCollection")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial PxCollection* PxCreateCollectionNative();

		/// <summary>/// Objects can only be serialized or deserialized through a collection.<br/>/// For serialization, users must add objects to the collection and serialize the collection as a whole.<br/>/// For deserialization, the system gives back a collection of deserialized objects to users.<br/>/// </summary>		public static PxCollection* PxCreateCollection()
		{
			PxCollection* ret = PxCreateCollectionNative();
			return ret;
		}

		/// <summary>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxSetPhysXGpuLoadHook")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PxSetPhysXGpuLoadHookNative(PxGpuLoadHook* hook);

		/// <summary>/// </summary>		public static void PxSetPhysXGpuLoadHook( PxGpuLoadHook* hook)
		{
			PxSetPhysXGpuLoadHookNative(hook);
		}

		/// <summary>
		/// <br/>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxGetSuggestedCudaDeviceOrdinal")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int PxGetSuggestedCudaDeviceOrdinalNative(PxErrorCallback* errc);

		/// <summary>/// <br/>/// </summary>		public static int PxGetSuggestedCudaDeviceOrdinal( PxErrorCallback* errc)
		{
			int ret = PxGetSuggestedCudaDeviceOrdinalNative(errc);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxCreateCudaContextManager")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial PxCudaContextManager* PxCreateCudaContextManagerNative(PxFoundation* foundation, PxCudaContextManagerDesc* desc, PxProfilerCallback* profilerCallback);

		/// <summary>/// <br/>/// <br/>/// </summary>		public static PxCudaContextManager* PxCreateCudaContextManager( PxFoundation* foundation,  PxCudaContextManagerDesc* desc,  PxProfilerCallback* profilerCallback)
		{
			PxCudaContextManager* ret = PxCreateCudaContextManagerNative(foundation, desc, profilerCallback);
			return ret;
		}

		/// <summary>/// <br/>/// <br/>/// </summary>		public static PxCudaContextManager* PxCreateCudaContextManager( PxFoundation* foundation,  ref PxCudaContextManagerDesc desc,  PxProfilerCallback* profilerCallback)
		{
			fixed (PxCudaContextManagerDesc* pdesc = &desc)
			{
				PxCudaContextManager* ret = PxCreateCudaContextManagerNative(foundation, (PxCudaContextManagerDesc*)pdesc, profilerCallback);
				return ret;
			}
		}

		/// <summary>/// <br/>/// <br/>/// </summary>		public static PxCudaContextManager* PxCreateCudaContextManager( PxFoundation* foundation,  PxCudaContextManagerDesc* desc,  ref PxProfilerCallback profilerCallback)
		{
			fixed (PxProfilerCallback* pprofilerCallback = &profilerCallback)
			{
				PxCudaContextManager* ret = PxCreateCudaContextManagerNative(foundation, desc, (PxProfilerCallback*)pprofilerCallback);
				return ret;
			}
		}

		/// <summary>/// <br/>/// <br/>/// </summary>		public static PxCudaContextManager* PxCreateCudaContextManager( PxFoundation* foundation,  ref PxCudaContextManagerDesc desc,  ref PxProfilerCallback profilerCallback)
		{
			fixed (PxCudaContextManagerDesc* pdesc = &desc)
			{
				fixed (PxProfilerCallback* pprofilerCallback = &profilerCallback)
				{
					PxCudaContextManager* ret = PxCreateCudaContextManagerNative(foundation, (PxCudaContextManagerDesc*)pdesc, (PxProfilerCallback*)pprofilerCallback);
					return ret;
				}
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxSetPhysXGpuProfilerCallback")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PxSetPhysXGpuProfilerCallbackNative(PxProfilerCallback* profilerCallback);

		/// <summary>/// <br/>/// <br/>/// </summary>		public static void PxSetPhysXGpuProfilerCallback( PxProfilerCallback* profilerCallback)
		{
			PxSetPhysXGpuProfilerCallbackNative(profilerCallback);
		}

		/// <summary>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxCudaRegisterFunction")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PxCudaRegisterFunctionNative(int moduleIndex, byte* functionName);

		/// <summary>/// </summary>		public static void PxCudaRegisterFunction( int moduleIndex,  byte* functionName)
		{
			PxCudaRegisterFunctionNative(moduleIndex, functionName);
		}

		/// <summary>/// </summary>		public static void PxCudaRegisterFunction( int moduleIndex,  ref byte functionName)
		{
			fixed (byte* pfunctionName = &functionName)
			{
				PxCudaRegisterFunctionNative(moduleIndex, (byte*)pfunctionName);
			}
		}

		/// <summary>/// </summary>		public static void PxCudaRegisterFunction( int moduleIndex,  string functionName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (functionName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(functionName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(functionName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PxCudaRegisterFunctionNative(moduleIndex, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxCudaRegisterFatBinary")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void** PxCudaRegisterFatBinaryNative(void* unknown0);

		/// <summary>/// </summary>		public static void** PxCudaRegisterFatBinary( void* unknown0)
		{
			void** ret = PxCudaRegisterFatBinaryNative(unknown0);
			return ret;
		}

		/// <summary>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxGetCudaModuleTable")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void** PxGetCudaModuleTableNative();

		/// <summary>/// </summary>		public static void** PxGetCudaModuleTable()
		{
			void** ret = PxGetCudaModuleTableNative();
			return ret;
		}

		/// <summary>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxGetCudaModuleTableSize")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial uint PxGetCudaModuleTableSizeNative();

		/// <summary>/// </summary>		public static uint PxGetCudaModuleTableSize()
		{
			uint ret = PxGetCudaModuleTableSizeNative();
			return ret;
		}

		/// <summary>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxGetCudaFunctionTable")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial PxKernelIndex* PxGetCudaFunctionTableNative();

		/// <summary>/// </summary>		public static PxKernelIndex* PxGetCudaFunctionTable()
		{
			PxKernelIndex* ret = PxGetCudaFunctionTableNative();
			return ret;
		}

		/// <summary>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxGetCudaFunctionTableSize")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial uint PxGetCudaFunctionTableSizeNative();

		/// <summary>/// </summary>		public static uint PxGetCudaFunctionTableSize()
		{
			uint ret = PxGetCudaFunctionTableSizeNative();
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This function returns pairs of box indices that belong to both the first <br/>
		/// &<br/>
		/// second input bvhs.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxFindOverlap")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte PxFindOverlapNative(PxReportCallback* callback, PxBVH* bvh0, PxBVH* bvh1);

		/// <summary>/// <br/>/// This function returns pairs of box indices that belong to both the first <br/>/// &<br/>/// second input bvhs.<br/>/// <br/>/// <br/>/// </summary>		public static bool PxFindOverlap( PxReportCallback* callback,  PxBVH* bvh0,  PxBVH* bvh1)
		{
			byte ret = PxFindOverlapNative(callback, bvh0, bvh1);
			return ret != 0;
		}

		/// <summary>/// <br/>/// This function returns pairs of box indices that belong to both the first <br/>/// &<br/>/// second input bvhs.<br/>/// <br/>/// <br/>/// </summary>		public static bool PxFindOverlap( PxReportCallback* callback,  ref PxBVH bvh0,  PxBVH* bvh1)
		{
			fixed (PxBVH* pbvh0 = &bvh0)
			{
				byte ret = PxFindOverlapNative(callback, (PxBVH*)pbvh0, bvh1);
				return ret != 0;
			}
		}

		/// <summary>/// <br/>/// This function returns pairs of box indices that belong to both the first <br/>/// &<br/>/// second input bvhs.<br/>/// <br/>/// <br/>/// </summary>		public static bool PxFindOverlap( PxReportCallback* callback,  PxBVH* bvh0,  ref PxBVH bvh1)
		{
			fixed (PxBVH* pbvh1 = &bvh1)
			{
				byte ret = PxFindOverlapNative(callback, bvh0, (PxBVH*)pbvh1);
				return ret != 0;
			}
		}

		/// <summary>/// <br/>/// This function returns pairs of box indices that belong to both the first <br/>/// &<br/>/// second input bvhs.<br/>/// <br/>/// <br/>/// </summary>		public static bool PxFindOverlap( PxReportCallback* callback,  ref PxBVH bvh0,  ref PxBVH bvh1)
		{
			fixed (PxBVH* pbvh0 = &bvh0)
			{
				fixed (PxBVH* pbvh1 = &bvh1)
				{
					byte ret = PxFindOverlapNative(callback, (PxBVH*)pbvh0, (PxBVH*)pbvh1);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxCustomGeometry_getUniqueID")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial uint PxCustomGeometryGetUniqueIDNative();

		/// <summary>/// </summary>		public static uint PxCustomGeometryGetUniqueID()
		{
			uint ret = PxCustomGeometryGetUniqueIDNative();
			return ret;
		}

		/// <summary>
		/// See #PxParticleClothDesc, #PxPartitionedParticleCloth.<br/>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxCreateParticleClothPreProcessor")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial PxParticleClothPreProcessor* PxCreateParticleClothPreProcessorNative(PxCudaContextManager* cudaContextManager);

		/// <summary>/// See #PxParticleClothDesc, #PxPartitionedParticleCloth.<br/>/// </summary>		public static PxParticleClothPreProcessor* PxCreateParticleClothPreProcessor( PxCudaContextManager* cudaContextManager)
		{
			PxParticleClothPreProcessor* ret = PxCreateParticleClothPreProcessorNative(cudaContextManager);
			return ret;
		}

		/// <summary>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxRegisterArticulationsReducedCoordinate")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PxRegisterArticulationsReducedCoordinateNative(PxPhysics* physics);

		/// <summary>/// </summary>		public static void PxRegisterArticulationsReducedCoordinate( PxPhysics* physics)
		{
			PxRegisterArticulationsReducedCoordinateNative(physics);
		}

		/// <summary>
		/// This call will link the default 'unified' implementation of heightfields which is identical to the narrow phase of triangle meshes.<br/>
		/// This function is called automatically inside PxCreatePhysics().<br/>
		/// On resource constrained platforms, it is possible to call PxCreateBasePhysics() and then NOT call this function<br/>
		/// to save on code memory if your application does not use heightfields. In this case the linker should strip out<br/>
		/// the relevant implementation code from the library. If you need to use heightfield but not some other optional<br/>
		/// component, you shoud call PxCreateBasePhysics() followed by this call.<br/>
		/// You must call this function at a time where no ::PxScene instance exists, typically before calling PxPhysics::createScene().<br/>
		/// This is to prevent a change to the heightfield implementation code at runtime which would have undefined results.<br/>
		/// Calling PxCreateBasePhysics() and then attempting to create a heightfield shape without first calling<br/>
		/// ::PxRegisterHeightFields(), will result in an error.<br/>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxRegisterHeightFields")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PxRegisterHeightFieldsNative(PxPhysics* physics);

		/// <summary>/// This call will link the default 'unified' implementation of heightfields which is identical to the narrow phase of triangle meshes.<br/>/// This function is called automatically inside PxCreatePhysics().<br/>/// On resource constrained platforms, it is possible to call PxCreateBasePhysics() and then NOT call this function<br/>/// to save on code memory if your application does not use heightfields. In this case the linker should strip out<br/>/// the relevant implementation code from the library. If you need to use heightfield but not some other optional<br/>/// component, you shoud call PxCreateBasePhysics() followed by this call.<br/>/// You must call this function at a time where no ::PxScene instance exists, typically before calling PxPhysics::createScene().<br/>/// This is to prevent a change to the heightfield implementation code at runtime which would have undefined results.<br/>/// Calling PxCreateBasePhysics() and then attempting to create a heightfield shape without first calling<br/>/// ::PxRegisterHeightFields(), will result in an error.<br/>/// </summary>		public static void PxRegisterHeightFields( PxPhysics* physics)
		{
			PxRegisterHeightFieldsNative(physics);
		}

		/// <summary>
		/// Creates an instance of this class. May not be a class member to avoid name mangling.<br/>
		/// Pass the constant #PX_PHYSICS_VERSION as the argument.<br/>
		/// There may be only one instance of this class per process. Calling this method after an instance<br/>
		/// has been created already will result in an error message and NULL will be returned.<br/>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxCreateBasePhysics")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial PxPhysics* PxCreateBasePhysicsNative(uint version, PxFoundation* foundation, PxTolerancesScale* scale, byte trackOutstandingAllocations, PxPvd* pvd, PxOmniPvd* omniPvd);

		/// <summary>/// Creates an instance of this class. May not be a class member to avoid name mangling.<br/>/// Pass the constant #PX_PHYSICS_VERSION as the argument.<br/>/// There may be only one instance of this class per process. Calling this method after an instance<br/>/// has been created already will result in an error message and NULL will be returned.<br/>/// </summary>		public static PxPhysics* PxCreateBasePhysics( uint version,  PxFoundation* foundation,  PxTolerancesScale* scale,  bool trackOutstandingAllocations,  PxPvd* pvd,  PxOmniPvd* omniPvd)
		{
			PxPhysics* ret = PxCreateBasePhysicsNative(version, foundation, scale, trackOutstandingAllocations ? (byte)1 : (byte)0, pvd, omniPvd);
			return ret;
		}

		/// <summary>/// Creates an instance of this class. May not be a class member to avoid name mangling.<br/>/// Pass the constant #PX_PHYSICS_VERSION as the argument.<br/>/// There may be only one instance of this class per process. Calling this method after an instance<br/>/// has been created already will result in an error message and NULL will be returned.<br/>/// </summary>		public static PxPhysics* PxCreateBasePhysics( uint version,  ref PxFoundation foundation,  PxTolerancesScale* scale,  bool trackOutstandingAllocations,  PxPvd* pvd,  PxOmniPvd* omniPvd)
		{
			fixed (PxFoundation* pfoundation = &foundation)
			{
				PxPhysics* ret = PxCreateBasePhysicsNative(version, (PxFoundation*)pfoundation, scale, trackOutstandingAllocations ? (byte)1 : (byte)0, pvd, omniPvd);
				return ret;
			}
		}

		/// <summary>/// Creates an instance of this class. May not be a class member to avoid name mangling.<br/>/// Pass the constant #PX_PHYSICS_VERSION as the argument.<br/>/// There may be only one instance of this class per process. Calling this method after an instance<br/>/// has been created already will result in an error message and NULL will be returned.<br/>/// </summary>		public static PxPhysics* PxCreateBasePhysics( uint version,  PxFoundation* foundation,  ref PxTolerancesScale scale,  bool trackOutstandingAllocations,  PxPvd* pvd,  PxOmniPvd* omniPvd)
		{
			fixed (PxTolerancesScale* pscale = &scale)
			{
				PxPhysics* ret = PxCreateBasePhysicsNative(version, foundation, (PxTolerancesScale*)pscale, trackOutstandingAllocations ? (byte)1 : (byte)0, pvd, omniPvd);
				return ret;
			}
		}

		/// <summary>/// Creates an instance of this class. May not be a class member to avoid name mangling.<br/>/// Pass the constant #PX_PHYSICS_VERSION as the argument.<br/>/// There may be only one instance of this class per process. Calling this method after an instance<br/>/// has been created already will result in an error message and NULL will be returned.<br/>/// </summary>		public static PxPhysics* PxCreateBasePhysics( uint version,  ref PxFoundation foundation,  ref PxTolerancesScale scale,  bool trackOutstandingAllocations,  PxPvd* pvd,  PxOmniPvd* omniPvd)
		{
			fixed (PxFoundation* pfoundation = &foundation)
			{
				fixed (PxTolerancesScale* pscale = &scale)
				{
					PxPhysics* ret = PxCreateBasePhysicsNative(version, (PxFoundation*)pfoundation, (PxTolerancesScale*)pscale, trackOutstandingAllocations ? (byte)1 : (byte)0, pvd, omniPvd);
					return ret;
				}
			}
		}

		/// <summary>/// Creates an instance of this class. May not be a class member to avoid name mangling.<br/>/// Pass the constant #PX_PHYSICS_VERSION as the argument.<br/>/// There may be only one instance of this class per process. Calling this method after an instance<br/>/// has been created already will result in an error message and NULL will be returned.<br/>/// </summary>		public static PxPhysics* PxCreateBasePhysics( uint version,  PxFoundation* foundation,  PxTolerancesScale* scale,  bool trackOutstandingAllocations,  ref PxPvd pvd,  PxOmniPvd* omniPvd)
		{
			fixed (PxPvd* ppvd = &pvd)
			{
				PxPhysics* ret = PxCreateBasePhysicsNative(version, foundation, scale, trackOutstandingAllocations ? (byte)1 : (byte)0, (PxPvd*)ppvd, omniPvd);
				return ret;
			}
		}

		/// <summary>/// Creates an instance of this class. May not be a class member to avoid name mangling.<br/>/// Pass the constant #PX_PHYSICS_VERSION as the argument.<br/>/// There may be only one instance of this class per process. Calling this method after an instance<br/>/// has been created already will result in an error message and NULL will be returned.<br/>/// </summary>		public static PxPhysics* PxCreateBasePhysics( uint version,  ref PxFoundation foundation,  PxTolerancesScale* scale,  bool trackOutstandingAllocations,  ref PxPvd pvd,  PxOmniPvd* omniPvd)
		{
			fixed (PxFoundation* pfoundation = &foundation)
			{
				fixed (PxPvd* ppvd = &pvd)
				{
					PxPhysics* ret = PxCreateBasePhysicsNative(version, (PxFoundation*)pfoundation, scale, trackOutstandingAllocations ? (byte)1 : (byte)0, (PxPvd*)ppvd, omniPvd);
					return ret;
				}
			}
		}

		/// <summary>/// Creates an instance of this class. May not be a class member to avoid name mangling.<br/>/// Pass the constant #PX_PHYSICS_VERSION as the argument.<br/>/// There may be only one instance of this class per process. Calling this method after an instance<br/>/// has been created already will result in an error message and NULL will be returned.<br/>/// </summary>		public static PxPhysics* PxCreateBasePhysics( uint version,  PxFoundation* foundation,  ref PxTolerancesScale scale,  bool trackOutstandingAllocations,  ref PxPvd pvd,  PxOmniPvd* omniPvd)
		{
			fixed (PxTolerancesScale* pscale = &scale)
			{
				fixed (PxPvd* ppvd = &pvd)
				{
					PxPhysics* ret = PxCreateBasePhysicsNative(version, foundation, (PxTolerancesScale*)pscale, trackOutstandingAllocations ? (byte)1 : (byte)0, (PxPvd*)ppvd, omniPvd);
					return ret;
				}
			}
		}

		/// <summary>/// Creates an instance of this class. May not be a class member to avoid name mangling.<br/>/// Pass the constant #PX_PHYSICS_VERSION as the argument.<br/>/// There may be only one instance of this class per process. Calling this method after an instance<br/>/// has been created already will result in an error message and NULL will be returned.<br/>/// </summary>		public static PxPhysics* PxCreateBasePhysics( uint version,  ref PxFoundation foundation,  ref PxTolerancesScale scale,  bool trackOutstandingAllocations,  ref PxPvd pvd,  PxOmniPvd* omniPvd)
		{
			fixed (PxFoundation* pfoundation = &foundation)
			{
				fixed (PxTolerancesScale* pscale = &scale)
				{
					fixed (PxPvd* ppvd = &pvd)
					{
						PxPhysics* ret = PxCreateBasePhysicsNative(version, (PxFoundation*)pfoundation, (PxTolerancesScale*)pscale, trackOutstandingAllocations ? (byte)1 : (byte)0, (PxPvd*)ppvd, omniPvd);
						return ret;
					}
				}
			}
		}

		/// <summary>/// Creates an instance of this class. May not be a class member to avoid name mangling.<br/>/// Pass the constant #PX_PHYSICS_VERSION as the argument.<br/>/// There may be only one instance of this class per process. Calling this method after an instance<br/>/// has been created already will result in an error message and NULL will be returned.<br/>/// </summary>		public static PxPhysics* PxCreateBasePhysics( uint version,  PxFoundation* foundation,  PxTolerancesScale* scale,  bool trackOutstandingAllocations,  PxPvd* pvd,  ref PxOmniPvd omniPvd)
		{
			fixed (PxOmniPvd* pomniPvd = &omniPvd)
			{
				PxPhysics* ret = PxCreateBasePhysicsNative(version, foundation, scale, trackOutstandingAllocations ? (byte)1 : (byte)0, pvd, (PxOmniPvd*)pomniPvd);
				return ret;
			}
		}

		/// <summary>/// Creates an instance of this class. May not be a class member to avoid name mangling.<br/>/// Pass the constant #PX_PHYSICS_VERSION as the argument.<br/>/// There may be only one instance of this class per process. Calling this method after an instance<br/>/// has been created already will result in an error message and NULL will be returned.<br/>/// </summary>		public static PxPhysics* PxCreateBasePhysics( uint version,  ref PxFoundation foundation,  PxTolerancesScale* scale,  bool trackOutstandingAllocations,  PxPvd* pvd,  ref PxOmniPvd omniPvd)
		{
			fixed (PxFoundation* pfoundation = &foundation)
			{
				fixed (PxOmniPvd* pomniPvd = &omniPvd)
				{
					PxPhysics* ret = PxCreateBasePhysicsNative(version, (PxFoundation*)pfoundation, scale, trackOutstandingAllocations ? (byte)1 : (byte)0, pvd, (PxOmniPvd*)pomniPvd);
					return ret;
				}
			}
		}

		/// <summary>/// Creates an instance of this class. May not be a class member to avoid name mangling.<br/>/// Pass the constant #PX_PHYSICS_VERSION as the argument.<br/>/// There may be only one instance of this class per process. Calling this method after an instance<br/>/// has been created already will result in an error message and NULL will be returned.<br/>/// </summary>		public static PxPhysics* PxCreateBasePhysics( uint version,  PxFoundation* foundation,  ref PxTolerancesScale scale,  bool trackOutstandingAllocations,  PxPvd* pvd,  ref PxOmniPvd omniPvd)
		{
			fixed (PxTolerancesScale* pscale = &scale)
			{
				fixed (PxOmniPvd* pomniPvd = &omniPvd)
				{
					PxPhysics* ret = PxCreateBasePhysicsNative(version, foundation, (PxTolerancesScale*)pscale, trackOutstandingAllocations ? (byte)1 : (byte)0, pvd, (PxOmniPvd*)pomniPvd);
					return ret;
				}
			}
		}

		/// <summary>/// Creates an instance of this class. May not be a class member to avoid name mangling.<br/>/// Pass the constant #PX_PHYSICS_VERSION as the argument.<br/>/// There may be only one instance of this class per process. Calling this method after an instance<br/>/// has been created already will result in an error message and NULL will be returned.<br/>/// </summary>		public static PxPhysics* PxCreateBasePhysics( uint version,  ref PxFoundation foundation,  ref PxTolerancesScale scale,  bool trackOutstandingAllocations,  PxPvd* pvd,  ref PxOmniPvd omniPvd)
		{
			fixed (PxFoundation* pfoundation = &foundation)
			{
				fixed (PxTolerancesScale* pscale = &scale)
				{
					fixed (PxOmniPvd* pomniPvd = &omniPvd)
					{
						PxPhysics* ret = PxCreateBasePhysicsNative(version, (PxFoundation*)pfoundation, (PxTolerancesScale*)pscale, trackOutstandingAllocations ? (byte)1 : (byte)0, pvd, (PxOmniPvd*)pomniPvd);
						return ret;
					}
				}
			}
		}

		/// <summary>/// Creates an instance of this class. May not be a class member to avoid name mangling.<br/>/// Pass the constant #PX_PHYSICS_VERSION as the argument.<br/>/// There may be only one instance of this class per process. Calling this method after an instance<br/>/// has been created already will result in an error message and NULL will be returned.<br/>/// </summary>		public static PxPhysics* PxCreateBasePhysics( uint version,  PxFoundation* foundation,  PxTolerancesScale* scale,  bool trackOutstandingAllocations,  ref PxPvd pvd,  ref PxOmniPvd omniPvd)
		{
			fixed (PxPvd* ppvd = &pvd)
			{
				fixed (PxOmniPvd* pomniPvd = &omniPvd)
				{
					PxPhysics* ret = PxCreateBasePhysicsNative(version, foundation, scale, trackOutstandingAllocations ? (byte)1 : (byte)0, (PxPvd*)ppvd, (PxOmniPvd*)pomniPvd);
					return ret;
				}
			}
		}

		/// <summary>/// Creates an instance of this class. May not be a class member to avoid name mangling.<br/>/// Pass the constant #PX_PHYSICS_VERSION as the argument.<br/>/// There may be only one instance of this class per process. Calling this method after an instance<br/>/// has been created already will result in an error message and NULL will be returned.<br/>/// </summary>		public static PxPhysics* PxCreateBasePhysics( uint version,  ref PxFoundation foundation,  PxTolerancesScale* scale,  bool trackOutstandingAllocations,  ref PxPvd pvd,  ref PxOmniPvd omniPvd)
		{
			fixed (PxFoundation* pfoundation = &foundation)
			{
				fixed (PxPvd* ppvd = &pvd)
				{
					fixed (PxOmniPvd* pomniPvd = &omniPvd)
					{
						PxPhysics* ret = PxCreateBasePhysicsNative(version, (PxFoundation*)pfoundation, scale, trackOutstandingAllocations ? (byte)1 : (byte)0, (PxPvd*)ppvd, (PxOmniPvd*)pomniPvd);
						return ret;
					}
				}
			}
		}

		/// <summary>/// Creates an instance of this class. May not be a class member to avoid name mangling.<br/>/// Pass the constant #PX_PHYSICS_VERSION as the argument.<br/>/// There may be only one instance of this class per process. Calling this method after an instance<br/>/// has been created already will result in an error message and NULL will be returned.<br/>/// </summary>		public static PxPhysics* PxCreateBasePhysics( uint version,  PxFoundation* foundation,  ref PxTolerancesScale scale,  bool trackOutstandingAllocations,  ref PxPvd pvd,  ref PxOmniPvd omniPvd)
		{
			fixed (PxTolerancesScale* pscale = &scale)
			{
				fixed (PxPvd* ppvd = &pvd)
				{
					fixed (PxOmniPvd* pomniPvd = &omniPvd)
					{
						PxPhysics* ret = PxCreateBasePhysicsNative(version, foundation, (PxTolerancesScale*)pscale, trackOutstandingAllocations ? (byte)1 : (byte)0, (PxPvd*)ppvd, (PxOmniPvd*)pomniPvd);
						return ret;
					}
				}
			}
		}

		/// <summary>/// Creates an instance of this class. May not be a class member to avoid name mangling.<br/>/// Pass the constant #PX_PHYSICS_VERSION as the argument.<br/>/// There may be only one instance of this class per process. Calling this method after an instance<br/>/// has been created already will result in an error message and NULL will be returned.<br/>/// </summary>		public static PxPhysics* PxCreateBasePhysics( uint version,  ref PxFoundation foundation,  ref PxTolerancesScale scale,  bool trackOutstandingAllocations,  ref PxPvd pvd,  ref PxOmniPvd omniPvd)
		{
			fixed (PxFoundation* pfoundation = &foundation)
			{
				fixed (PxTolerancesScale* pscale = &scale)
				{
					fixed (PxPvd* ppvd = &pvd)
					{
						fixed (PxOmniPvd* pomniPvd = &omniPvd)
						{
							PxPhysics* ret = PxCreateBasePhysicsNative(version, (PxFoundation*)pfoundation, (PxTolerancesScale*)pscale, trackOutstandingAllocations ? (byte)1 : (byte)0, (PxPvd*)ppvd, (PxOmniPvd*)pomniPvd);
							return ret;
						}
					}
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "PxGetPhysics")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial PxPhysics* PxGetPhysicsNative();

		public static PxPhysics* PxGetPhysics()
		{
			PxPhysics* ret = PxGetPhysicsNative();
			return ret;
		}

		/// <summary>
		/// <br/>
		/// Mark static objects with this group when adding them to the broadphase.<br/>
		/// Overlaps between static objects will not be detected. All static objects<br/>
		/// should have the same group.<br/>
		/// <br/>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxGetBroadPhaseStaticFilterGroup")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial PxBpFilterGroup PxGetBroadPhaseStaticFilterGroupNative();

		/// <summary>/// <br/>/// Mark static objects with this group when adding them to the broadphase.<br/>/// Overlaps between static objects will not be detected. All static objects<br/>/// should have the same group.<br/>/// <br/>/// </summary>		public static PxBpFilterGroup PxGetBroadPhaseStaticFilterGroup()
		{
			PxBpFilterGroup ret = PxGetBroadPhaseStaticFilterGroupNative();
			return ret;
		}

		/// <summary>
		/// <br/>
		/// Mark dynamic objects with this group when adding them to the broadphase.<br/>
		/// Each dynamic object must have an ID, and overlaps between dynamic objects that have<br/>
		/// the same ID will not be detected. This is useful to dismiss overlaps between shapes<br/>
		/// of the same (compound) actor directly within the broadphase.<br/>
		/// <br/>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxGetBroadPhaseDynamicFilterGroup")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial PxBpFilterGroup PxGetBroadPhaseDynamicFilterGroupNative(uint id);

		/// <summary>/// <br/>/// Mark dynamic objects with this group when adding them to the broadphase.<br/>/// Each dynamic object must have an ID, and overlaps between dynamic objects that have<br/>/// the same ID will not be detected. This is useful to dismiss overlaps between shapes<br/>/// of the same (compound) actor directly within the broadphase.<br/>/// <br/>/// </summary>		public static PxBpFilterGroup PxGetBroadPhaseDynamicFilterGroup( uint id)
		{
			PxBpFilterGroup ret = PxGetBroadPhaseDynamicFilterGroupNative(id);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// Mark kinematic objects with this group when adding them to the broadphase.<br/>
		/// Each kinematic object must have an ID, and overlaps between kinematic objects that have<br/>
		/// the same ID will not be detected.<br/>
		/// <br/>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxGetBroadPhaseKinematicFilterGroup")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial PxBpFilterGroup PxGetBroadPhaseKinematicFilterGroupNative(uint id);

		/// <summary>/// <br/>/// Mark kinematic objects with this group when adding them to the broadphase.<br/>/// Each kinematic object must have an ID, and overlaps between kinematic objects that have<br/>/// the same ID will not be detected.<br/>/// <br/>/// </summary>		public static PxBpFilterGroup PxGetBroadPhaseKinematicFilterGroup( uint id)
		{
			PxBpFilterGroup ret = PxGetBroadPhaseKinematicFilterGroupNative(id);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// Use this function to create a new standalone broadphase.<br/>
		/// <br/>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxCreateBroadPhase")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial PxBroadPhase* PxCreateBroadPhaseNative(PxBroadPhaseDesc* desc);

		/// <summary>/// <br/>/// Use this function to create a new standalone broadphase.<br/>/// <br/>/// </summary>		public static PxBroadPhase* PxCreateBroadPhase( PxBroadPhaseDesc* desc)
		{
			PxBroadPhase* ret = PxCreateBroadPhaseNative(desc);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// Use this function to create a new standalone high-level broadphase.<br/>
		/// <br/>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxCreateAABBManager")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial PxAABBManager* PxCreateAABBManagerNative(PxBroadPhase* broadphase);

		/// <summary>/// <br/>/// Use this function to create a new standalone high-level broadphase.<br/>/// <br/>/// </summary>		public static PxAABBManager* PxCreateAABBManager( PxBroadPhase* broadphase)
		{
			PxAABBManager* ret = PxCreateAABBManagerNative(broadphase);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// The character controller is informed by #PxDeletionListener::onRelease() when actors or shapes are released, and updates its internal<br/>
		/// caches accordingly. If character controller movement or a call to #PxControllerManager::shiftOrigin() may overlap with actor/shape releases,<br/>
		/// internal data structures must be guarded against concurrent access.<br/>
		/// Locking guarantees thread safety in such scenarios.<br/>
		/// <br/>
		/// By default, locking is disabled.<br/>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxCreateControllerManager")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial PxControllerManager* PxCreateControllerManagerNative(PxScene* scene, byte lockingEnabled);

		/// <summary>/// <br/>/// <br/>/// The character controller is informed by #PxDeletionListener::onRelease() when actors or shapes are released, and updates its internal<br/>/// caches accordingly. If character controller movement or a call to #PxControllerManager::shiftOrigin() may overlap with actor/shape releases,<br/>/// internal data structures must be guarded against concurrent access.<br/>/// Locking guarantees thread safety in such scenarios.<br/>/// <br/>/// By default, locking is disabled.<br/>/// </summary>		public static PxControllerManager* PxCreateControllerManager( PxScene* scene,  bool lockingEnabled)
		{
			PxControllerManager* ret = PxCreateControllerManagerNative(scene, lockingEnabled ? (byte)1 : (byte)0);
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "PxCreateCooking")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial PxCooking* PxCreateCookingNative(uint version, PxFoundation* foundation, PxCookingParams* @params);

		public static PxCooking* PxCreateCooking( uint version,  PxFoundation* foundation,  PxCookingParams* @params)
		{
			PxCooking* ret = PxCreateCookingNative(version, foundation, @params);
			return ret;
		}

		public static PxCooking* PxCreateCooking( uint version,  ref PxFoundation foundation,  PxCookingParams* @params)
		{
			fixed (PxFoundation* pfoundation = &foundation)
			{
				PxCooking* ret = PxCreateCookingNative(version, (PxFoundation*)pfoundation, @params);
				return ret;
			}
		}

		public static PxCooking* PxCreateCooking( uint version,  PxFoundation* foundation,  ref PxCookingParams @params)
		{
			fixed (PxCookingParams* pparams = &@params)
			{
				PxCooking* ret = PxCreateCookingNative(version, foundation, (PxCookingParams*)pparams);
				return ret;
			}
		}

		public static PxCooking* PxCreateCooking( uint version,  ref PxFoundation foundation,  ref PxCookingParams @params)
		{
			fixed (PxFoundation* pfoundation = &foundation)
			{
				fixed (PxCookingParams* pparams = &@params)
				{
					PxCooking* ret = PxCreateCookingNative(version, (PxFoundation*)pfoundation, (PxCookingParams*)pparams);
					return ret;
				}
			}
		}

		/// <summary>
		/// Immediate cooking<br/>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxGetStandaloneInsertionCallback")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial PxInsertionCallback* PxGetStandaloneInsertionCallbackNative();

		/// <summary>/// Immediate cooking<br/>/// </summary>		public static PxInsertionCallback* PxGetStandaloneInsertionCallback()
		{
			PxInsertionCallback* ret = PxGetStandaloneInsertionCallbackNative();
			return ret;
		}

		/// <summary>
		/// PxCookBVH() allows a BVH description to be cooked into a binary stream<br/>
		/// suitable for loading and performing BVH detection at runtime.<br/>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxCookBVH")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte PxCookBVHNative(PxBVHDesc* desc, PxOutputStream* stream);

		/// <summary>/// PxCookBVH() allows a BVH description to be cooked into a binary stream<br/>/// suitable for loading and performing BVH detection at runtime.<br/>/// </summary>		public static bool PxCookBVH( PxBVHDesc* desc,  PxOutputStream* stream)
		{
			byte ret = PxCookBVHNative(desc, stream);
			return ret != 0;
		}

		/// <summary>/// PxCookBVH() allows a BVH description to be cooked into a binary stream<br/>/// suitable for loading and performing BVH detection at runtime.<br/>/// </summary>		public static bool PxCookBVH( PxBVHDesc* desc,  ref PxOutputStream stream)
		{
			fixed (PxOutputStream* pstream = &stream)
			{
				byte ret = PxCookBVHNative(desc, (PxOutputStream*)pstream);
				return ret != 0;
			}
		}

		/// <summary>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxCreateBVH")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial PxBVH* PxCreateBVHNative(PxBVHDesc* desc, PxInsertionCallback* insertionCallback);

		/// <summary>/// </summary>		public static PxBVH* PxCreateBVH( PxBVHDesc* desc,  PxInsertionCallback* insertionCallback)
		{
			PxBVH* ret = PxCreateBVHNative(desc, insertionCallback);
			return ret;
		}

		/// <summary>/// </summary>		public static PxBVH* PxCreateBVH( PxBVHDesc* desc,  ref PxInsertionCallback insertionCallback)
		{
			fixed (PxInsertionCallback* pinsertionCallback = &insertionCallback)
			{
				PxBVH* ret = PxCreateBVHNative(desc, (PxInsertionCallback*)pinsertionCallback);
				return ret;
			}
		}

		/// <summary>
		/// To create a heightfield object there is an option to precompute some of calculations done while loading the heightfield data.<br/>
		/// cookHeightField() allows a heightfield description to be cooked into a binary stream<br/>
		/// suitable for loading and performing collision detection at runtime.<br/>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxCookHeightField")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte PxCookHeightFieldNative(PxHeightFieldDesc* desc, PxOutputStream* stream);

		/// <summary>/// To create a heightfield object there is an option to precompute some of calculations done while loading the heightfield data.<br/>/// cookHeightField() allows a heightfield description to be cooked into a binary stream<br/>/// suitable for loading and performing collision detection at runtime.<br/>/// </summary>		public static bool PxCookHeightField( PxHeightFieldDesc* desc,  PxOutputStream* stream)
		{
			byte ret = PxCookHeightFieldNative(desc, stream);
			return ret != 0;
		}

		/// <summary>/// To create a heightfield object there is an option to precompute some of calculations done while loading the heightfield data.<br/>/// cookHeightField() allows a heightfield description to be cooked into a binary stream<br/>/// suitable for loading and performing collision detection at runtime.<br/>/// </summary>		public static bool PxCookHeightField( PxHeightFieldDesc* desc,  ref PxOutputStream stream)
		{
			fixed (PxOutputStream* pstream = &stream)
			{
				byte ret = PxCookHeightFieldNative(desc, (PxOutputStream*)pstream);
				return ret != 0;
			}
		}

		/// <summary>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxCreateHeightField")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial PxHeightField* PxCreateHeightFieldNative(PxHeightFieldDesc* desc, PxInsertionCallback* insertionCallback);

		/// <summary>/// </summary>		public static PxHeightField* PxCreateHeightField( PxHeightFieldDesc* desc,  PxInsertionCallback* insertionCallback)
		{
			PxHeightField* ret = PxCreateHeightFieldNative(desc, insertionCallback);
			return ret;
		}

		/// <summary>/// </summary>		public static PxHeightField* PxCreateHeightField( PxHeightFieldDesc* desc,  ref PxInsertionCallback insertionCallback)
		{
			fixed (PxInsertionCallback* pinsertionCallback = &insertionCallback)
			{
				PxHeightField* ret = PxCreateHeightFieldNative(desc, (PxInsertionCallback*)pinsertionCallback);
				return ret;
			}
		}

		/// <summary>
		/// To create a triangle mesh object it is necessary to first 'cook' the mesh data into<br/>
		/// a form which allows the SDK to perform efficient collision detection.<br/>
		/// cookConvexMesh() allows a mesh description to be cooked into a binary stream<br/>
		/// suitable for loading and performing collision detection at runtime.<br/>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxCookConvexMesh")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte PxCookConvexMeshNative(PxCookingParams* @params, PxConvexMeshDesc* desc, PxOutputStream* stream, Enum* condition);

		/// <summary>/// To create a triangle mesh object it is necessary to first 'cook' the mesh data into<br/>/// a form which allows the SDK to perform efficient collision detection.<br/>/// cookConvexMesh() allows a mesh description to be cooked into a binary stream<br/>/// suitable for loading and performing collision detection at runtime.<br/>/// </summary>		public static bool PxCookConvexMesh( PxCookingParams* @params,  PxConvexMeshDesc* desc,  PxOutputStream* stream,  Enum* condition)
		{
			byte ret = PxCookConvexMeshNative(@params, desc, stream, condition);
			return ret != 0;
		}

		/// <summary>/// To create a triangle mesh object it is necessary to first 'cook' the mesh data into<br/>/// a form which allows the SDK to perform efficient collision detection.<br/>/// cookConvexMesh() allows a mesh description to be cooked into a binary stream<br/>/// suitable for loading and performing collision detection at runtime.<br/>/// </summary>		public static bool PxCookConvexMesh( PxCookingParams* @params,  ref PxConvexMeshDesc desc,  PxOutputStream* stream,  Enum* condition)
		{
			fixed (PxConvexMeshDesc* pdesc = &desc)
			{
				byte ret = PxCookConvexMeshNative(@params, (PxConvexMeshDesc*)pdesc, stream, condition);
				return ret != 0;
			}
		}

		/// <summary>/// To create a triangle mesh object it is necessary to first 'cook' the mesh data into<br/>/// a form which allows the SDK to perform efficient collision detection.<br/>/// cookConvexMesh() allows a mesh description to be cooked into a binary stream<br/>/// suitable for loading and performing collision detection at runtime.<br/>/// </summary>		public static bool PxCookConvexMesh( PxCookingParams* @params,  PxConvexMeshDesc* desc,  ref PxOutputStream stream,  Enum* condition)
		{
			fixed (PxOutputStream* pstream = &stream)
			{
				byte ret = PxCookConvexMeshNative(@params, desc, (PxOutputStream*)pstream, condition);
				return ret != 0;
			}
		}

		/// <summary>/// To create a triangle mesh object it is necessary to first 'cook' the mesh data into<br/>/// a form which allows the SDK to perform efficient collision detection.<br/>/// cookConvexMesh() allows a mesh description to be cooked into a binary stream<br/>/// suitable for loading and performing collision detection at runtime.<br/>/// </summary>		public static bool PxCookConvexMesh( PxCookingParams* @params,  ref PxConvexMeshDesc desc,  ref PxOutputStream stream,  Enum* condition)
		{
			fixed (PxConvexMeshDesc* pdesc = &desc)
			{
				fixed (PxOutputStream* pstream = &stream)
				{
					byte ret = PxCookConvexMeshNative(@params, (PxConvexMeshDesc*)pdesc, (PxOutputStream*)pstream, condition);
					return ret != 0;
				}
			}
		}

		/// <summary>/// To create a triangle mesh object it is necessary to first 'cook' the mesh data into<br/>/// a form which allows the SDK to perform efficient collision detection.<br/>/// cookConvexMesh() allows a mesh description to be cooked into a binary stream<br/>/// suitable for loading and performing collision detection at runtime.<br/>/// </summary>		public static bool PxCookConvexMesh( PxCookingParams* @params,  PxConvexMeshDesc* desc,  PxOutputStream* stream,  ref Enum condition)
		{
			fixed (Enum* pcondition = &condition)
			{
				byte ret = PxCookConvexMeshNative(@params, desc, stream, (Enum*)pcondition);
				return ret != 0;
			}
		}

		/// <summary>/// To create a triangle mesh object it is necessary to first 'cook' the mesh data into<br/>/// a form which allows the SDK to perform efficient collision detection.<br/>/// cookConvexMesh() allows a mesh description to be cooked into a binary stream<br/>/// suitable for loading and performing collision detection at runtime.<br/>/// </summary>		public static bool PxCookConvexMesh( PxCookingParams* @params,  ref PxConvexMeshDesc desc,  PxOutputStream* stream,  ref Enum condition)
		{
			fixed (PxConvexMeshDesc* pdesc = &desc)
			{
				fixed (Enum* pcondition = &condition)
				{
					byte ret = PxCookConvexMeshNative(@params, (PxConvexMeshDesc*)pdesc, stream, (Enum*)pcondition);
					return ret != 0;
				}
			}
		}

		/// <summary>/// To create a triangle mesh object it is necessary to first 'cook' the mesh data into<br/>/// a form which allows the SDK to perform efficient collision detection.<br/>/// cookConvexMesh() allows a mesh description to be cooked into a binary stream<br/>/// suitable for loading and performing collision detection at runtime.<br/>/// </summary>		public static bool PxCookConvexMesh( PxCookingParams* @params,  PxConvexMeshDesc* desc,  ref PxOutputStream stream,  ref Enum condition)
		{
			fixed (PxOutputStream* pstream = &stream)
			{
				fixed (Enum* pcondition = &condition)
				{
					byte ret = PxCookConvexMeshNative(@params, desc, (PxOutputStream*)pstream, (Enum*)pcondition);
					return ret != 0;
				}
			}
		}

		/// <summary>/// To create a triangle mesh object it is necessary to first 'cook' the mesh data into<br/>/// a form which allows the SDK to perform efficient collision detection.<br/>/// cookConvexMesh() allows a mesh description to be cooked into a binary stream<br/>/// suitable for loading and performing collision detection at runtime.<br/>/// </summary>		public static bool PxCookConvexMesh( PxCookingParams* @params,  ref PxConvexMeshDesc desc,  ref PxOutputStream stream,  ref Enum condition)
		{
			fixed (PxConvexMeshDesc* pdesc = &desc)
			{
				fixed (PxOutputStream* pstream = &stream)
				{
					fixed (Enum* pcondition = &condition)
					{
						byte ret = PxCookConvexMeshNative(@params, (PxConvexMeshDesc*)pdesc, (PxOutputStream*)pstream, (Enum*)pcondition);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxCreateConvexMesh")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial PxConvexMesh* PxCreateConvexMeshNative(PxCookingParams* @params, PxConvexMeshDesc* desc, PxInsertionCallback* insertionCallback, Enum* condition);

		/// <summary>/// </summary>		public static PxConvexMesh* PxCreateConvexMesh( PxCookingParams* @params,  PxConvexMeshDesc* desc,  PxInsertionCallback* insertionCallback,  Enum* condition)
		{
			PxConvexMesh* ret = PxCreateConvexMeshNative(@params, desc, insertionCallback, condition);
			return ret;
		}

		/// <summary>/// </summary>		public static PxConvexMesh* PxCreateConvexMesh( PxCookingParams* @params,  ref PxConvexMeshDesc desc,  PxInsertionCallback* insertionCallback,  Enum* condition)
		{
			fixed (PxConvexMeshDesc* pdesc = &desc)
			{
				PxConvexMesh* ret = PxCreateConvexMeshNative(@params, (PxConvexMeshDesc*)pdesc, insertionCallback, condition);
				return ret;
			}
		}

		/// <summary>/// </summary>		public static PxConvexMesh* PxCreateConvexMesh( PxCookingParams* @params,  PxConvexMeshDesc* desc,  ref PxInsertionCallback insertionCallback,  Enum* condition)
		{
			fixed (PxInsertionCallback* pinsertionCallback = &insertionCallback)
			{
				PxConvexMesh* ret = PxCreateConvexMeshNative(@params, desc, (PxInsertionCallback*)pinsertionCallback, condition);
				return ret;
			}
		}

		/// <summary>/// </summary>		public static PxConvexMesh* PxCreateConvexMesh( PxCookingParams* @params,  ref PxConvexMeshDesc desc,  ref PxInsertionCallback insertionCallback,  Enum* condition)
		{
			fixed (PxConvexMeshDesc* pdesc = &desc)
			{
				fixed (PxInsertionCallback* pinsertionCallback = &insertionCallback)
				{
					PxConvexMesh* ret = PxCreateConvexMeshNative(@params, (PxConvexMeshDesc*)pdesc, (PxInsertionCallback*)pinsertionCallback, condition);
					return ret;
				}
			}
		}

		/// <summary>/// </summary>		public static PxConvexMesh* PxCreateConvexMesh( PxCookingParams* @params,  PxConvexMeshDesc* desc,  PxInsertionCallback* insertionCallback,  ref Enum condition)
		{
			fixed (Enum* pcondition = &condition)
			{
				PxConvexMesh* ret = PxCreateConvexMeshNative(@params, desc, insertionCallback, (Enum*)pcondition);
				return ret;
			}
		}

		/// <summary>/// </summary>		public static PxConvexMesh* PxCreateConvexMesh( PxCookingParams* @params,  ref PxConvexMeshDesc desc,  PxInsertionCallback* insertionCallback,  ref Enum condition)
		{
			fixed (PxConvexMeshDesc* pdesc = &desc)
			{
				fixed (Enum* pcondition = &condition)
				{
					PxConvexMesh* ret = PxCreateConvexMeshNative(@params, (PxConvexMeshDesc*)pdesc, insertionCallback, (Enum*)pcondition);
					return ret;
				}
			}
		}

		/// <summary>/// </summary>		public static PxConvexMesh* PxCreateConvexMesh( PxCookingParams* @params,  PxConvexMeshDesc* desc,  ref PxInsertionCallback insertionCallback,  ref Enum condition)
		{
			fixed (PxInsertionCallback* pinsertionCallback = &insertionCallback)
			{
				fixed (Enum* pcondition = &condition)
				{
					PxConvexMesh* ret = PxCreateConvexMeshNative(@params, desc, (PxInsertionCallback*)pinsertionCallback, (Enum*)pcondition);
					return ret;
				}
			}
		}

		/// <summary>/// </summary>		public static PxConvexMesh* PxCreateConvexMesh( PxCookingParams* @params,  ref PxConvexMeshDesc desc,  ref PxInsertionCallback insertionCallback,  ref Enum condition)
		{
			fixed (PxConvexMeshDesc* pdesc = &desc)
			{
				fixed (PxInsertionCallback* pinsertionCallback = &insertionCallback)
				{
					fixed (Enum* pcondition = &condition)
					{
						PxConvexMesh* ret = PxCreateConvexMeshNative(@params, (PxConvexMeshDesc*)pdesc, (PxInsertionCallback*)pinsertionCallback, (Enum*)pcondition);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// The convex mesh descriptor must contain an already created convex mesh - the vertices, indices and polygons must be provided.	<br/>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxValidateConvexMesh")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte PxValidateConvexMeshNative(PxCookingParams* @params, PxConvexMeshDesc* desc);

		/// <summary>/// The convex mesh descriptor must contain an already created convex mesh - the vertices, indices and polygons must be provided.	<br/>/// </summary>		public static bool PxValidateConvexMesh( PxCookingParams* @params,  PxConvexMeshDesc* desc)
		{
			byte ret = PxValidateConvexMeshNative(@params, desc);
			return ret != 0;
		}

		/// <summary>/// The convex mesh descriptor must contain an already created convex mesh - the vertices, indices and polygons must be provided.	<br/>/// </summary>		public static bool PxValidateConvexMesh( PxCookingParams* @params,  ref PxConvexMeshDesc desc)
		{
			fixed (PxConvexMeshDesc* pdesc = &desc)
			{
				byte ret = PxValidateConvexMeshNative(@params, (PxConvexMeshDesc*)pdesc);
				return ret != 0;
			}
		}

		/// <summary>
		/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>
		/// The output vertices, indices and polygons must be used to construct a hull.<br/>
		/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>
		/// array's.<br/>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxComputeHullPolygons")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte PxComputeHullPolygonsNative(PxCookingParams* @params, PxSimpleTriangleMesh* mesh, PxAllocatorCallback* inCallback, uint* nbVerts, Vector3** vertices, uint* nbIndices, uint** indices, uint* nbPolygons, PxHullPolygon** hullPolygons);

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  Vector3** vertices,  uint* nbIndices,  uint** indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, nbVerts, vertices, nbIndices, indices, nbPolygons, hullPolygons);
			return ret != 0;
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  Vector3** vertices,  uint* nbIndices,  uint** indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, nbVerts, vertices, nbIndices, indices, nbPolygons, hullPolygons);
				return ret != 0;
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  Vector3** vertices,  uint* nbIndices,  uint** indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, nbVerts, vertices, nbIndices, indices, nbPolygons, hullPolygons);
				return ret != 0;
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  Vector3** vertices,  uint* nbIndices,  uint** indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, nbVerts, vertices, nbIndices, indices, nbPolygons, hullPolygons);
					return ret != 0;
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  Vector3** vertices,  uint* nbIndices,  uint** indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (uint* pnbVerts = &nbVerts)
			{
				byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, (uint*)pnbVerts, vertices, nbIndices, indices, nbPolygons, hullPolygons);
				return ret != 0;
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  Vector3** vertices,  uint* nbIndices,  uint** indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, (uint*)pnbVerts, vertices, nbIndices, indices, nbPolygons, hullPolygons);
					return ret != 0;
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  Vector3** vertices,  uint* nbIndices,  uint** indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, vertices, nbIndices, indices, nbPolygons, hullPolygons);
					return ret != 0;
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  Vector3** vertices,  uint* nbIndices,  uint** indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (uint* pnbVerts = &nbVerts)
					{
						byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, vertices, nbIndices, indices, nbPolygons, hullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  ref Vector3 vertices,  uint* nbIndices,  uint** indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (Vector3* pvertices = &vertices)
			{
				byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, nbVerts, (Vector3**)pvertices, nbIndices, indices, nbPolygons, hullPolygons);
				return ret != 0;
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  ref Vector3 vertices,  uint* nbIndices,  uint** indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (Vector3* pvertices = &vertices)
				{
					byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, nbVerts, (Vector3**)pvertices, nbIndices, indices, nbPolygons, hullPolygons);
					return ret != 0;
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  ref Vector3 vertices,  uint* nbIndices,  uint** indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (Vector3* pvertices = &vertices)
				{
					byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, nbVerts, (Vector3**)pvertices, nbIndices, indices, nbPolygons, hullPolygons);
					return ret != 0;
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  ref Vector3 vertices,  uint* nbIndices,  uint** indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (Vector3* pvertices = &vertices)
					{
						byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, nbVerts, (Vector3**)pvertices, nbIndices, indices, nbPolygons, hullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  ref Vector3 vertices,  uint* nbIndices,  uint** indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (uint* pnbVerts = &nbVerts)
			{
				fixed (Vector3* pvertices = &vertices)
				{
					byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, (uint*)pnbVerts, (Vector3**)pvertices, nbIndices, indices, nbPolygons, hullPolygons);
					return ret != 0;
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  ref Vector3 vertices,  uint* nbIndices,  uint** indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (Vector3* pvertices = &vertices)
					{
						byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, (uint*)pnbVerts, (Vector3**)pvertices, nbIndices, indices, nbPolygons, hullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  ref Vector3 vertices,  uint* nbIndices,  uint** indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (Vector3* pvertices = &vertices)
					{
						byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, (Vector3**)pvertices, nbIndices, indices, nbPolygons, hullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  ref Vector3 vertices,  uint* nbIndices,  uint** indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (uint* pnbVerts = &nbVerts)
					{
						fixed (Vector3* pvertices = &vertices)
						{
							byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, (Vector3**)pvertices, nbIndices, indices, nbPolygons, hullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  Vector3** vertices,  ref uint nbIndices,  uint** indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (uint* pnbIndices = &nbIndices)
			{
				byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, nbVerts, vertices, (uint*)pnbIndices, indices, nbPolygons, hullPolygons);
				return ret != 0;
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  Vector3** vertices,  ref uint nbIndices,  uint** indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (uint* pnbIndices = &nbIndices)
				{
					byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, nbVerts, vertices, (uint*)pnbIndices, indices, nbPolygons, hullPolygons);
					return ret != 0;
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  Vector3** vertices,  ref uint nbIndices,  uint** indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (uint* pnbIndices = &nbIndices)
				{
					byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, nbVerts, vertices, (uint*)pnbIndices, indices, nbPolygons, hullPolygons);
					return ret != 0;
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  Vector3** vertices,  ref uint nbIndices,  uint** indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (uint* pnbIndices = &nbIndices)
					{
						byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, nbVerts, vertices, (uint*)pnbIndices, indices, nbPolygons, hullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  Vector3** vertices,  ref uint nbIndices,  uint** indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (uint* pnbVerts = &nbVerts)
			{
				fixed (uint* pnbIndices = &nbIndices)
				{
					byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, (uint*)pnbVerts, vertices, (uint*)pnbIndices, indices, nbPolygons, hullPolygons);
					return ret != 0;
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  Vector3** vertices,  ref uint nbIndices,  uint** indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (uint* pnbIndices = &nbIndices)
					{
						byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, (uint*)pnbVerts, vertices, (uint*)pnbIndices, indices, nbPolygons, hullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  Vector3** vertices,  ref uint nbIndices,  uint** indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (uint* pnbIndices = &nbIndices)
					{
						byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, vertices, (uint*)pnbIndices, indices, nbPolygons, hullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  Vector3** vertices,  ref uint nbIndices,  uint** indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (uint* pnbVerts = &nbVerts)
					{
						fixed (uint* pnbIndices = &nbIndices)
						{
							byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, vertices, (uint*)pnbIndices, indices, nbPolygons, hullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  uint** indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (Vector3* pvertices = &vertices)
			{
				fixed (uint* pnbIndices = &nbIndices)
				{
					byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, nbVerts, (Vector3**)pvertices, (uint*)pnbIndices, indices, nbPolygons, hullPolygons);
					return ret != 0;
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  uint** indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (Vector3* pvertices = &vertices)
				{
					fixed (uint* pnbIndices = &nbIndices)
					{
						byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, nbVerts, (Vector3**)pvertices, (uint*)pnbIndices, indices, nbPolygons, hullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  uint** indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (Vector3* pvertices = &vertices)
				{
					fixed (uint* pnbIndices = &nbIndices)
					{
						byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, nbVerts, (Vector3**)pvertices, (uint*)pnbIndices, indices, nbPolygons, hullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  uint** indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (Vector3* pvertices = &vertices)
					{
						fixed (uint* pnbIndices = &nbIndices)
						{
							byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, nbVerts, (Vector3**)pvertices, (uint*)pnbIndices, indices, nbPolygons, hullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  uint** indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (uint* pnbVerts = &nbVerts)
			{
				fixed (Vector3* pvertices = &vertices)
				{
					fixed (uint* pnbIndices = &nbIndices)
					{
						byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, (uint*)pnbVerts, (Vector3**)pvertices, (uint*)pnbIndices, indices, nbPolygons, hullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  uint** indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (Vector3* pvertices = &vertices)
					{
						fixed (uint* pnbIndices = &nbIndices)
						{
							byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, (uint*)pnbVerts, (Vector3**)pvertices, (uint*)pnbIndices, indices, nbPolygons, hullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  uint** indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (Vector3* pvertices = &vertices)
					{
						fixed (uint* pnbIndices = &nbIndices)
						{
							byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, (Vector3**)pvertices, (uint*)pnbIndices, indices, nbPolygons, hullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  uint** indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (uint* pnbVerts = &nbVerts)
					{
						fixed (Vector3* pvertices = &vertices)
						{
							fixed (uint* pnbIndices = &nbIndices)
							{
								byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, (Vector3**)pvertices, (uint*)pnbIndices, indices, nbPolygons, hullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  Vector3** vertices,  uint* nbIndices,  ref uint indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (uint* pindices = &indices)
			{
				byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, nbVerts, vertices, nbIndices, (uint**)pindices, nbPolygons, hullPolygons);
				return ret != 0;
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  Vector3** vertices,  uint* nbIndices,  ref uint indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (uint* pindices = &indices)
				{
					byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, nbVerts, vertices, nbIndices, (uint**)pindices, nbPolygons, hullPolygons);
					return ret != 0;
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  Vector3** vertices,  uint* nbIndices,  ref uint indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (uint* pindices = &indices)
				{
					byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, nbVerts, vertices, nbIndices, (uint**)pindices, nbPolygons, hullPolygons);
					return ret != 0;
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  Vector3** vertices,  uint* nbIndices,  ref uint indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (uint* pindices = &indices)
					{
						byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, nbVerts, vertices, nbIndices, (uint**)pindices, nbPolygons, hullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  Vector3** vertices,  uint* nbIndices,  ref uint indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (uint* pnbVerts = &nbVerts)
			{
				fixed (uint* pindices = &indices)
				{
					byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, (uint*)pnbVerts, vertices, nbIndices, (uint**)pindices, nbPolygons, hullPolygons);
					return ret != 0;
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  Vector3** vertices,  uint* nbIndices,  ref uint indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (uint* pindices = &indices)
					{
						byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, (uint*)pnbVerts, vertices, nbIndices, (uint**)pindices, nbPolygons, hullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  Vector3** vertices,  uint* nbIndices,  ref uint indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (uint* pindices = &indices)
					{
						byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, vertices, nbIndices, (uint**)pindices, nbPolygons, hullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  Vector3** vertices,  uint* nbIndices,  ref uint indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (uint* pnbVerts = &nbVerts)
					{
						fixed (uint* pindices = &indices)
						{
							byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, vertices, nbIndices, (uint**)pindices, nbPolygons, hullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  ref Vector3 vertices,  uint* nbIndices,  ref uint indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (Vector3* pvertices = &vertices)
			{
				fixed (uint* pindices = &indices)
				{
					byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, nbVerts, (Vector3**)pvertices, nbIndices, (uint**)pindices, nbPolygons, hullPolygons);
					return ret != 0;
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  ref Vector3 vertices,  uint* nbIndices,  ref uint indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (Vector3* pvertices = &vertices)
				{
					fixed (uint* pindices = &indices)
					{
						byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, nbVerts, (Vector3**)pvertices, nbIndices, (uint**)pindices, nbPolygons, hullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  ref Vector3 vertices,  uint* nbIndices,  ref uint indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (Vector3* pvertices = &vertices)
				{
					fixed (uint* pindices = &indices)
					{
						byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, nbVerts, (Vector3**)pvertices, nbIndices, (uint**)pindices, nbPolygons, hullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  ref Vector3 vertices,  uint* nbIndices,  ref uint indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (Vector3* pvertices = &vertices)
					{
						fixed (uint* pindices = &indices)
						{
							byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, nbVerts, (Vector3**)pvertices, nbIndices, (uint**)pindices, nbPolygons, hullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  ref Vector3 vertices,  uint* nbIndices,  ref uint indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (uint* pnbVerts = &nbVerts)
			{
				fixed (Vector3* pvertices = &vertices)
				{
					fixed (uint* pindices = &indices)
					{
						byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, (uint*)pnbVerts, (Vector3**)pvertices, nbIndices, (uint**)pindices, nbPolygons, hullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  ref Vector3 vertices,  uint* nbIndices,  ref uint indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (Vector3* pvertices = &vertices)
					{
						fixed (uint* pindices = &indices)
						{
							byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, (uint*)pnbVerts, (Vector3**)pvertices, nbIndices, (uint**)pindices, nbPolygons, hullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  ref Vector3 vertices,  uint* nbIndices,  ref uint indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (Vector3* pvertices = &vertices)
					{
						fixed (uint* pindices = &indices)
						{
							byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, (Vector3**)pvertices, nbIndices, (uint**)pindices, nbPolygons, hullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  ref Vector3 vertices,  uint* nbIndices,  ref uint indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (uint* pnbVerts = &nbVerts)
					{
						fixed (Vector3* pvertices = &vertices)
						{
							fixed (uint* pindices = &indices)
							{
								byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, (Vector3**)pvertices, nbIndices, (uint**)pindices, nbPolygons, hullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  Vector3** vertices,  ref uint nbIndices,  ref uint indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (uint* pnbIndices = &nbIndices)
			{
				fixed (uint* pindices = &indices)
				{
					byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, nbVerts, vertices, (uint*)pnbIndices, (uint**)pindices, nbPolygons, hullPolygons);
					return ret != 0;
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  Vector3** vertices,  ref uint nbIndices,  ref uint indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (uint* pnbIndices = &nbIndices)
				{
					fixed (uint* pindices = &indices)
					{
						byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, nbVerts, vertices, (uint*)pnbIndices, (uint**)pindices, nbPolygons, hullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  Vector3** vertices,  ref uint nbIndices,  ref uint indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (uint* pnbIndices = &nbIndices)
				{
					fixed (uint* pindices = &indices)
					{
						byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, nbVerts, vertices, (uint*)pnbIndices, (uint**)pindices, nbPolygons, hullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  Vector3** vertices,  ref uint nbIndices,  ref uint indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (uint* pnbIndices = &nbIndices)
					{
						fixed (uint* pindices = &indices)
						{
							byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, nbVerts, vertices, (uint*)pnbIndices, (uint**)pindices, nbPolygons, hullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  Vector3** vertices,  ref uint nbIndices,  ref uint indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (uint* pnbVerts = &nbVerts)
			{
				fixed (uint* pnbIndices = &nbIndices)
				{
					fixed (uint* pindices = &indices)
					{
						byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, (uint*)pnbVerts, vertices, (uint*)pnbIndices, (uint**)pindices, nbPolygons, hullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  Vector3** vertices,  ref uint nbIndices,  ref uint indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (uint* pnbIndices = &nbIndices)
					{
						fixed (uint* pindices = &indices)
						{
							byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, (uint*)pnbVerts, vertices, (uint*)pnbIndices, (uint**)pindices, nbPolygons, hullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  Vector3** vertices,  ref uint nbIndices,  ref uint indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (uint* pnbIndices = &nbIndices)
					{
						fixed (uint* pindices = &indices)
						{
							byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, vertices, (uint*)pnbIndices, (uint**)pindices, nbPolygons, hullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  Vector3** vertices,  ref uint nbIndices,  ref uint indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (uint* pnbVerts = &nbVerts)
					{
						fixed (uint* pnbIndices = &nbIndices)
						{
							fixed (uint* pindices = &indices)
							{
								byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, vertices, (uint*)pnbIndices, (uint**)pindices, nbPolygons, hullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  ref uint indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (Vector3* pvertices = &vertices)
			{
				fixed (uint* pnbIndices = &nbIndices)
				{
					fixed (uint* pindices = &indices)
					{
						byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, nbVerts, (Vector3**)pvertices, (uint*)pnbIndices, (uint**)pindices, nbPolygons, hullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  ref uint indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (Vector3* pvertices = &vertices)
				{
					fixed (uint* pnbIndices = &nbIndices)
					{
						fixed (uint* pindices = &indices)
						{
							byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, nbVerts, (Vector3**)pvertices, (uint*)pnbIndices, (uint**)pindices, nbPolygons, hullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  ref uint indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (Vector3* pvertices = &vertices)
				{
					fixed (uint* pnbIndices = &nbIndices)
					{
						fixed (uint* pindices = &indices)
						{
							byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, nbVerts, (Vector3**)pvertices, (uint*)pnbIndices, (uint**)pindices, nbPolygons, hullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  ref uint indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (Vector3* pvertices = &vertices)
					{
						fixed (uint* pnbIndices = &nbIndices)
						{
							fixed (uint* pindices = &indices)
							{
								byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, nbVerts, (Vector3**)pvertices, (uint*)pnbIndices, (uint**)pindices, nbPolygons, hullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  ref uint indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (uint* pnbVerts = &nbVerts)
			{
				fixed (Vector3* pvertices = &vertices)
				{
					fixed (uint* pnbIndices = &nbIndices)
					{
						fixed (uint* pindices = &indices)
						{
							byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, (uint*)pnbVerts, (Vector3**)pvertices, (uint*)pnbIndices, (uint**)pindices, nbPolygons, hullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  ref uint indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (Vector3* pvertices = &vertices)
					{
						fixed (uint* pnbIndices = &nbIndices)
						{
							fixed (uint* pindices = &indices)
							{
								byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, (uint*)pnbVerts, (Vector3**)pvertices, (uint*)pnbIndices, (uint**)pindices, nbPolygons, hullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  ref uint indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (Vector3* pvertices = &vertices)
					{
						fixed (uint* pnbIndices = &nbIndices)
						{
							fixed (uint* pindices = &indices)
							{
								byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, (Vector3**)pvertices, (uint*)pnbIndices, (uint**)pindices, nbPolygons, hullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  ref uint indices,  uint* nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (uint* pnbVerts = &nbVerts)
					{
						fixed (Vector3* pvertices = &vertices)
						{
							fixed (uint* pnbIndices = &nbIndices)
							{
								fixed (uint* pindices = &indices)
								{
									byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, (Vector3**)pvertices, (uint*)pnbIndices, (uint**)pindices, nbPolygons, hullPolygons);
									return ret != 0;
								}
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  Vector3** vertices,  uint* nbIndices,  uint** indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (uint* pnbPolygons = &nbPolygons)
			{
				byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, nbVerts, vertices, nbIndices, indices, (uint*)pnbPolygons, hullPolygons);
				return ret != 0;
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  Vector3** vertices,  uint* nbIndices,  uint** indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (uint* pnbPolygons = &nbPolygons)
				{
					byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, nbVerts, vertices, nbIndices, indices, (uint*)pnbPolygons, hullPolygons);
					return ret != 0;
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  Vector3** vertices,  uint* nbIndices,  uint** indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (uint* pnbPolygons = &nbPolygons)
				{
					byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, nbVerts, vertices, nbIndices, indices, (uint*)pnbPolygons, hullPolygons);
					return ret != 0;
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  Vector3** vertices,  uint* nbIndices,  uint** indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (uint* pnbPolygons = &nbPolygons)
					{
						byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, nbVerts, vertices, nbIndices, indices, (uint*)pnbPolygons, hullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  Vector3** vertices,  uint* nbIndices,  uint** indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (uint* pnbVerts = &nbVerts)
			{
				fixed (uint* pnbPolygons = &nbPolygons)
				{
					byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, (uint*)pnbVerts, vertices, nbIndices, indices, (uint*)pnbPolygons, hullPolygons);
					return ret != 0;
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  Vector3** vertices,  uint* nbIndices,  uint** indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (uint* pnbPolygons = &nbPolygons)
					{
						byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, (uint*)pnbVerts, vertices, nbIndices, indices, (uint*)pnbPolygons, hullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  Vector3** vertices,  uint* nbIndices,  uint** indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (uint* pnbPolygons = &nbPolygons)
					{
						byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, vertices, nbIndices, indices, (uint*)pnbPolygons, hullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  Vector3** vertices,  uint* nbIndices,  uint** indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (uint* pnbVerts = &nbVerts)
					{
						fixed (uint* pnbPolygons = &nbPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, vertices, nbIndices, indices, (uint*)pnbPolygons, hullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  ref Vector3 vertices,  uint* nbIndices,  uint** indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (Vector3* pvertices = &vertices)
			{
				fixed (uint* pnbPolygons = &nbPolygons)
				{
					byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, nbVerts, (Vector3**)pvertices, nbIndices, indices, (uint*)pnbPolygons, hullPolygons);
					return ret != 0;
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  ref Vector3 vertices,  uint* nbIndices,  uint** indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (Vector3* pvertices = &vertices)
				{
					fixed (uint* pnbPolygons = &nbPolygons)
					{
						byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, nbVerts, (Vector3**)pvertices, nbIndices, indices, (uint*)pnbPolygons, hullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  ref Vector3 vertices,  uint* nbIndices,  uint** indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (Vector3* pvertices = &vertices)
				{
					fixed (uint* pnbPolygons = &nbPolygons)
					{
						byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, nbVerts, (Vector3**)pvertices, nbIndices, indices, (uint*)pnbPolygons, hullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  ref Vector3 vertices,  uint* nbIndices,  uint** indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (Vector3* pvertices = &vertices)
					{
						fixed (uint* pnbPolygons = &nbPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, nbVerts, (Vector3**)pvertices, nbIndices, indices, (uint*)pnbPolygons, hullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  ref Vector3 vertices,  uint* nbIndices,  uint** indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (uint* pnbVerts = &nbVerts)
			{
				fixed (Vector3* pvertices = &vertices)
				{
					fixed (uint* pnbPolygons = &nbPolygons)
					{
						byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, (uint*)pnbVerts, (Vector3**)pvertices, nbIndices, indices, (uint*)pnbPolygons, hullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  ref Vector3 vertices,  uint* nbIndices,  uint** indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (Vector3* pvertices = &vertices)
					{
						fixed (uint* pnbPolygons = &nbPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, (uint*)pnbVerts, (Vector3**)pvertices, nbIndices, indices, (uint*)pnbPolygons, hullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  ref Vector3 vertices,  uint* nbIndices,  uint** indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (Vector3* pvertices = &vertices)
					{
						fixed (uint* pnbPolygons = &nbPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, (Vector3**)pvertices, nbIndices, indices, (uint*)pnbPolygons, hullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  ref Vector3 vertices,  uint* nbIndices,  uint** indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (uint* pnbVerts = &nbVerts)
					{
						fixed (Vector3* pvertices = &vertices)
						{
							fixed (uint* pnbPolygons = &nbPolygons)
							{
								byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, (Vector3**)pvertices, nbIndices, indices, (uint*)pnbPolygons, hullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  Vector3** vertices,  ref uint nbIndices,  uint** indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (uint* pnbIndices = &nbIndices)
			{
				fixed (uint* pnbPolygons = &nbPolygons)
				{
					byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, nbVerts, vertices, (uint*)pnbIndices, indices, (uint*)pnbPolygons, hullPolygons);
					return ret != 0;
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  Vector3** vertices,  ref uint nbIndices,  uint** indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (uint* pnbIndices = &nbIndices)
				{
					fixed (uint* pnbPolygons = &nbPolygons)
					{
						byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, nbVerts, vertices, (uint*)pnbIndices, indices, (uint*)pnbPolygons, hullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  Vector3** vertices,  ref uint nbIndices,  uint** indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (uint* pnbIndices = &nbIndices)
				{
					fixed (uint* pnbPolygons = &nbPolygons)
					{
						byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, nbVerts, vertices, (uint*)pnbIndices, indices, (uint*)pnbPolygons, hullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  Vector3** vertices,  ref uint nbIndices,  uint** indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (uint* pnbIndices = &nbIndices)
					{
						fixed (uint* pnbPolygons = &nbPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, nbVerts, vertices, (uint*)pnbIndices, indices, (uint*)pnbPolygons, hullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  Vector3** vertices,  ref uint nbIndices,  uint** indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (uint* pnbVerts = &nbVerts)
			{
				fixed (uint* pnbIndices = &nbIndices)
				{
					fixed (uint* pnbPolygons = &nbPolygons)
					{
						byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, (uint*)pnbVerts, vertices, (uint*)pnbIndices, indices, (uint*)pnbPolygons, hullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  Vector3** vertices,  ref uint nbIndices,  uint** indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (uint* pnbIndices = &nbIndices)
					{
						fixed (uint* pnbPolygons = &nbPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, (uint*)pnbVerts, vertices, (uint*)pnbIndices, indices, (uint*)pnbPolygons, hullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  Vector3** vertices,  ref uint nbIndices,  uint** indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (uint* pnbIndices = &nbIndices)
					{
						fixed (uint* pnbPolygons = &nbPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, vertices, (uint*)pnbIndices, indices, (uint*)pnbPolygons, hullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  Vector3** vertices,  ref uint nbIndices,  uint** indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (uint* pnbVerts = &nbVerts)
					{
						fixed (uint* pnbIndices = &nbIndices)
						{
							fixed (uint* pnbPolygons = &nbPolygons)
							{
								byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, vertices, (uint*)pnbIndices, indices, (uint*)pnbPolygons, hullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  uint** indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (Vector3* pvertices = &vertices)
			{
				fixed (uint* pnbIndices = &nbIndices)
				{
					fixed (uint* pnbPolygons = &nbPolygons)
					{
						byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, nbVerts, (Vector3**)pvertices, (uint*)pnbIndices, indices, (uint*)pnbPolygons, hullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  uint** indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (Vector3* pvertices = &vertices)
				{
					fixed (uint* pnbIndices = &nbIndices)
					{
						fixed (uint* pnbPolygons = &nbPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, nbVerts, (Vector3**)pvertices, (uint*)pnbIndices, indices, (uint*)pnbPolygons, hullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  uint** indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (Vector3* pvertices = &vertices)
				{
					fixed (uint* pnbIndices = &nbIndices)
					{
						fixed (uint* pnbPolygons = &nbPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, nbVerts, (Vector3**)pvertices, (uint*)pnbIndices, indices, (uint*)pnbPolygons, hullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  uint** indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (Vector3* pvertices = &vertices)
					{
						fixed (uint* pnbIndices = &nbIndices)
						{
							fixed (uint* pnbPolygons = &nbPolygons)
							{
								byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, nbVerts, (Vector3**)pvertices, (uint*)pnbIndices, indices, (uint*)pnbPolygons, hullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  uint** indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (uint* pnbVerts = &nbVerts)
			{
				fixed (Vector3* pvertices = &vertices)
				{
					fixed (uint* pnbIndices = &nbIndices)
					{
						fixed (uint* pnbPolygons = &nbPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, (uint*)pnbVerts, (Vector3**)pvertices, (uint*)pnbIndices, indices, (uint*)pnbPolygons, hullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  uint** indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (Vector3* pvertices = &vertices)
					{
						fixed (uint* pnbIndices = &nbIndices)
						{
							fixed (uint* pnbPolygons = &nbPolygons)
							{
								byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, (uint*)pnbVerts, (Vector3**)pvertices, (uint*)pnbIndices, indices, (uint*)pnbPolygons, hullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  uint** indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (Vector3* pvertices = &vertices)
					{
						fixed (uint* pnbIndices = &nbIndices)
						{
							fixed (uint* pnbPolygons = &nbPolygons)
							{
								byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, (Vector3**)pvertices, (uint*)pnbIndices, indices, (uint*)pnbPolygons, hullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  uint** indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (uint* pnbVerts = &nbVerts)
					{
						fixed (Vector3* pvertices = &vertices)
						{
							fixed (uint* pnbIndices = &nbIndices)
							{
								fixed (uint* pnbPolygons = &nbPolygons)
								{
									byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, (Vector3**)pvertices, (uint*)pnbIndices, indices, (uint*)pnbPolygons, hullPolygons);
									return ret != 0;
								}
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  Vector3** vertices,  uint* nbIndices,  ref uint indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (uint* pindices = &indices)
			{
				fixed (uint* pnbPolygons = &nbPolygons)
				{
					byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, nbVerts, vertices, nbIndices, (uint**)pindices, (uint*)pnbPolygons, hullPolygons);
					return ret != 0;
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  Vector3** vertices,  uint* nbIndices,  ref uint indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (uint* pindices = &indices)
				{
					fixed (uint* pnbPolygons = &nbPolygons)
					{
						byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, nbVerts, vertices, nbIndices, (uint**)pindices, (uint*)pnbPolygons, hullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  Vector3** vertices,  uint* nbIndices,  ref uint indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (uint* pindices = &indices)
				{
					fixed (uint* pnbPolygons = &nbPolygons)
					{
						byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, nbVerts, vertices, nbIndices, (uint**)pindices, (uint*)pnbPolygons, hullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  Vector3** vertices,  uint* nbIndices,  ref uint indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (uint* pindices = &indices)
					{
						fixed (uint* pnbPolygons = &nbPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, nbVerts, vertices, nbIndices, (uint**)pindices, (uint*)pnbPolygons, hullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  Vector3** vertices,  uint* nbIndices,  ref uint indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (uint* pnbVerts = &nbVerts)
			{
				fixed (uint* pindices = &indices)
				{
					fixed (uint* pnbPolygons = &nbPolygons)
					{
						byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, (uint*)pnbVerts, vertices, nbIndices, (uint**)pindices, (uint*)pnbPolygons, hullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  Vector3** vertices,  uint* nbIndices,  ref uint indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (uint* pindices = &indices)
					{
						fixed (uint* pnbPolygons = &nbPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, (uint*)pnbVerts, vertices, nbIndices, (uint**)pindices, (uint*)pnbPolygons, hullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  Vector3** vertices,  uint* nbIndices,  ref uint indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (uint* pindices = &indices)
					{
						fixed (uint* pnbPolygons = &nbPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, vertices, nbIndices, (uint**)pindices, (uint*)pnbPolygons, hullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  Vector3** vertices,  uint* nbIndices,  ref uint indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (uint* pnbVerts = &nbVerts)
					{
						fixed (uint* pindices = &indices)
						{
							fixed (uint* pnbPolygons = &nbPolygons)
							{
								byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, vertices, nbIndices, (uint**)pindices, (uint*)pnbPolygons, hullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  ref Vector3 vertices,  uint* nbIndices,  ref uint indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (Vector3* pvertices = &vertices)
			{
				fixed (uint* pindices = &indices)
				{
					fixed (uint* pnbPolygons = &nbPolygons)
					{
						byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, nbVerts, (Vector3**)pvertices, nbIndices, (uint**)pindices, (uint*)pnbPolygons, hullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  ref Vector3 vertices,  uint* nbIndices,  ref uint indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (Vector3* pvertices = &vertices)
				{
					fixed (uint* pindices = &indices)
					{
						fixed (uint* pnbPolygons = &nbPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, nbVerts, (Vector3**)pvertices, nbIndices, (uint**)pindices, (uint*)pnbPolygons, hullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  ref Vector3 vertices,  uint* nbIndices,  ref uint indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (Vector3* pvertices = &vertices)
				{
					fixed (uint* pindices = &indices)
					{
						fixed (uint* pnbPolygons = &nbPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, nbVerts, (Vector3**)pvertices, nbIndices, (uint**)pindices, (uint*)pnbPolygons, hullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  ref Vector3 vertices,  uint* nbIndices,  ref uint indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (Vector3* pvertices = &vertices)
					{
						fixed (uint* pindices = &indices)
						{
							fixed (uint* pnbPolygons = &nbPolygons)
							{
								byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, nbVerts, (Vector3**)pvertices, nbIndices, (uint**)pindices, (uint*)pnbPolygons, hullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  ref Vector3 vertices,  uint* nbIndices,  ref uint indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (uint* pnbVerts = &nbVerts)
			{
				fixed (Vector3* pvertices = &vertices)
				{
					fixed (uint* pindices = &indices)
					{
						fixed (uint* pnbPolygons = &nbPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, (uint*)pnbVerts, (Vector3**)pvertices, nbIndices, (uint**)pindices, (uint*)pnbPolygons, hullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  ref Vector3 vertices,  uint* nbIndices,  ref uint indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (Vector3* pvertices = &vertices)
					{
						fixed (uint* pindices = &indices)
						{
							fixed (uint* pnbPolygons = &nbPolygons)
							{
								byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, (uint*)pnbVerts, (Vector3**)pvertices, nbIndices, (uint**)pindices, (uint*)pnbPolygons, hullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  ref Vector3 vertices,  uint* nbIndices,  ref uint indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (Vector3* pvertices = &vertices)
					{
						fixed (uint* pindices = &indices)
						{
							fixed (uint* pnbPolygons = &nbPolygons)
							{
								byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, (Vector3**)pvertices, nbIndices, (uint**)pindices, (uint*)pnbPolygons, hullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  ref Vector3 vertices,  uint* nbIndices,  ref uint indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (uint* pnbVerts = &nbVerts)
					{
						fixed (Vector3* pvertices = &vertices)
						{
							fixed (uint* pindices = &indices)
							{
								fixed (uint* pnbPolygons = &nbPolygons)
								{
									byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, (Vector3**)pvertices, nbIndices, (uint**)pindices, (uint*)pnbPolygons, hullPolygons);
									return ret != 0;
								}
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  Vector3** vertices,  ref uint nbIndices,  ref uint indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (uint* pnbIndices = &nbIndices)
			{
				fixed (uint* pindices = &indices)
				{
					fixed (uint* pnbPolygons = &nbPolygons)
					{
						byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, nbVerts, vertices, (uint*)pnbIndices, (uint**)pindices, (uint*)pnbPolygons, hullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  Vector3** vertices,  ref uint nbIndices,  ref uint indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (uint* pnbIndices = &nbIndices)
				{
					fixed (uint* pindices = &indices)
					{
						fixed (uint* pnbPolygons = &nbPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, nbVerts, vertices, (uint*)pnbIndices, (uint**)pindices, (uint*)pnbPolygons, hullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  Vector3** vertices,  ref uint nbIndices,  ref uint indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (uint* pnbIndices = &nbIndices)
				{
					fixed (uint* pindices = &indices)
					{
						fixed (uint* pnbPolygons = &nbPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, nbVerts, vertices, (uint*)pnbIndices, (uint**)pindices, (uint*)pnbPolygons, hullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  Vector3** vertices,  ref uint nbIndices,  ref uint indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (uint* pnbIndices = &nbIndices)
					{
						fixed (uint* pindices = &indices)
						{
							fixed (uint* pnbPolygons = &nbPolygons)
							{
								byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, nbVerts, vertices, (uint*)pnbIndices, (uint**)pindices, (uint*)pnbPolygons, hullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  Vector3** vertices,  ref uint nbIndices,  ref uint indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (uint* pnbVerts = &nbVerts)
			{
				fixed (uint* pnbIndices = &nbIndices)
				{
					fixed (uint* pindices = &indices)
					{
						fixed (uint* pnbPolygons = &nbPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, (uint*)pnbVerts, vertices, (uint*)pnbIndices, (uint**)pindices, (uint*)pnbPolygons, hullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  Vector3** vertices,  ref uint nbIndices,  ref uint indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (uint* pnbIndices = &nbIndices)
					{
						fixed (uint* pindices = &indices)
						{
							fixed (uint* pnbPolygons = &nbPolygons)
							{
								byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, (uint*)pnbVerts, vertices, (uint*)pnbIndices, (uint**)pindices, (uint*)pnbPolygons, hullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  Vector3** vertices,  ref uint nbIndices,  ref uint indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (uint* pnbIndices = &nbIndices)
					{
						fixed (uint* pindices = &indices)
						{
							fixed (uint* pnbPolygons = &nbPolygons)
							{
								byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, vertices, (uint*)pnbIndices, (uint**)pindices, (uint*)pnbPolygons, hullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  Vector3** vertices,  ref uint nbIndices,  ref uint indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (uint* pnbVerts = &nbVerts)
					{
						fixed (uint* pnbIndices = &nbIndices)
						{
							fixed (uint* pindices = &indices)
							{
								fixed (uint* pnbPolygons = &nbPolygons)
								{
									byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, vertices, (uint*)pnbIndices, (uint**)pindices, (uint*)pnbPolygons, hullPolygons);
									return ret != 0;
								}
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  ref uint indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (Vector3* pvertices = &vertices)
			{
				fixed (uint* pnbIndices = &nbIndices)
				{
					fixed (uint* pindices = &indices)
					{
						fixed (uint* pnbPolygons = &nbPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, nbVerts, (Vector3**)pvertices, (uint*)pnbIndices, (uint**)pindices, (uint*)pnbPolygons, hullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  ref uint indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (Vector3* pvertices = &vertices)
				{
					fixed (uint* pnbIndices = &nbIndices)
					{
						fixed (uint* pindices = &indices)
						{
							fixed (uint* pnbPolygons = &nbPolygons)
							{
								byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, nbVerts, (Vector3**)pvertices, (uint*)pnbIndices, (uint**)pindices, (uint*)pnbPolygons, hullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  ref uint indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (Vector3* pvertices = &vertices)
				{
					fixed (uint* pnbIndices = &nbIndices)
					{
						fixed (uint* pindices = &indices)
						{
							fixed (uint* pnbPolygons = &nbPolygons)
							{
								byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, nbVerts, (Vector3**)pvertices, (uint*)pnbIndices, (uint**)pindices, (uint*)pnbPolygons, hullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  ref uint indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (Vector3* pvertices = &vertices)
					{
						fixed (uint* pnbIndices = &nbIndices)
						{
							fixed (uint* pindices = &indices)
							{
								fixed (uint* pnbPolygons = &nbPolygons)
								{
									byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, nbVerts, (Vector3**)pvertices, (uint*)pnbIndices, (uint**)pindices, (uint*)pnbPolygons, hullPolygons);
									return ret != 0;
								}
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  ref uint indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (uint* pnbVerts = &nbVerts)
			{
				fixed (Vector3* pvertices = &vertices)
				{
					fixed (uint* pnbIndices = &nbIndices)
					{
						fixed (uint* pindices = &indices)
						{
							fixed (uint* pnbPolygons = &nbPolygons)
							{
								byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, (uint*)pnbVerts, (Vector3**)pvertices, (uint*)pnbIndices, (uint**)pindices, (uint*)pnbPolygons, hullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  ref uint indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (Vector3* pvertices = &vertices)
					{
						fixed (uint* pnbIndices = &nbIndices)
						{
							fixed (uint* pindices = &indices)
							{
								fixed (uint* pnbPolygons = &nbPolygons)
								{
									byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, (uint*)pnbVerts, (Vector3**)pvertices, (uint*)pnbIndices, (uint**)pindices, (uint*)pnbPolygons, hullPolygons);
									return ret != 0;
								}
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  ref uint indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (Vector3* pvertices = &vertices)
					{
						fixed (uint* pnbIndices = &nbIndices)
						{
							fixed (uint* pindices = &indices)
							{
								fixed (uint* pnbPolygons = &nbPolygons)
								{
									byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, (Vector3**)pvertices, (uint*)pnbIndices, (uint**)pindices, (uint*)pnbPolygons, hullPolygons);
									return ret != 0;
								}
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  ref uint indices,  ref uint nbPolygons,  PxHullPolygon** hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (uint* pnbVerts = &nbVerts)
					{
						fixed (Vector3* pvertices = &vertices)
						{
							fixed (uint* pnbIndices = &nbIndices)
							{
								fixed (uint* pindices = &indices)
								{
									fixed (uint* pnbPolygons = &nbPolygons)
									{
										byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, (Vector3**)pvertices, (uint*)pnbIndices, (uint**)pindices, (uint*)pnbPolygons, hullPolygons);
										return ret != 0;
									}
								}
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  Vector3** vertices,  uint* nbIndices,  uint** indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxHullPolygon* phullPolygons = &hullPolygons)
			{
				byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, nbVerts, vertices, nbIndices, indices, nbPolygons, (PxHullPolygon**)phullPolygons);
				return ret != 0;
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  Vector3** vertices,  uint* nbIndices,  uint** indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxHullPolygon* phullPolygons = &hullPolygons)
				{
					byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, nbVerts, vertices, nbIndices, indices, nbPolygons, (PxHullPolygon**)phullPolygons);
					return ret != 0;
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  Vector3** vertices,  uint* nbIndices,  uint** indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (PxHullPolygon* phullPolygons = &hullPolygons)
				{
					byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, nbVerts, vertices, nbIndices, indices, nbPolygons, (PxHullPolygon**)phullPolygons);
					return ret != 0;
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  Vector3** vertices,  uint* nbIndices,  uint** indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (PxHullPolygon* phullPolygons = &hullPolygons)
					{
						byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, nbVerts, vertices, nbIndices, indices, nbPolygons, (PxHullPolygon**)phullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  Vector3** vertices,  uint* nbIndices,  uint** indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (uint* pnbVerts = &nbVerts)
			{
				fixed (PxHullPolygon* phullPolygons = &hullPolygons)
				{
					byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, (uint*)pnbVerts, vertices, nbIndices, indices, nbPolygons, (PxHullPolygon**)phullPolygons);
					return ret != 0;
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  Vector3** vertices,  uint* nbIndices,  uint** indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (PxHullPolygon* phullPolygons = &hullPolygons)
					{
						byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, (uint*)pnbVerts, vertices, nbIndices, indices, nbPolygons, (PxHullPolygon**)phullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  Vector3** vertices,  uint* nbIndices,  uint** indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (PxHullPolygon* phullPolygons = &hullPolygons)
					{
						byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, vertices, nbIndices, indices, nbPolygons, (PxHullPolygon**)phullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  Vector3** vertices,  uint* nbIndices,  uint** indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (uint* pnbVerts = &nbVerts)
					{
						fixed (PxHullPolygon* phullPolygons = &hullPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, vertices, nbIndices, indices, nbPolygons, (PxHullPolygon**)phullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  ref Vector3 vertices,  uint* nbIndices,  uint** indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (Vector3* pvertices = &vertices)
			{
				fixed (PxHullPolygon* phullPolygons = &hullPolygons)
				{
					byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, nbVerts, (Vector3**)pvertices, nbIndices, indices, nbPolygons, (PxHullPolygon**)phullPolygons);
					return ret != 0;
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  ref Vector3 vertices,  uint* nbIndices,  uint** indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (Vector3* pvertices = &vertices)
				{
					fixed (PxHullPolygon* phullPolygons = &hullPolygons)
					{
						byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, nbVerts, (Vector3**)pvertices, nbIndices, indices, nbPolygons, (PxHullPolygon**)phullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  ref Vector3 vertices,  uint* nbIndices,  uint** indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (Vector3* pvertices = &vertices)
				{
					fixed (PxHullPolygon* phullPolygons = &hullPolygons)
					{
						byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, nbVerts, (Vector3**)pvertices, nbIndices, indices, nbPolygons, (PxHullPolygon**)phullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  ref Vector3 vertices,  uint* nbIndices,  uint** indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (Vector3* pvertices = &vertices)
					{
						fixed (PxHullPolygon* phullPolygons = &hullPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, nbVerts, (Vector3**)pvertices, nbIndices, indices, nbPolygons, (PxHullPolygon**)phullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  ref Vector3 vertices,  uint* nbIndices,  uint** indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (uint* pnbVerts = &nbVerts)
			{
				fixed (Vector3* pvertices = &vertices)
				{
					fixed (PxHullPolygon* phullPolygons = &hullPolygons)
					{
						byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, (uint*)pnbVerts, (Vector3**)pvertices, nbIndices, indices, nbPolygons, (PxHullPolygon**)phullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  ref Vector3 vertices,  uint* nbIndices,  uint** indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (Vector3* pvertices = &vertices)
					{
						fixed (PxHullPolygon* phullPolygons = &hullPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, (uint*)pnbVerts, (Vector3**)pvertices, nbIndices, indices, nbPolygons, (PxHullPolygon**)phullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  ref Vector3 vertices,  uint* nbIndices,  uint** indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (Vector3* pvertices = &vertices)
					{
						fixed (PxHullPolygon* phullPolygons = &hullPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, (Vector3**)pvertices, nbIndices, indices, nbPolygons, (PxHullPolygon**)phullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  ref Vector3 vertices,  uint* nbIndices,  uint** indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (uint* pnbVerts = &nbVerts)
					{
						fixed (Vector3* pvertices = &vertices)
						{
							fixed (PxHullPolygon* phullPolygons = &hullPolygons)
							{
								byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, (Vector3**)pvertices, nbIndices, indices, nbPolygons, (PxHullPolygon**)phullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  Vector3** vertices,  ref uint nbIndices,  uint** indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (uint* pnbIndices = &nbIndices)
			{
				fixed (PxHullPolygon* phullPolygons = &hullPolygons)
				{
					byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, nbVerts, vertices, (uint*)pnbIndices, indices, nbPolygons, (PxHullPolygon**)phullPolygons);
					return ret != 0;
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  Vector3** vertices,  ref uint nbIndices,  uint** indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (uint* pnbIndices = &nbIndices)
				{
					fixed (PxHullPolygon* phullPolygons = &hullPolygons)
					{
						byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, nbVerts, vertices, (uint*)pnbIndices, indices, nbPolygons, (PxHullPolygon**)phullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  Vector3** vertices,  ref uint nbIndices,  uint** indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (uint* pnbIndices = &nbIndices)
				{
					fixed (PxHullPolygon* phullPolygons = &hullPolygons)
					{
						byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, nbVerts, vertices, (uint*)pnbIndices, indices, nbPolygons, (PxHullPolygon**)phullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  Vector3** vertices,  ref uint nbIndices,  uint** indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (uint* pnbIndices = &nbIndices)
					{
						fixed (PxHullPolygon* phullPolygons = &hullPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, nbVerts, vertices, (uint*)pnbIndices, indices, nbPolygons, (PxHullPolygon**)phullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  Vector3** vertices,  ref uint nbIndices,  uint** indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (uint* pnbVerts = &nbVerts)
			{
				fixed (uint* pnbIndices = &nbIndices)
				{
					fixed (PxHullPolygon* phullPolygons = &hullPolygons)
					{
						byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, (uint*)pnbVerts, vertices, (uint*)pnbIndices, indices, nbPolygons, (PxHullPolygon**)phullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  Vector3** vertices,  ref uint nbIndices,  uint** indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (uint* pnbIndices = &nbIndices)
					{
						fixed (PxHullPolygon* phullPolygons = &hullPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, (uint*)pnbVerts, vertices, (uint*)pnbIndices, indices, nbPolygons, (PxHullPolygon**)phullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  Vector3** vertices,  ref uint nbIndices,  uint** indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (uint* pnbIndices = &nbIndices)
					{
						fixed (PxHullPolygon* phullPolygons = &hullPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, vertices, (uint*)pnbIndices, indices, nbPolygons, (PxHullPolygon**)phullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  Vector3** vertices,  ref uint nbIndices,  uint** indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (uint* pnbVerts = &nbVerts)
					{
						fixed (uint* pnbIndices = &nbIndices)
						{
							fixed (PxHullPolygon* phullPolygons = &hullPolygons)
							{
								byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, vertices, (uint*)pnbIndices, indices, nbPolygons, (PxHullPolygon**)phullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  uint** indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (Vector3* pvertices = &vertices)
			{
				fixed (uint* pnbIndices = &nbIndices)
				{
					fixed (PxHullPolygon* phullPolygons = &hullPolygons)
					{
						byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, nbVerts, (Vector3**)pvertices, (uint*)pnbIndices, indices, nbPolygons, (PxHullPolygon**)phullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  uint** indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (Vector3* pvertices = &vertices)
				{
					fixed (uint* pnbIndices = &nbIndices)
					{
						fixed (PxHullPolygon* phullPolygons = &hullPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, nbVerts, (Vector3**)pvertices, (uint*)pnbIndices, indices, nbPolygons, (PxHullPolygon**)phullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  uint** indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (Vector3* pvertices = &vertices)
				{
					fixed (uint* pnbIndices = &nbIndices)
					{
						fixed (PxHullPolygon* phullPolygons = &hullPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, nbVerts, (Vector3**)pvertices, (uint*)pnbIndices, indices, nbPolygons, (PxHullPolygon**)phullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  uint** indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (Vector3* pvertices = &vertices)
					{
						fixed (uint* pnbIndices = &nbIndices)
						{
							fixed (PxHullPolygon* phullPolygons = &hullPolygons)
							{
								byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, nbVerts, (Vector3**)pvertices, (uint*)pnbIndices, indices, nbPolygons, (PxHullPolygon**)phullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}
	}
}
