// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Hexa.NET.PhysX
{
	public unsafe partial class PhysX
	{

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  uint** indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (uint* pnbVerts = &nbVerts)
			{
				fixed (Vector3* pvertices = &vertices)
				{
					fixed (uint* pnbIndices = &nbIndices)
					{
						fixed (PxHullPolygon* phullPolygons = &hullPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, (uint*)pnbVerts, (Vector3**)pvertices, (uint*)pnbIndices, indices, nbPolygons, (PxHullPolygon**)phullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  uint** indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (Vector3* pvertices = &vertices)
					{
						fixed (uint* pnbIndices = &nbIndices)
						{
							fixed (PxHullPolygon* phullPolygons = &hullPolygons)
							{
								byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, (uint*)pnbVerts, (Vector3**)pvertices, (uint*)pnbIndices, indices, nbPolygons, (PxHullPolygon**)phullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  uint** indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (Vector3* pvertices = &vertices)
					{
						fixed (uint* pnbIndices = &nbIndices)
						{
							fixed (PxHullPolygon* phullPolygons = &hullPolygons)
							{
								byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, (Vector3**)pvertices, (uint*)pnbIndices, indices, nbPolygons, (PxHullPolygon**)phullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  uint** indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (uint* pnbVerts = &nbVerts)
					{
						fixed (Vector3* pvertices = &vertices)
						{
							fixed (uint* pnbIndices = &nbIndices)
							{
								fixed (PxHullPolygon* phullPolygons = &hullPolygons)
								{
									byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, (Vector3**)pvertices, (uint*)pnbIndices, indices, nbPolygons, (PxHullPolygon**)phullPolygons);
									return ret != 0;
								}
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  Vector3** vertices,  uint* nbIndices,  ref uint indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (uint* pindices = &indices)
			{
				fixed (PxHullPolygon* phullPolygons = &hullPolygons)
				{
					byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, nbVerts, vertices, nbIndices, (uint**)pindices, nbPolygons, (PxHullPolygon**)phullPolygons);
					return ret != 0;
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  Vector3** vertices,  uint* nbIndices,  ref uint indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (uint* pindices = &indices)
				{
					fixed (PxHullPolygon* phullPolygons = &hullPolygons)
					{
						byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, nbVerts, vertices, nbIndices, (uint**)pindices, nbPolygons, (PxHullPolygon**)phullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  Vector3** vertices,  uint* nbIndices,  ref uint indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (uint* pindices = &indices)
				{
					fixed (PxHullPolygon* phullPolygons = &hullPolygons)
					{
						byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, nbVerts, vertices, nbIndices, (uint**)pindices, nbPolygons, (PxHullPolygon**)phullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  Vector3** vertices,  uint* nbIndices,  ref uint indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (uint* pindices = &indices)
					{
						fixed (PxHullPolygon* phullPolygons = &hullPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, nbVerts, vertices, nbIndices, (uint**)pindices, nbPolygons, (PxHullPolygon**)phullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  Vector3** vertices,  uint* nbIndices,  ref uint indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (uint* pnbVerts = &nbVerts)
			{
				fixed (uint* pindices = &indices)
				{
					fixed (PxHullPolygon* phullPolygons = &hullPolygons)
					{
						byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, (uint*)pnbVerts, vertices, nbIndices, (uint**)pindices, nbPolygons, (PxHullPolygon**)phullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  Vector3** vertices,  uint* nbIndices,  ref uint indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (uint* pindices = &indices)
					{
						fixed (PxHullPolygon* phullPolygons = &hullPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, (uint*)pnbVerts, vertices, nbIndices, (uint**)pindices, nbPolygons, (PxHullPolygon**)phullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  Vector3** vertices,  uint* nbIndices,  ref uint indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (uint* pindices = &indices)
					{
						fixed (PxHullPolygon* phullPolygons = &hullPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, vertices, nbIndices, (uint**)pindices, nbPolygons, (PxHullPolygon**)phullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  Vector3** vertices,  uint* nbIndices,  ref uint indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (uint* pnbVerts = &nbVerts)
					{
						fixed (uint* pindices = &indices)
						{
							fixed (PxHullPolygon* phullPolygons = &hullPolygons)
							{
								byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, vertices, nbIndices, (uint**)pindices, nbPolygons, (PxHullPolygon**)phullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  ref Vector3 vertices,  uint* nbIndices,  ref uint indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (Vector3* pvertices = &vertices)
			{
				fixed (uint* pindices = &indices)
				{
					fixed (PxHullPolygon* phullPolygons = &hullPolygons)
					{
						byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, nbVerts, (Vector3**)pvertices, nbIndices, (uint**)pindices, nbPolygons, (PxHullPolygon**)phullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  ref Vector3 vertices,  uint* nbIndices,  ref uint indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (Vector3* pvertices = &vertices)
				{
					fixed (uint* pindices = &indices)
					{
						fixed (PxHullPolygon* phullPolygons = &hullPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, nbVerts, (Vector3**)pvertices, nbIndices, (uint**)pindices, nbPolygons, (PxHullPolygon**)phullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  ref Vector3 vertices,  uint* nbIndices,  ref uint indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (Vector3* pvertices = &vertices)
				{
					fixed (uint* pindices = &indices)
					{
						fixed (PxHullPolygon* phullPolygons = &hullPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, nbVerts, (Vector3**)pvertices, nbIndices, (uint**)pindices, nbPolygons, (PxHullPolygon**)phullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  ref Vector3 vertices,  uint* nbIndices,  ref uint indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (Vector3* pvertices = &vertices)
					{
						fixed (uint* pindices = &indices)
						{
							fixed (PxHullPolygon* phullPolygons = &hullPolygons)
							{
								byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, nbVerts, (Vector3**)pvertices, nbIndices, (uint**)pindices, nbPolygons, (PxHullPolygon**)phullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  ref Vector3 vertices,  uint* nbIndices,  ref uint indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (uint* pnbVerts = &nbVerts)
			{
				fixed (Vector3* pvertices = &vertices)
				{
					fixed (uint* pindices = &indices)
					{
						fixed (PxHullPolygon* phullPolygons = &hullPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, (uint*)pnbVerts, (Vector3**)pvertices, nbIndices, (uint**)pindices, nbPolygons, (PxHullPolygon**)phullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  ref Vector3 vertices,  uint* nbIndices,  ref uint indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (Vector3* pvertices = &vertices)
					{
						fixed (uint* pindices = &indices)
						{
							fixed (PxHullPolygon* phullPolygons = &hullPolygons)
							{
								byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, (uint*)pnbVerts, (Vector3**)pvertices, nbIndices, (uint**)pindices, nbPolygons, (PxHullPolygon**)phullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  ref Vector3 vertices,  uint* nbIndices,  ref uint indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (Vector3* pvertices = &vertices)
					{
						fixed (uint* pindices = &indices)
						{
							fixed (PxHullPolygon* phullPolygons = &hullPolygons)
							{
								byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, (Vector3**)pvertices, nbIndices, (uint**)pindices, nbPolygons, (PxHullPolygon**)phullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  ref Vector3 vertices,  uint* nbIndices,  ref uint indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (uint* pnbVerts = &nbVerts)
					{
						fixed (Vector3* pvertices = &vertices)
						{
							fixed (uint* pindices = &indices)
							{
								fixed (PxHullPolygon* phullPolygons = &hullPolygons)
								{
									byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, (Vector3**)pvertices, nbIndices, (uint**)pindices, nbPolygons, (PxHullPolygon**)phullPolygons);
									return ret != 0;
								}
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  Vector3** vertices,  ref uint nbIndices,  ref uint indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (uint* pnbIndices = &nbIndices)
			{
				fixed (uint* pindices = &indices)
				{
					fixed (PxHullPolygon* phullPolygons = &hullPolygons)
					{
						byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, nbVerts, vertices, (uint*)pnbIndices, (uint**)pindices, nbPolygons, (PxHullPolygon**)phullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  Vector3** vertices,  ref uint nbIndices,  ref uint indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (uint* pnbIndices = &nbIndices)
				{
					fixed (uint* pindices = &indices)
					{
						fixed (PxHullPolygon* phullPolygons = &hullPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, nbVerts, vertices, (uint*)pnbIndices, (uint**)pindices, nbPolygons, (PxHullPolygon**)phullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  Vector3** vertices,  ref uint nbIndices,  ref uint indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (uint* pnbIndices = &nbIndices)
				{
					fixed (uint* pindices = &indices)
					{
						fixed (PxHullPolygon* phullPolygons = &hullPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, nbVerts, vertices, (uint*)pnbIndices, (uint**)pindices, nbPolygons, (PxHullPolygon**)phullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  Vector3** vertices,  ref uint nbIndices,  ref uint indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (uint* pnbIndices = &nbIndices)
					{
						fixed (uint* pindices = &indices)
						{
							fixed (PxHullPolygon* phullPolygons = &hullPolygons)
							{
								byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, nbVerts, vertices, (uint*)pnbIndices, (uint**)pindices, nbPolygons, (PxHullPolygon**)phullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  Vector3** vertices,  ref uint nbIndices,  ref uint indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (uint* pnbVerts = &nbVerts)
			{
				fixed (uint* pnbIndices = &nbIndices)
				{
					fixed (uint* pindices = &indices)
					{
						fixed (PxHullPolygon* phullPolygons = &hullPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, (uint*)pnbVerts, vertices, (uint*)pnbIndices, (uint**)pindices, nbPolygons, (PxHullPolygon**)phullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  Vector3** vertices,  ref uint nbIndices,  ref uint indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (uint* pnbIndices = &nbIndices)
					{
						fixed (uint* pindices = &indices)
						{
							fixed (PxHullPolygon* phullPolygons = &hullPolygons)
							{
								byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, (uint*)pnbVerts, vertices, (uint*)pnbIndices, (uint**)pindices, nbPolygons, (PxHullPolygon**)phullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  Vector3** vertices,  ref uint nbIndices,  ref uint indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (uint* pnbIndices = &nbIndices)
					{
						fixed (uint* pindices = &indices)
						{
							fixed (PxHullPolygon* phullPolygons = &hullPolygons)
							{
								byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, vertices, (uint*)pnbIndices, (uint**)pindices, nbPolygons, (PxHullPolygon**)phullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  Vector3** vertices,  ref uint nbIndices,  ref uint indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (uint* pnbVerts = &nbVerts)
					{
						fixed (uint* pnbIndices = &nbIndices)
						{
							fixed (uint* pindices = &indices)
							{
								fixed (PxHullPolygon* phullPolygons = &hullPolygons)
								{
									byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, vertices, (uint*)pnbIndices, (uint**)pindices, nbPolygons, (PxHullPolygon**)phullPolygons);
									return ret != 0;
								}
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  ref uint indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (Vector3* pvertices = &vertices)
			{
				fixed (uint* pnbIndices = &nbIndices)
				{
					fixed (uint* pindices = &indices)
					{
						fixed (PxHullPolygon* phullPolygons = &hullPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, nbVerts, (Vector3**)pvertices, (uint*)pnbIndices, (uint**)pindices, nbPolygons, (PxHullPolygon**)phullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  ref uint indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (Vector3* pvertices = &vertices)
				{
					fixed (uint* pnbIndices = &nbIndices)
					{
						fixed (uint* pindices = &indices)
						{
							fixed (PxHullPolygon* phullPolygons = &hullPolygons)
							{
								byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, nbVerts, (Vector3**)pvertices, (uint*)pnbIndices, (uint**)pindices, nbPolygons, (PxHullPolygon**)phullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  ref uint indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (Vector3* pvertices = &vertices)
				{
					fixed (uint* pnbIndices = &nbIndices)
					{
						fixed (uint* pindices = &indices)
						{
							fixed (PxHullPolygon* phullPolygons = &hullPolygons)
							{
								byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, nbVerts, (Vector3**)pvertices, (uint*)pnbIndices, (uint**)pindices, nbPolygons, (PxHullPolygon**)phullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  ref uint indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (Vector3* pvertices = &vertices)
					{
						fixed (uint* pnbIndices = &nbIndices)
						{
							fixed (uint* pindices = &indices)
							{
								fixed (PxHullPolygon* phullPolygons = &hullPolygons)
								{
									byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, nbVerts, (Vector3**)pvertices, (uint*)pnbIndices, (uint**)pindices, nbPolygons, (PxHullPolygon**)phullPolygons);
									return ret != 0;
								}
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  ref uint indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (uint* pnbVerts = &nbVerts)
			{
				fixed (Vector3* pvertices = &vertices)
				{
					fixed (uint* pnbIndices = &nbIndices)
					{
						fixed (uint* pindices = &indices)
						{
							fixed (PxHullPolygon* phullPolygons = &hullPolygons)
							{
								byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, (uint*)pnbVerts, (Vector3**)pvertices, (uint*)pnbIndices, (uint**)pindices, nbPolygons, (PxHullPolygon**)phullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  ref uint indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (Vector3* pvertices = &vertices)
					{
						fixed (uint* pnbIndices = &nbIndices)
						{
							fixed (uint* pindices = &indices)
							{
								fixed (PxHullPolygon* phullPolygons = &hullPolygons)
								{
									byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, (uint*)pnbVerts, (Vector3**)pvertices, (uint*)pnbIndices, (uint**)pindices, nbPolygons, (PxHullPolygon**)phullPolygons);
									return ret != 0;
								}
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  ref uint indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (Vector3* pvertices = &vertices)
					{
						fixed (uint* pnbIndices = &nbIndices)
						{
							fixed (uint* pindices = &indices)
							{
								fixed (PxHullPolygon* phullPolygons = &hullPolygons)
								{
									byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, (Vector3**)pvertices, (uint*)pnbIndices, (uint**)pindices, nbPolygons, (PxHullPolygon**)phullPolygons);
									return ret != 0;
								}
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  ref uint indices,  uint* nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (uint* pnbVerts = &nbVerts)
					{
						fixed (Vector3* pvertices = &vertices)
						{
							fixed (uint* pnbIndices = &nbIndices)
							{
								fixed (uint* pindices = &indices)
								{
									fixed (PxHullPolygon* phullPolygons = &hullPolygons)
									{
										byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, (Vector3**)pvertices, (uint*)pnbIndices, (uint**)pindices, nbPolygons, (PxHullPolygon**)phullPolygons);
										return ret != 0;
									}
								}
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  Vector3** vertices,  uint* nbIndices,  uint** indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (uint* pnbPolygons = &nbPolygons)
			{
				fixed (PxHullPolygon* phullPolygons = &hullPolygons)
				{
					byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, nbVerts, vertices, nbIndices, indices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
					return ret != 0;
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  Vector3** vertices,  uint* nbIndices,  uint** indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (uint* pnbPolygons = &nbPolygons)
				{
					fixed (PxHullPolygon* phullPolygons = &hullPolygons)
					{
						byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, nbVerts, vertices, nbIndices, indices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  Vector3** vertices,  uint* nbIndices,  uint** indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (uint* pnbPolygons = &nbPolygons)
				{
					fixed (PxHullPolygon* phullPolygons = &hullPolygons)
					{
						byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, nbVerts, vertices, nbIndices, indices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  Vector3** vertices,  uint* nbIndices,  uint** indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (uint* pnbPolygons = &nbPolygons)
					{
						fixed (PxHullPolygon* phullPolygons = &hullPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, nbVerts, vertices, nbIndices, indices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  Vector3** vertices,  uint* nbIndices,  uint** indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (uint* pnbVerts = &nbVerts)
			{
				fixed (uint* pnbPolygons = &nbPolygons)
				{
					fixed (PxHullPolygon* phullPolygons = &hullPolygons)
					{
						byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, (uint*)pnbVerts, vertices, nbIndices, indices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  Vector3** vertices,  uint* nbIndices,  uint** indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (uint* pnbPolygons = &nbPolygons)
					{
						fixed (PxHullPolygon* phullPolygons = &hullPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, (uint*)pnbVerts, vertices, nbIndices, indices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  Vector3** vertices,  uint* nbIndices,  uint** indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (uint* pnbPolygons = &nbPolygons)
					{
						fixed (PxHullPolygon* phullPolygons = &hullPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, vertices, nbIndices, indices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  Vector3** vertices,  uint* nbIndices,  uint** indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (uint* pnbVerts = &nbVerts)
					{
						fixed (uint* pnbPolygons = &nbPolygons)
						{
							fixed (PxHullPolygon* phullPolygons = &hullPolygons)
							{
								byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, vertices, nbIndices, indices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  ref Vector3 vertices,  uint* nbIndices,  uint** indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (Vector3* pvertices = &vertices)
			{
				fixed (uint* pnbPolygons = &nbPolygons)
				{
					fixed (PxHullPolygon* phullPolygons = &hullPolygons)
					{
						byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, nbVerts, (Vector3**)pvertices, nbIndices, indices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  ref Vector3 vertices,  uint* nbIndices,  uint** indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (Vector3* pvertices = &vertices)
				{
					fixed (uint* pnbPolygons = &nbPolygons)
					{
						fixed (PxHullPolygon* phullPolygons = &hullPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, nbVerts, (Vector3**)pvertices, nbIndices, indices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  ref Vector3 vertices,  uint* nbIndices,  uint** indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (Vector3* pvertices = &vertices)
				{
					fixed (uint* pnbPolygons = &nbPolygons)
					{
						fixed (PxHullPolygon* phullPolygons = &hullPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, nbVerts, (Vector3**)pvertices, nbIndices, indices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  ref Vector3 vertices,  uint* nbIndices,  uint** indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (Vector3* pvertices = &vertices)
					{
						fixed (uint* pnbPolygons = &nbPolygons)
						{
							fixed (PxHullPolygon* phullPolygons = &hullPolygons)
							{
								byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, nbVerts, (Vector3**)pvertices, nbIndices, indices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  ref Vector3 vertices,  uint* nbIndices,  uint** indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (uint* pnbVerts = &nbVerts)
			{
				fixed (Vector3* pvertices = &vertices)
				{
					fixed (uint* pnbPolygons = &nbPolygons)
					{
						fixed (PxHullPolygon* phullPolygons = &hullPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, (uint*)pnbVerts, (Vector3**)pvertices, nbIndices, indices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  ref Vector3 vertices,  uint* nbIndices,  uint** indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (Vector3* pvertices = &vertices)
					{
						fixed (uint* pnbPolygons = &nbPolygons)
						{
							fixed (PxHullPolygon* phullPolygons = &hullPolygons)
							{
								byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, (uint*)pnbVerts, (Vector3**)pvertices, nbIndices, indices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  ref Vector3 vertices,  uint* nbIndices,  uint** indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (Vector3* pvertices = &vertices)
					{
						fixed (uint* pnbPolygons = &nbPolygons)
						{
							fixed (PxHullPolygon* phullPolygons = &hullPolygons)
							{
								byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, (Vector3**)pvertices, nbIndices, indices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  ref Vector3 vertices,  uint* nbIndices,  uint** indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (uint* pnbVerts = &nbVerts)
					{
						fixed (Vector3* pvertices = &vertices)
						{
							fixed (uint* pnbPolygons = &nbPolygons)
							{
								fixed (PxHullPolygon* phullPolygons = &hullPolygons)
								{
									byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, (Vector3**)pvertices, nbIndices, indices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
									return ret != 0;
								}
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  Vector3** vertices,  ref uint nbIndices,  uint** indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (uint* pnbIndices = &nbIndices)
			{
				fixed (uint* pnbPolygons = &nbPolygons)
				{
					fixed (PxHullPolygon* phullPolygons = &hullPolygons)
					{
						byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, nbVerts, vertices, (uint*)pnbIndices, indices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  Vector3** vertices,  ref uint nbIndices,  uint** indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (uint* pnbIndices = &nbIndices)
				{
					fixed (uint* pnbPolygons = &nbPolygons)
					{
						fixed (PxHullPolygon* phullPolygons = &hullPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, nbVerts, vertices, (uint*)pnbIndices, indices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  Vector3** vertices,  ref uint nbIndices,  uint** indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (uint* pnbIndices = &nbIndices)
				{
					fixed (uint* pnbPolygons = &nbPolygons)
					{
						fixed (PxHullPolygon* phullPolygons = &hullPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, nbVerts, vertices, (uint*)pnbIndices, indices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  Vector3** vertices,  ref uint nbIndices,  uint** indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (uint* pnbIndices = &nbIndices)
					{
						fixed (uint* pnbPolygons = &nbPolygons)
						{
							fixed (PxHullPolygon* phullPolygons = &hullPolygons)
							{
								byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, nbVerts, vertices, (uint*)pnbIndices, indices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  Vector3** vertices,  ref uint nbIndices,  uint** indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (uint* pnbVerts = &nbVerts)
			{
				fixed (uint* pnbIndices = &nbIndices)
				{
					fixed (uint* pnbPolygons = &nbPolygons)
					{
						fixed (PxHullPolygon* phullPolygons = &hullPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, (uint*)pnbVerts, vertices, (uint*)pnbIndices, indices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  Vector3** vertices,  ref uint nbIndices,  uint** indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (uint* pnbIndices = &nbIndices)
					{
						fixed (uint* pnbPolygons = &nbPolygons)
						{
							fixed (PxHullPolygon* phullPolygons = &hullPolygons)
							{
								byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, (uint*)pnbVerts, vertices, (uint*)pnbIndices, indices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  Vector3** vertices,  ref uint nbIndices,  uint** indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (uint* pnbIndices = &nbIndices)
					{
						fixed (uint* pnbPolygons = &nbPolygons)
						{
							fixed (PxHullPolygon* phullPolygons = &hullPolygons)
							{
								byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, vertices, (uint*)pnbIndices, indices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  Vector3** vertices,  ref uint nbIndices,  uint** indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (uint* pnbVerts = &nbVerts)
					{
						fixed (uint* pnbIndices = &nbIndices)
						{
							fixed (uint* pnbPolygons = &nbPolygons)
							{
								fixed (PxHullPolygon* phullPolygons = &hullPolygons)
								{
									byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, vertices, (uint*)pnbIndices, indices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
									return ret != 0;
								}
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  uint** indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (Vector3* pvertices = &vertices)
			{
				fixed (uint* pnbIndices = &nbIndices)
				{
					fixed (uint* pnbPolygons = &nbPolygons)
					{
						fixed (PxHullPolygon* phullPolygons = &hullPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, nbVerts, (Vector3**)pvertices, (uint*)pnbIndices, indices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  uint** indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (Vector3* pvertices = &vertices)
				{
					fixed (uint* pnbIndices = &nbIndices)
					{
						fixed (uint* pnbPolygons = &nbPolygons)
						{
							fixed (PxHullPolygon* phullPolygons = &hullPolygons)
							{
								byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, nbVerts, (Vector3**)pvertices, (uint*)pnbIndices, indices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  uint** indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (Vector3* pvertices = &vertices)
				{
					fixed (uint* pnbIndices = &nbIndices)
					{
						fixed (uint* pnbPolygons = &nbPolygons)
						{
							fixed (PxHullPolygon* phullPolygons = &hullPolygons)
							{
								byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, nbVerts, (Vector3**)pvertices, (uint*)pnbIndices, indices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  uint** indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (Vector3* pvertices = &vertices)
					{
						fixed (uint* pnbIndices = &nbIndices)
						{
							fixed (uint* pnbPolygons = &nbPolygons)
							{
								fixed (PxHullPolygon* phullPolygons = &hullPolygons)
								{
									byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, nbVerts, (Vector3**)pvertices, (uint*)pnbIndices, indices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
									return ret != 0;
								}
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  uint** indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (uint* pnbVerts = &nbVerts)
			{
				fixed (Vector3* pvertices = &vertices)
				{
					fixed (uint* pnbIndices = &nbIndices)
					{
						fixed (uint* pnbPolygons = &nbPolygons)
						{
							fixed (PxHullPolygon* phullPolygons = &hullPolygons)
							{
								byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, (uint*)pnbVerts, (Vector3**)pvertices, (uint*)pnbIndices, indices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  uint** indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (Vector3* pvertices = &vertices)
					{
						fixed (uint* pnbIndices = &nbIndices)
						{
							fixed (uint* pnbPolygons = &nbPolygons)
							{
								fixed (PxHullPolygon* phullPolygons = &hullPolygons)
								{
									byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, (uint*)pnbVerts, (Vector3**)pvertices, (uint*)pnbIndices, indices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
									return ret != 0;
								}
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  uint** indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (Vector3* pvertices = &vertices)
					{
						fixed (uint* pnbIndices = &nbIndices)
						{
							fixed (uint* pnbPolygons = &nbPolygons)
							{
								fixed (PxHullPolygon* phullPolygons = &hullPolygons)
								{
									byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, (Vector3**)pvertices, (uint*)pnbIndices, indices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
									return ret != 0;
								}
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  uint** indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (uint* pnbVerts = &nbVerts)
					{
						fixed (Vector3* pvertices = &vertices)
						{
							fixed (uint* pnbIndices = &nbIndices)
							{
								fixed (uint* pnbPolygons = &nbPolygons)
								{
									fixed (PxHullPolygon* phullPolygons = &hullPolygons)
									{
										byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, (Vector3**)pvertices, (uint*)pnbIndices, indices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
										return ret != 0;
									}
								}
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  Vector3** vertices,  uint* nbIndices,  ref uint indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (uint* pindices = &indices)
			{
				fixed (uint* pnbPolygons = &nbPolygons)
				{
					fixed (PxHullPolygon* phullPolygons = &hullPolygons)
					{
						byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, nbVerts, vertices, nbIndices, (uint**)pindices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  Vector3** vertices,  uint* nbIndices,  ref uint indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (uint* pindices = &indices)
				{
					fixed (uint* pnbPolygons = &nbPolygons)
					{
						fixed (PxHullPolygon* phullPolygons = &hullPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, nbVerts, vertices, nbIndices, (uint**)pindices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  Vector3** vertices,  uint* nbIndices,  ref uint indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (uint* pindices = &indices)
				{
					fixed (uint* pnbPolygons = &nbPolygons)
					{
						fixed (PxHullPolygon* phullPolygons = &hullPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, nbVerts, vertices, nbIndices, (uint**)pindices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  Vector3** vertices,  uint* nbIndices,  ref uint indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (uint* pindices = &indices)
					{
						fixed (uint* pnbPolygons = &nbPolygons)
						{
							fixed (PxHullPolygon* phullPolygons = &hullPolygons)
							{
								byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, nbVerts, vertices, nbIndices, (uint**)pindices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  Vector3** vertices,  uint* nbIndices,  ref uint indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (uint* pnbVerts = &nbVerts)
			{
				fixed (uint* pindices = &indices)
				{
					fixed (uint* pnbPolygons = &nbPolygons)
					{
						fixed (PxHullPolygon* phullPolygons = &hullPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, (uint*)pnbVerts, vertices, nbIndices, (uint**)pindices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  Vector3** vertices,  uint* nbIndices,  ref uint indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (uint* pindices = &indices)
					{
						fixed (uint* pnbPolygons = &nbPolygons)
						{
							fixed (PxHullPolygon* phullPolygons = &hullPolygons)
							{
								byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, (uint*)pnbVerts, vertices, nbIndices, (uint**)pindices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  Vector3** vertices,  uint* nbIndices,  ref uint indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (uint* pindices = &indices)
					{
						fixed (uint* pnbPolygons = &nbPolygons)
						{
							fixed (PxHullPolygon* phullPolygons = &hullPolygons)
							{
								byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, vertices, nbIndices, (uint**)pindices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  Vector3** vertices,  uint* nbIndices,  ref uint indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (uint* pnbVerts = &nbVerts)
					{
						fixed (uint* pindices = &indices)
						{
							fixed (uint* pnbPolygons = &nbPolygons)
							{
								fixed (PxHullPolygon* phullPolygons = &hullPolygons)
								{
									byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, vertices, nbIndices, (uint**)pindices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
									return ret != 0;
								}
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  ref Vector3 vertices,  uint* nbIndices,  ref uint indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (Vector3* pvertices = &vertices)
			{
				fixed (uint* pindices = &indices)
				{
					fixed (uint* pnbPolygons = &nbPolygons)
					{
						fixed (PxHullPolygon* phullPolygons = &hullPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, nbVerts, (Vector3**)pvertices, nbIndices, (uint**)pindices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  ref Vector3 vertices,  uint* nbIndices,  ref uint indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (Vector3* pvertices = &vertices)
				{
					fixed (uint* pindices = &indices)
					{
						fixed (uint* pnbPolygons = &nbPolygons)
						{
							fixed (PxHullPolygon* phullPolygons = &hullPolygons)
							{
								byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, nbVerts, (Vector3**)pvertices, nbIndices, (uint**)pindices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  ref Vector3 vertices,  uint* nbIndices,  ref uint indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (Vector3* pvertices = &vertices)
				{
					fixed (uint* pindices = &indices)
					{
						fixed (uint* pnbPolygons = &nbPolygons)
						{
							fixed (PxHullPolygon* phullPolygons = &hullPolygons)
							{
								byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, nbVerts, (Vector3**)pvertices, nbIndices, (uint**)pindices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  ref Vector3 vertices,  uint* nbIndices,  ref uint indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (Vector3* pvertices = &vertices)
					{
						fixed (uint* pindices = &indices)
						{
							fixed (uint* pnbPolygons = &nbPolygons)
							{
								fixed (PxHullPolygon* phullPolygons = &hullPolygons)
								{
									byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, nbVerts, (Vector3**)pvertices, nbIndices, (uint**)pindices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
									return ret != 0;
								}
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  ref Vector3 vertices,  uint* nbIndices,  ref uint indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (uint* pnbVerts = &nbVerts)
			{
				fixed (Vector3* pvertices = &vertices)
				{
					fixed (uint* pindices = &indices)
					{
						fixed (uint* pnbPolygons = &nbPolygons)
						{
							fixed (PxHullPolygon* phullPolygons = &hullPolygons)
							{
								byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, (uint*)pnbVerts, (Vector3**)pvertices, nbIndices, (uint**)pindices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  ref Vector3 vertices,  uint* nbIndices,  ref uint indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (Vector3* pvertices = &vertices)
					{
						fixed (uint* pindices = &indices)
						{
							fixed (uint* pnbPolygons = &nbPolygons)
							{
								fixed (PxHullPolygon* phullPolygons = &hullPolygons)
								{
									byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, (uint*)pnbVerts, (Vector3**)pvertices, nbIndices, (uint**)pindices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
									return ret != 0;
								}
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  ref Vector3 vertices,  uint* nbIndices,  ref uint indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (Vector3* pvertices = &vertices)
					{
						fixed (uint* pindices = &indices)
						{
							fixed (uint* pnbPolygons = &nbPolygons)
							{
								fixed (PxHullPolygon* phullPolygons = &hullPolygons)
								{
									byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, (Vector3**)pvertices, nbIndices, (uint**)pindices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
									return ret != 0;
								}
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  ref Vector3 vertices,  uint* nbIndices,  ref uint indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (uint* pnbVerts = &nbVerts)
					{
						fixed (Vector3* pvertices = &vertices)
						{
							fixed (uint* pindices = &indices)
							{
								fixed (uint* pnbPolygons = &nbPolygons)
								{
									fixed (PxHullPolygon* phullPolygons = &hullPolygons)
									{
										byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, (Vector3**)pvertices, nbIndices, (uint**)pindices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
										return ret != 0;
									}
								}
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  Vector3** vertices,  ref uint nbIndices,  ref uint indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (uint* pnbIndices = &nbIndices)
			{
				fixed (uint* pindices = &indices)
				{
					fixed (uint* pnbPolygons = &nbPolygons)
					{
						fixed (PxHullPolygon* phullPolygons = &hullPolygons)
						{
							byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, nbVerts, vertices, (uint*)pnbIndices, (uint**)pindices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  Vector3** vertices,  ref uint nbIndices,  ref uint indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (uint* pnbIndices = &nbIndices)
				{
					fixed (uint* pindices = &indices)
					{
						fixed (uint* pnbPolygons = &nbPolygons)
						{
							fixed (PxHullPolygon* phullPolygons = &hullPolygons)
							{
								byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, nbVerts, vertices, (uint*)pnbIndices, (uint**)pindices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  Vector3** vertices,  ref uint nbIndices,  ref uint indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (uint* pnbIndices = &nbIndices)
				{
					fixed (uint* pindices = &indices)
					{
						fixed (uint* pnbPolygons = &nbPolygons)
						{
							fixed (PxHullPolygon* phullPolygons = &hullPolygons)
							{
								byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, nbVerts, vertices, (uint*)pnbIndices, (uint**)pindices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  Vector3** vertices,  ref uint nbIndices,  ref uint indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (uint* pnbIndices = &nbIndices)
					{
						fixed (uint* pindices = &indices)
						{
							fixed (uint* pnbPolygons = &nbPolygons)
							{
								fixed (PxHullPolygon* phullPolygons = &hullPolygons)
								{
									byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, nbVerts, vertices, (uint*)pnbIndices, (uint**)pindices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
									return ret != 0;
								}
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  Vector3** vertices,  ref uint nbIndices,  ref uint indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (uint* pnbVerts = &nbVerts)
			{
				fixed (uint* pnbIndices = &nbIndices)
				{
					fixed (uint* pindices = &indices)
					{
						fixed (uint* pnbPolygons = &nbPolygons)
						{
							fixed (PxHullPolygon* phullPolygons = &hullPolygons)
							{
								byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, (uint*)pnbVerts, vertices, (uint*)pnbIndices, (uint**)pindices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  Vector3** vertices,  ref uint nbIndices,  ref uint indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (uint* pnbIndices = &nbIndices)
					{
						fixed (uint* pindices = &indices)
						{
							fixed (uint* pnbPolygons = &nbPolygons)
							{
								fixed (PxHullPolygon* phullPolygons = &hullPolygons)
								{
									byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, (uint*)pnbVerts, vertices, (uint*)pnbIndices, (uint**)pindices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
									return ret != 0;
								}
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  Vector3** vertices,  ref uint nbIndices,  ref uint indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (uint* pnbIndices = &nbIndices)
					{
						fixed (uint* pindices = &indices)
						{
							fixed (uint* pnbPolygons = &nbPolygons)
							{
								fixed (PxHullPolygon* phullPolygons = &hullPolygons)
								{
									byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, vertices, (uint*)pnbIndices, (uint**)pindices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
									return ret != 0;
								}
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  Vector3** vertices,  ref uint nbIndices,  ref uint indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (uint* pnbVerts = &nbVerts)
					{
						fixed (uint* pnbIndices = &nbIndices)
						{
							fixed (uint* pindices = &indices)
							{
								fixed (uint* pnbPolygons = &nbPolygons)
								{
									fixed (PxHullPolygon* phullPolygons = &hullPolygons)
									{
										byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, vertices, (uint*)pnbIndices, (uint**)pindices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
										return ret != 0;
									}
								}
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  ref uint indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (Vector3* pvertices = &vertices)
			{
				fixed (uint* pnbIndices = &nbIndices)
				{
					fixed (uint* pindices = &indices)
					{
						fixed (uint* pnbPolygons = &nbPolygons)
						{
							fixed (PxHullPolygon* phullPolygons = &hullPolygons)
							{
								byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, nbVerts, (Vector3**)pvertices, (uint*)pnbIndices, (uint**)pindices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  uint* nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  ref uint indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (Vector3* pvertices = &vertices)
				{
					fixed (uint* pnbIndices = &nbIndices)
					{
						fixed (uint* pindices = &indices)
						{
							fixed (uint* pnbPolygons = &nbPolygons)
							{
								fixed (PxHullPolygon* phullPolygons = &hullPolygons)
								{
									byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, nbVerts, (Vector3**)pvertices, (uint*)pnbIndices, (uint**)pindices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
									return ret != 0;
								}
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  ref uint indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (Vector3* pvertices = &vertices)
				{
					fixed (uint* pnbIndices = &nbIndices)
					{
						fixed (uint* pindices = &indices)
						{
							fixed (uint* pnbPolygons = &nbPolygons)
							{
								fixed (PxHullPolygon* phullPolygons = &hullPolygons)
								{
									byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, nbVerts, (Vector3**)pvertices, (uint*)pnbIndices, (uint**)pindices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
									return ret != 0;
								}
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  uint* nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  ref uint indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (Vector3* pvertices = &vertices)
					{
						fixed (uint* pnbIndices = &nbIndices)
						{
							fixed (uint* pindices = &indices)
							{
								fixed (uint* pnbPolygons = &nbPolygons)
								{
									fixed (PxHullPolygon* phullPolygons = &hullPolygons)
									{
										byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, nbVerts, (Vector3**)pvertices, (uint*)pnbIndices, (uint**)pindices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
										return ret != 0;
									}
								}
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  ref uint indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (uint* pnbVerts = &nbVerts)
			{
				fixed (Vector3* pvertices = &vertices)
				{
					fixed (uint* pnbIndices = &nbIndices)
					{
						fixed (uint* pindices = &indices)
						{
							fixed (uint* pnbPolygons = &nbPolygons)
							{
								fixed (PxHullPolygon* phullPolygons = &hullPolygons)
								{
									byte ret = PxComputeHullPolygonsNative(@params, mesh, inCallback, (uint*)pnbVerts, (Vector3**)pvertices, (uint*)pnbIndices, (uint**)pindices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
									return ret != 0;
								}
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  PxAllocatorCallback* inCallback,  ref uint nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  ref uint indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (Vector3* pvertices = &vertices)
					{
						fixed (uint* pnbIndices = &nbIndices)
						{
							fixed (uint* pindices = &indices)
							{
								fixed (uint* pnbPolygons = &nbPolygons)
								{
									fixed (PxHullPolygon* phullPolygons = &hullPolygons)
									{
										byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, inCallback, (uint*)pnbVerts, (Vector3**)pvertices, (uint*)pnbIndices, (uint**)pindices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
										return ret != 0;
									}
								}
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  PxSimpleTriangleMesh* mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  ref uint indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxAllocatorCallback* pinCallback = &inCallback)
			{
				fixed (uint* pnbVerts = &nbVerts)
				{
					fixed (Vector3* pvertices = &vertices)
					{
						fixed (uint* pnbIndices = &nbIndices)
						{
							fixed (uint* pindices = &indices)
							{
								fixed (uint* pnbPolygons = &nbPolygons)
								{
									fixed (PxHullPolygon* phullPolygons = &hullPolygons)
									{
										byte ret = PxComputeHullPolygonsNative(@params, mesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, (Vector3**)pvertices, (uint*)pnbIndices, (uint**)pindices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
										return ret != 0;
									}
								}
							}
						}
					}
				}
			}
		}

		/// <summary>/// Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. <br/>/// The output vertices, indices and polygons must be used to construct a hull.<br/>/// The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those<br/>/// array's.<br/>/// </summary>		public static bool PxComputeHullPolygons( PxCookingParams* @params,  ref PxSimpleTriangleMesh mesh,  ref PxAllocatorCallback inCallback,  ref uint nbVerts,  ref Vector3 vertices,  ref uint nbIndices,  ref uint indices,  ref uint nbPolygons,  ref PxHullPolygon hullPolygons)
		{
			fixed (PxSimpleTriangleMesh* pmesh = &mesh)
			{
				fixed (PxAllocatorCallback* pinCallback = &inCallback)
				{
					fixed (uint* pnbVerts = &nbVerts)
					{
						fixed (Vector3* pvertices = &vertices)
						{
							fixed (uint* pnbIndices = &nbIndices)
							{
								fixed (uint* pindices = &indices)
								{
									fixed (uint* pnbPolygons = &nbPolygons)
									{
										fixed (PxHullPolygon* phullPolygons = &hullPolygons)
										{
											byte ret = PxComputeHullPolygonsNative(@params, (PxSimpleTriangleMesh*)pmesh, (PxAllocatorCallback*)pinCallback, (uint*)pnbVerts, (Vector3**)pvertices, (uint*)pnbIndices, (uint**)pindices, (uint*)pnbPolygons, (PxHullPolygon**)phullPolygons);
											return ret != 0;
										}
									}
								}
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// The following conditions are true for a valid triangle mesh:<br/>
		/// 1. There are no duplicate vertices (within specified vertexWeldTolerance. See PxCookingParams::meshWeldTolerance)<br/>
		/// 2. There are no large triangles (within specified PxTolerancesScale.)<br/>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxValidateTriangleMesh")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte PxValidateTriangleMeshNative(PxCookingParams* @params, PxTriangleMeshDesc* desc);

		/// <summary>/// The following conditions are true for a valid triangle mesh:<br/>/// 1. There are no duplicate vertices (within specified vertexWeldTolerance. See PxCookingParams::meshWeldTolerance)<br/>/// 2. There are no large triangles (within specified PxTolerancesScale.)<br/>/// </summary>		public static bool PxValidateTriangleMesh( PxCookingParams* @params,  PxTriangleMeshDesc* desc)
		{
			byte ret = PxValidateTriangleMeshNative(@params, desc);
			return ret != 0;
		}

		/// <summary>/// The following conditions are true for a valid triangle mesh:<br/>/// 1. There are no duplicate vertices (within specified vertexWeldTolerance. See PxCookingParams::meshWeldTolerance)<br/>/// 2. There are no large triangles (within specified PxTolerancesScale.)<br/>/// </summary>		public static bool PxValidateTriangleMesh( PxCookingParams* @params,  ref PxTriangleMeshDesc desc)
		{
			fixed (PxTriangleMeshDesc* pdesc = &desc)
			{
				byte ret = PxValidateTriangleMeshNative(@params, (PxTriangleMeshDesc*)pdesc);
				return ret != 0;
			}
		}

		/// <summary>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxCreateTriangleMesh")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial PxTriangleMesh* PxCreateTriangleMeshNative(PxCookingParams* @params, PxTriangleMeshDesc* desc, PxInsertionCallback* insertionCallback, Enum* condition);

		/// <summary>/// </summary>		public static PxTriangleMesh* PxCreateTriangleMesh( PxCookingParams* @params,  PxTriangleMeshDesc* desc,  PxInsertionCallback* insertionCallback,  Enum* condition)
		{
			PxTriangleMesh* ret = PxCreateTriangleMeshNative(@params, desc, insertionCallback, condition);
			return ret;
		}

		/// <summary>/// </summary>		public static PxTriangleMesh* PxCreateTriangleMesh( PxCookingParams* @params,  ref PxTriangleMeshDesc desc,  PxInsertionCallback* insertionCallback,  Enum* condition)
		{
			fixed (PxTriangleMeshDesc* pdesc = &desc)
			{
				PxTriangleMesh* ret = PxCreateTriangleMeshNative(@params, (PxTriangleMeshDesc*)pdesc, insertionCallback, condition);
				return ret;
			}
		}

		/// <summary>/// </summary>		public static PxTriangleMesh* PxCreateTriangleMesh( PxCookingParams* @params,  PxTriangleMeshDesc* desc,  ref PxInsertionCallback insertionCallback,  Enum* condition)
		{
			fixed (PxInsertionCallback* pinsertionCallback = &insertionCallback)
			{
				PxTriangleMesh* ret = PxCreateTriangleMeshNative(@params, desc, (PxInsertionCallback*)pinsertionCallback, condition);
				return ret;
			}
		}

		/// <summary>/// </summary>		public static PxTriangleMesh* PxCreateTriangleMesh( PxCookingParams* @params,  ref PxTriangleMeshDesc desc,  ref PxInsertionCallback insertionCallback,  Enum* condition)
		{
			fixed (PxTriangleMeshDesc* pdesc = &desc)
			{
				fixed (PxInsertionCallback* pinsertionCallback = &insertionCallback)
				{
					PxTriangleMesh* ret = PxCreateTriangleMeshNative(@params, (PxTriangleMeshDesc*)pdesc, (PxInsertionCallback*)pinsertionCallback, condition);
					return ret;
				}
			}
		}

		/// <summary>/// </summary>		public static PxTriangleMesh* PxCreateTriangleMesh( PxCookingParams* @params,  PxTriangleMeshDesc* desc,  PxInsertionCallback* insertionCallback,  ref Enum condition)
		{
			fixed (Enum* pcondition = &condition)
			{
				PxTriangleMesh* ret = PxCreateTriangleMeshNative(@params, desc, insertionCallback, (Enum*)pcondition);
				return ret;
			}
		}

		/// <summary>/// </summary>		public static PxTriangleMesh* PxCreateTriangleMesh( PxCookingParams* @params,  ref PxTriangleMeshDesc desc,  PxInsertionCallback* insertionCallback,  ref Enum condition)
		{
			fixed (PxTriangleMeshDesc* pdesc = &desc)
			{
				fixed (Enum* pcondition = &condition)
				{
					PxTriangleMesh* ret = PxCreateTriangleMeshNative(@params, (PxTriangleMeshDesc*)pdesc, insertionCallback, (Enum*)pcondition);
					return ret;
				}
			}
		}

		/// <summary>/// </summary>		public static PxTriangleMesh* PxCreateTriangleMesh( PxCookingParams* @params,  PxTriangleMeshDesc* desc,  ref PxInsertionCallback insertionCallback,  ref Enum condition)
		{
			fixed (PxInsertionCallback* pinsertionCallback = &insertionCallback)
			{
				fixed (Enum* pcondition = &condition)
				{
					PxTriangleMesh* ret = PxCreateTriangleMeshNative(@params, desc, (PxInsertionCallback*)pinsertionCallback, (Enum*)pcondition);
					return ret;
				}
			}
		}

		/// <summary>/// </summary>		public static PxTriangleMesh* PxCreateTriangleMesh( PxCookingParams* @params,  ref PxTriangleMeshDesc desc,  ref PxInsertionCallback insertionCallback,  ref Enum condition)
		{
			fixed (PxTriangleMeshDesc* pdesc = &desc)
			{
				fixed (PxInsertionCallback* pinsertionCallback = &insertionCallback)
				{
					fixed (Enum* pcondition = &condition)
					{
						PxTriangleMesh* ret = PxCreateTriangleMeshNative(@params, (PxTriangleMeshDesc*)pdesc, (PxInsertionCallback*)pinsertionCallback, (Enum*)pcondition);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To create a triangle mesh object it is necessary to first 'cook' the mesh data into<br/>
		/// a form which allows the SDK to perform efficient collision detection.<br/>
		/// PxCookTriangleMesh() allows a mesh description to be cooked into a binary stream<br/>
		/// suitable for loading and performing collision detection at runtime.<br/>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxCookTriangleMesh")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte PxCookTriangleMeshNative(PxCookingParams* @params, PxTriangleMeshDesc* desc, PxOutputStream* stream, Enum* condition);

		/// <summary>/// To create a triangle mesh object it is necessary to first 'cook' the mesh data into<br/>/// a form which allows the SDK to perform efficient collision detection.<br/>/// PxCookTriangleMesh() allows a mesh description to be cooked into a binary stream<br/>/// suitable for loading and performing collision detection at runtime.<br/>/// </summary>		public static bool PxCookTriangleMesh( PxCookingParams* @params,  PxTriangleMeshDesc* desc,  PxOutputStream* stream,  Enum* condition)
		{
			byte ret = PxCookTriangleMeshNative(@params, desc, stream, condition);
			return ret != 0;
		}

		/// <summary>/// To create a triangle mesh object it is necessary to first 'cook' the mesh data into<br/>/// a form which allows the SDK to perform efficient collision detection.<br/>/// PxCookTriangleMesh() allows a mesh description to be cooked into a binary stream<br/>/// suitable for loading and performing collision detection at runtime.<br/>/// </summary>		public static bool PxCookTriangleMesh( PxCookingParams* @params,  ref PxTriangleMeshDesc desc,  PxOutputStream* stream,  Enum* condition)
		{
			fixed (PxTriangleMeshDesc* pdesc = &desc)
			{
				byte ret = PxCookTriangleMeshNative(@params, (PxTriangleMeshDesc*)pdesc, stream, condition);
				return ret != 0;
			}
		}

		/// <summary>/// To create a triangle mesh object it is necessary to first 'cook' the mesh data into<br/>/// a form which allows the SDK to perform efficient collision detection.<br/>/// PxCookTriangleMesh() allows a mesh description to be cooked into a binary stream<br/>/// suitable for loading and performing collision detection at runtime.<br/>/// </summary>		public static bool PxCookTriangleMesh( PxCookingParams* @params,  PxTriangleMeshDesc* desc,  ref PxOutputStream stream,  Enum* condition)
		{
			fixed (PxOutputStream* pstream = &stream)
			{
				byte ret = PxCookTriangleMeshNative(@params, desc, (PxOutputStream*)pstream, condition);
				return ret != 0;
			}
		}

		/// <summary>/// To create a triangle mesh object it is necessary to first 'cook' the mesh data into<br/>/// a form which allows the SDK to perform efficient collision detection.<br/>/// PxCookTriangleMesh() allows a mesh description to be cooked into a binary stream<br/>/// suitable for loading and performing collision detection at runtime.<br/>/// </summary>		public static bool PxCookTriangleMesh( PxCookingParams* @params,  ref PxTriangleMeshDesc desc,  ref PxOutputStream stream,  Enum* condition)
		{
			fixed (PxTriangleMeshDesc* pdesc = &desc)
			{
				fixed (PxOutputStream* pstream = &stream)
				{
					byte ret = PxCookTriangleMeshNative(@params, (PxTriangleMeshDesc*)pdesc, (PxOutputStream*)pstream, condition);
					return ret != 0;
				}
			}
		}

		/// <summary>/// To create a triangle mesh object it is necessary to first 'cook' the mesh data into<br/>/// a form which allows the SDK to perform efficient collision detection.<br/>/// PxCookTriangleMesh() allows a mesh description to be cooked into a binary stream<br/>/// suitable for loading and performing collision detection at runtime.<br/>/// </summary>		public static bool PxCookTriangleMesh( PxCookingParams* @params,  PxTriangleMeshDesc* desc,  PxOutputStream* stream,  ref Enum condition)
		{
			fixed (Enum* pcondition = &condition)
			{
				byte ret = PxCookTriangleMeshNative(@params, desc, stream, (Enum*)pcondition);
				return ret != 0;
			}
		}

		/// <summary>/// To create a triangle mesh object it is necessary to first 'cook' the mesh data into<br/>/// a form which allows the SDK to perform efficient collision detection.<br/>/// PxCookTriangleMesh() allows a mesh description to be cooked into a binary stream<br/>/// suitable for loading and performing collision detection at runtime.<br/>/// </summary>		public static bool PxCookTriangleMesh( PxCookingParams* @params,  ref PxTriangleMeshDesc desc,  PxOutputStream* stream,  ref Enum condition)
		{
			fixed (PxTriangleMeshDesc* pdesc = &desc)
			{
				fixed (Enum* pcondition = &condition)
				{
					byte ret = PxCookTriangleMeshNative(@params, (PxTriangleMeshDesc*)pdesc, stream, (Enum*)pcondition);
					return ret != 0;
				}
			}
		}

		/// <summary>/// To create a triangle mesh object it is necessary to first 'cook' the mesh data into<br/>/// a form which allows the SDK to perform efficient collision detection.<br/>/// PxCookTriangleMesh() allows a mesh description to be cooked into a binary stream<br/>/// suitable for loading and performing collision detection at runtime.<br/>/// </summary>		public static bool PxCookTriangleMesh( PxCookingParams* @params,  PxTriangleMeshDesc* desc,  ref PxOutputStream stream,  ref Enum condition)
		{
			fixed (PxOutputStream* pstream = &stream)
			{
				fixed (Enum* pcondition = &condition)
				{
					byte ret = PxCookTriangleMeshNative(@params, desc, (PxOutputStream*)pstream, (Enum*)pcondition);
					return ret != 0;
				}
			}
		}

		/// <summary>/// To create a triangle mesh object it is necessary to first 'cook' the mesh data into<br/>/// a form which allows the SDK to perform efficient collision detection.<br/>/// PxCookTriangleMesh() allows a mesh description to be cooked into a binary stream<br/>/// suitable for loading and performing collision detection at runtime.<br/>/// </summary>		public static bool PxCookTriangleMesh( PxCookingParams* @params,  ref PxTriangleMeshDesc desc,  ref PxOutputStream stream,  ref Enum condition)
		{
			fixed (PxTriangleMeshDesc* pdesc = &desc)
			{
				fixed (PxOutputStream* pstream = &stream)
				{
					fixed (Enum* pcondition = &condition)
					{
						byte ret = PxCookTriangleMeshNative(@params, (PxTriangleMeshDesc*)pdesc, (PxOutputStream*)pstream, (Enum*)pcondition);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Tetrahedron <br/>
		/// &<br/>
		/// soft body meshes<br/>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxCookTetrahedronMesh")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte PxCookTetrahedronMeshNative(PxCookingParams* @params, PxTetrahedronMeshDesc* meshDesc, PxOutputStream* stream);

		/// <summary>/// Tetrahedron <br/>/// &<br/>/// soft body meshes<br/>/// </summary>		public static bool PxCookTetrahedronMesh( PxCookingParams* @params,  PxTetrahedronMeshDesc* meshDesc,  PxOutputStream* stream)
		{
			byte ret = PxCookTetrahedronMeshNative(@params, meshDesc, stream);
			return ret != 0;
		}

		/// <summary>/// Tetrahedron <br/>/// &<br/>/// soft body meshes<br/>/// </summary>		public static bool PxCookTetrahedronMesh( PxCookingParams* @params,  ref PxTetrahedronMeshDesc meshDesc,  PxOutputStream* stream)
		{
			fixed (PxTetrahedronMeshDesc* pmeshDesc = &meshDesc)
			{
				byte ret = PxCookTetrahedronMeshNative(@params, (PxTetrahedronMeshDesc*)pmeshDesc, stream);
				return ret != 0;
			}
		}

		/// <summary>/// Tetrahedron <br/>/// &<br/>/// soft body meshes<br/>/// </summary>		public static bool PxCookTetrahedronMesh( PxCookingParams* @params,  PxTetrahedronMeshDesc* meshDesc,  ref PxOutputStream stream)
		{
			fixed (PxOutputStream* pstream = &stream)
			{
				byte ret = PxCookTetrahedronMeshNative(@params, meshDesc, (PxOutputStream*)pstream);
				return ret != 0;
			}
		}

		/// <summary>/// Tetrahedron <br/>/// &<br/>/// soft body meshes<br/>/// </summary>		public static bool PxCookTetrahedronMesh( PxCookingParams* @params,  ref PxTetrahedronMeshDesc meshDesc,  ref PxOutputStream stream)
		{
			fixed (PxTetrahedronMeshDesc* pmeshDesc = &meshDesc)
			{
				fixed (PxOutputStream* pstream = &stream)
				{
					byte ret = PxCookTetrahedronMeshNative(@params, (PxTetrahedronMeshDesc*)pmeshDesc, (PxOutputStream*)pstream);
					return ret != 0;
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "PxCreateTetrahedronMesh")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial PxTetrahedronMesh* PxCreateTetrahedronMeshNative(PxCookingParams* @params, PxTetrahedronMeshDesc* meshDesc, PxInsertionCallback* insertionCallback);

		public static PxTetrahedronMesh* PxCreateTetrahedronMesh( PxCookingParams* @params,  PxTetrahedronMeshDesc* meshDesc,  PxInsertionCallback* insertionCallback)
		{
			PxTetrahedronMesh* ret = PxCreateTetrahedronMeshNative(@params, meshDesc, insertionCallback);
			return ret;
		}

		public static PxTetrahedronMesh* PxCreateTetrahedronMesh( PxCookingParams* @params,  ref PxTetrahedronMeshDesc meshDesc,  PxInsertionCallback* insertionCallback)
		{
			fixed (PxTetrahedronMeshDesc* pmeshDesc = &meshDesc)
			{
				PxTetrahedronMesh* ret = PxCreateTetrahedronMeshNative(@params, (PxTetrahedronMeshDesc*)pmeshDesc, insertionCallback);
				return ret;
			}
		}

		public static PxTetrahedronMesh* PxCreateTetrahedronMesh( PxCookingParams* @params,  PxTetrahedronMeshDesc* meshDesc,  ref PxInsertionCallback insertionCallback)
		{
			fixed (PxInsertionCallback* pinsertionCallback = &insertionCallback)
			{
				PxTetrahedronMesh* ret = PxCreateTetrahedronMeshNative(@params, meshDesc, (PxInsertionCallback*)pinsertionCallback);
				return ret;
			}
		}

		public static PxTetrahedronMesh* PxCreateTetrahedronMesh( PxCookingParams* @params,  ref PxTetrahedronMeshDesc meshDesc,  ref PxInsertionCallback insertionCallback)
		{
			fixed (PxTetrahedronMeshDesc* pmeshDesc = &meshDesc)
			{
				fixed (PxInsertionCallback* pinsertionCallback = &insertionCallback)
				{
					PxTetrahedronMesh* ret = PxCreateTetrahedronMeshNative(@params, (PxTetrahedronMeshDesc*)pmeshDesc, (PxInsertionCallback*)pinsertionCallback);
					return ret;
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "PxCookSoftBodyMesh")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte PxCookSoftBodyMeshNative(PxCookingParams* @params, PxTetrahedronMeshDesc* simulationMeshDesc, PxTetrahedronMeshDesc* collisionMeshDesc, PxSoftBodySimulationDataDesc* softbodyDataDesc, PxOutputStream* stream);

		public static bool PxCookSoftBodyMesh( PxCookingParams* @params,  PxTetrahedronMeshDesc* simulationMeshDesc,  PxTetrahedronMeshDesc* collisionMeshDesc,  PxSoftBodySimulationDataDesc* softbodyDataDesc,  PxOutputStream* stream)
		{
			byte ret = PxCookSoftBodyMeshNative(@params, simulationMeshDesc, collisionMeshDesc, softbodyDataDesc, stream);
			return ret != 0;
		}

		public static bool PxCookSoftBodyMesh( PxCookingParams* @params,  ref PxTetrahedronMeshDesc simulationMeshDesc,  PxTetrahedronMeshDesc* collisionMeshDesc,  PxSoftBodySimulationDataDesc* softbodyDataDesc,  PxOutputStream* stream)
		{
			fixed (PxTetrahedronMeshDesc* psimulationMeshDesc = &simulationMeshDesc)
			{
				byte ret = PxCookSoftBodyMeshNative(@params, (PxTetrahedronMeshDesc*)psimulationMeshDesc, collisionMeshDesc, softbodyDataDesc, stream);
				return ret != 0;
			}
		}

		public static bool PxCookSoftBodyMesh( PxCookingParams* @params,  PxTetrahedronMeshDesc* simulationMeshDesc,  ref PxTetrahedronMeshDesc collisionMeshDesc,  PxSoftBodySimulationDataDesc* softbodyDataDesc,  PxOutputStream* stream)
		{
			fixed (PxTetrahedronMeshDesc* pcollisionMeshDesc = &collisionMeshDesc)
			{
				byte ret = PxCookSoftBodyMeshNative(@params, simulationMeshDesc, (PxTetrahedronMeshDesc*)pcollisionMeshDesc, softbodyDataDesc, stream);
				return ret != 0;
			}
		}

		public static bool PxCookSoftBodyMesh( PxCookingParams* @params,  ref PxTetrahedronMeshDesc simulationMeshDesc,  ref PxTetrahedronMeshDesc collisionMeshDesc,  PxSoftBodySimulationDataDesc* softbodyDataDesc,  PxOutputStream* stream)
		{
			fixed (PxTetrahedronMeshDesc* psimulationMeshDesc = &simulationMeshDesc)
			{
				fixed (PxTetrahedronMeshDesc* pcollisionMeshDesc = &collisionMeshDesc)
				{
					byte ret = PxCookSoftBodyMeshNative(@params, (PxTetrahedronMeshDesc*)psimulationMeshDesc, (PxTetrahedronMeshDesc*)pcollisionMeshDesc, softbodyDataDesc, stream);
					return ret != 0;
				}
			}
		}

		public static bool PxCookSoftBodyMesh( PxCookingParams* @params,  PxTetrahedronMeshDesc* simulationMeshDesc,  PxTetrahedronMeshDesc* collisionMeshDesc,  ref PxSoftBodySimulationDataDesc softbodyDataDesc,  PxOutputStream* stream)
		{
			fixed (PxSoftBodySimulationDataDesc* psoftbodyDataDesc = &softbodyDataDesc)
			{
				byte ret = PxCookSoftBodyMeshNative(@params, simulationMeshDesc, collisionMeshDesc, (PxSoftBodySimulationDataDesc*)psoftbodyDataDesc, stream);
				return ret != 0;
			}
		}

		public static bool PxCookSoftBodyMesh( PxCookingParams* @params,  ref PxTetrahedronMeshDesc simulationMeshDesc,  PxTetrahedronMeshDesc* collisionMeshDesc,  ref PxSoftBodySimulationDataDesc softbodyDataDesc,  PxOutputStream* stream)
		{
			fixed (PxTetrahedronMeshDesc* psimulationMeshDesc = &simulationMeshDesc)
			{
				fixed (PxSoftBodySimulationDataDesc* psoftbodyDataDesc = &softbodyDataDesc)
				{
					byte ret = PxCookSoftBodyMeshNative(@params, (PxTetrahedronMeshDesc*)psimulationMeshDesc, collisionMeshDesc, (PxSoftBodySimulationDataDesc*)psoftbodyDataDesc, stream);
					return ret != 0;
				}
			}
		}

		public static bool PxCookSoftBodyMesh( PxCookingParams* @params,  PxTetrahedronMeshDesc* simulationMeshDesc,  ref PxTetrahedronMeshDesc collisionMeshDesc,  ref PxSoftBodySimulationDataDesc softbodyDataDesc,  PxOutputStream* stream)
		{
			fixed (PxTetrahedronMeshDesc* pcollisionMeshDesc = &collisionMeshDesc)
			{
				fixed (PxSoftBodySimulationDataDesc* psoftbodyDataDesc = &softbodyDataDesc)
				{
					byte ret = PxCookSoftBodyMeshNative(@params, simulationMeshDesc, (PxTetrahedronMeshDesc*)pcollisionMeshDesc, (PxSoftBodySimulationDataDesc*)psoftbodyDataDesc, stream);
					return ret != 0;
				}
			}
		}

		public static bool PxCookSoftBodyMesh( PxCookingParams* @params,  ref PxTetrahedronMeshDesc simulationMeshDesc,  ref PxTetrahedronMeshDesc collisionMeshDesc,  ref PxSoftBodySimulationDataDesc softbodyDataDesc,  PxOutputStream* stream)
		{
			fixed (PxTetrahedronMeshDesc* psimulationMeshDesc = &simulationMeshDesc)
			{
				fixed (PxTetrahedronMeshDesc* pcollisionMeshDesc = &collisionMeshDesc)
				{
					fixed (PxSoftBodySimulationDataDesc* psoftbodyDataDesc = &softbodyDataDesc)
					{
						byte ret = PxCookSoftBodyMeshNative(@params, (PxTetrahedronMeshDesc*)psimulationMeshDesc, (PxTetrahedronMeshDesc*)pcollisionMeshDesc, (PxSoftBodySimulationDataDesc*)psoftbodyDataDesc, stream);
						return ret != 0;
					}
				}
			}
		}

		public static bool PxCookSoftBodyMesh( PxCookingParams* @params,  PxTetrahedronMeshDesc* simulationMeshDesc,  PxTetrahedronMeshDesc* collisionMeshDesc,  PxSoftBodySimulationDataDesc* softbodyDataDesc,  ref PxOutputStream stream)
		{
			fixed (PxOutputStream* pstream = &stream)
			{
				byte ret = PxCookSoftBodyMeshNative(@params, simulationMeshDesc, collisionMeshDesc, softbodyDataDesc, (PxOutputStream*)pstream);
				return ret != 0;
			}
		}

		public static bool PxCookSoftBodyMesh( PxCookingParams* @params,  ref PxTetrahedronMeshDesc simulationMeshDesc,  PxTetrahedronMeshDesc* collisionMeshDesc,  PxSoftBodySimulationDataDesc* softbodyDataDesc,  ref PxOutputStream stream)
		{
			fixed (PxTetrahedronMeshDesc* psimulationMeshDesc = &simulationMeshDesc)
			{
				fixed (PxOutputStream* pstream = &stream)
				{
					byte ret = PxCookSoftBodyMeshNative(@params, (PxTetrahedronMeshDesc*)psimulationMeshDesc, collisionMeshDesc, softbodyDataDesc, (PxOutputStream*)pstream);
					return ret != 0;
				}
			}
		}

		public static bool PxCookSoftBodyMesh( PxCookingParams* @params,  PxTetrahedronMeshDesc* simulationMeshDesc,  ref PxTetrahedronMeshDesc collisionMeshDesc,  PxSoftBodySimulationDataDesc* softbodyDataDesc,  ref PxOutputStream stream)
		{
			fixed (PxTetrahedronMeshDesc* pcollisionMeshDesc = &collisionMeshDesc)
			{
				fixed (PxOutputStream* pstream = &stream)
				{
					byte ret = PxCookSoftBodyMeshNative(@params, simulationMeshDesc, (PxTetrahedronMeshDesc*)pcollisionMeshDesc, softbodyDataDesc, (PxOutputStream*)pstream);
					return ret != 0;
				}
			}
		}

		public static bool PxCookSoftBodyMesh( PxCookingParams* @params,  ref PxTetrahedronMeshDesc simulationMeshDesc,  ref PxTetrahedronMeshDesc collisionMeshDesc,  PxSoftBodySimulationDataDesc* softbodyDataDesc,  ref PxOutputStream stream)
		{
			fixed (PxTetrahedronMeshDesc* psimulationMeshDesc = &simulationMeshDesc)
			{
				fixed (PxTetrahedronMeshDesc* pcollisionMeshDesc = &collisionMeshDesc)
				{
					fixed (PxOutputStream* pstream = &stream)
					{
						byte ret = PxCookSoftBodyMeshNative(@params, (PxTetrahedronMeshDesc*)psimulationMeshDesc, (PxTetrahedronMeshDesc*)pcollisionMeshDesc, softbodyDataDesc, (PxOutputStream*)pstream);
						return ret != 0;
					}
				}
			}
		}

		public static bool PxCookSoftBodyMesh( PxCookingParams* @params,  PxTetrahedronMeshDesc* simulationMeshDesc,  PxTetrahedronMeshDesc* collisionMeshDesc,  ref PxSoftBodySimulationDataDesc softbodyDataDesc,  ref PxOutputStream stream)
		{
			fixed (PxSoftBodySimulationDataDesc* psoftbodyDataDesc = &softbodyDataDesc)
			{
				fixed (PxOutputStream* pstream = &stream)
				{
					byte ret = PxCookSoftBodyMeshNative(@params, simulationMeshDesc, collisionMeshDesc, (PxSoftBodySimulationDataDesc*)psoftbodyDataDesc, (PxOutputStream*)pstream);
					return ret != 0;
				}
			}
		}

		public static bool PxCookSoftBodyMesh( PxCookingParams* @params,  ref PxTetrahedronMeshDesc simulationMeshDesc,  PxTetrahedronMeshDesc* collisionMeshDesc,  ref PxSoftBodySimulationDataDesc softbodyDataDesc,  ref PxOutputStream stream)
		{
			fixed (PxTetrahedronMeshDesc* psimulationMeshDesc = &simulationMeshDesc)
			{
				fixed (PxSoftBodySimulationDataDesc* psoftbodyDataDesc = &softbodyDataDesc)
				{
					fixed (PxOutputStream* pstream = &stream)
					{
						byte ret = PxCookSoftBodyMeshNative(@params, (PxTetrahedronMeshDesc*)psimulationMeshDesc, collisionMeshDesc, (PxSoftBodySimulationDataDesc*)psoftbodyDataDesc, (PxOutputStream*)pstream);
						return ret != 0;
					}
				}
			}
		}

		public static bool PxCookSoftBodyMesh( PxCookingParams* @params,  PxTetrahedronMeshDesc* simulationMeshDesc,  ref PxTetrahedronMeshDesc collisionMeshDesc,  ref PxSoftBodySimulationDataDesc softbodyDataDesc,  ref PxOutputStream stream)
		{
			fixed (PxTetrahedronMeshDesc* pcollisionMeshDesc = &collisionMeshDesc)
			{
				fixed (PxSoftBodySimulationDataDesc* psoftbodyDataDesc = &softbodyDataDesc)
				{
					fixed (PxOutputStream* pstream = &stream)
					{
						byte ret = PxCookSoftBodyMeshNative(@params, simulationMeshDesc, (PxTetrahedronMeshDesc*)pcollisionMeshDesc, (PxSoftBodySimulationDataDesc*)psoftbodyDataDesc, (PxOutputStream*)pstream);
						return ret != 0;
					}
				}
			}
		}

		public static bool PxCookSoftBodyMesh( PxCookingParams* @params,  ref PxTetrahedronMeshDesc simulationMeshDesc,  ref PxTetrahedronMeshDesc collisionMeshDesc,  ref PxSoftBodySimulationDataDesc softbodyDataDesc,  ref PxOutputStream stream)
		{
			fixed (PxTetrahedronMeshDesc* psimulationMeshDesc = &simulationMeshDesc)
			{
				fixed (PxTetrahedronMeshDesc* pcollisionMeshDesc = &collisionMeshDesc)
				{
					fixed (PxSoftBodySimulationDataDesc* psoftbodyDataDesc = &softbodyDataDesc)
					{
						fixed (PxOutputStream* pstream = &stream)
						{
							byte ret = PxCookSoftBodyMeshNative(@params, (PxTetrahedronMeshDesc*)psimulationMeshDesc, (PxTetrahedronMeshDesc*)pcollisionMeshDesc, (PxSoftBodySimulationDataDesc*)psoftbodyDataDesc, (PxOutputStream*)pstream);
							return ret != 0;
						}
					}
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "PxCreateSoftBodyMesh")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial PxSoftBodyMesh* PxCreateSoftBodyMeshNative(PxCookingParams* @params, PxTetrahedronMeshDesc* simulationMeshDesc, PxTetrahedronMeshDesc* collisionMeshDesc, PxSoftBodySimulationDataDesc* softbodyDataDesc, PxInsertionCallback* insertionCallback);

		public static PxSoftBodyMesh* PxCreateSoftBodyMesh( PxCookingParams* @params,  PxTetrahedronMeshDesc* simulationMeshDesc,  PxTetrahedronMeshDesc* collisionMeshDesc,  PxSoftBodySimulationDataDesc* softbodyDataDesc,  PxInsertionCallback* insertionCallback)
		{
			PxSoftBodyMesh* ret = PxCreateSoftBodyMeshNative(@params, simulationMeshDesc, collisionMeshDesc, softbodyDataDesc, insertionCallback);
			return ret;
		}

		public static PxSoftBodyMesh* PxCreateSoftBodyMesh( PxCookingParams* @params,  ref PxTetrahedronMeshDesc simulationMeshDesc,  PxTetrahedronMeshDesc* collisionMeshDesc,  PxSoftBodySimulationDataDesc* softbodyDataDesc,  PxInsertionCallback* insertionCallback)
		{
			fixed (PxTetrahedronMeshDesc* psimulationMeshDesc = &simulationMeshDesc)
			{
				PxSoftBodyMesh* ret = PxCreateSoftBodyMeshNative(@params, (PxTetrahedronMeshDesc*)psimulationMeshDesc, collisionMeshDesc, softbodyDataDesc, insertionCallback);
				return ret;
			}
		}

		public static PxSoftBodyMesh* PxCreateSoftBodyMesh( PxCookingParams* @params,  PxTetrahedronMeshDesc* simulationMeshDesc,  ref PxTetrahedronMeshDesc collisionMeshDesc,  PxSoftBodySimulationDataDesc* softbodyDataDesc,  PxInsertionCallback* insertionCallback)
		{
			fixed (PxTetrahedronMeshDesc* pcollisionMeshDesc = &collisionMeshDesc)
			{
				PxSoftBodyMesh* ret = PxCreateSoftBodyMeshNative(@params, simulationMeshDesc, (PxTetrahedronMeshDesc*)pcollisionMeshDesc, softbodyDataDesc, insertionCallback);
				return ret;
			}
		}

		public static PxSoftBodyMesh* PxCreateSoftBodyMesh( PxCookingParams* @params,  ref PxTetrahedronMeshDesc simulationMeshDesc,  ref PxTetrahedronMeshDesc collisionMeshDesc,  PxSoftBodySimulationDataDesc* softbodyDataDesc,  PxInsertionCallback* insertionCallback)
		{
			fixed (PxTetrahedronMeshDesc* psimulationMeshDesc = &simulationMeshDesc)
			{
				fixed (PxTetrahedronMeshDesc* pcollisionMeshDesc = &collisionMeshDesc)
				{
					PxSoftBodyMesh* ret = PxCreateSoftBodyMeshNative(@params, (PxTetrahedronMeshDesc*)psimulationMeshDesc, (PxTetrahedronMeshDesc*)pcollisionMeshDesc, softbodyDataDesc, insertionCallback);
					return ret;
				}
			}
		}

		public static PxSoftBodyMesh* PxCreateSoftBodyMesh( PxCookingParams* @params,  PxTetrahedronMeshDesc* simulationMeshDesc,  PxTetrahedronMeshDesc* collisionMeshDesc,  ref PxSoftBodySimulationDataDesc softbodyDataDesc,  PxInsertionCallback* insertionCallback)
		{
			fixed (PxSoftBodySimulationDataDesc* psoftbodyDataDesc = &softbodyDataDesc)
			{
				PxSoftBodyMesh* ret = PxCreateSoftBodyMeshNative(@params, simulationMeshDesc, collisionMeshDesc, (PxSoftBodySimulationDataDesc*)psoftbodyDataDesc, insertionCallback);
				return ret;
			}
		}

		public static PxSoftBodyMesh* PxCreateSoftBodyMesh( PxCookingParams* @params,  ref PxTetrahedronMeshDesc simulationMeshDesc,  PxTetrahedronMeshDesc* collisionMeshDesc,  ref PxSoftBodySimulationDataDesc softbodyDataDesc,  PxInsertionCallback* insertionCallback)
		{
			fixed (PxTetrahedronMeshDesc* psimulationMeshDesc = &simulationMeshDesc)
			{
				fixed (PxSoftBodySimulationDataDesc* psoftbodyDataDesc = &softbodyDataDesc)
				{
					PxSoftBodyMesh* ret = PxCreateSoftBodyMeshNative(@params, (PxTetrahedronMeshDesc*)psimulationMeshDesc, collisionMeshDesc, (PxSoftBodySimulationDataDesc*)psoftbodyDataDesc, insertionCallback);
					return ret;
				}
			}
		}

		public static PxSoftBodyMesh* PxCreateSoftBodyMesh( PxCookingParams* @params,  PxTetrahedronMeshDesc* simulationMeshDesc,  ref PxTetrahedronMeshDesc collisionMeshDesc,  ref PxSoftBodySimulationDataDesc softbodyDataDesc,  PxInsertionCallback* insertionCallback)
		{
			fixed (PxTetrahedronMeshDesc* pcollisionMeshDesc = &collisionMeshDesc)
			{
				fixed (PxSoftBodySimulationDataDesc* psoftbodyDataDesc = &softbodyDataDesc)
				{
					PxSoftBodyMesh* ret = PxCreateSoftBodyMeshNative(@params, simulationMeshDesc, (PxTetrahedronMeshDesc*)pcollisionMeshDesc, (PxSoftBodySimulationDataDesc*)psoftbodyDataDesc, insertionCallback);
					return ret;
				}
			}
		}

		public static PxSoftBodyMesh* PxCreateSoftBodyMesh( PxCookingParams* @params,  ref PxTetrahedronMeshDesc simulationMeshDesc,  ref PxTetrahedronMeshDesc collisionMeshDesc,  ref PxSoftBodySimulationDataDesc softbodyDataDesc,  PxInsertionCallback* insertionCallback)
		{
			fixed (PxTetrahedronMeshDesc* psimulationMeshDesc = &simulationMeshDesc)
			{
				fixed (PxTetrahedronMeshDesc* pcollisionMeshDesc = &collisionMeshDesc)
				{
					fixed (PxSoftBodySimulationDataDesc* psoftbodyDataDesc = &softbodyDataDesc)
					{
						PxSoftBodyMesh* ret = PxCreateSoftBodyMeshNative(@params, (PxTetrahedronMeshDesc*)psimulationMeshDesc, (PxTetrahedronMeshDesc*)pcollisionMeshDesc, (PxSoftBodySimulationDataDesc*)psoftbodyDataDesc, insertionCallback);
						return ret;
					}
				}
			}
		}

		public static PxSoftBodyMesh* PxCreateSoftBodyMesh( PxCookingParams* @params,  PxTetrahedronMeshDesc* simulationMeshDesc,  PxTetrahedronMeshDesc* collisionMeshDesc,  PxSoftBodySimulationDataDesc* softbodyDataDesc,  ref PxInsertionCallback insertionCallback)
		{
			fixed (PxInsertionCallback* pinsertionCallback = &insertionCallback)
			{
				PxSoftBodyMesh* ret = PxCreateSoftBodyMeshNative(@params, simulationMeshDesc, collisionMeshDesc, softbodyDataDesc, (PxInsertionCallback*)pinsertionCallback);
				return ret;
			}
		}

		public static PxSoftBodyMesh* PxCreateSoftBodyMesh( PxCookingParams* @params,  ref PxTetrahedronMeshDesc simulationMeshDesc,  PxTetrahedronMeshDesc* collisionMeshDesc,  PxSoftBodySimulationDataDesc* softbodyDataDesc,  ref PxInsertionCallback insertionCallback)
		{
			fixed (PxTetrahedronMeshDesc* psimulationMeshDesc = &simulationMeshDesc)
			{
				fixed (PxInsertionCallback* pinsertionCallback = &insertionCallback)
				{
					PxSoftBodyMesh* ret = PxCreateSoftBodyMeshNative(@params, (PxTetrahedronMeshDesc*)psimulationMeshDesc, collisionMeshDesc, softbodyDataDesc, (PxInsertionCallback*)pinsertionCallback);
					return ret;
				}
			}
		}

		public static PxSoftBodyMesh* PxCreateSoftBodyMesh( PxCookingParams* @params,  PxTetrahedronMeshDesc* simulationMeshDesc,  ref PxTetrahedronMeshDesc collisionMeshDesc,  PxSoftBodySimulationDataDesc* softbodyDataDesc,  ref PxInsertionCallback insertionCallback)
		{
			fixed (PxTetrahedronMeshDesc* pcollisionMeshDesc = &collisionMeshDesc)
			{
				fixed (PxInsertionCallback* pinsertionCallback = &insertionCallback)
				{
					PxSoftBodyMesh* ret = PxCreateSoftBodyMeshNative(@params, simulationMeshDesc, (PxTetrahedronMeshDesc*)pcollisionMeshDesc, softbodyDataDesc, (PxInsertionCallback*)pinsertionCallback);
					return ret;
				}
			}
		}

		public static PxSoftBodyMesh* PxCreateSoftBodyMesh( PxCookingParams* @params,  ref PxTetrahedronMeshDesc simulationMeshDesc,  ref PxTetrahedronMeshDesc collisionMeshDesc,  PxSoftBodySimulationDataDesc* softbodyDataDesc,  ref PxInsertionCallback insertionCallback)
		{
			fixed (PxTetrahedronMeshDesc* psimulationMeshDesc = &simulationMeshDesc)
			{
				fixed (PxTetrahedronMeshDesc* pcollisionMeshDesc = &collisionMeshDesc)
				{
					fixed (PxInsertionCallback* pinsertionCallback = &insertionCallback)
					{
						PxSoftBodyMesh* ret = PxCreateSoftBodyMeshNative(@params, (PxTetrahedronMeshDesc*)psimulationMeshDesc, (PxTetrahedronMeshDesc*)pcollisionMeshDesc, softbodyDataDesc, (PxInsertionCallback*)pinsertionCallback);
						return ret;
					}
				}
			}
		}

		public static PxSoftBodyMesh* PxCreateSoftBodyMesh( PxCookingParams* @params,  PxTetrahedronMeshDesc* simulationMeshDesc,  PxTetrahedronMeshDesc* collisionMeshDesc,  ref PxSoftBodySimulationDataDesc softbodyDataDesc,  ref PxInsertionCallback insertionCallback)
		{
			fixed (PxSoftBodySimulationDataDesc* psoftbodyDataDesc = &softbodyDataDesc)
			{
				fixed (PxInsertionCallback* pinsertionCallback = &insertionCallback)
				{
					PxSoftBodyMesh* ret = PxCreateSoftBodyMeshNative(@params, simulationMeshDesc, collisionMeshDesc, (PxSoftBodySimulationDataDesc*)psoftbodyDataDesc, (PxInsertionCallback*)pinsertionCallback);
					return ret;
				}
			}
		}

		public static PxSoftBodyMesh* PxCreateSoftBodyMesh( PxCookingParams* @params,  ref PxTetrahedronMeshDesc simulationMeshDesc,  PxTetrahedronMeshDesc* collisionMeshDesc,  ref PxSoftBodySimulationDataDesc softbodyDataDesc,  ref PxInsertionCallback insertionCallback)
		{
			fixed (PxTetrahedronMeshDesc* psimulationMeshDesc = &simulationMeshDesc)
			{
				fixed (PxSoftBodySimulationDataDesc* psoftbodyDataDesc = &softbodyDataDesc)
				{
					fixed (PxInsertionCallback* pinsertionCallback = &insertionCallback)
					{
						PxSoftBodyMesh* ret = PxCreateSoftBodyMeshNative(@params, (PxTetrahedronMeshDesc*)psimulationMeshDesc, collisionMeshDesc, (PxSoftBodySimulationDataDesc*)psoftbodyDataDesc, (PxInsertionCallback*)pinsertionCallback);
						return ret;
					}
				}
			}
		}

		public static PxSoftBodyMesh* PxCreateSoftBodyMesh( PxCookingParams* @params,  PxTetrahedronMeshDesc* simulationMeshDesc,  ref PxTetrahedronMeshDesc collisionMeshDesc,  ref PxSoftBodySimulationDataDesc softbodyDataDesc,  ref PxInsertionCallback insertionCallback)
		{
			fixed (PxTetrahedronMeshDesc* pcollisionMeshDesc = &collisionMeshDesc)
			{
				fixed (PxSoftBodySimulationDataDesc* psoftbodyDataDesc = &softbodyDataDesc)
				{
					fixed (PxInsertionCallback* pinsertionCallback = &insertionCallback)
					{
						PxSoftBodyMesh* ret = PxCreateSoftBodyMeshNative(@params, simulationMeshDesc, (PxTetrahedronMeshDesc*)pcollisionMeshDesc, (PxSoftBodySimulationDataDesc*)psoftbodyDataDesc, (PxInsertionCallback*)pinsertionCallback);
						return ret;
					}
				}
			}
		}

		public static PxSoftBodyMesh* PxCreateSoftBodyMesh( PxCookingParams* @params,  ref PxTetrahedronMeshDesc simulationMeshDesc,  ref PxTetrahedronMeshDesc collisionMeshDesc,  ref PxSoftBodySimulationDataDesc softbodyDataDesc,  ref PxInsertionCallback insertionCallback)
		{
			fixed (PxTetrahedronMeshDesc* psimulationMeshDesc = &simulationMeshDesc)
			{
				fixed (PxTetrahedronMeshDesc* pcollisionMeshDesc = &collisionMeshDesc)
				{
					fixed (PxSoftBodySimulationDataDesc* psoftbodyDataDesc = &softbodyDataDesc)
					{
						fixed (PxInsertionCallback* pinsertionCallback = &insertionCallback)
						{
							PxSoftBodyMesh* ret = PxCreateSoftBodyMeshNative(@params, (PxTetrahedronMeshDesc*)psimulationMeshDesc, (PxTetrahedronMeshDesc*)pcollisionMeshDesc, (PxSoftBodySimulationDataDesc*)psoftbodyDataDesc, (PxInsertionCallback*)pinsertionCallback);
							return ret;
						}
					}
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "PxComputeModelsMapping")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial PxCollisionMeshMappingData* PxComputeModelsMappingNative(PxCookingParams* @params, PxTetrahedronMeshData* simulationMesh, PxTetrahedronMeshData* collisionMesh, PxSoftBodyCollisionData* collisionData, PxBoundedData* vertexToTet);

		public static PxCollisionMeshMappingData* PxComputeModelsMapping( PxCookingParams* @params,  PxTetrahedronMeshData* simulationMesh,  PxTetrahedronMeshData* collisionMesh,  PxSoftBodyCollisionData* collisionData,  PxBoundedData* vertexToTet)
		{
			PxCollisionMeshMappingData* ret = PxComputeModelsMappingNative(@params, simulationMesh, collisionMesh, collisionData, vertexToTet);
			return ret;
		}

		public static PxCollisionMeshMappingData* PxComputeModelsMapping( PxCookingParams* @params,  ref PxTetrahedronMeshData simulationMesh,  PxTetrahedronMeshData* collisionMesh,  PxSoftBodyCollisionData* collisionData,  PxBoundedData* vertexToTet)
		{
			fixed (PxTetrahedronMeshData* psimulationMesh = &simulationMesh)
			{
				PxCollisionMeshMappingData* ret = PxComputeModelsMappingNative(@params, (PxTetrahedronMeshData*)psimulationMesh, collisionMesh, collisionData, vertexToTet);
				return ret;
			}
		}

		public static PxCollisionMeshMappingData* PxComputeModelsMapping( PxCookingParams* @params,  PxTetrahedronMeshData* simulationMesh,  ref PxTetrahedronMeshData collisionMesh,  PxSoftBodyCollisionData* collisionData,  PxBoundedData* vertexToTet)
		{
			fixed (PxTetrahedronMeshData* pcollisionMesh = &collisionMesh)
			{
				PxCollisionMeshMappingData* ret = PxComputeModelsMappingNative(@params, simulationMesh, (PxTetrahedronMeshData*)pcollisionMesh, collisionData, vertexToTet);
				return ret;
			}
		}

		public static PxCollisionMeshMappingData* PxComputeModelsMapping( PxCookingParams* @params,  ref PxTetrahedronMeshData simulationMesh,  ref PxTetrahedronMeshData collisionMesh,  PxSoftBodyCollisionData* collisionData,  PxBoundedData* vertexToTet)
		{
			fixed (PxTetrahedronMeshData* psimulationMesh = &simulationMesh)
			{
				fixed (PxTetrahedronMeshData* pcollisionMesh = &collisionMesh)
				{
					PxCollisionMeshMappingData* ret = PxComputeModelsMappingNative(@params, (PxTetrahedronMeshData*)psimulationMesh, (PxTetrahedronMeshData*)pcollisionMesh, collisionData, vertexToTet);
					return ret;
				}
			}
		}

		public static PxCollisionMeshMappingData* PxComputeModelsMapping( PxCookingParams* @params,  PxTetrahedronMeshData* simulationMesh,  PxTetrahedronMeshData* collisionMesh,  ref PxSoftBodyCollisionData collisionData,  PxBoundedData* vertexToTet)
		{
			fixed (PxSoftBodyCollisionData* pcollisionData = &collisionData)
			{
				PxCollisionMeshMappingData* ret = PxComputeModelsMappingNative(@params, simulationMesh, collisionMesh, (PxSoftBodyCollisionData*)pcollisionData, vertexToTet);
				return ret;
			}
		}

		public static PxCollisionMeshMappingData* PxComputeModelsMapping( PxCookingParams* @params,  ref PxTetrahedronMeshData simulationMesh,  PxTetrahedronMeshData* collisionMesh,  ref PxSoftBodyCollisionData collisionData,  PxBoundedData* vertexToTet)
		{
			fixed (PxTetrahedronMeshData* psimulationMesh = &simulationMesh)
			{
				fixed (PxSoftBodyCollisionData* pcollisionData = &collisionData)
				{
					PxCollisionMeshMappingData* ret = PxComputeModelsMappingNative(@params, (PxTetrahedronMeshData*)psimulationMesh, collisionMesh, (PxSoftBodyCollisionData*)pcollisionData, vertexToTet);
					return ret;
				}
			}
		}

		public static PxCollisionMeshMappingData* PxComputeModelsMapping( PxCookingParams* @params,  PxTetrahedronMeshData* simulationMesh,  ref PxTetrahedronMeshData collisionMesh,  ref PxSoftBodyCollisionData collisionData,  PxBoundedData* vertexToTet)
		{
			fixed (PxTetrahedronMeshData* pcollisionMesh = &collisionMesh)
			{
				fixed (PxSoftBodyCollisionData* pcollisionData = &collisionData)
				{
					PxCollisionMeshMappingData* ret = PxComputeModelsMappingNative(@params, simulationMesh, (PxTetrahedronMeshData*)pcollisionMesh, (PxSoftBodyCollisionData*)pcollisionData, vertexToTet);
					return ret;
				}
			}
		}

		public static PxCollisionMeshMappingData* PxComputeModelsMapping( PxCookingParams* @params,  ref PxTetrahedronMeshData simulationMesh,  ref PxTetrahedronMeshData collisionMesh,  ref PxSoftBodyCollisionData collisionData,  PxBoundedData* vertexToTet)
		{
			fixed (PxTetrahedronMeshData* psimulationMesh = &simulationMesh)
			{
				fixed (PxTetrahedronMeshData* pcollisionMesh = &collisionMesh)
				{
					fixed (PxSoftBodyCollisionData* pcollisionData = &collisionData)
					{
						PxCollisionMeshMappingData* ret = PxComputeModelsMappingNative(@params, (PxTetrahedronMeshData*)psimulationMesh, (PxTetrahedronMeshData*)pcollisionMesh, (PxSoftBodyCollisionData*)pcollisionData, vertexToTet);
						return ret;
					}
				}
			}
		}

		public static PxCollisionMeshMappingData* PxComputeModelsMapping( PxCookingParams* @params,  PxTetrahedronMeshData* simulationMesh,  PxTetrahedronMeshData* collisionMesh,  PxSoftBodyCollisionData* collisionData,  ref PxBoundedData vertexToTet)
		{
			fixed (PxBoundedData* pvertexToTet = &vertexToTet)
			{
				PxCollisionMeshMappingData* ret = PxComputeModelsMappingNative(@params, simulationMesh, collisionMesh, collisionData, (PxBoundedData*)pvertexToTet);
				return ret;
			}
		}

		public static PxCollisionMeshMappingData* PxComputeModelsMapping( PxCookingParams* @params,  ref PxTetrahedronMeshData simulationMesh,  PxTetrahedronMeshData* collisionMesh,  PxSoftBodyCollisionData* collisionData,  ref PxBoundedData vertexToTet)
		{
			fixed (PxTetrahedronMeshData* psimulationMesh = &simulationMesh)
			{
				fixed (PxBoundedData* pvertexToTet = &vertexToTet)
				{
					PxCollisionMeshMappingData* ret = PxComputeModelsMappingNative(@params, (PxTetrahedronMeshData*)psimulationMesh, collisionMesh, collisionData, (PxBoundedData*)pvertexToTet);
					return ret;
				}
			}
		}

		public static PxCollisionMeshMappingData* PxComputeModelsMapping( PxCookingParams* @params,  PxTetrahedronMeshData* simulationMesh,  ref PxTetrahedronMeshData collisionMesh,  PxSoftBodyCollisionData* collisionData,  ref PxBoundedData vertexToTet)
		{
			fixed (PxTetrahedronMeshData* pcollisionMesh = &collisionMesh)
			{
				fixed (PxBoundedData* pvertexToTet = &vertexToTet)
				{
					PxCollisionMeshMappingData* ret = PxComputeModelsMappingNative(@params, simulationMesh, (PxTetrahedronMeshData*)pcollisionMesh, collisionData, (PxBoundedData*)pvertexToTet);
					return ret;
				}
			}
		}

		public static PxCollisionMeshMappingData* PxComputeModelsMapping( PxCookingParams* @params,  ref PxTetrahedronMeshData simulationMesh,  ref PxTetrahedronMeshData collisionMesh,  PxSoftBodyCollisionData* collisionData,  ref PxBoundedData vertexToTet)
		{
			fixed (PxTetrahedronMeshData* psimulationMesh = &simulationMesh)
			{
				fixed (PxTetrahedronMeshData* pcollisionMesh = &collisionMesh)
				{
					fixed (PxBoundedData* pvertexToTet = &vertexToTet)
					{
						PxCollisionMeshMappingData* ret = PxComputeModelsMappingNative(@params, (PxTetrahedronMeshData*)psimulationMesh, (PxTetrahedronMeshData*)pcollisionMesh, collisionData, (PxBoundedData*)pvertexToTet);
						return ret;
					}
				}
			}
		}

		public static PxCollisionMeshMappingData* PxComputeModelsMapping( PxCookingParams* @params,  PxTetrahedronMeshData* simulationMesh,  PxTetrahedronMeshData* collisionMesh,  ref PxSoftBodyCollisionData collisionData,  ref PxBoundedData vertexToTet)
		{
			fixed (PxSoftBodyCollisionData* pcollisionData = &collisionData)
			{
				fixed (PxBoundedData* pvertexToTet = &vertexToTet)
				{
					PxCollisionMeshMappingData* ret = PxComputeModelsMappingNative(@params, simulationMesh, collisionMesh, (PxSoftBodyCollisionData*)pcollisionData, (PxBoundedData*)pvertexToTet);
					return ret;
				}
			}
		}

		public static PxCollisionMeshMappingData* PxComputeModelsMapping( PxCookingParams* @params,  ref PxTetrahedronMeshData simulationMesh,  PxTetrahedronMeshData* collisionMesh,  ref PxSoftBodyCollisionData collisionData,  ref PxBoundedData vertexToTet)
		{
			fixed (PxTetrahedronMeshData* psimulationMesh = &simulationMesh)
			{
				fixed (PxSoftBodyCollisionData* pcollisionData = &collisionData)
				{
					fixed (PxBoundedData* pvertexToTet = &vertexToTet)
					{
						PxCollisionMeshMappingData* ret = PxComputeModelsMappingNative(@params, (PxTetrahedronMeshData*)psimulationMesh, collisionMesh, (PxSoftBodyCollisionData*)pcollisionData, (PxBoundedData*)pvertexToTet);
						return ret;
					}
				}
			}
		}

		public static PxCollisionMeshMappingData* PxComputeModelsMapping( PxCookingParams* @params,  PxTetrahedronMeshData* simulationMesh,  ref PxTetrahedronMeshData collisionMesh,  ref PxSoftBodyCollisionData collisionData,  ref PxBoundedData vertexToTet)
		{
			fixed (PxTetrahedronMeshData* pcollisionMesh = &collisionMesh)
			{
				fixed (PxSoftBodyCollisionData* pcollisionData = &collisionData)
				{
					fixed (PxBoundedData* pvertexToTet = &vertexToTet)
					{
						PxCollisionMeshMappingData* ret = PxComputeModelsMappingNative(@params, simulationMesh, (PxTetrahedronMeshData*)pcollisionMesh, (PxSoftBodyCollisionData*)pcollisionData, (PxBoundedData*)pvertexToTet);
						return ret;
					}
				}
			}
		}

		public static PxCollisionMeshMappingData* PxComputeModelsMapping( PxCookingParams* @params,  ref PxTetrahedronMeshData simulationMesh,  ref PxTetrahedronMeshData collisionMesh,  ref PxSoftBodyCollisionData collisionData,  ref PxBoundedData vertexToTet)
		{
			fixed (PxTetrahedronMeshData* psimulationMesh = &simulationMesh)
			{
				fixed (PxTetrahedronMeshData* pcollisionMesh = &collisionMesh)
				{
					fixed (PxSoftBodyCollisionData* pcollisionData = &collisionData)
					{
						fixed (PxBoundedData* pvertexToTet = &vertexToTet)
						{
							PxCollisionMeshMappingData* ret = PxComputeModelsMappingNative(@params, (PxTetrahedronMeshData*)psimulationMesh, (PxTetrahedronMeshData*)pcollisionMesh, (PxSoftBodyCollisionData*)pcollisionData, (PxBoundedData*)pvertexToTet);
							return ret;
						}
					}
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "PxComputeCollisionData")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial PxCollisionTetrahedronMeshData* PxComputeCollisionDataNative(PxCookingParams* @params, PxTetrahedronMeshDesc* collisionMeshDesc);

		public static PxCollisionTetrahedronMeshData* PxComputeCollisionData( PxCookingParams* @params,  PxTetrahedronMeshDesc* collisionMeshDesc)
		{
			PxCollisionTetrahedronMeshData* ret = PxComputeCollisionDataNative(@params, collisionMeshDesc);
			return ret;
		}

		public static PxCollisionTetrahedronMeshData* PxComputeCollisionData( PxCookingParams* @params,  ref PxTetrahedronMeshDesc collisionMeshDesc)
		{
			fixed (PxTetrahedronMeshDesc* pcollisionMeshDesc = &collisionMeshDesc)
			{
				PxCollisionTetrahedronMeshData* ret = PxComputeCollisionDataNative(@params, (PxTetrahedronMeshDesc*)pcollisionMeshDesc);
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "PxComputeSimulationData")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial PxSimulationTetrahedronMeshData* PxComputeSimulationDataNative(PxCookingParams* @params, PxTetrahedronMeshDesc* simulationMeshDesc);

		public static PxSimulationTetrahedronMeshData* PxComputeSimulationData( PxCookingParams* @params,  PxTetrahedronMeshDesc* simulationMeshDesc)
		{
			PxSimulationTetrahedronMeshData* ret = PxComputeSimulationDataNative(@params, simulationMeshDesc);
			return ret;
		}

		public static PxSimulationTetrahedronMeshData* PxComputeSimulationData( PxCookingParams* @params,  ref PxTetrahedronMeshDesc simulationMeshDesc)
		{
			fixed (PxTetrahedronMeshDesc* psimulationMeshDesc = &simulationMeshDesc)
			{
				PxSimulationTetrahedronMeshData* ret = PxComputeSimulationDataNative(@params, (PxTetrahedronMeshDesc*)psimulationMeshDesc);
				return ret;
			}
		}

		[LibraryImport(LibName, EntryPoint = "PxAssembleSoftBodyMesh")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial PxSoftBodyMesh* PxAssembleSoftBodyMeshNative(PxTetrahedronMeshData* simulationMesh, PxSoftBodySimulationData* simulationData, PxTetrahedronMeshData* collisionMesh, PxSoftBodyCollisionData* collisionData, PxCollisionMeshMappingData* mappingData, PxInsertionCallback* insertionCallback);

		public static PxSoftBodyMesh* PxAssembleSoftBodyMesh( PxTetrahedronMeshData* simulationMesh,  PxSoftBodySimulationData* simulationData,  PxTetrahedronMeshData* collisionMesh,  PxSoftBodyCollisionData* collisionData,  PxCollisionMeshMappingData* mappingData,  PxInsertionCallback* insertionCallback)
		{
			PxSoftBodyMesh* ret = PxAssembleSoftBodyMeshNative(simulationMesh, simulationData, collisionMesh, collisionData, mappingData, insertionCallback);
			return ret;
		}

		public static PxSoftBodyMesh* PxAssembleSoftBodyMesh( PxTetrahedronMeshData* simulationMesh,  ref PxSoftBodySimulationData simulationData,  PxTetrahedronMeshData* collisionMesh,  PxSoftBodyCollisionData* collisionData,  PxCollisionMeshMappingData* mappingData,  PxInsertionCallback* insertionCallback)
		{
			fixed (PxSoftBodySimulationData* psimulationData = &simulationData)
			{
				PxSoftBodyMesh* ret = PxAssembleSoftBodyMeshNative(simulationMesh, (PxSoftBodySimulationData*)psimulationData, collisionMesh, collisionData, mappingData, insertionCallback);
				return ret;
			}
		}

		public static PxSoftBodyMesh* PxAssembleSoftBodyMesh( PxTetrahedronMeshData* simulationMesh,  PxSoftBodySimulationData* simulationData,  ref PxTetrahedronMeshData collisionMesh,  PxSoftBodyCollisionData* collisionData,  PxCollisionMeshMappingData* mappingData,  PxInsertionCallback* insertionCallback)
		{
			fixed (PxTetrahedronMeshData* pcollisionMesh = &collisionMesh)
			{
				PxSoftBodyMesh* ret = PxAssembleSoftBodyMeshNative(simulationMesh, simulationData, (PxTetrahedronMeshData*)pcollisionMesh, collisionData, mappingData, insertionCallback);
				return ret;
			}
		}

		public static PxSoftBodyMesh* PxAssembleSoftBodyMesh( PxTetrahedronMeshData* simulationMesh,  ref PxSoftBodySimulationData simulationData,  ref PxTetrahedronMeshData collisionMesh,  PxSoftBodyCollisionData* collisionData,  PxCollisionMeshMappingData* mappingData,  PxInsertionCallback* insertionCallback)
		{
			fixed (PxSoftBodySimulationData* psimulationData = &simulationData)
			{
				fixed (PxTetrahedronMeshData* pcollisionMesh = &collisionMesh)
				{
					PxSoftBodyMesh* ret = PxAssembleSoftBodyMeshNative(simulationMesh, (PxSoftBodySimulationData*)psimulationData, (PxTetrahedronMeshData*)pcollisionMesh, collisionData, mappingData, insertionCallback);
					return ret;
				}
			}
		}

		public static PxSoftBodyMesh* PxAssembleSoftBodyMesh( PxTetrahedronMeshData* simulationMesh,  PxSoftBodySimulationData* simulationData,  PxTetrahedronMeshData* collisionMesh,  ref PxSoftBodyCollisionData collisionData,  PxCollisionMeshMappingData* mappingData,  PxInsertionCallback* insertionCallback)
		{
			fixed (PxSoftBodyCollisionData* pcollisionData = &collisionData)
			{
				PxSoftBodyMesh* ret = PxAssembleSoftBodyMeshNative(simulationMesh, simulationData, collisionMesh, (PxSoftBodyCollisionData*)pcollisionData, mappingData, insertionCallback);
				return ret;
			}
		}

		public static PxSoftBodyMesh* PxAssembleSoftBodyMesh( PxTetrahedronMeshData* simulationMesh,  ref PxSoftBodySimulationData simulationData,  PxTetrahedronMeshData* collisionMesh,  ref PxSoftBodyCollisionData collisionData,  PxCollisionMeshMappingData* mappingData,  PxInsertionCallback* insertionCallback)
		{
			fixed (PxSoftBodySimulationData* psimulationData = &simulationData)
			{
				fixed (PxSoftBodyCollisionData* pcollisionData = &collisionData)
				{
					PxSoftBodyMesh* ret = PxAssembleSoftBodyMeshNative(simulationMesh, (PxSoftBodySimulationData*)psimulationData, collisionMesh, (PxSoftBodyCollisionData*)pcollisionData, mappingData, insertionCallback);
					return ret;
				}
			}
		}

		public static PxSoftBodyMesh* PxAssembleSoftBodyMesh( PxTetrahedronMeshData* simulationMesh,  PxSoftBodySimulationData* simulationData,  ref PxTetrahedronMeshData collisionMesh,  ref PxSoftBodyCollisionData collisionData,  PxCollisionMeshMappingData* mappingData,  PxInsertionCallback* insertionCallback)
		{
			fixed (PxTetrahedronMeshData* pcollisionMesh = &collisionMesh)
			{
				fixed (PxSoftBodyCollisionData* pcollisionData = &collisionData)
				{
					PxSoftBodyMesh* ret = PxAssembleSoftBodyMeshNative(simulationMesh, simulationData, (PxTetrahedronMeshData*)pcollisionMesh, (PxSoftBodyCollisionData*)pcollisionData, mappingData, insertionCallback);
					return ret;
				}
			}
		}

		public static PxSoftBodyMesh* PxAssembleSoftBodyMesh( PxTetrahedronMeshData* simulationMesh,  ref PxSoftBodySimulationData simulationData,  ref PxTetrahedronMeshData collisionMesh,  ref PxSoftBodyCollisionData collisionData,  PxCollisionMeshMappingData* mappingData,  PxInsertionCallback* insertionCallback)
		{
			fixed (PxSoftBodySimulationData* psimulationData = &simulationData)
			{
				fixed (PxTetrahedronMeshData* pcollisionMesh = &collisionMesh)
				{
					fixed (PxSoftBodyCollisionData* pcollisionData = &collisionData)
					{
						PxSoftBodyMesh* ret = PxAssembleSoftBodyMeshNative(simulationMesh, (PxSoftBodySimulationData*)psimulationData, (PxTetrahedronMeshData*)pcollisionMesh, (PxSoftBodyCollisionData*)pcollisionData, mappingData, insertionCallback);
						return ret;
					}
				}
			}
		}

		public static PxSoftBodyMesh* PxAssembleSoftBodyMesh( PxTetrahedronMeshData* simulationMesh,  PxSoftBodySimulationData* simulationData,  PxTetrahedronMeshData* collisionMesh,  PxSoftBodyCollisionData* collisionData,  ref PxCollisionMeshMappingData mappingData,  PxInsertionCallback* insertionCallback)
		{
			fixed (PxCollisionMeshMappingData* pmappingData = &mappingData)
			{
				PxSoftBodyMesh* ret = PxAssembleSoftBodyMeshNative(simulationMesh, simulationData, collisionMesh, collisionData, (PxCollisionMeshMappingData*)pmappingData, insertionCallback);
				return ret;
			}
		}

		public static PxSoftBodyMesh* PxAssembleSoftBodyMesh( PxTetrahedronMeshData* simulationMesh,  ref PxSoftBodySimulationData simulationData,  PxTetrahedronMeshData* collisionMesh,  PxSoftBodyCollisionData* collisionData,  ref PxCollisionMeshMappingData mappingData,  PxInsertionCallback* insertionCallback)
		{
			fixed (PxSoftBodySimulationData* psimulationData = &simulationData)
			{
				fixed (PxCollisionMeshMappingData* pmappingData = &mappingData)
				{
					PxSoftBodyMesh* ret = PxAssembleSoftBodyMeshNative(simulationMesh, (PxSoftBodySimulationData*)psimulationData, collisionMesh, collisionData, (PxCollisionMeshMappingData*)pmappingData, insertionCallback);
					return ret;
				}
			}
		}

		public static PxSoftBodyMesh* PxAssembleSoftBodyMesh( PxTetrahedronMeshData* simulationMesh,  PxSoftBodySimulationData* simulationData,  ref PxTetrahedronMeshData collisionMesh,  PxSoftBodyCollisionData* collisionData,  ref PxCollisionMeshMappingData mappingData,  PxInsertionCallback* insertionCallback)
		{
			fixed (PxTetrahedronMeshData* pcollisionMesh = &collisionMesh)
			{
				fixed (PxCollisionMeshMappingData* pmappingData = &mappingData)
				{
					PxSoftBodyMesh* ret = PxAssembleSoftBodyMeshNative(simulationMesh, simulationData, (PxTetrahedronMeshData*)pcollisionMesh, collisionData, (PxCollisionMeshMappingData*)pmappingData, insertionCallback);
					return ret;
				}
			}
		}

		public static PxSoftBodyMesh* PxAssembleSoftBodyMesh( PxTetrahedronMeshData* simulationMesh,  ref PxSoftBodySimulationData simulationData,  ref PxTetrahedronMeshData collisionMesh,  PxSoftBodyCollisionData* collisionData,  ref PxCollisionMeshMappingData mappingData,  PxInsertionCallback* insertionCallback)
		{
			fixed (PxSoftBodySimulationData* psimulationData = &simulationData)
			{
				fixed (PxTetrahedronMeshData* pcollisionMesh = &collisionMesh)
				{
					fixed (PxCollisionMeshMappingData* pmappingData = &mappingData)
					{
						PxSoftBodyMesh* ret = PxAssembleSoftBodyMeshNative(simulationMesh, (PxSoftBodySimulationData*)psimulationData, (PxTetrahedronMeshData*)pcollisionMesh, collisionData, (PxCollisionMeshMappingData*)pmappingData, insertionCallback);
						return ret;
					}
				}
			}
		}

		public static PxSoftBodyMesh* PxAssembleSoftBodyMesh( PxTetrahedronMeshData* simulationMesh,  PxSoftBodySimulationData* simulationData,  PxTetrahedronMeshData* collisionMesh,  ref PxSoftBodyCollisionData collisionData,  ref PxCollisionMeshMappingData mappingData,  PxInsertionCallback* insertionCallback)
		{
			fixed (PxSoftBodyCollisionData* pcollisionData = &collisionData)
			{
				fixed (PxCollisionMeshMappingData* pmappingData = &mappingData)
				{
					PxSoftBodyMesh* ret = PxAssembleSoftBodyMeshNative(simulationMesh, simulationData, collisionMesh, (PxSoftBodyCollisionData*)pcollisionData, (PxCollisionMeshMappingData*)pmappingData, insertionCallback);
					return ret;
				}
			}
		}

		public static PxSoftBodyMesh* PxAssembleSoftBodyMesh( PxTetrahedronMeshData* simulationMesh,  ref PxSoftBodySimulationData simulationData,  PxTetrahedronMeshData* collisionMesh,  ref PxSoftBodyCollisionData collisionData,  ref PxCollisionMeshMappingData mappingData,  PxInsertionCallback* insertionCallback)
		{
			fixed (PxSoftBodySimulationData* psimulationData = &simulationData)
			{
				fixed (PxSoftBodyCollisionData* pcollisionData = &collisionData)
				{
					fixed (PxCollisionMeshMappingData* pmappingData = &mappingData)
					{
						PxSoftBodyMesh* ret = PxAssembleSoftBodyMeshNative(simulationMesh, (PxSoftBodySimulationData*)psimulationData, collisionMesh, (PxSoftBodyCollisionData*)pcollisionData, (PxCollisionMeshMappingData*)pmappingData, insertionCallback);
						return ret;
					}
				}
			}
		}

		public static PxSoftBodyMesh* PxAssembleSoftBodyMesh( PxTetrahedronMeshData* simulationMesh,  PxSoftBodySimulationData* simulationData,  ref PxTetrahedronMeshData collisionMesh,  ref PxSoftBodyCollisionData collisionData,  ref PxCollisionMeshMappingData mappingData,  PxInsertionCallback* insertionCallback)
		{
			fixed (PxTetrahedronMeshData* pcollisionMesh = &collisionMesh)
			{
				fixed (PxSoftBodyCollisionData* pcollisionData = &collisionData)
				{
					fixed (PxCollisionMeshMappingData* pmappingData = &mappingData)
					{
						PxSoftBodyMesh* ret = PxAssembleSoftBodyMeshNative(simulationMesh, simulationData, (PxTetrahedronMeshData*)pcollisionMesh, (PxSoftBodyCollisionData*)pcollisionData, (PxCollisionMeshMappingData*)pmappingData, insertionCallback);
						return ret;
					}
				}
			}
		}

		public static PxSoftBodyMesh* PxAssembleSoftBodyMesh( PxTetrahedronMeshData* simulationMesh,  ref PxSoftBodySimulationData simulationData,  ref PxTetrahedronMeshData collisionMesh,  ref PxSoftBodyCollisionData collisionData,  ref PxCollisionMeshMappingData mappingData,  PxInsertionCallback* insertionCallback)
		{
			fixed (PxSoftBodySimulationData* psimulationData = &simulationData)
			{
				fixed (PxTetrahedronMeshData* pcollisionMesh = &collisionMesh)
				{
					fixed (PxSoftBodyCollisionData* pcollisionData = &collisionData)
					{
						fixed (PxCollisionMeshMappingData* pmappingData = &mappingData)
						{
							PxSoftBodyMesh* ret = PxAssembleSoftBodyMeshNative(simulationMesh, (PxSoftBodySimulationData*)psimulationData, (PxTetrahedronMeshData*)pcollisionMesh, (PxSoftBodyCollisionData*)pcollisionData, (PxCollisionMeshMappingData*)pmappingData, insertionCallback);
							return ret;
						}
					}
				}
			}
		}

		public static PxSoftBodyMesh* PxAssembleSoftBodyMesh( PxTetrahedronMeshData* simulationMesh,  PxSoftBodySimulationData* simulationData,  PxTetrahedronMeshData* collisionMesh,  PxSoftBodyCollisionData* collisionData,  PxCollisionMeshMappingData* mappingData,  ref PxInsertionCallback insertionCallback)
		{
			fixed (PxInsertionCallback* pinsertionCallback = &insertionCallback)
			{
				PxSoftBodyMesh* ret = PxAssembleSoftBodyMeshNative(simulationMesh, simulationData, collisionMesh, collisionData, mappingData, (PxInsertionCallback*)pinsertionCallback);
				return ret;
			}
		}

		public static PxSoftBodyMesh* PxAssembleSoftBodyMesh( PxTetrahedronMeshData* simulationMesh,  ref PxSoftBodySimulationData simulationData,  PxTetrahedronMeshData* collisionMesh,  PxSoftBodyCollisionData* collisionData,  PxCollisionMeshMappingData* mappingData,  ref PxInsertionCallback insertionCallback)
		{
			fixed (PxSoftBodySimulationData* psimulationData = &simulationData)
			{
				fixed (PxInsertionCallback* pinsertionCallback = &insertionCallback)
				{
					PxSoftBodyMesh* ret = PxAssembleSoftBodyMeshNative(simulationMesh, (PxSoftBodySimulationData*)psimulationData, collisionMesh, collisionData, mappingData, (PxInsertionCallback*)pinsertionCallback);
					return ret;
				}
			}
		}

		public static PxSoftBodyMesh* PxAssembleSoftBodyMesh( PxTetrahedronMeshData* simulationMesh,  PxSoftBodySimulationData* simulationData,  ref PxTetrahedronMeshData collisionMesh,  PxSoftBodyCollisionData* collisionData,  PxCollisionMeshMappingData* mappingData,  ref PxInsertionCallback insertionCallback)
		{
			fixed (PxTetrahedronMeshData* pcollisionMesh = &collisionMesh)
			{
				fixed (PxInsertionCallback* pinsertionCallback = &insertionCallback)
				{
					PxSoftBodyMesh* ret = PxAssembleSoftBodyMeshNative(simulationMesh, simulationData, (PxTetrahedronMeshData*)pcollisionMesh, collisionData, mappingData, (PxInsertionCallback*)pinsertionCallback);
					return ret;
				}
			}
		}

		public static PxSoftBodyMesh* PxAssembleSoftBodyMesh( PxTetrahedronMeshData* simulationMesh,  ref PxSoftBodySimulationData simulationData,  ref PxTetrahedronMeshData collisionMesh,  PxSoftBodyCollisionData* collisionData,  PxCollisionMeshMappingData* mappingData,  ref PxInsertionCallback insertionCallback)
		{
			fixed (PxSoftBodySimulationData* psimulationData = &simulationData)
			{
				fixed (PxTetrahedronMeshData* pcollisionMesh = &collisionMesh)
				{
					fixed (PxInsertionCallback* pinsertionCallback = &insertionCallback)
					{
						PxSoftBodyMesh* ret = PxAssembleSoftBodyMeshNative(simulationMesh, (PxSoftBodySimulationData*)psimulationData, (PxTetrahedronMeshData*)pcollisionMesh, collisionData, mappingData, (PxInsertionCallback*)pinsertionCallback);
						return ret;
					}
				}
			}
		}

		public static PxSoftBodyMesh* PxAssembleSoftBodyMesh( PxTetrahedronMeshData* simulationMesh,  PxSoftBodySimulationData* simulationData,  PxTetrahedronMeshData* collisionMesh,  ref PxSoftBodyCollisionData collisionData,  PxCollisionMeshMappingData* mappingData,  ref PxInsertionCallback insertionCallback)
		{
			fixed (PxSoftBodyCollisionData* pcollisionData = &collisionData)
			{
				fixed (PxInsertionCallback* pinsertionCallback = &insertionCallback)
				{
					PxSoftBodyMesh* ret = PxAssembleSoftBodyMeshNative(simulationMesh, simulationData, collisionMesh, (PxSoftBodyCollisionData*)pcollisionData, mappingData, (PxInsertionCallback*)pinsertionCallback);
					return ret;
				}
			}
		}

		public static PxSoftBodyMesh* PxAssembleSoftBodyMesh( PxTetrahedronMeshData* simulationMesh,  ref PxSoftBodySimulationData simulationData,  PxTetrahedronMeshData* collisionMesh,  ref PxSoftBodyCollisionData collisionData,  PxCollisionMeshMappingData* mappingData,  ref PxInsertionCallback insertionCallback)
		{
			fixed (PxSoftBodySimulationData* psimulationData = &simulationData)
			{
				fixed (PxSoftBodyCollisionData* pcollisionData = &collisionData)
				{
					fixed (PxInsertionCallback* pinsertionCallback = &insertionCallback)
					{
						PxSoftBodyMesh* ret = PxAssembleSoftBodyMeshNative(simulationMesh, (PxSoftBodySimulationData*)psimulationData, collisionMesh, (PxSoftBodyCollisionData*)pcollisionData, mappingData, (PxInsertionCallback*)pinsertionCallback);
						return ret;
					}
				}
			}
		}

		public static PxSoftBodyMesh* PxAssembleSoftBodyMesh( PxTetrahedronMeshData* simulationMesh,  PxSoftBodySimulationData* simulationData,  ref PxTetrahedronMeshData collisionMesh,  ref PxSoftBodyCollisionData collisionData,  PxCollisionMeshMappingData* mappingData,  ref PxInsertionCallback insertionCallback)
		{
			fixed (PxTetrahedronMeshData* pcollisionMesh = &collisionMesh)
			{
				fixed (PxSoftBodyCollisionData* pcollisionData = &collisionData)
				{
					fixed (PxInsertionCallback* pinsertionCallback = &insertionCallback)
					{
						PxSoftBodyMesh* ret = PxAssembleSoftBodyMeshNative(simulationMesh, simulationData, (PxTetrahedronMeshData*)pcollisionMesh, (PxSoftBodyCollisionData*)pcollisionData, mappingData, (PxInsertionCallback*)pinsertionCallback);
						return ret;
					}
				}
			}
		}

		public static PxSoftBodyMesh* PxAssembleSoftBodyMesh( PxTetrahedronMeshData* simulationMesh,  ref PxSoftBodySimulationData simulationData,  ref PxTetrahedronMeshData collisionMesh,  ref PxSoftBodyCollisionData collisionData,  PxCollisionMeshMappingData* mappingData,  ref PxInsertionCallback insertionCallback)
		{
			fixed (PxSoftBodySimulationData* psimulationData = &simulationData)
			{
				fixed (PxTetrahedronMeshData* pcollisionMesh = &collisionMesh)
				{
					fixed (PxSoftBodyCollisionData* pcollisionData = &collisionData)
					{
						fixed (PxInsertionCallback* pinsertionCallback = &insertionCallback)
						{
							PxSoftBodyMesh* ret = PxAssembleSoftBodyMeshNative(simulationMesh, (PxSoftBodySimulationData*)psimulationData, (PxTetrahedronMeshData*)pcollisionMesh, (PxSoftBodyCollisionData*)pcollisionData, mappingData, (PxInsertionCallback*)pinsertionCallback);
							return ret;
						}
					}
				}
			}
		}

		public static PxSoftBodyMesh* PxAssembleSoftBodyMesh( PxTetrahedronMeshData* simulationMesh,  PxSoftBodySimulationData* simulationData,  PxTetrahedronMeshData* collisionMesh,  PxSoftBodyCollisionData* collisionData,  ref PxCollisionMeshMappingData mappingData,  ref PxInsertionCallback insertionCallback)
		{
			fixed (PxCollisionMeshMappingData* pmappingData = &mappingData)
			{
				fixed (PxInsertionCallback* pinsertionCallback = &insertionCallback)
				{
					PxSoftBodyMesh* ret = PxAssembleSoftBodyMeshNative(simulationMesh, simulationData, collisionMesh, collisionData, (PxCollisionMeshMappingData*)pmappingData, (PxInsertionCallback*)pinsertionCallback);
					return ret;
				}
			}
		}

		public static PxSoftBodyMesh* PxAssembleSoftBodyMesh( PxTetrahedronMeshData* simulationMesh,  ref PxSoftBodySimulationData simulationData,  PxTetrahedronMeshData* collisionMesh,  PxSoftBodyCollisionData* collisionData,  ref PxCollisionMeshMappingData mappingData,  ref PxInsertionCallback insertionCallback)
		{
			fixed (PxSoftBodySimulationData* psimulationData = &simulationData)
			{
				fixed (PxCollisionMeshMappingData* pmappingData = &mappingData)
				{
					fixed (PxInsertionCallback* pinsertionCallback = &insertionCallback)
					{
						PxSoftBodyMesh* ret = PxAssembleSoftBodyMeshNative(simulationMesh, (PxSoftBodySimulationData*)psimulationData, collisionMesh, collisionData, (PxCollisionMeshMappingData*)pmappingData, (PxInsertionCallback*)pinsertionCallback);
						return ret;
					}
				}
			}
		}

		public static PxSoftBodyMesh* PxAssembleSoftBodyMesh( PxTetrahedronMeshData* simulationMesh,  PxSoftBodySimulationData* simulationData,  ref PxTetrahedronMeshData collisionMesh,  PxSoftBodyCollisionData* collisionData,  ref PxCollisionMeshMappingData mappingData,  ref PxInsertionCallback insertionCallback)
		{
			fixed (PxTetrahedronMeshData* pcollisionMesh = &collisionMesh)
			{
				fixed (PxCollisionMeshMappingData* pmappingData = &mappingData)
				{
					fixed (PxInsertionCallback* pinsertionCallback = &insertionCallback)
					{
						PxSoftBodyMesh* ret = PxAssembleSoftBodyMeshNative(simulationMesh, simulationData, (PxTetrahedronMeshData*)pcollisionMesh, collisionData, (PxCollisionMeshMappingData*)pmappingData, (PxInsertionCallback*)pinsertionCallback);
						return ret;
					}
				}
			}
		}

		public static PxSoftBodyMesh* PxAssembleSoftBodyMesh( PxTetrahedronMeshData* simulationMesh,  ref PxSoftBodySimulationData simulationData,  ref PxTetrahedronMeshData collisionMesh,  PxSoftBodyCollisionData* collisionData,  ref PxCollisionMeshMappingData mappingData,  ref PxInsertionCallback insertionCallback)
		{
			fixed (PxSoftBodySimulationData* psimulationData = &simulationData)
			{
				fixed (PxTetrahedronMeshData* pcollisionMesh = &collisionMesh)
				{
					fixed (PxCollisionMeshMappingData* pmappingData = &mappingData)
					{
						fixed (PxInsertionCallback* pinsertionCallback = &insertionCallback)
						{
							PxSoftBodyMesh* ret = PxAssembleSoftBodyMeshNative(simulationMesh, (PxSoftBodySimulationData*)psimulationData, (PxTetrahedronMeshData*)pcollisionMesh, collisionData, (PxCollisionMeshMappingData*)pmappingData, (PxInsertionCallback*)pinsertionCallback);
							return ret;
						}
					}
				}
			}
		}

		public static PxSoftBodyMesh* PxAssembleSoftBodyMesh( PxTetrahedronMeshData* simulationMesh,  PxSoftBodySimulationData* simulationData,  PxTetrahedronMeshData* collisionMesh,  ref PxSoftBodyCollisionData collisionData,  ref PxCollisionMeshMappingData mappingData,  ref PxInsertionCallback insertionCallback)
		{
			fixed (PxSoftBodyCollisionData* pcollisionData = &collisionData)
			{
				fixed (PxCollisionMeshMappingData* pmappingData = &mappingData)
				{
					fixed (PxInsertionCallback* pinsertionCallback = &insertionCallback)
					{
						PxSoftBodyMesh* ret = PxAssembleSoftBodyMeshNative(simulationMesh, simulationData, collisionMesh, (PxSoftBodyCollisionData*)pcollisionData, (PxCollisionMeshMappingData*)pmappingData, (PxInsertionCallback*)pinsertionCallback);
						return ret;
					}
				}
			}
		}

		public static PxSoftBodyMesh* PxAssembleSoftBodyMesh( PxTetrahedronMeshData* simulationMesh,  ref PxSoftBodySimulationData simulationData,  PxTetrahedronMeshData* collisionMesh,  ref PxSoftBodyCollisionData collisionData,  ref PxCollisionMeshMappingData mappingData,  ref PxInsertionCallback insertionCallback)
		{
			fixed (PxSoftBodySimulationData* psimulationData = &simulationData)
			{
				fixed (PxSoftBodyCollisionData* pcollisionData = &collisionData)
				{
					fixed (PxCollisionMeshMappingData* pmappingData = &mappingData)
					{
						fixed (PxInsertionCallback* pinsertionCallback = &insertionCallback)
						{
							PxSoftBodyMesh* ret = PxAssembleSoftBodyMeshNative(simulationMesh, (PxSoftBodySimulationData*)psimulationData, collisionMesh, (PxSoftBodyCollisionData*)pcollisionData, (PxCollisionMeshMappingData*)pmappingData, (PxInsertionCallback*)pinsertionCallback);
							return ret;
						}
					}
				}
			}
		}

		public static PxSoftBodyMesh* PxAssembleSoftBodyMesh( PxTetrahedronMeshData* simulationMesh,  PxSoftBodySimulationData* simulationData,  ref PxTetrahedronMeshData collisionMesh,  ref PxSoftBodyCollisionData collisionData,  ref PxCollisionMeshMappingData mappingData,  ref PxInsertionCallback insertionCallback)
		{
			fixed (PxTetrahedronMeshData* pcollisionMesh = &collisionMesh)
			{
				fixed (PxSoftBodyCollisionData* pcollisionData = &collisionData)
				{
					fixed (PxCollisionMeshMappingData* pmappingData = &mappingData)
					{
						fixed (PxInsertionCallback* pinsertionCallback = &insertionCallback)
						{
							PxSoftBodyMesh* ret = PxAssembleSoftBodyMeshNative(simulationMesh, simulationData, (PxTetrahedronMeshData*)pcollisionMesh, (PxSoftBodyCollisionData*)pcollisionData, (PxCollisionMeshMappingData*)pmappingData, (PxInsertionCallback*)pinsertionCallback);
							return ret;
						}
					}
				}
			}
		}

		public static PxSoftBodyMesh* PxAssembleSoftBodyMesh( PxTetrahedronMeshData* simulationMesh,  ref PxSoftBodySimulationData simulationData,  ref PxTetrahedronMeshData collisionMesh,  ref PxSoftBodyCollisionData collisionData,  ref PxCollisionMeshMappingData mappingData,  ref PxInsertionCallback insertionCallback)
		{
			fixed (PxSoftBodySimulationData* psimulationData = &simulationData)
			{
				fixed (PxTetrahedronMeshData* pcollisionMesh = &collisionMesh)
				{
					fixed (PxSoftBodyCollisionData* pcollisionData = &collisionData)
					{
						fixed (PxCollisionMeshMappingData* pmappingData = &mappingData)
						{
							fixed (PxInsertionCallback* pinsertionCallback = &insertionCallback)
							{
								PxSoftBodyMesh* ret = PxAssembleSoftBodyMeshNative(simulationMesh, (PxSoftBodySimulationData*)psimulationData, (PxTetrahedronMeshData*)pcollisionMesh, (PxSoftBodyCollisionData*)pcollisionData, (PxCollisionMeshMappingData*)pmappingData, (PxInsertionCallback*)pinsertionCallback);
								return ret;
							}
						}
					}
				}
			}
		}

		[LibraryImport(LibName, EntryPoint = "PxAssembleSoftBodyMesh_Sim")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial PxSoftBodyMesh* PxAssembleSoftBodyMeshSimNative(PxSimulationTetrahedronMeshData* simulationMesh, PxCollisionTetrahedronMeshData* collisionMesh, PxCollisionMeshMappingData* mappingData, PxInsertionCallback* insertionCallback);

		public static PxSoftBodyMesh* PxAssembleSoftBodyMeshSim( PxSimulationTetrahedronMeshData* simulationMesh,  PxCollisionTetrahedronMeshData* collisionMesh,  PxCollisionMeshMappingData* mappingData,  PxInsertionCallback* insertionCallback)
		{
			PxSoftBodyMesh* ret = PxAssembleSoftBodyMeshSimNative(simulationMesh, collisionMesh, mappingData, insertionCallback);
			return ret;
		}

		public static PxSoftBodyMesh* PxAssembleSoftBodyMeshSim( PxSimulationTetrahedronMeshData* simulationMesh,  ref PxCollisionTetrahedronMeshData collisionMesh,  PxCollisionMeshMappingData* mappingData,  PxInsertionCallback* insertionCallback)
		{
			fixed (PxCollisionTetrahedronMeshData* pcollisionMesh = &collisionMesh)
			{
				PxSoftBodyMesh* ret = PxAssembleSoftBodyMeshSimNative(simulationMesh, (PxCollisionTetrahedronMeshData*)pcollisionMesh, mappingData, insertionCallback);
				return ret;
			}
		}

		public static PxSoftBodyMesh* PxAssembleSoftBodyMeshSim( PxSimulationTetrahedronMeshData* simulationMesh,  PxCollisionTetrahedronMeshData* collisionMesh,  ref PxCollisionMeshMappingData mappingData,  PxInsertionCallback* insertionCallback)
		{
			fixed (PxCollisionMeshMappingData* pmappingData = &mappingData)
			{
				PxSoftBodyMesh* ret = PxAssembleSoftBodyMeshSimNative(simulationMesh, collisionMesh, (PxCollisionMeshMappingData*)pmappingData, insertionCallback);
				return ret;
			}
		}

		public static PxSoftBodyMesh* PxAssembleSoftBodyMeshSim( PxSimulationTetrahedronMeshData* simulationMesh,  ref PxCollisionTetrahedronMeshData collisionMesh,  ref PxCollisionMeshMappingData mappingData,  PxInsertionCallback* insertionCallback)
		{
			fixed (PxCollisionTetrahedronMeshData* pcollisionMesh = &collisionMesh)
			{
				fixed (PxCollisionMeshMappingData* pmappingData = &mappingData)
				{
					PxSoftBodyMesh* ret = PxAssembleSoftBodyMeshSimNative(simulationMesh, (PxCollisionTetrahedronMeshData*)pcollisionMesh, (PxCollisionMeshMappingData*)pmappingData, insertionCallback);
					return ret;
				}
			}
		}

		public static PxSoftBodyMesh* PxAssembleSoftBodyMeshSim( PxSimulationTetrahedronMeshData* simulationMesh,  PxCollisionTetrahedronMeshData* collisionMesh,  PxCollisionMeshMappingData* mappingData,  ref PxInsertionCallback insertionCallback)
		{
			fixed (PxInsertionCallback* pinsertionCallback = &insertionCallback)
			{
				PxSoftBodyMesh* ret = PxAssembleSoftBodyMeshSimNative(simulationMesh, collisionMesh, mappingData, (PxInsertionCallback*)pinsertionCallback);
				return ret;
			}
		}

		public static PxSoftBodyMesh* PxAssembleSoftBodyMeshSim( PxSimulationTetrahedronMeshData* simulationMesh,  ref PxCollisionTetrahedronMeshData collisionMesh,  PxCollisionMeshMappingData* mappingData,  ref PxInsertionCallback insertionCallback)
		{
			fixed (PxCollisionTetrahedronMeshData* pcollisionMesh = &collisionMesh)
			{
				fixed (PxInsertionCallback* pinsertionCallback = &insertionCallback)
				{
					PxSoftBodyMesh* ret = PxAssembleSoftBodyMeshSimNative(simulationMesh, (PxCollisionTetrahedronMeshData*)pcollisionMesh, mappingData, (PxInsertionCallback*)pinsertionCallback);
					return ret;
				}
			}
		}

		public static PxSoftBodyMesh* PxAssembleSoftBodyMeshSim( PxSimulationTetrahedronMeshData* simulationMesh,  PxCollisionTetrahedronMeshData* collisionMesh,  ref PxCollisionMeshMappingData mappingData,  ref PxInsertionCallback insertionCallback)
		{
			fixed (PxCollisionMeshMappingData* pmappingData = &mappingData)
			{
				fixed (PxInsertionCallback* pinsertionCallback = &insertionCallback)
				{
					PxSoftBodyMesh* ret = PxAssembleSoftBodyMeshSimNative(simulationMesh, collisionMesh, (PxCollisionMeshMappingData*)pmappingData, (PxInsertionCallback*)pinsertionCallback);
					return ret;
				}
			}
		}

		public static PxSoftBodyMesh* PxAssembleSoftBodyMeshSim( PxSimulationTetrahedronMeshData* simulationMesh,  ref PxCollisionTetrahedronMeshData collisionMesh,  ref PxCollisionMeshMappingData mappingData,  ref PxInsertionCallback insertionCallback)
		{
			fixed (PxCollisionTetrahedronMeshData* pcollisionMesh = &collisionMesh)
			{
				fixed (PxCollisionMeshMappingData* pmappingData = &mappingData)
				{
					fixed (PxInsertionCallback* pinsertionCallback = &insertionCallback)
					{
						PxSoftBodyMesh* ret = PxAssembleSoftBodyMeshSimNative(simulationMesh, (PxCollisionTetrahedronMeshData*)pcollisionMesh, (PxCollisionMeshMappingData*)pmappingData, (PxInsertionCallback*)pinsertionCallback);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// <br/>
		/// This replaces the following functions from previous SDK versions:<br/>
		/// void NxJointDesc::setGlobalAnchor(const NxVec3<br/>
		/// &<br/>
		/// wsAnchor);<br/>
		/// void NxJointDesc::setGlobalAxis(const NxVec3<br/>
		/// &<br/>
		/// wsAxis);<br/>
		/// The function sets the joint's localPose using world-space input parameters.<br/>
		/// <br/>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxSetJointGlobalFrame")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PxSetJointGlobalFrameNative(PxJoint* joint, Vector3* wsAnchor, Vector3* wsAxis);

		/// <summary>/// <br/>/// This replaces the following functions from previous SDK versions:<br/>/// void NxJointDesc::setGlobalAnchor(const NxVec3<br/>/// &<br/>/// wsAnchor);<br/>/// void NxJointDesc::setGlobalAxis(const NxVec3<br/>/// &<br/>/// wsAxis);<br/>/// The function sets the joint's localPose using world-space input parameters.<br/>/// <br/>/// </summary>		public static void PxSetJointGlobalFrame( PxJoint* joint,  Vector3* wsAnchor,  Vector3* wsAxis)
		{
			PxSetJointGlobalFrameNative(joint, wsAnchor, wsAxis);
		}

		/// <summary>/// <br/>/// This replaces the following functions from previous SDK versions:<br/>/// void NxJointDesc::setGlobalAnchor(const NxVec3<br/>/// &<br/>/// wsAnchor);<br/>/// void NxJointDesc::setGlobalAxis(const NxVec3<br/>/// &<br/>/// wsAxis);<br/>/// The function sets the joint's localPose using world-space input parameters.<br/>/// <br/>/// </summary>		public static void PxSetJointGlobalFrame( PxJoint* joint,  ref Vector3 wsAnchor,  Vector3* wsAxis)
		{
			fixed (Vector3* pwsAnchor = &wsAnchor)
			{
				PxSetJointGlobalFrameNative(joint, (Vector3*)pwsAnchor, wsAxis);
			}
		}

		/// <summary>/// <br/>/// This replaces the following functions from previous SDK versions:<br/>/// void NxJointDesc::setGlobalAnchor(const NxVec3<br/>/// &<br/>/// wsAnchor);<br/>/// void NxJointDesc::setGlobalAxis(const NxVec3<br/>/// &<br/>/// wsAxis);<br/>/// The function sets the joint's localPose using world-space input parameters.<br/>/// <br/>/// </summary>		public static void PxSetJointGlobalFrame( PxJoint* joint,  Vector3* wsAnchor,  ref Vector3 wsAxis)
		{
			fixed (Vector3* pwsAxis = &wsAxis)
			{
				PxSetJointGlobalFrameNative(joint, wsAnchor, (Vector3*)pwsAxis);
			}
		}

		/// <summary>/// <br/>/// This replaces the following functions from previous SDK versions:<br/>/// void NxJointDesc::setGlobalAnchor(const NxVec3<br/>/// &<br/>/// wsAnchor);<br/>/// void NxJointDesc::setGlobalAxis(const NxVec3<br/>/// &<br/>/// wsAxis);<br/>/// The function sets the joint's localPose using world-space input parameters.<br/>/// <br/>/// </summary>		public static void PxSetJointGlobalFrame( PxJoint* joint,  ref Vector3 wsAnchor,  ref Vector3 wsAxis)
		{
			fixed (Vector3* pwsAnchor = &wsAnchor)
			{
				fixed (Vector3* pwsAxis = &wsAxis)
				{
					PxSetJointGlobalFrameNative(joint, (Vector3*)pwsAnchor, (Vector3*)pwsAxis);
				}
			}
		}

		/// <summary>
		/// - "smooth" because smoothing groups are not supported here<br/>
		/// - takes angles into account for correct cube normals computation<br/>
		/// To use 32bit indices pass a pointer in dFaces and set wFaces to zero. Alternatively pass a pointer to <br/>
		/// wFaces and set dFaces to zero.<br/>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxBuildSmoothNormals")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte PxBuildSmoothNormalsNative(uint nbTris, uint nbVerts, Vector3* verts, uint* dFaces, ushort* wFaces, Vector3* normals, byte flip);

		/// <summary>/// - "smooth" because smoothing groups are not supported here<br/>/// - takes angles into account for correct cube normals computation<br/>/// To use 32bit indices pass a pointer in dFaces and set wFaces to zero. Alternatively pass a pointer to <br/>/// wFaces and set dFaces to zero.<br/>/// </summary>		public static bool PxBuildSmoothNormals( uint nbTris,  uint nbVerts,  Vector3* verts,  uint* dFaces,  ushort* wFaces,  Vector3* normals,  bool flip)
		{
			byte ret = PxBuildSmoothNormalsNative(nbTris, nbVerts, verts, dFaces, wFaces, normals, flip ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>/// - "smooth" because smoothing groups are not supported here<br/>/// - takes angles into account for correct cube normals computation<br/>/// To use 32bit indices pass a pointer in dFaces and set wFaces to zero. Alternatively pass a pointer to <br/>/// wFaces and set dFaces to zero.<br/>/// </summary>		public static bool PxBuildSmoothNormals( uint nbTris,  uint nbVerts,  ref Vector3 verts,  uint* dFaces,  ushort* wFaces,  Vector3* normals,  bool flip)
		{
			fixed (Vector3* pverts = &verts)
			{
				byte ret = PxBuildSmoothNormalsNative(nbTris, nbVerts, (Vector3*)pverts, dFaces, wFaces, normals, flip ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>/// - "smooth" because smoothing groups are not supported here<br/>/// - takes angles into account for correct cube normals computation<br/>/// To use 32bit indices pass a pointer in dFaces and set wFaces to zero. Alternatively pass a pointer to <br/>/// wFaces and set dFaces to zero.<br/>/// </summary>		public static bool PxBuildSmoothNormals( uint nbTris,  uint nbVerts,  Vector3* verts,  ref uint dFaces,  ushort* wFaces,  Vector3* normals,  bool flip)
		{
			fixed (uint* pdFaces = &dFaces)
			{
				byte ret = PxBuildSmoothNormalsNative(nbTris, nbVerts, verts, (uint*)pdFaces, wFaces, normals, flip ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>/// - "smooth" because smoothing groups are not supported here<br/>/// - takes angles into account for correct cube normals computation<br/>/// To use 32bit indices pass a pointer in dFaces and set wFaces to zero. Alternatively pass a pointer to <br/>/// wFaces and set dFaces to zero.<br/>/// </summary>		public static bool PxBuildSmoothNormals( uint nbTris,  uint nbVerts,  ref Vector3 verts,  ref uint dFaces,  ushort* wFaces,  Vector3* normals,  bool flip)
		{
			fixed (Vector3* pverts = &verts)
			{
				fixed (uint* pdFaces = &dFaces)
				{
					byte ret = PxBuildSmoothNormalsNative(nbTris, nbVerts, (Vector3*)pverts, (uint*)pdFaces, wFaces, normals, flip ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}

		/// <summary>/// - "smooth" because smoothing groups are not supported here<br/>/// - takes angles into account for correct cube normals computation<br/>/// To use 32bit indices pass a pointer in dFaces and set wFaces to zero. Alternatively pass a pointer to <br/>/// wFaces and set dFaces to zero.<br/>/// </summary>		public static bool PxBuildSmoothNormals( uint nbTris,  uint nbVerts,  Vector3* verts,  uint* dFaces,  ref ushort wFaces,  Vector3* normals,  bool flip)
		{
			fixed (ushort* pwFaces = &wFaces)
			{
				byte ret = PxBuildSmoothNormalsNative(nbTris, nbVerts, verts, dFaces, (ushort*)pwFaces, normals, flip ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>/// - "smooth" because smoothing groups are not supported here<br/>/// - takes angles into account for correct cube normals computation<br/>/// To use 32bit indices pass a pointer in dFaces and set wFaces to zero. Alternatively pass a pointer to <br/>/// wFaces and set dFaces to zero.<br/>/// </summary>		public static bool PxBuildSmoothNormals( uint nbTris,  uint nbVerts,  ref Vector3 verts,  uint* dFaces,  ref ushort wFaces,  Vector3* normals,  bool flip)
		{
			fixed (Vector3* pverts = &verts)
			{
				fixed (ushort* pwFaces = &wFaces)
				{
					byte ret = PxBuildSmoothNormalsNative(nbTris, nbVerts, (Vector3*)pverts, dFaces, (ushort*)pwFaces, normals, flip ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}

		/// <summary>/// - "smooth" because smoothing groups are not supported here<br/>/// - takes angles into account for correct cube normals computation<br/>/// To use 32bit indices pass a pointer in dFaces and set wFaces to zero. Alternatively pass a pointer to <br/>/// wFaces and set dFaces to zero.<br/>/// </summary>		public static bool PxBuildSmoothNormals( uint nbTris,  uint nbVerts,  Vector3* verts,  ref uint dFaces,  ref ushort wFaces,  Vector3* normals,  bool flip)
		{
			fixed (uint* pdFaces = &dFaces)
			{
				fixed (ushort* pwFaces = &wFaces)
				{
					byte ret = PxBuildSmoothNormalsNative(nbTris, nbVerts, verts, (uint*)pdFaces, (ushort*)pwFaces, normals, flip ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}

		/// <summary>/// - "smooth" because smoothing groups are not supported here<br/>/// - takes angles into account for correct cube normals computation<br/>/// To use 32bit indices pass a pointer in dFaces and set wFaces to zero. Alternatively pass a pointer to <br/>/// wFaces and set dFaces to zero.<br/>/// </summary>		public static bool PxBuildSmoothNormals( uint nbTris,  uint nbVerts,  ref Vector3 verts,  ref uint dFaces,  ref ushort wFaces,  Vector3* normals,  bool flip)
		{
			fixed (Vector3* pverts = &verts)
			{
				fixed (uint* pdFaces = &dFaces)
				{
					fixed (ushort* pwFaces = &wFaces)
					{
						byte ret = PxBuildSmoothNormalsNative(nbTris, nbVerts, (Vector3*)pverts, (uint*)pdFaces, (ushort*)pwFaces, normals, flip ? (byte)1 : (byte)0);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// - "smooth" because smoothing groups are not supported here<br/>/// - takes angles into account for correct cube normals computation<br/>/// To use 32bit indices pass a pointer in dFaces and set wFaces to zero. Alternatively pass a pointer to <br/>/// wFaces and set dFaces to zero.<br/>/// </summary>		public static bool PxBuildSmoothNormals( uint nbTris,  uint nbVerts,  Vector3* verts,  uint* dFaces,  ushort* wFaces,  ref Vector3 normals,  bool flip)
		{
			fixed (Vector3* pnormals = &normals)
			{
				byte ret = PxBuildSmoothNormalsNative(nbTris, nbVerts, verts, dFaces, wFaces, (Vector3*)pnormals, flip ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>/// - "smooth" because smoothing groups are not supported here<br/>/// - takes angles into account for correct cube normals computation<br/>/// To use 32bit indices pass a pointer in dFaces and set wFaces to zero. Alternatively pass a pointer to <br/>/// wFaces and set dFaces to zero.<br/>/// </summary>		public static bool PxBuildSmoothNormals( uint nbTris,  uint nbVerts,  ref Vector3 verts,  uint* dFaces,  ushort* wFaces,  ref Vector3 normals,  bool flip)
		{
			fixed (Vector3* pverts = &verts)
			{
				fixed (Vector3* pnormals = &normals)
				{
					byte ret = PxBuildSmoothNormalsNative(nbTris, nbVerts, (Vector3*)pverts, dFaces, wFaces, (Vector3*)pnormals, flip ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}

		/// <summary>/// - "smooth" because smoothing groups are not supported here<br/>/// - takes angles into account for correct cube normals computation<br/>/// To use 32bit indices pass a pointer in dFaces and set wFaces to zero. Alternatively pass a pointer to <br/>/// wFaces and set dFaces to zero.<br/>/// </summary>		public static bool PxBuildSmoothNormals( uint nbTris,  uint nbVerts,  Vector3* verts,  ref uint dFaces,  ushort* wFaces,  ref Vector3 normals,  bool flip)
		{
			fixed (uint* pdFaces = &dFaces)
			{
				fixed (Vector3* pnormals = &normals)
				{
					byte ret = PxBuildSmoothNormalsNative(nbTris, nbVerts, verts, (uint*)pdFaces, wFaces, (Vector3*)pnormals, flip ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}

		/// <summary>/// - "smooth" because smoothing groups are not supported here<br/>/// - takes angles into account for correct cube normals computation<br/>/// To use 32bit indices pass a pointer in dFaces and set wFaces to zero. Alternatively pass a pointer to <br/>/// wFaces and set dFaces to zero.<br/>/// </summary>		public static bool PxBuildSmoothNormals( uint nbTris,  uint nbVerts,  ref Vector3 verts,  ref uint dFaces,  ushort* wFaces,  ref Vector3 normals,  bool flip)
		{
			fixed (Vector3* pverts = &verts)
			{
				fixed (uint* pdFaces = &dFaces)
				{
					fixed (Vector3* pnormals = &normals)
					{
						byte ret = PxBuildSmoothNormalsNative(nbTris, nbVerts, (Vector3*)pverts, (uint*)pdFaces, wFaces, (Vector3*)pnormals, flip ? (byte)1 : (byte)0);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// - "smooth" because smoothing groups are not supported here<br/>/// - takes angles into account for correct cube normals computation<br/>/// To use 32bit indices pass a pointer in dFaces and set wFaces to zero. Alternatively pass a pointer to <br/>/// wFaces and set dFaces to zero.<br/>/// </summary>		public static bool PxBuildSmoothNormals( uint nbTris,  uint nbVerts,  Vector3* verts,  uint* dFaces,  ref ushort wFaces,  ref Vector3 normals,  bool flip)
		{
			fixed (ushort* pwFaces = &wFaces)
			{
				fixed (Vector3* pnormals = &normals)
				{
					byte ret = PxBuildSmoothNormalsNative(nbTris, nbVerts, verts, dFaces, (ushort*)pwFaces, (Vector3*)pnormals, flip ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}

		/// <summary>/// - "smooth" because smoothing groups are not supported here<br/>/// - takes angles into account for correct cube normals computation<br/>/// To use 32bit indices pass a pointer in dFaces and set wFaces to zero. Alternatively pass a pointer to <br/>/// wFaces and set dFaces to zero.<br/>/// </summary>		public static bool PxBuildSmoothNormals( uint nbTris,  uint nbVerts,  ref Vector3 verts,  uint* dFaces,  ref ushort wFaces,  ref Vector3 normals,  bool flip)
		{
			fixed (Vector3* pverts = &verts)
			{
				fixed (ushort* pwFaces = &wFaces)
				{
					fixed (Vector3* pnormals = &normals)
					{
						byte ret = PxBuildSmoothNormalsNative(nbTris, nbVerts, (Vector3*)pverts, dFaces, (ushort*)pwFaces, (Vector3*)pnormals, flip ? (byte)1 : (byte)0);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// - "smooth" because smoothing groups are not supported here<br/>/// - takes angles into account for correct cube normals computation<br/>/// To use 32bit indices pass a pointer in dFaces and set wFaces to zero. Alternatively pass a pointer to <br/>/// wFaces and set dFaces to zero.<br/>/// </summary>		public static bool PxBuildSmoothNormals( uint nbTris,  uint nbVerts,  Vector3* verts,  ref uint dFaces,  ref ushort wFaces,  ref Vector3 normals,  bool flip)
		{
			fixed (uint* pdFaces = &dFaces)
			{
				fixed (ushort* pwFaces = &wFaces)
				{
					fixed (Vector3* pnormals = &normals)
					{
						byte ret = PxBuildSmoothNormalsNative(nbTris, nbVerts, verts, (uint*)pdFaces, (ushort*)pwFaces, (Vector3*)pnormals, flip ? (byte)1 : (byte)0);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>/// - "smooth" because smoothing groups are not supported here<br/>/// - takes angles into account for correct cube normals computation<br/>/// To use 32bit indices pass a pointer in dFaces and set wFaces to zero. Alternatively pass a pointer to <br/>/// wFaces and set dFaces to zero.<br/>/// </summary>		public static bool PxBuildSmoothNormals( uint nbTris,  uint nbVerts,  ref Vector3 verts,  ref uint dFaces,  ref ushort wFaces,  ref Vector3 normals,  bool flip)
		{
			fixed (Vector3* pverts = &verts)
			{
				fixed (uint* pdFaces = &dFaces)
				{
					fixed (ushort* pwFaces = &wFaces)
					{
						fixed (Vector3* pnormals = &normals)
						{
							byte ret = PxBuildSmoothNormalsNative(nbTris, nbVerts, (Vector3*)pverts, (uint*)pdFaces, (ushort*)pwFaces, (Vector3*)pnormals, flip ? (byte)1 : (byte)0);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// <br/>
		/// This should be called before calling any functions or methods in extensions which may require allocation. <br/>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxInitExtensions")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte PxInitExtensionsNative(PxPhysics* physics, PxPvd* pvd);

		/// <summary>/// <br/>/// This should be called before calling any functions or methods in extensions which may require allocation. <br/>/// </summary>		public static bool PxInitExtensions( PxPhysics* physics,  PxPvd* pvd)
		{
			byte ret = PxInitExtensionsNative(physics, pvd);
			return ret != 0;
		}

		/// <summary>/// <br/>/// This should be called before calling any functions or methods in extensions which may require allocation. <br/>/// </summary>		public static bool PxInitExtensions( PxPhysics* physics,  ref PxPvd pvd)
		{
			fixed (PxPvd* ppvd = &pvd)
			{
				byte ret = PxInitExtensionsNative(physics, (PxPvd*)ppvd);
				return ret != 0;
			}
		}

		/// <summary>
		/// <br/>
		/// This function should be called to cleanly shut down the PhysXExtensions library before application exit. <br/>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxCloseExtensions")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PxCloseExtensionsNative();

		/// <summary>/// <br/>/// This function should be called to cleanly shut down the PhysXExtensions library before application exit. <br/>/// </summary>		public static void PxCloseExtensions()
		{
			PxCloseExtensionsNative();
		}

		/// <summary>
		/// Call this before using any of the vehicle functions.<br/>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxInitVehicleSDK")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte PxInitVehicleSDKNative(PxPhysics* physics, PxSerializationRegistry* serializationRegistry);

		/// <summary>/// Call this before using any of the vehicle functions.<br/>/// </summary>		public static bool PxInitVehicleSDK( PxPhysics* physics,  PxSerializationRegistry* serializationRegistry)
		{
			byte ret = PxInitVehicleSDKNative(physics, serializationRegistry);
			return ret != 0;
		}

		/// <summary>/// Call this before using any of the vehicle functions.<br/>/// </summary>		public static bool PxInitVehicleSDK( PxPhysics* physics,  ref PxSerializationRegistry serializationRegistry)
		{
			fixed (PxSerializationRegistry* pserializationRegistry = &serializationRegistry)
			{
				byte ret = PxInitVehicleSDKNative(physics, (PxSerializationRegistry*)pserializationRegistry);
				return ret != 0;
			}
		}

		/// <summary>
		/// Call this function as part of the physx shutdown process.<br/>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxCloseVehicleSDK")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PxCloseVehicleSDKNative(PxSerializationRegistry* serializationRegistry);

		/// <summary>/// Call this function as part of the physx shutdown process.<br/>/// </summary>		public static void PxCloseVehicleSDK( PxSerializationRegistry* serializationRegistry)
		{
			PxCloseVehicleSDKNative(serializationRegistry);
		}

		/// <summary>
		/// <br/>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxCreatePvd")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial PxPvd* PxCreatePvdNative(PxFoundation* foundation);

		/// <summary>/// <br/>/// </summary>		public static PxPvd* PxCreatePvd( PxFoundation* foundation)
		{
			PxPvd* ret = PxCreatePvdNative(foundation);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxDefaultPvdSocketTransportCreate")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial PxPvdTransport* PxDefaultPvdSocketTransportCreateNative(byte* host, int port, uint timeoutInMilliseconds);

		/// <summary>/// <br/>/// </summary>		public static PxPvdTransport* PxDefaultPvdSocketTransportCreate( byte* host,  int port,  uint timeoutInMilliseconds)
		{
			PxPvdTransport* ret = PxDefaultPvdSocketTransportCreateNative(host, port, timeoutInMilliseconds);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "PxDefaultPvdFileTransportCreate")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial PxPvdTransport* PxDefaultPvdFileTransportCreateNative(byte* name);

		/// <summary>/// <br/>/// </summary>		public static PxPvdTransport* PxDefaultPvdFileTransportCreate( byte* name)
		{
			PxPvdTransport* ret = PxDefaultPvdFileTransportCreateNative(name);
			return ret;
		}

		[LibraryImport(LibName, EntryPoint = "PxAllocatorCallback_delete")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PxAllocatorCallbackDeleteNative(PhysxPxAllocatorCallbackPod* selfPod);

		public static void PxAllocatorCallbackDelete( PhysxPxAllocatorCallbackPod* selfPod)
		{
			PxAllocatorCallbackDeleteNative(selfPod);
		}

		[LibraryImport(LibName, EntryPoint = "PxAllocatorCallback_allocate_mut")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void* PxAllocatorCallbackAllocateMutNative(PhysxPxAllocatorCallbackPod* selfPod, ulong sizePod, byte* typeName, byte* filename, int line);

		public static void* PxAllocatorCallbackAllocateMut( PhysxPxAllocatorCallbackPod* selfPod,  ulong sizePod,  byte* typeName,  byte* filename,  int line)
		{
			void* ret = PxAllocatorCallbackAllocateMutNative(selfPod, sizePod, typeName, filename, line);
			return ret;
		}

		public static void* PxAllocatorCallbackAllocateMut( PhysxPxAllocatorCallbackPod* selfPod,  nuint sizePod,  byte* typeName,  byte* filename,  int line)
		{
			void* ret = PxAllocatorCallbackAllocateMutNative(selfPod, sizePod, typeName, filename, line);
			return ret;
		}

		public static void* PxAllocatorCallbackAllocateMut( PhysxPxAllocatorCallbackPod* selfPod,  ulong sizePod,  ref byte typeName,  byte* filename,  int line)
		{
			fixed (byte* ptypeName = &typeName)
			{
				void* ret = PxAllocatorCallbackAllocateMutNative(selfPod, sizePod, (byte*)ptypeName, filename, line);
				return ret;
			}
		}

		public static void* PxAllocatorCallbackAllocateMut( PhysxPxAllocatorCallbackPod* selfPod,  ulong sizePod,  string typeName,  byte* filename,  int line)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (typeName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(typeName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(typeName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			void* ret = PxAllocatorCallbackAllocateMutNative(selfPod, sizePod, pStr0, filename, line);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static void* PxAllocatorCallbackAllocateMut( PhysxPxAllocatorCallbackPod* selfPod,  nuint sizePod,  ref byte typeName,  byte* filename,  int line)
		{
			fixed (byte* ptypeName = &typeName)
			{
				void* ret = PxAllocatorCallbackAllocateMutNative(selfPod, sizePod, (byte*)ptypeName, filename, line);
				return ret;
			}
		}

		public static void* PxAllocatorCallbackAllocateMut( PhysxPxAllocatorCallbackPod* selfPod,  nuint sizePod,  string typeName,  byte* filename,  int line)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (typeName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(typeName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(typeName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			void* ret = PxAllocatorCallbackAllocateMutNative(selfPod, sizePod, pStr0, filename, line);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static void* PxAllocatorCallbackAllocateMut( PhysxPxAllocatorCallbackPod* selfPod,  ulong sizePod,  byte* typeName,  ref byte filename,  int line)
		{
			fixed (byte* pfilename = &filename)
			{
				void* ret = PxAllocatorCallbackAllocateMutNative(selfPod, sizePod, typeName, (byte*)pfilename, line);
				return ret;
			}
		}

		public static void* PxAllocatorCallbackAllocateMut( PhysxPxAllocatorCallbackPod* selfPod,  ulong sizePod,  byte* typeName,  string filename,  int line)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			void* ret = PxAllocatorCallbackAllocateMutNative(selfPod, sizePod, typeName, pStr0, line);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static void* PxAllocatorCallbackAllocateMut( PhysxPxAllocatorCallbackPod* selfPod,  nuint sizePod,  byte* typeName,  ref byte filename,  int line)
		{
			fixed (byte* pfilename = &filename)
			{
				void* ret = PxAllocatorCallbackAllocateMutNative(selfPod, sizePod, typeName, (byte*)pfilename, line);
				return ret;
			}
		}

		public static void* PxAllocatorCallbackAllocateMut( PhysxPxAllocatorCallbackPod* selfPod,  nuint sizePod,  byte* typeName,  string filename,  int line)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			void* ret = PxAllocatorCallbackAllocateMutNative(selfPod, sizePod, typeName, pStr0, line);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static void* PxAllocatorCallbackAllocateMut( PhysxPxAllocatorCallbackPod* selfPod,  ulong sizePod,  ref byte typeName,  ref byte filename,  int line)
		{
			fixed (byte* ptypeName = &typeName)
			{
				fixed (byte* pfilename = &filename)
				{
					void* ret = PxAllocatorCallbackAllocateMutNative(selfPod, sizePod, (byte*)ptypeName, (byte*)pfilename, line);
					return ret;
				}
			}
		}

		public static void* PxAllocatorCallbackAllocateMut( PhysxPxAllocatorCallbackPod* selfPod,  ulong sizePod,  string typeName,  string filename,  int line)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (typeName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(typeName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(typeName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (filename != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(filename);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(filename, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			void* ret = PxAllocatorCallbackAllocateMutNative(selfPod, sizePod, pStr0, pStr1, line);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static void* PxAllocatorCallbackAllocateMut( PhysxPxAllocatorCallbackPod* selfPod,  nuint sizePod,  ref byte typeName,  ref byte filename,  int line)
		{
			fixed (byte* ptypeName = &typeName)
			{
				fixed (byte* pfilename = &filename)
				{
					void* ret = PxAllocatorCallbackAllocateMutNative(selfPod, sizePod, (byte*)ptypeName, (byte*)pfilename, line);
					return ret;
				}
			}
		}

		public static void* PxAllocatorCallbackAllocateMut( PhysxPxAllocatorCallbackPod* selfPod,  nuint sizePod,  string typeName,  string filename,  int line)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (typeName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(typeName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(typeName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (filename != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(filename);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(filename, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			void* ret = PxAllocatorCallbackAllocateMutNative(selfPod, sizePod, pStr0, pStr1, line);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
	}
}
