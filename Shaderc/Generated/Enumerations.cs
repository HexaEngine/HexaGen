// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;

namespace HexaEngine.Shaderc
{
	public enum ShadercTargetEnv
	{
		/// <summary>
		/// SPIR-V under Vulkan semantics
		/// </summary>
		Vulkan = unchecked(0),

		/// <summary>
		/// SPIR-V under OpenGL semantics
		/// </summary>
		Opengl = unchecked(1),

		/// <summary>
		/// SPIR-V under OpenGL semantics,
		/// including compatibility profile
		/// functions
		/// </summary>
		OpenglCompat = unchecked(2),

		/// <summary>
		/// Deprecated, SPIR-V under WebGPU
		/// semantics
		/// </summary>
		Webgpu = unchecked(3),

		Default = Vulkan,
	}

	public enum ShadercEnvVersion
	{
		/// <summary>
		/// For Vulkan, use Vulkan's mapping of version numbers to integers.
		/// See vulkan.h
		/// </summary>
		Vulkan10 = unchecked((int)((1U<<22))),

		/// <summary>
		/// For Vulkan, use Vulkan's mapping of version numbers to integers.
		/// See vulkan.h
		/// </summary>
		Vulkan11 = unchecked((int)((1U<<22)|(1<<12))),

		/// <summary>
		/// For Vulkan, use Vulkan's mapping of version numbers to integers.
		/// See vulkan.h
		/// </summary>
		Vulkan12 = unchecked((int)((1U<<22)|(2<<12))),

		/// <summary>
		/// For Vulkan, use Vulkan's mapping of version numbers to integers.
		/// See vulkan.h
		/// </summary>
		Vulkan13 = unchecked((int)((1U<<22)|(3<<12))),

		/// <summary>
		/// For OpenGL, use the number from #version in shaders.
		/// TODO(dneto): Currently no difference between OpenGL 4.5 and 4.6.
		/// See glslang/Standalone/Standalone.cpp
		/// TODO(dneto): Glslang doesn't accept a OpenGL client version of 460.
		/// </summary>
		Opengl45 = unchecked(450),

		/// <summary>
		/// Deprecated, WebGPU env never defined versions
		/// </summary>
		Webgpu = unchecked(451),

	}

	/// <summary>
	/// The known versions of SPIR-V.
	/// </summary>
	public enum ShadercSpirvVersion
	{
		/// <summary>
		/// Use the values used for word 1 of a SPIR-V binary:
		/// - bits 24 to 31: zero
		/// - bits 16 to 23: major version number
		/// - bits 8 to 15: minor version number
		/// - bits 0 to 7: zero
		/// </summary>
		Version10 = unchecked((int)0x010000u),

		/// <summary>
		/// Use the values used for word 1 of a SPIR-V binary:
		/// - bits 24 to 31: zero
		/// - bits 16 to 23: major version number
		/// - bits 8 to 15: minor version number
		/// - bits 0 to 7: zero
		/// </summary>
		Version11 = unchecked((int)0x010100u),

		/// <summary>
		/// Use the values used for word 1 of a SPIR-V binary:
		/// - bits 24 to 31: zero
		/// - bits 16 to 23: major version number
		/// - bits 8 to 15: minor version number
		/// - bits 0 to 7: zero
		/// </summary>
		Version12 = unchecked((int)0x010200u),

		/// <summary>
		/// Use the values used for word 1 of a SPIR-V binary:
		/// - bits 24 to 31: zero
		/// - bits 16 to 23: major version number
		/// - bits 8 to 15: minor version number
		/// - bits 0 to 7: zero
		/// </summary>
		Version13 = unchecked((int)0x010300u),

		/// <summary>
		/// Use the values used for word 1 of a SPIR-V binary:
		/// - bits 24 to 31: zero
		/// - bits 16 to 23: major version number
		/// - bits 8 to 15: minor version number
		/// - bits 0 to 7: zero
		/// </summary>
		Version14 = unchecked((int)0x010400u),

		/// <summary>
		/// Use the values used for word 1 of a SPIR-V binary:
		/// - bits 24 to 31: zero
		/// - bits 16 to 23: major version number
		/// - bits 8 to 15: minor version number
		/// - bits 0 to 7: zero
		/// </summary>
		Version15 = unchecked((int)0x010500u),

		/// <summary>
		/// Use the values used for word 1 of a SPIR-V binary:
		/// - bits 24 to 31: zero
		/// - bits 16 to 23: major version number
		/// - bits 8 to 15: minor version number
		/// - bits 0 to 7: zero
		/// </summary>
		Version16 = unchecked((int)0x010600u),

	}

	/// <summary>
	/// Indicate the status of a compilation.
	/// </summary>
	public enum ShadercCompilationStatus
	{
		Success = unchecked(0),
		/// <summary>
		/// error stage deduction
		/// </summary>
		InvalidStage = unchecked(1),

		Error = unchecked(2),
		/// <summary>
		/// unexpected failure
		/// </summary>
		InternalError = unchecked(3),

		NullResultObject = unchecked(4),
		InvalidAssembly = unchecked(5),
		ValidationError = unchecked(6),
		TransformationError = unchecked(7),
		ConfigurationError = unchecked(8),
	}

	/// <summary>
	/// Source language kind.
	/// </summary>
	public enum ShadercSourceLanguage
	{
		Glsl = unchecked(0),
		Hlsl = unchecked(1),
	}

	public enum ShadercShaderKind
	{
		/// <summary>
		/// Forced shader kinds. These shader kinds force the compiler to compile the
		/// source code as the specified kind of shader.
		/// </summary>
		VertexShader = unchecked(0),

		/// <summary>
		/// Forced shader kinds. These shader kinds force the compiler to compile the
		/// source code as the specified kind of shader.
		/// </summary>
		FragmentShader = unchecked(1),

		/// <summary>
		/// Forced shader kinds. These shader kinds force the compiler to compile the
		/// source code as the specified kind of shader.
		/// </summary>
		ComputeShader = unchecked(2),

		/// <summary>
		/// Forced shader kinds. These shader kinds force the compiler to compile the
		/// source code as the specified kind of shader.
		/// </summary>
		GeometryShader = unchecked(3),

		/// <summary>
		/// Forced shader kinds. These shader kinds force the compiler to compile the
		/// source code as the specified kind of shader.
		/// </summary>
		TessControlShader = unchecked(4),

		/// <summary>
		/// Forced shader kinds. These shader kinds force the compiler to compile the
		/// source code as the specified kind of shader.
		/// </summary>
		TessEvaluationShader = unchecked(5),

		/// <summary>
		/// Forced shader kinds. These shader kinds force the compiler to compile the
		/// source code as the specified kind of shader.
		/// </summary>
		GlslVertexShader = VertexShader,

		/// <summary>
		/// Forced shader kinds. These shader kinds force the compiler to compile the
		/// source code as the specified kind of shader.
		/// </summary>
		GlslFragmentShader = FragmentShader,

		/// <summary>
		/// Forced shader kinds. These shader kinds force the compiler to compile the
		/// source code as the specified kind of shader.
		/// </summary>
		GlslComputeShader = ComputeShader,

		/// <summary>
		/// Forced shader kinds. These shader kinds force the compiler to compile the
		/// source code as the specified kind of shader.
		/// </summary>
		GlslGeometryShader = GeometryShader,

		/// <summary>
		/// Forced shader kinds. These shader kinds force the compiler to compile the
		/// source code as the specified kind of shader.
		/// </summary>
		GlslTessControlShader = TessControlShader,

		/// <summary>
		/// Forced shader kinds. These shader kinds force the compiler to compile the
		/// source code as the specified kind of shader.
		/// </summary>
		GlslTessEvaluationShader = TessEvaluationShader,

		/// <summary>
		/// Deduce the shader kind from #pragma annotation in the source code. Compiler
		/// will emit error if #pragma annotation is not found.
		/// </summary>
		GlslInferFromSource = unchecked(6),

		/// <summary>
		/// Default shader kinds. Compiler will fall back to compile the source code as
		/// the specified kind of shader when #pragma annotation is not found in the
		/// source code.
		/// </summary>
		GlslDefaultVertexShader = unchecked(7),

		/// <summary>
		/// Default shader kinds. Compiler will fall back to compile the source code as
		/// the specified kind of shader when #pragma annotation is not found in the
		/// source code.
		/// </summary>
		GlslDefaultFragmentShader = unchecked(8),

		/// <summary>
		/// Default shader kinds. Compiler will fall back to compile the source code as
		/// the specified kind of shader when #pragma annotation is not found in the
		/// source code.
		/// </summary>
		GlslDefaultComputeShader = unchecked(9),

		/// <summary>
		/// Default shader kinds. Compiler will fall back to compile the source code as
		/// the specified kind of shader when #pragma annotation is not found in the
		/// source code.
		/// </summary>
		GlslDefaultGeometryShader = unchecked(10),

		/// <summary>
		/// Default shader kinds. Compiler will fall back to compile the source code as
		/// the specified kind of shader when #pragma annotation is not found in the
		/// source code.
		/// </summary>
		GlslDefaultTessControlShader = unchecked(11),

		/// <summary>
		/// Default shader kinds. Compiler will fall back to compile the source code as
		/// the specified kind of shader when #pragma annotation is not found in the
		/// source code.
		/// </summary>
		GlslDefaultTessEvaluationShader = unchecked(12),

		/// <summary>
		/// Default shader kinds. Compiler will fall back to compile the source code as
		/// the specified kind of shader when #pragma annotation is not found in the
		/// source code.
		/// </summary>
		SpirvAssembly = unchecked(13),

		/// <summary>
		/// Default shader kinds. Compiler will fall back to compile the source code as
		/// the specified kind of shader when #pragma annotation is not found in the
		/// source code.
		/// </summary>
		RaygenShader = unchecked(14),

		/// <summary>
		/// Default shader kinds. Compiler will fall back to compile the source code as
		/// the specified kind of shader when #pragma annotation is not found in the
		/// source code.
		/// </summary>
		AnyhitShader = unchecked(15),

		/// <summary>
		/// Default shader kinds. Compiler will fall back to compile the source code as
		/// the specified kind of shader when #pragma annotation is not found in the
		/// source code.
		/// </summary>
		ClosesthitShader = unchecked(16),

		/// <summary>
		/// Default shader kinds. Compiler will fall back to compile the source code as
		/// the specified kind of shader when #pragma annotation is not found in the
		/// source code.
		/// </summary>
		MissShader = unchecked(17),

		/// <summary>
		/// Default shader kinds. Compiler will fall back to compile the source code as
		/// the specified kind of shader when #pragma annotation is not found in the
		/// source code.
		/// </summary>
		IntersectionShader = unchecked(18),

		/// <summary>
		/// Default shader kinds. Compiler will fall back to compile the source code as
		/// the specified kind of shader when #pragma annotation is not found in the
		/// source code.
		/// </summary>
		CallableShader = unchecked(19),

		/// <summary>
		/// Default shader kinds. Compiler will fall back to compile the source code as
		/// the specified kind of shader when #pragma annotation is not found in the
		/// source code.
		/// </summary>
		GlslRaygenShader = RaygenShader,

		/// <summary>
		/// Default shader kinds. Compiler will fall back to compile the source code as
		/// the specified kind of shader when #pragma annotation is not found in the
		/// source code.
		/// </summary>
		GlslAnyhitShader = AnyhitShader,

		/// <summary>
		/// Default shader kinds. Compiler will fall back to compile the source code as
		/// the specified kind of shader when #pragma annotation is not found in the
		/// source code.
		/// </summary>
		GlslClosesthitShader = ClosesthitShader,

		/// <summary>
		/// Default shader kinds. Compiler will fall back to compile the source code as
		/// the specified kind of shader when #pragma annotation is not found in the
		/// source code.
		/// </summary>
		GlslMissShader = MissShader,

		/// <summary>
		/// Default shader kinds. Compiler will fall back to compile the source code as
		/// the specified kind of shader when #pragma annotation is not found in the
		/// source code.
		/// </summary>
		GlslIntersectionShader = IntersectionShader,

		/// <summary>
		/// Default shader kinds. Compiler will fall back to compile the source code as
		/// the specified kind of shader when #pragma annotation is not found in the
		/// source code.
		/// </summary>
		GlslCallableShader = CallableShader,

		/// <summary>
		/// Default shader kinds. Compiler will fall back to compile the source code as
		/// the specified kind of shader when #pragma annotation is not found in the
		/// source code.
		/// </summary>
		GlslDefaultRaygenShader = unchecked(20),

		/// <summary>
		/// Default shader kinds. Compiler will fall back to compile the source code as
		/// the specified kind of shader when #pragma annotation is not found in the
		/// source code.
		/// </summary>
		GlslDefaultAnyhitShader = unchecked(21),

		/// <summary>
		/// Default shader kinds. Compiler will fall back to compile the source code as
		/// the specified kind of shader when #pragma annotation is not found in the
		/// source code.
		/// </summary>
		GlslDefaultClosesthitShader = unchecked(22),

		/// <summary>
		/// Default shader kinds. Compiler will fall back to compile the source code as
		/// the specified kind of shader when #pragma annotation is not found in the
		/// source code.
		/// </summary>
		GlslDefaultMissShader = unchecked(23),

		/// <summary>
		/// Default shader kinds. Compiler will fall back to compile the source code as
		/// the specified kind of shader when #pragma annotation is not found in the
		/// source code.
		/// </summary>
		GlslDefaultIntersectionShader = unchecked(24),

		/// <summary>
		/// Default shader kinds. Compiler will fall back to compile the source code as
		/// the specified kind of shader when #pragma annotation is not found in the
		/// source code.
		/// </summary>
		GlslDefaultCallableShader = unchecked(25),

		/// <summary>
		/// Default shader kinds. Compiler will fall back to compile the source code as
		/// the specified kind of shader when #pragma annotation is not found in the
		/// source code.
		/// </summary>
		TaskShader = unchecked(26),

		/// <summary>
		/// Default shader kinds. Compiler will fall back to compile the source code as
		/// the specified kind of shader when #pragma annotation is not found in the
		/// source code.
		/// </summary>
		MeshShader = unchecked(27),

		/// <summary>
		/// Default shader kinds. Compiler will fall back to compile the source code as
		/// the specified kind of shader when #pragma annotation is not found in the
		/// source code.
		/// </summary>
		GlslTaskShader = TaskShader,

		/// <summary>
		/// Default shader kinds. Compiler will fall back to compile the source code as
		/// the specified kind of shader when #pragma annotation is not found in the
		/// source code.
		/// </summary>
		GlslMeshShader = MeshShader,

		/// <summary>
		/// Default shader kinds. Compiler will fall back to compile the source code as
		/// the specified kind of shader when #pragma annotation is not found in the
		/// source code.
		/// </summary>
		GlslDefaultTaskShader = unchecked(28),

		/// <summary>
		/// Default shader kinds. Compiler will fall back to compile the source code as
		/// the specified kind of shader when #pragma annotation is not found in the
		/// source code.
		/// </summary>
		GlslDefaultMeshShader = unchecked(29),

	}

	public enum ShadercProfile
	{
		/// <summary>
		/// Used if and only if GLSL version did not specify
		/// profiles.
		/// </summary>
		None = unchecked(0),

		Core = unchecked(1),
		/// <summary>
		/// Disabled. This generates an error
		/// </summary>
		Compatibility = unchecked(2),

		Es = unchecked(3),
	}

	/// <summary>
	/// Optimization level.
	/// </summary>
	public enum ShadercOptimizationLevel
	{
		/// <summary>
		/// no optimization
		/// </summary>
		Zero = unchecked(0),

		/// <summary>
		/// optimize towards reducing code size
		/// </summary>
		Size = unchecked(1),

		/// <summary>
		/// optimize towards performance
		/// </summary>
		Performance = unchecked(2),

	}

	/// <summary>
	/// Resource limits.
	/// </summary>
	public enum ShadercLimit
	{
		MaxLights = unchecked(0),
		MaxClipPlanes = unchecked(1),
		MaxTextureUnits = unchecked(2),
		MaxTextureCoords = unchecked(3),
		MaxVertexAttribs = unchecked(4),
		MaxVertexUniformComponents = unchecked(5),
		MaxVaryingFloats = unchecked(6),
		MaxVertexTextureImageUnits = unchecked(7),
		MaxCombinedTextureImageUnits = unchecked(8),
		MaxTextureImageUnits = unchecked(9),
		MaxFragmentUniformComponents = unchecked(10),
		MaxDrawBuffers = unchecked(11),
		MaxVertexUniformVectors = unchecked(12),
		MaxVaryingVectors = unchecked(13),
		MaxFragmentUniformVectors = unchecked(14),
		MaxVertexOutputVectors = unchecked(15),
		MaxFragmentInputVectors = unchecked(16),
		MinProgramTexelOffset = unchecked(17),
		MaxProgramTexelOffset = unchecked(18),
		MaxClipDistances = unchecked(19),
		MaxComputeWorkGroupCountX = unchecked(20),
		MaxComputeWorkGroupCountY = unchecked(21),
		MaxComputeWorkGroupCountZ = unchecked(22),
		MaxComputeWorkGroupSizeX = unchecked(23),
		MaxComputeWorkGroupSizeY = unchecked(24),
		MaxComputeWorkGroupSizeZ = unchecked(25),
		MaxComputeUniformComponents = unchecked(26),
		MaxComputeTextureImageUnits = unchecked(27),
		MaxComputeImageUniforms = unchecked(28),
		MaxComputeAtomicCounters = unchecked(29),
		MaxComputeAtomicCounterBuffers = unchecked(30),
		MaxVaryingComponents = unchecked(31),
		MaxVertexOutputComponents = unchecked(32),
		MaxGeometryInputComponents = unchecked(33),
		MaxGeometryOutputComponents = unchecked(34),
		MaxFragmentInputComponents = unchecked(35),
		MaxImageUnits = unchecked(36),
		MaxCombinedImageUnitsAndFragmentOutputs = unchecked(37),
		MaxCombinedShaderOutputResources = unchecked(38),
		MaxImageSamples = unchecked(39),
		MaxVertexImageUniforms = unchecked(40),
		MaxTessControlImageUniforms = unchecked(41),
		MaxTessEvaluationImageUniforms = unchecked(42),
		MaxGeometryImageUniforms = unchecked(43),
		MaxFragmentImageUniforms = unchecked(44),
		MaxCombinedImageUniforms = unchecked(45),
		MaxGeometryTextureImageUnits = unchecked(46),
		MaxGeometryOutputVertices = unchecked(47),
		MaxGeometryTotalOutputComponents = unchecked(48),
		MaxGeometryUniformComponents = unchecked(49),
		MaxGeometryVaryingComponents = unchecked(50),
		MaxTessControlInputComponents = unchecked(51),
		MaxTessControlOutputComponents = unchecked(52),
		MaxTessControlTextureImageUnits = unchecked(53),
		MaxTessControlUniformComponents = unchecked(54),
		MaxTessControlTotalOutputComponents = unchecked(55),
		MaxTessEvaluationInputComponents = unchecked(56),
		MaxTessEvaluationOutputComponents = unchecked(57),
		MaxTessEvaluationTextureImageUnits = unchecked(58),
		MaxTessEvaluationUniformComponents = unchecked(59),
		MaxTessPatchComponents = unchecked(60),
		MaxPatchVertices = unchecked(61),
		MaxTessGenLevel = unchecked(62),
		MaxViewports = unchecked(63),
		MaxVertexAtomicCounters = unchecked(64),
		MaxTessControlAtomicCounters = unchecked(65),
		MaxTessEvaluationAtomicCounters = unchecked(66),
		MaxGeometryAtomicCounters = unchecked(67),
		MaxFragmentAtomicCounters = unchecked(68),
		MaxCombinedAtomicCounters = unchecked(69),
		MaxAtomicCounterBindings = unchecked(70),
		MaxVertexAtomicCounterBuffers = unchecked(71),
		MaxTessControlAtomicCounterBuffers = unchecked(72),
		MaxTessEvaluationAtomicCounterBuffers = unchecked(73),
		MaxGeometryAtomicCounterBuffers = unchecked(74),
		MaxFragmentAtomicCounterBuffers = unchecked(75),
		MaxCombinedAtomicCounterBuffers = unchecked(76),
		MaxAtomicCounterBufferSize = unchecked(77),
		MaxTransformFeedbackBuffers = unchecked(78),
		MaxTransformFeedbackInterleavedComponents = unchecked(79),
		MaxCullDistances = unchecked(80),
		MaxCombinedClipAndCullDistances = unchecked(81),
		MaxSamples = unchecked(82),
		MaxMeshOutputVerticesNv = unchecked(83),
		MaxMeshOutputPrimitivesNv = unchecked(84),
		MaxMeshWorkGroupSizeXNv = unchecked(85),
		MaxMeshWorkGroupSizeYNv = unchecked(86),
		MaxMeshWorkGroupSizeZNv = unchecked(87),
		MaxTaskWorkGroupSizeXNv = unchecked(88),
		MaxTaskWorkGroupSizeYNv = unchecked(89),
		MaxTaskWorkGroupSizeZNv = unchecked(90),
		MaxMeshViewCountNv = unchecked(91),
		MaxMeshOutputVerticesExt = unchecked(92),
		MaxMeshOutputPrimitivesExt = unchecked(93),
		MaxMeshWorkGroupSizeXExt = unchecked(94),
		MaxMeshWorkGroupSizeYExt = unchecked(95),
		MaxMeshWorkGroupSizeZExt = unchecked(96),
		MaxTaskWorkGroupSizeXExt = unchecked(97),
		MaxTaskWorkGroupSizeYExt = unchecked(98),
		MaxTaskWorkGroupSizeZExt = unchecked(99),
		MaxMeshViewCountExt = unchecked(100),
		MaxDualSourceDrawBuffersExt = unchecked(101),
	}

	/// <summary>
	/// Uniform resource kinds.
	/// In Vulkan, uniform resources are bound to the pipeline via descriptors
	/// with numbered bindings and sets.
	/// </summary>
	public enum ShadercUniformKind
	{
		/// <summary>
		/// Image and image buffer.
		/// </summary>
		Image = unchecked(0),

		/// <summary>
		/// Pure sampler.
		/// </summary>
		Sampler = unchecked(1),

		/// <summary>
		/// Sampled texture in GLSL, and Shader Resource View in HLSL.
		/// </summary>
		Texture = unchecked(2),

		/// <summary>
		/// Uniform Buffer Object (UBO) in GLSL.  Cbuffer in HLSL.
		/// </summary>
		Buffer = unchecked(3),

		/// <summary>
		/// Shader Storage Buffer Object (SSBO) in GLSL.
		/// </summary>
		StorageBuffer = unchecked(4),

		/// <summary>
		/// Unordered Access View, in HLSL.  (Writable storage image or storage
		/// buffer.)
		/// </summary>
		UnorderedAccessView = unchecked(5),

	}

	/// <summary>
	/// The kinds of include requests.
	/// </summary>
	public enum ShadercIncludeType
	{
		/// <summary>
		/// E.g. #include "source"
		/// </summary>
		Relative = unchecked(0),

		/// <summary>
		/// E.g. #include 
		/// <source
		/// >
		/// </summary>
		Standard = unchecked(1),

	}

}
