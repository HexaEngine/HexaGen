// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace HexaEngine.Shaderc
{
	public static unsafe class Extensions
	{
		/// <summary>		/// Releases the resources held by the shaderc_compiler_t.		/// After this call it is invalid to make any future calls to functions		/// involving this shaderc_compiler_t.		/// </summary>		public static void Release(this ShadercCompiler shadercCompiler)
		{
			Shaderc.ShadercCompilerReleaseNative(shadercCompiler);
		}

		/// <summary>		/// Releases the compilation options. It is invalid to use the given		/// shaderc_compile_options_t object in any future calls. It is safe to pass		/// NULL to this function, and doing such will have no effect.		/// </summary>		public static void Release(this ShadercCompileOptions options)
		{
			Shaderc.ShadercCompileOptionsReleaseNative(options);
		}

		/// <summary>		/// Adds a predefined macro to the compilation options. This has the same		/// effect as passing -Dname=value to the command-line compiler.  If value		/// is NULL, it has the same effect as passing -Dname to the command-line		/// compiler. If a macro definition with the same name has previously been		/// added, the value is replaced with the new value. The macro name and		/// value are passed in with char pointers, which point to their data, and		/// the lengths of their data. The strings that the name and value pointers		/// point to must remain valid for the duration of the call, but can be		/// modified or deleted after this function has returned. In case of adding		/// a valueless macro, the value argument should be a null pointer or the		/// value_length should be 0u.		/// </summary>		public static void AddMacroDefinition(this ShadercCompileOptions options, byte* name, nuint nameLength, byte* value, nuint valueLength)
		{
			Shaderc.ShadercCompileOptionsAddMacroDefinitionNative(options, name, nameLength, value, valueLength);
		}

		/// <summary>		/// Adds a predefined macro to the compilation options. This has the same		/// effect as passing -Dname=value to the command-line compiler.  If value		/// is NULL, it has the same effect as passing -Dname to the command-line		/// compiler. If a macro definition with the same name has previously been		/// added, the value is replaced with the new value. The macro name and		/// value are passed in with char pointers, which point to their data, and		/// the lengths of their data. The strings that the name and value pointers		/// point to must remain valid for the duration of the call, but can be		/// modified or deleted after this function has returned. In case of adding		/// a valueless macro, the value argument should be a null pointer or the		/// value_length should be 0u.		/// </summary>		public static void AddMacroDefinition(this ShadercCompileOptions options, ref byte name, nuint nameLength, byte* value, nuint valueLength)
		{
			fixed (byte* pname = &name)
			{
				Shaderc.ShadercCompileOptionsAddMacroDefinitionNative(options, (byte*)pname, nameLength, value, valueLength);
			}
		}

		/// <summary>		/// Adds a predefined macro to the compilation options. This has the same		/// effect as passing -Dname=value to the command-line compiler.  If value		/// is NULL, it has the same effect as passing -Dname to the command-line		/// compiler. If a macro definition with the same name has previously been		/// added, the value is replaced with the new value. The macro name and		/// value are passed in with char pointers, which point to their data, and		/// the lengths of their data. The strings that the name and value pointers		/// point to must remain valid for the duration of the call, but can be		/// modified or deleted after this function has returned. In case of adding		/// a valueless macro, the value argument should be a null pointer or the		/// value_length should be 0u.		/// </summary>		public static void AddMacroDefinition(this ShadercCompileOptions options, string name, nuint nameLength, byte* value, nuint valueLength)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Shaderc.ShadercCompileOptionsAddMacroDefinitionNative(options, pStr0, nameLength, value, valueLength);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>		/// Adds a predefined macro to the compilation options. This has the same		/// effect as passing -Dname=value to the command-line compiler.  If value		/// is NULL, it has the same effect as passing -Dname to the command-line		/// compiler. If a macro definition with the same name has previously been		/// added, the value is replaced with the new value. The macro name and		/// value are passed in with char pointers, which point to their data, and		/// the lengths of their data. The strings that the name and value pointers		/// point to must remain valid for the duration of the call, but can be		/// modified or deleted after this function has returned. In case of adding		/// a valueless macro, the value argument should be a null pointer or the		/// value_length should be 0u.		/// </summary>		public static void AddMacroDefinition(this ShadercCompileOptions options, byte* name, nuint nameLength, ref byte value, nuint valueLength)
		{
			fixed (byte* pvalue = &value)
			{
				Shaderc.ShadercCompileOptionsAddMacroDefinitionNative(options, name, nameLength, (byte*)pvalue, valueLength);
			}
		}

		/// <summary>		/// Adds a predefined macro to the compilation options. This has the same		/// effect as passing -Dname=value to the command-line compiler.  If value		/// is NULL, it has the same effect as passing -Dname to the command-line		/// compiler. If a macro definition with the same name has previously been		/// added, the value is replaced with the new value. The macro name and		/// value are passed in with char pointers, which point to their data, and		/// the lengths of their data. The strings that the name and value pointers		/// point to must remain valid for the duration of the call, but can be		/// modified or deleted after this function has returned. In case of adding		/// a valueless macro, the value argument should be a null pointer or the		/// value_length should be 0u.		/// </summary>		public static void AddMacroDefinition(this ShadercCompileOptions options, byte* name, nuint nameLength, string value, nuint valueLength)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (value != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(value);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(value, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Shaderc.ShadercCompileOptionsAddMacroDefinitionNative(options, name, nameLength, pStr0, valueLength);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>		/// Adds a predefined macro to the compilation options. This has the same		/// effect as passing -Dname=value to the command-line compiler.  If value		/// is NULL, it has the same effect as passing -Dname to the command-line		/// compiler. If a macro definition with the same name has previously been		/// added, the value is replaced with the new value. The macro name and		/// value are passed in with char pointers, which point to their data, and		/// the lengths of their data. The strings that the name and value pointers		/// point to must remain valid for the duration of the call, but can be		/// modified or deleted after this function has returned. In case of adding		/// a valueless macro, the value argument should be a null pointer or the		/// value_length should be 0u.		/// </summary>		public static void AddMacroDefinition(this ShadercCompileOptions options, ref byte name, nuint nameLength, ref byte value, nuint valueLength)
		{
			fixed (byte* pname = &name)
			{
				fixed (byte* pvalue = &value)
				{
					Shaderc.ShadercCompileOptionsAddMacroDefinitionNative(options, (byte*)pname, nameLength, (byte*)pvalue, valueLength);
				}
			}
		}

		/// <summary>		/// Adds a predefined macro to the compilation options. This has the same		/// effect as passing -Dname=value to the command-line compiler.  If value		/// is NULL, it has the same effect as passing -Dname to the command-line		/// compiler. If a macro definition with the same name has previously been		/// added, the value is replaced with the new value. The macro name and		/// value are passed in with char pointers, which point to their data, and		/// the lengths of their data. The strings that the name and value pointers		/// point to must remain valid for the duration of the call, but can be		/// modified or deleted after this function has returned. In case of adding		/// a valueless macro, the value argument should be a null pointer or the		/// value_length should be 0u.		/// </summary>		public static void AddMacroDefinition(this ShadercCompileOptions options, string name, nuint nameLength, string value, nuint valueLength)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (value != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(value);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(value, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			Shaderc.ShadercCompileOptionsAddMacroDefinitionNative(options, pStr0, nameLength, pStr1, valueLength);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>		/// Sets the source language.  The default is GLSL.		/// </summary>		public static void SetSourceLanguage(this ShadercCompileOptions options, ShadercSourceLanguage lang)
		{
			Shaderc.ShadercCompileOptionsSetSourceLanguageNative(options, lang);
		}

		/// <summary>		/// Sets the compiler mode to generate debug information in the output.		/// </summary>		public static void SetGenerateDebugInfo(this ShadercCompileOptions options)
		{
			Shaderc.ShadercCompileOptionsSetGenerateDebugInfoNative(options);
		}

		/// <summary>		/// Sets the compiler optimization level to the given level. Only the last one		/// takes effect if multiple calls of this function exist.		/// </summary>		public static void SetOptimizationLevel(this ShadercCompileOptions options, ShadercOptimizationLevel level)
		{
			Shaderc.ShadercCompileOptionsSetOptimizationLevelNative(options, level);
		}

		/// <summary>		/// Forces the GLSL language version and profile to a given pair. The version		/// number is the same as would appear in the #version annotation in the source.		/// Version and profile specified here overrides the #version annotation in the		/// source. Use profile: 'shaderc_profile_none' for GLSL versions that do not		/// define profiles, e.g. versions below 150.		/// </summary>		public static void SetForcedVersionProfile(this ShadercCompileOptions options, int version, ShadercProfile profile)
		{
			Shaderc.ShadercCompileOptionsSetForcedVersionProfileNative(options, version, profile);
		}

		/// <summary>		/// Sets includer callback functions.		/// </summary>		public static void SetIncludeCallbacks(this ShadercCompileOptions options, ShadercIncludeResolveFn resolver, ShadercIncludeResultReleaseFn resultReleaser, void* userData)
		{
			Shaderc.ShadercCompileOptionsSetIncludeCallbacksNative(options, resolver, resultReleaser, userData);
		}

		/// <summary>		/// Sets the compiler mode to suppress warnings, overriding warnings-as-errors		/// mode. When both suppress-warnings and warnings-as-errors modes are		/// turned on, warning messages will be inhibited, and will not be emitted		/// as error messages.		/// </summary>		public static void SetSuppressWarnings(this ShadercCompileOptions options)
		{
			Shaderc.ShadercCompileOptionsSetSuppressWarningsNative(options);
		}

		/// <summary>		/// Sets the target shader environment, affecting which warnings or errors will		/// be issued.  The version will be for distinguishing between different versions		/// of the target environment.  The version value should be either 0 or		/// a value listed in shaderc_env_version.  The 0 value maps to Vulkan 1.0 if		/// |target| is Vulkan, and it maps to OpenGL 4.5 if |target| is OpenGL.		/// </summary>		public static void SetTargetEnv(this ShadercCompileOptions options, ShadercTargetEnv target, uint version)
		{
			Shaderc.ShadercCompileOptionsSetTargetEnvNative(options, target, version);
		}

		/// <summary>		/// Sets the target SPIR-V version. The generated module will use this version		/// of SPIR-V.  Each target environment determines what versions of SPIR-V		/// it can consume.  Defaults to the highest version of SPIR-V 1.0 which is		/// required to be supported by the target environment.  E.g. Default to SPIR-V		/// 1.0 for Vulkan 1.0 and SPIR-V 1.3 for Vulkan 1.1.		/// </summary>		public static void SetTargetSpirv(this ShadercCompileOptions options, ShadercSpirvVersion version)
		{
			Shaderc.ShadercCompileOptionsSetTargetSpirvNative(options, version);
		}

		/// <summary>		/// Sets the compiler mode to treat all warnings as errors. Note the		/// suppress-warnings mode overrides this option, i.e. if both		/// warning-as-errors and suppress-warnings modes are set, warnings will not		/// be emitted as error messages.		/// </summary>		public static void SetWarningsAsErrors(this ShadercCompileOptions options)
		{
			Shaderc.ShadercCompileOptionsSetWarningsAsErrorsNative(options);
		}

		/// <summary>		/// Sets a resource limit.		/// </summary>		public static void SetLimit(this ShadercCompileOptions options, ShadercLimit limit, int value)
		{
			Shaderc.ShadercCompileOptionsSetLimitNative(options, limit, value);
		}

		/// <summary>		/// Sets whether the compiler should automatically assign bindings to uniforms		/// that aren't already explicitly bound in the shader source.		/// </summary>		public static void SetAutoBindUniforms(this ShadercCompileOptions options, bool autoBind)
		{
			Shaderc.ShadercCompileOptionsSetAutoBindUniformsNative(options, autoBind ? (byte)1 : (byte)0);
		}

		/// <summary>		/// Sets whether the compiler should automatically remove sampler variables		/// and convert image variables to combined image-sampler variables.		/// </summary>		public static void SetAutoCombinedImageSampler(this ShadercCompileOptions options, bool upgrade)
		{
			Shaderc.ShadercCompileOptionsSetAutoCombinedImageSamplerNative(options, upgrade ? (byte)1 : (byte)0);
		}

		/// <summary>		/// Sets whether the compiler should use HLSL IO mapping rules for bindings.		/// Defaults to false.		/// </summary>		public static void SetHlslIoMapping(this ShadercCompileOptions options, bool hlslIomap)
		{
			Shaderc.ShadercCompileOptionsSetHlslIoMappingNative(options, hlslIomap ? (byte)1 : (byte)0);
		}

		/// <summary>		/// Sets whether the compiler should determine block member offsets using HLSL		/// packing rules instead of standard GLSL rules.  Defaults to false.  Only		/// affects GLSL compilation.  HLSL rules are always used when compiling HLSL.		/// </summary>		public static void SetHlslOffsets(this ShadercCompileOptions options, bool hlslOffsets)
		{
			Shaderc.ShadercCompileOptionsSetHlslOffsetsNative(options, hlslOffsets ? (byte)1 : (byte)0);
		}

		/// <summary>		/// Sets the base binding number used for for a uniform resource type when		/// automatically assigning bindings.  For GLSL compilation, sets the lowest		/// automatically assigned number.  For HLSL compilation, the regsiter number		/// assigned to the resource is added to this specified base.		/// </summary>		public static void SetBindingBase(this ShadercCompileOptions options, ShadercUniformKind kind, uint baseValue)
		{
			Shaderc.ShadercCompileOptionsSetBindingBaseNative(options, kind, baseValue);
		}

		/// <summary>		/// Like shaderc_compile_options_set_binding_base, but only takes effect when		/// compiling a given shader stage.  The stage is assumed to be one of vertex,		/// fragment, tessellation evaluation, tesselation control, geometry, or compute.		/// </summary>		public static void SetBindingBaseForStage(this ShadercCompileOptions options, ShadercShaderKind shaderKind, ShadercUniformKind kind, uint baseValue)
		{
			Shaderc.ShadercCompileOptionsSetBindingBaseForStageNative(options, shaderKind, kind, baseValue);
		}

		/// <summary>		/// Sets whether the compiler should preserve all bindings, even when those		/// bindings are not used.		/// </summary>		public static void SetPreserveBindings(this ShadercCompileOptions options, bool preserveBindings)
		{
			Shaderc.ShadercCompileOptionsSetPreserveBindingsNative(options, preserveBindings ? (byte)1 : (byte)0);
		}

		/// <summary>		/// Sets whether the compiler should automatically assign locations to		/// uniform variables that don't have explicit locations in the shader source.		/// </summary>		public static void SetAutoMapLocations(this ShadercCompileOptions options, bool autoMap)
		{
			Shaderc.ShadercCompileOptionsSetAutoMapLocationsNative(options, autoMap ? (byte)1 : (byte)0);
		}

		/// <summary>		/// Sets a descriptor set and binding for an HLSL register in the given stage.		/// This method keeps a copy of the string data.		/// </summary>		public static void SetHlslRegisterSetAndBindingForStage(this ShadercCompileOptions options, ShadercShaderKind shaderKind, byte* reg, byte* set, byte* binding)
		{
			Shaderc.ShadercCompileOptionsSetHlslRegisterSetAndBindingForStageNative(options, shaderKind, reg, set, binding);
		}

		/// <summary>		/// Sets a descriptor set and binding for an HLSL register in the given stage.		/// This method keeps a copy of the string data.		/// </summary>		public static void SetHlslRegisterSetAndBindingForStage(this ShadercCompileOptions options, ShadercShaderKind shaderKind, ref byte reg, byte* set, byte* binding)
		{
			fixed (byte* preg = &reg)
			{
				Shaderc.ShadercCompileOptionsSetHlslRegisterSetAndBindingForStageNative(options, shaderKind, (byte*)preg, set, binding);
			}
		}

		/// <summary>		/// Sets a descriptor set and binding for an HLSL register in the given stage.		/// This method keeps a copy of the string data.		/// </summary>		public static void SetHlslRegisterSetAndBindingForStage(this ShadercCompileOptions options, ShadercShaderKind shaderKind, string reg, byte* set, byte* binding)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (reg != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(reg);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(reg, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Shaderc.ShadercCompileOptionsSetHlslRegisterSetAndBindingForStageNative(options, shaderKind, pStr0, set, binding);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>		/// Sets a descriptor set and binding for an HLSL register in the given stage.		/// This method keeps a copy of the string data.		/// </summary>		public static void SetHlslRegisterSetAndBindingForStage(this ShadercCompileOptions options, ShadercShaderKind shaderKind, byte* reg, ref byte set, byte* binding)
		{
			fixed (byte* pset = &set)
			{
				Shaderc.ShadercCompileOptionsSetHlslRegisterSetAndBindingForStageNative(options, shaderKind, reg, (byte*)pset, binding);
			}
		}

		/// <summary>		/// Sets a descriptor set and binding for an HLSL register in the given stage.		/// This method keeps a copy of the string data.		/// </summary>		public static void SetHlslRegisterSetAndBindingForStage(this ShadercCompileOptions options, ShadercShaderKind shaderKind, byte* reg, string set, byte* binding)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (set != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(set);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(set, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Shaderc.ShadercCompileOptionsSetHlslRegisterSetAndBindingForStageNative(options, shaderKind, reg, pStr0, binding);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>		/// Sets a descriptor set and binding for an HLSL register in the given stage.		/// This method keeps a copy of the string data.		/// </summary>		public static void SetHlslRegisterSetAndBindingForStage(this ShadercCompileOptions options, ShadercShaderKind shaderKind, ref byte reg, ref byte set, byte* binding)
		{
			fixed (byte* preg = &reg)
			{
				fixed (byte* pset = &set)
				{
					Shaderc.ShadercCompileOptionsSetHlslRegisterSetAndBindingForStageNative(options, shaderKind, (byte*)preg, (byte*)pset, binding);
				}
			}
		}

		/// <summary>		/// Sets a descriptor set and binding for an HLSL register in the given stage.		/// This method keeps a copy of the string data.		/// </summary>		public static void SetHlslRegisterSetAndBindingForStage(this ShadercCompileOptions options, ShadercShaderKind shaderKind, string reg, string set, byte* binding)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (reg != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(reg);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(reg, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (set != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(set);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(set, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			Shaderc.ShadercCompileOptionsSetHlslRegisterSetAndBindingForStageNative(options, shaderKind, pStr0, pStr1, binding);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>		/// Sets a descriptor set and binding for an HLSL register in the given stage.		/// This method keeps a copy of the string data.		/// </summary>		public static void SetHlslRegisterSetAndBindingForStage(this ShadercCompileOptions options, ShadercShaderKind shaderKind, byte* reg, byte* set, ref byte binding)
		{
			fixed (byte* pbinding = &binding)
			{
				Shaderc.ShadercCompileOptionsSetHlslRegisterSetAndBindingForStageNative(options, shaderKind, reg, set, (byte*)pbinding);
			}
		}

		/// <summary>		/// Sets a descriptor set and binding for an HLSL register in the given stage.		/// This method keeps a copy of the string data.		/// </summary>		public static void SetHlslRegisterSetAndBindingForStage(this ShadercCompileOptions options, ShadercShaderKind shaderKind, byte* reg, byte* set, string binding)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (binding != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(binding);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(binding, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Shaderc.ShadercCompileOptionsSetHlslRegisterSetAndBindingForStageNative(options, shaderKind, reg, set, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>		/// Sets a descriptor set and binding for an HLSL register in the given stage.		/// This method keeps a copy of the string data.		/// </summary>		public static void SetHlslRegisterSetAndBindingForStage(this ShadercCompileOptions options, ShadercShaderKind shaderKind, ref byte reg, byte* set, ref byte binding)
		{
			fixed (byte* preg = &reg)
			{
				fixed (byte* pbinding = &binding)
				{
					Shaderc.ShadercCompileOptionsSetHlslRegisterSetAndBindingForStageNative(options, shaderKind, (byte*)preg, set, (byte*)pbinding);
				}
			}
		}

		/// <summary>		/// Sets a descriptor set and binding for an HLSL register in the given stage.		/// This method keeps a copy of the string data.		/// </summary>		public static void SetHlslRegisterSetAndBindingForStage(this ShadercCompileOptions options, ShadercShaderKind shaderKind, string reg, byte* set, string binding)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (reg != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(reg);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(reg, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (binding != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(binding);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(binding, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			Shaderc.ShadercCompileOptionsSetHlslRegisterSetAndBindingForStageNative(options, shaderKind, pStr0, set, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>		/// Sets a descriptor set and binding for an HLSL register in the given stage.		/// This method keeps a copy of the string data.		/// </summary>		public static void SetHlslRegisterSetAndBindingForStage(this ShadercCompileOptions options, ShadercShaderKind shaderKind, byte* reg, ref byte set, ref byte binding)
		{
			fixed (byte* pset = &set)
			{
				fixed (byte* pbinding = &binding)
				{
					Shaderc.ShadercCompileOptionsSetHlslRegisterSetAndBindingForStageNative(options, shaderKind, reg, (byte*)pset, (byte*)pbinding);
				}
			}
		}

		/// <summary>		/// Sets a descriptor set and binding for an HLSL register in the given stage.		/// This method keeps a copy of the string data.		/// </summary>		public static void SetHlslRegisterSetAndBindingForStage(this ShadercCompileOptions options, ShadercShaderKind shaderKind, byte* reg, string set, string binding)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (set != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(set);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(set, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (binding != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(binding);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(binding, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			Shaderc.ShadercCompileOptionsSetHlslRegisterSetAndBindingForStageNative(options, shaderKind, reg, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>		/// Sets a descriptor set and binding for an HLSL register in the given stage.		/// This method keeps a copy of the string data.		/// </summary>		public static void SetHlslRegisterSetAndBindingForStage(this ShadercCompileOptions options, ShadercShaderKind shaderKind, ref byte reg, ref byte set, ref byte binding)
		{
			fixed (byte* preg = &reg)
			{
				fixed (byte* pset = &set)
				{
					fixed (byte* pbinding = &binding)
					{
						Shaderc.ShadercCompileOptionsSetHlslRegisterSetAndBindingForStageNative(options, shaderKind, (byte*)preg, (byte*)pset, (byte*)pbinding);
					}
				}
			}
		}

		/// <summary>		/// Sets a descriptor set and binding for an HLSL register in the given stage.		/// This method keeps a copy of the string data.		/// </summary>		public static void SetHlslRegisterSetAndBindingForStage(this ShadercCompileOptions options, ShadercShaderKind shaderKind, string reg, string set, string binding)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (reg != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(reg);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(reg, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (set != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(set);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(set, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (binding != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(binding);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(binding, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			Shaderc.ShadercCompileOptionsSetHlslRegisterSetAndBindingForStageNative(options, shaderKind, pStr0, pStr1, pStr2);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>		/// Like shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage,		/// but affects all shader stages.		/// </summary>		public static void SetHlslRegisterSetAndBinding(this ShadercCompileOptions options, byte* reg, byte* set, byte* binding)
		{
			Shaderc.ShadercCompileOptionsSetHlslRegisterSetAndBindingNative(options, reg, set, binding);
		}

		/// <summary>		/// Like shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage,		/// but affects all shader stages.		/// </summary>		public static void SetHlslRegisterSetAndBinding(this ShadercCompileOptions options, ref byte reg, byte* set, byte* binding)
		{
			fixed (byte* preg = &reg)
			{
				Shaderc.ShadercCompileOptionsSetHlslRegisterSetAndBindingNative(options, (byte*)preg, set, binding);
			}
		}

		/// <summary>		/// Like shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage,		/// but affects all shader stages.		/// </summary>		public static void SetHlslRegisterSetAndBinding(this ShadercCompileOptions options, string reg, byte* set, byte* binding)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (reg != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(reg);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(reg, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Shaderc.ShadercCompileOptionsSetHlslRegisterSetAndBindingNative(options, pStr0, set, binding);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>		/// Like shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage,		/// but affects all shader stages.		/// </summary>		public static void SetHlslRegisterSetAndBinding(this ShadercCompileOptions options, byte* reg, ref byte set, byte* binding)
		{
			fixed (byte* pset = &set)
			{
				Shaderc.ShadercCompileOptionsSetHlslRegisterSetAndBindingNative(options, reg, (byte*)pset, binding);
			}
		}

		/// <summary>		/// Like shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage,		/// but affects all shader stages.		/// </summary>		public static void SetHlslRegisterSetAndBinding(this ShadercCompileOptions options, byte* reg, string set, byte* binding)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (set != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(set);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(set, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Shaderc.ShadercCompileOptionsSetHlslRegisterSetAndBindingNative(options, reg, pStr0, binding);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>		/// Like shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage,		/// but affects all shader stages.		/// </summary>		public static void SetHlslRegisterSetAndBinding(this ShadercCompileOptions options, ref byte reg, ref byte set, byte* binding)
		{
			fixed (byte* preg = &reg)
			{
				fixed (byte* pset = &set)
				{
					Shaderc.ShadercCompileOptionsSetHlslRegisterSetAndBindingNative(options, (byte*)preg, (byte*)pset, binding);
				}
			}
		}

		/// <summary>		/// Like shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage,		/// but affects all shader stages.		/// </summary>		public static void SetHlslRegisterSetAndBinding(this ShadercCompileOptions options, string reg, string set, byte* binding)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (reg != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(reg);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(reg, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (set != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(set);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(set, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			Shaderc.ShadercCompileOptionsSetHlslRegisterSetAndBindingNative(options, pStr0, pStr1, binding);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>		/// Like shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage,		/// but affects all shader stages.		/// </summary>		public static void SetHlslRegisterSetAndBinding(this ShadercCompileOptions options, byte* reg, byte* set, ref byte binding)
		{
			fixed (byte* pbinding = &binding)
			{
				Shaderc.ShadercCompileOptionsSetHlslRegisterSetAndBindingNative(options, reg, set, (byte*)pbinding);
			}
		}

		/// <summary>		/// Like shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage,		/// but affects all shader stages.		/// </summary>		public static void SetHlslRegisterSetAndBinding(this ShadercCompileOptions options, byte* reg, byte* set, string binding)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (binding != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(binding);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(binding, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Shaderc.ShadercCompileOptionsSetHlslRegisterSetAndBindingNative(options, reg, set, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>		/// Like shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage,		/// but affects all shader stages.		/// </summary>		public static void SetHlslRegisterSetAndBinding(this ShadercCompileOptions options, ref byte reg, byte* set, ref byte binding)
		{
			fixed (byte* preg = &reg)
			{
				fixed (byte* pbinding = &binding)
				{
					Shaderc.ShadercCompileOptionsSetHlslRegisterSetAndBindingNative(options, (byte*)preg, set, (byte*)pbinding);
				}
			}
		}

		/// <summary>		/// Like shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage,		/// but affects all shader stages.		/// </summary>		public static void SetHlslRegisterSetAndBinding(this ShadercCompileOptions options, string reg, byte* set, string binding)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (reg != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(reg);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(reg, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (binding != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(binding);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(binding, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			Shaderc.ShadercCompileOptionsSetHlslRegisterSetAndBindingNative(options, pStr0, set, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>		/// Like shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage,		/// but affects all shader stages.		/// </summary>		public static void SetHlslRegisterSetAndBinding(this ShadercCompileOptions options, byte* reg, ref byte set, ref byte binding)
		{
			fixed (byte* pset = &set)
			{
				fixed (byte* pbinding = &binding)
				{
					Shaderc.ShadercCompileOptionsSetHlslRegisterSetAndBindingNative(options, reg, (byte*)pset, (byte*)pbinding);
				}
			}
		}

		/// <summary>		/// Like shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage,		/// but affects all shader stages.		/// </summary>		public static void SetHlslRegisterSetAndBinding(this ShadercCompileOptions options, byte* reg, string set, string binding)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (set != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(set);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(set, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (binding != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(binding);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(binding, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			Shaderc.ShadercCompileOptionsSetHlslRegisterSetAndBindingNative(options, reg, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>		/// Like shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage,		/// but affects all shader stages.		/// </summary>		public static void SetHlslRegisterSetAndBinding(this ShadercCompileOptions options, ref byte reg, ref byte set, ref byte binding)
		{
			fixed (byte* preg = &reg)
			{
				fixed (byte* pset = &set)
				{
					fixed (byte* pbinding = &binding)
					{
						Shaderc.ShadercCompileOptionsSetHlslRegisterSetAndBindingNative(options, (byte*)preg, (byte*)pset, (byte*)pbinding);
					}
				}
			}
		}

		/// <summary>		/// Like shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage,		/// but affects all shader stages.		/// </summary>		public static void SetHlslRegisterSetAndBinding(this ShadercCompileOptions options, string reg, string set, string binding)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (reg != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(reg);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(reg, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (set != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(set);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(set, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (binding != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(binding);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(binding, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			Shaderc.ShadercCompileOptionsSetHlslRegisterSetAndBindingNative(options, pStr0, pStr1, pStr2);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>		/// Sets whether the compiler should enable extension		/// SPV_GOOGLE_hlsl_functionality1.		/// </summary>		public static void SetHlslFunctionality1(this ShadercCompileOptions options, bool enable)
		{
			Shaderc.ShadercCompileOptionsSetHlslFunctionality1Native(options, enable ? (byte)1 : (byte)0);
		}

		/// <summary>		/// Sets whether 16-bit types are supported in HLSL or not.		/// </summary>		public static void SetHlsl16Types(this ShadercCompileOptions options, bool enable)
		{
			Shaderc.ShadercCompileOptionsSetHlsl16TypesNative(options, enable ? (byte)1 : (byte)0);
		}

		/// <summary>		/// Sets whether the compiler should invert position.Y output in vertex shader.		/// </summary>		public static void SetInvertY(this ShadercCompileOptions options, bool enable)
		{
			Shaderc.ShadercCompileOptionsSetInvertYNative(options, enable ? (byte)1 : (byte)0);
		}

		/// <summary>		/// Sets whether the compiler generates code for max and min builtins which,		/// if given a NaN operand, will return the other operand. Similarly, the clamp		/// builtin will favour the non-NaN operands, as if clamp were implemented		/// as a composition of max and min.		/// </summary>		public static void SetNanClamp(this ShadercCompileOptions options, bool enable)
		{
			Shaderc.ShadercCompileOptionsSetNanClampNative(options, enable ? (byte)1 : (byte)0);
		}

		/// <summary>		/// Releases the resources held by the result object. It is invalid to use the		/// result object for any further operations.		/// </summary>		public static void Release(this ShadercCompilationResult result)
		{
			Shaderc.ShadercResultReleaseNative(result);
		}

	}
}
