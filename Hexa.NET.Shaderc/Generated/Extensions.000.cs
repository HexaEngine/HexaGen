// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.Shaderc
{
	public static unsafe partial class Extensions
	{
		/// <summary>/// Releases the resources held by the shaderc_compiler_t.<br/>/// After this call it is invalid to make any future calls to functions<br/>/// involving this shaderc_compiler_t.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compiler_release")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Release(this ShadercCompiler unknown0)
		{
			Shaderc.ShadercCompilerReleaseNative(unknown0);
		}

		/// <summary>/// Takes a GLSL source string and the associated shader kind, input file<br/>/// name, compiles it according to the given additional_options. If the shader<br/>/// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,<br/>/// the compiler will try to deduce the shader kind from the source<br/>/// string and a failure in deducing will generate an error. Currently only<br/>/// #pragma annotation is supported. If the shader kind is set to one of the<br/>/// default shader kinds, the compiler will fall back to the default shader<br/>/// kind in case it failed to deduce the shader kind from source string.<br/>/// The input_file_name is a null-termintated string. It is used as a tag to<br/>/// identify the source string in cases like emitting error messages. It<br/>/// doesn't have to be a 'file name'.<br/>/// The source string will be compiled into SPIR-V binary and a<br/>/// shaderc_compilation_result will be returned to hold the results.<br/>/// The entry_point_name null-terminated string defines the name of the entry<br/>/// point to associate with this GLSL source. If the additional_options<br/>/// parameter is not null, then the compilation is modified by any options<br/>/// present.  May be safely called from multiple threads without explicit<br/>/// synchronization. If there was failure in allocating the compiler object,<br/>/// null will be returned.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpv(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] byte* sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] ulong sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] byte* inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] byte* entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvNative(compiler, sourceText, sourceTextSize, shaderKind, inputFileName, entryPointName, additionalOptions);
			return ret;
		}

		/// <summary>/// Takes a GLSL source string and the associated shader kind, input file<br/>/// name, compiles it according to the given additional_options. If the shader<br/>/// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,<br/>/// the compiler will try to deduce the shader kind from the source<br/>/// string and a failure in deducing will generate an error. Currently only<br/>/// #pragma annotation is supported. If the shader kind is set to one of the<br/>/// default shader kinds, the compiler will fall back to the default shader<br/>/// kind in case it failed to deduce the shader kind from source string.<br/>/// The input_file_name is a null-termintated string. It is used as a tag to<br/>/// identify the source string in cases like emitting error messages. It<br/>/// doesn't have to be a 'file name'.<br/>/// The source string will be compiled into SPIR-V binary and a<br/>/// shaderc_compilation_result will be returned to hold the results.<br/>/// The entry_point_name null-terminated string defines the name of the entry<br/>/// point to associate with this GLSL source. If the additional_options<br/>/// parameter is not null, then the compilation is modified by any options<br/>/// present.  May be safely called from multiple threads without explicit<br/>/// synchronization. If there was failure in allocating the compiler object,<br/>/// null will be returned.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpv(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] ref byte sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] ulong sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] byte* inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] byte* entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			fixed (byte* psourceText = &sourceText)
			{
				ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvNative(compiler, (byte*)psourceText, sourceTextSize, shaderKind, inputFileName, entryPointName, additionalOptions);
				return ret;
			}
		}

		/// <summary>/// Takes a GLSL source string and the associated shader kind, input file<br/>/// name, compiles it according to the given additional_options. If the shader<br/>/// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,<br/>/// the compiler will try to deduce the shader kind from the source<br/>/// string and a failure in deducing will generate an error. Currently only<br/>/// #pragma annotation is supported. If the shader kind is set to one of the<br/>/// default shader kinds, the compiler will fall back to the default shader<br/>/// kind in case it failed to deduce the shader kind from source string.<br/>/// The input_file_name is a null-termintated string. It is used as a tag to<br/>/// identify the source string in cases like emitting error messages. It<br/>/// doesn't have to be a 'file name'.<br/>/// The source string will be compiled into SPIR-V binary and a<br/>/// shaderc_compilation_result will be returned to hold the results.<br/>/// The entry_point_name null-terminated string defines the name of the entry<br/>/// point to associate with this GLSL source. If the additional_options<br/>/// parameter is not null, then the compilation is modified by any options<br/>/// present.  May be safely called from multiple threads without explicit<br/>/// synchronization. If there was failure in allocating the compiler object,<br/>/// null will be returned.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpv(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] string sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] ulong sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] byte* inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] byte* entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (sourceText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(sourceText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(sourceText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvNative(compiler, pStr0, sourceTextSize, shaderKind, inputFileName, entryPointName, additionalOptions);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// Takes a GLSL source string and the associated shader kind, input file<br/>/// name, compiles it according to the given additional_options. If the shader<br/>/// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,<br/>/// the compiler will try to deduce the shader kind from the source<br/>/// string and a failure in deducing will generate an error. Currently only<br/>/// #pragma annotation is supported. If the shader kind is set to one of the<br/>/// default shader kinds, the compiler will fall back to the default shader<br/>/// kind in case it failed to deduce the shader kind from source string.<br/>/// The input_file_name is a null-termintated string. It is used as a tag to<br/>/// identify the source string in cases like emitting error messages. It<br/>/// doesn't have to be a 'file name'.<br/>/// The source string will be compiled into SPIR-V binary and a<br/>/// shaderc_compilation_result will be returned to hold the results.<br/>/// The entry_point_name null-terminated string defines the name of the entry<br/>/// point to associate with this GLSL source. If the additional_options<br/>/// parameter is not null, then the compilation is modified by any options<br/>/// present.  May be safely called from multiple threads without explicit<br/>/// synchronization. If there was failure in allocating the compiler object,<br/>/// null will be returned.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpv(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] byte* sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] nuint sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] byte* inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] byte* entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvNative(compiler, sourceText, sourceTextSize, shaderKind, inputFileName, entryPointName, additionalOptions);
			return ret;
		}

		/// <summary>/// Takes a GLSL source string and the associated shader kind, input file<br/>/// name, compiles it according to the given additional_options. If the shader<br/>/// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,<br/>/// the compiler will try to deduce the shader kind from the source<br/>/// string and a failure in deducing will generate an error. Currently only<br/>/// #pragma annotation is supported. If the shader kind is set to one of the<br/>/// default shader kinds, the compiler will fall back to the default shader<br/>/// kind in case it failed to deduce the shader kind from source string.<br/>/// The input_file_name is a null-termintated string. It is used as a tag to<br/>/// identify the source string in cases like emitting error messages. It<br/>/// doesn't have to be a 'file name'.<br/>/// The source string will be compiled into SPIR-V binary and a<br/>/// shaderc_compilation_result will be returned to hold the results.<br/>/// The entry_point_name null-terminated string defines the name of the entry<br/>/// point to associate with this GLSL source. If the additional_options<br/>/// parameter is not null, then the compilation is modified by any options<br/>/// present.  May be safely called from multiple threads without explicit<br/>/// synchronization. If there was failure in allocating the compiler object,<br/>/// null will be returned.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpv(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] ref byte sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] nuint sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] byte* inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] byte* entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			fixed (byte* psourceText = &sourceText)
			{
				ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvNative(compiler, (byte*)psourceText, sourceTextSize, shaderKind, inputFileName, entryPointName, additionalOptions);
				return ret;
			}
		}

		/// <summary>/// Takes a GLSL source string and the associated shader kind, input file<br/>/// name, compiles it according to the given additional_options. If the shader<br/>/// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,<br/>/// the compiler will try to deduce the shader kind from the source<br/>/// string and a failure in deducing will generate an error. Currently only<br/>/// #pragma annotation is supported. If the shader kind is set to one of the<br/>/// default shader kinds, the compiler will fall back to the default shader<br/>/// kind in case it failed to deduce the shader kind from source string.<br/>/// The input_file_name is a null-termintated string. It is used as a tag to<br/>/// identify the source string in cases like emitting error messages. It<br/>/// doesn't have to be a 'file name'.<br/>/// The source string will be compiled into SPIR-V binary and a<br/>/// shaderc_compilation_result will be returned to hold the results.<br/>/// The entry_point_name null-terminated string defines the name of the entry<br/>/// point to associate with this GLSL source. If the additional_options<br/>/// parameter is not null, then the compilation is modified by any options<br/>/// present.  May be safely called from multiple threads without explicit<br/>/// synchronization. If there was failure in allocating the compiler object,<br/>/// null will be returned.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpv(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] string sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] nuint sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] byte* inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] byte* entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (sourceText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(sourceText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(sourceText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvNative(compiler, pStr0, sourceTextSize, shaderKind, inputFileName, entryPointName, additionalOptions);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// Takes a GLSL source string and the associated shader kind, input file<br/>/// name, compiles it according to the given additional_options. If the shader<br/>/// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,<br/>/// the compiler will try to deduce the shader kind from the source<br/>/// string and a failure in deducing will generate an error. Currently only<br/>/// #pragma annotation is supported. If the shader kind is set to one of the<br/>/// default shader kinds, the compiler will fall back to the default shader<br/>/// kind in case it failed to deduce the shader kind from source string.<br/>/// The input_file_name is a null-termintated string. It is used as a tag to<br/>/// identify the source string in cases like emitting error messages. It<br/>/// doesn't have to be a 'file name'.<br/>/// The source string will be compiled into SPIR-V binary and a<br/>/// shaderc_compilation_result will be returned to hold the results.<br/>/// The entry_point_name null-terminated string defines the name of the entry<br/>/// point to associate with this GLSL source. If the additional_options<br/>/// parameter is not null, then the compilation is modified by any options<br/>/// present.  May be safely called from multiple threads without explicit<br/>/// synchronization. If there was failure in allocating the compiler object,<br/>/// null will be returned.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpv(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] byte* sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] ulong sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] ref byte inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] byte* entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			fixed (byte* pinputFileName = &inputFileName)
			{
				ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvNative(compiler, sourceText, sourceTextSize, shaderKind, (byte*)pinputFileName, entryPointName, additionalOptions);
				return ret;
			}
		}

		/// <summary>/// Takes a GLSL source string and the associated shader kind, input file<br/>/// name, compiles it according to the given additional_options. If the shader<br/>/// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,<br/>/// the compiler will try to deduce the shader kind from the source<br/>/// string and a failure in deducing will generate an error. Currently only<br/>/// #pragma annotation is supported. If the shader kind is set to one of the<br/>/// default shader kinds, the compiler will fall back to the default shader<br/>/// kind in case it failed to deduce the shader kind from source string.<br/>/// The input_file_name is a null-termintated string. It is used as a tag to<br/>/// identify the source string in cases like emitting error messages. It<br/>/// doesn't have to be a 'file name'.<br/>/// The source string will be compiled into SPIR-V binary and a<br/>/// shaderc_compilation_result will be returned to hold the results.<br/>/// The entry_point_name null-terminated string defines the name of the entry<br/>/// point to associate with this GLSL source. If the additional_options<br/>/// parameter is not null, then the compilation is modified by any options<br/>/// present.  May be safely called from multiple threads without explicit<br/>/// synchronization. If there was failure in allocating the compiler object,<br/>/// null will be returned.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpv(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] byte* sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] ulong sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] string inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] byte* entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inputFileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inputFileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inputFileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvNative(compiler, sourceText, sourceTextSize, shaderKind, pStr0, entryPointName, additionalOptions);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// Takes a GLSL source string and the associated shader kind, input file<br/>/// name, compiles it according to the given additional_options. If the shader<br/>/// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,<br/>/// the compiler will try to deduce the shader kind from the source<br/>/// string and a failure in deducing will generate an error. Currently only<br/>/// #pragma annotation is supported. If the shader kind is set to one of the<br/>/// default shader kinds, the compiler will fall back to the default shader<br/>/// kind in case it failed to deduce the shader kind from source string.<br/>/// The input_file_name is a null-termintated string. It is used as a tag to<br/>/// identify the source string in cases like emitting error messages. It<br/>/// doesn't have to be a 'file name'.<br/>/// The source string will be compiled into SPIR-V binary and a<br/>/// shaderc_compilation_result will be returned to hold the results.<br/>/// The entry_point_name null-terminated string defines the name of the entry<br/>/// point to associate with this GLSL source. If the additional_options<br/>/// parameter is not null, then the compilation is modified by any options<br/>/// present.  May be safely called from multiple threads without explicit<br/>/// synchronization. If there was failure in allocating the compiler object,<br/>/// null will be returned.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpv(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] ref byte sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] ulong sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] ref byte inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] byte* entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			fixed (byte* psourceText = &sourceText)
			{
				fixed (byte* pinputFileName = &inputFileName)
				{
					ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvNative(compiler, (byte*)psourceText, sourceTextSize, shaderKind, (byte*)pinputFileName, entryPointName, additionalOptions);
					return ret;
				}
			}
		}

		/// <summary>/// Takes a GLSL source string and the associated shader kind, input file<br/>/// name, compiles it according to the given additional_options. If the shader<br/>/// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,<br/>/// the compiler will try to deduce the shader kind from the source<br/>/// string and a failure in deducing will generate an error. Currently only<br/>/// #pragma annotation is supported. If the shader kind is set to one of the<br/>/// default shader kinds, the compiler will fall back to the default shader<br/>/// kind in case it failed to deduce the shader kind from source string.<br/>/// The input_file_name is a null-termintated string. It is used as a tag to<br/>/// identify the source string in cases like emitting error messages. It<br/>/// doesn't have to be a 'file name'.<br/>/// The source string will be compiled into SPIR-V binary and a<br/>/// shaderc_compilation_result will be returned to hold the results.<br/>/// The entry_point_name null-terminated string defines the name of the entry<br/>/// point to associate with this GLSL source. If the additional_options<br/>/// parameter is not null, then the compilation is modified by any options<br/>/// present.  May be safely called from multiple threads without explicit<br/>/// synchronization. If there was failure in allocating the compiler object,<br/>/// null will be returned.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpv(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] string sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] ulong sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] string inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] byte* entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (sourceText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(sourceText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(sourceText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (inputFileName != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(inputFileName);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(inputFileName, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvNative(compiler, pStr0, sourceTextSize, shaderKind, pStr1, entryPointName, additionalOptions);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// Takes a GLSL source string and the associated shader kind, input file<br/>/// name, compiles it according to the given additional_options. If the shader<br/>/// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,<br/>/// the compiler will try to deduce the shader kind from the source<br/>/// string and a failure in deducing will generate an error. Currently only<br/>/// #pragma annotation is supported. If the shader kind is set to one of the<br/>/// default shader kinds, the compiler will fall back to the default shader<br/>/// kind in case it failed to deduce the shader kind from source string.<br/>/// The input_file_name is a null-termintated string. It is used as a tag to<br/>/// identify the source string in cases like emitting error messages. It<br/>/// doesn't have to be a 'file name'.<br/>/// The source string will be compiled into SPIR-V binary and a<br/>/// shaderc_compilation_result will be returned to hold the results.<br/>/// The entry_point_name null-terminated string defines the name of the entry<br/>/// point to associate with this GLSL source. If the additional_options<br/>/// parameter is not null, then the compilation is modified by any options<br/>/// present.  May be safely called from multiple threads without explicit<br/>/// synchronization. If there was failure in allocating the compiler object,<br/>/// null will be returned.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpv(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] byte* sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] nuint sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] ref byte inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] byte* entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			fixed (byte* pinputFileName = &inputFileName)
			{
				ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvNative(compiler, sourceText, sourceTextSize, shaderKind, (byte*)pinputFileName, entryPointName, additionalOptions);
				return ret;
			}
		}

		/// <summary>/// Takes a GLSL source string and the associated shader kind, input file<br/>/// name, compiles it according to the given additional_options. If the shader<br/>/// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,<br/>/// the compiler will try to deduce the shader kind from the source<br/>/// string and a failure in deducing will generate an error. Currently only<br/>/// #pragma annotation is supported. If the shader kind is set to one of the<br/>/// default shader kinds, the compiler will fall back to the default shader<br/>/// kind in case it failed to deduce the shader kind from source string.<br/>/// The input_file_name is a null-termintated string. It is used as a tag to<br/>/// identify the source string in cases like emitting error messages. It<br/>/// doesn't have to be a 'file name'.<br/>/// The source string will be compiled into SPIR-V binary and a<br/>/// shaderc_compilation_result will be returned to hold the results.<br/>/// The entry_point_name null-terminated string defines the name of the entry<br/>/// point to associate with this GLSL source. If the additional_options<br/>/// parameter is not null, then the compilation is modified by any options<br/>/// present.  May be safely called from multiple threads without explicit<br/>/// synchronization. If there was failure in allocating the compiler object,<br/>/// null will be returned.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpv(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] byte* sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] nuint sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] string inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] byte* entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inputFileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inputFileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inputFileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvNative(compiler, sourceText, sourceTextSize, shaderKind, pStr0, entryPointName, additionalOptions);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// Takes a GLSL source string and the associated shader kind, input file<br/>/// name, compiles it according to the given additional_options. If the shader<br/>/// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,<br/>/// the compiler will try to deduce the shader kind from the source<br/>/// string and a failure in deducing will generate an error. Currently only<br/>/// #pragma annotation is supported. If the shader kind is set to one of the<br/>/// default shader kinds, the compiler will fall back to the default shader<br/>/// kind in case it failed to deduce the shader kind from source string.<br/>/// The input_file_name is a null-termintated string. It is used as a tag to<br/>/// identify the source string in cases like emitting error messages. It<br/>/// doesn't have to be a 'file name'.<br/>/// The source string will be compiled into SPIR-V binary and a<br/>/// shaderc_compilation_result will be returned to hold the results.<br/>/// The entry_point_name null-terminated string defines the name of the entry<br/>/// point to associate with this GLSL source. If the additional_options<br/>/// parameter is not null, then the compilation is modified by any options<br/>/// present.  May be safely called from multiple threads without explicit<br/>/// synchronization. If there was failure in allocating the compiler object,<br/>/// null will be returned.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpv(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] ref byte sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] nuint sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] ref byte inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] byte* entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			fixed (byte* psourceText = &sourceText)
			{
				fixed (byte* pinputFileName = &inputFileName)
				{
					ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvNative(compiler, (byte*)psourceText, sourceTextSize, shaderKind, (byte*)pinputFileName, entryPointName, additionalOptions);
					return ret;
				}
			}
		}

		/// <summary>/// Takes a GLSL source string and the associated shader kind, input file<br/>/// name, compiles it according to the given additional_options. If the shader<br/>/// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,<br/>/// the compiler will try to deduce the shader kind from the source<br/>/// string and a failure in deducing will generate an error. Currently only<br/>/// #pragma annotation is supported. If the shader kind is set to one of the<br/>/// default shader kinds, the compiler will fall back to the default shader<br/>/// kind in case it failed to deduce the shader kind from source string.<br/>/// The input_file_name is a null-termintated string. It is used as a tag to<br/>/// identify the source string in cases like emitting error messages. It<br/>/// doesn't have to be a 'file name'.<br/>/// The source string will be compiled into SPIR-V binary and a<br/>/// shaderc_compilation_result will be returned to hold the results.<br/>/// The entry_point_name null-terminated string defines the name of the entry<br/>/// point to associate with this GLSL source. If the additional_options<br/>/// parameter is not null, then the compilation is modified by any options<br/>/// present.  May be safely called from multiple threads without explicit<br/>/// synchronization. If there was failure in allocating the compiler object,<br/>/// null will be returned.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpv(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] string sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] nuint sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] string inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] byte* entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (sourceText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(sourceText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(sourceText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (inputFileName != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(inputFileName);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(inputFileName, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvNative(compiler, pStr0, sourceTextSize, shaderKind, pStr1, entryPointName, additionalOptions);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// Takes a GLSL source string and the associated shader kind, input file<br/>/// name, compiles it according to the given additional_options. If the shader<br/>/// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,<br/>/// the compiler will try to deduce the shader kind from the source<br/>/// string and a failure in deducing will generate an error. Currently only<br/>/// #pragma annotation is supported. If the shader kind is set to one of the<br/>/// default shader kinds, the compiler will fall back to the default shader<br/>/// kind in case it failed to deduce the shader kind from source string.<br/>/// The input_file_name is a null-termintated string. It is used as a tag to<br/>/// identify the source string in cases like emitting error messages. It<br/>/// doesn't have to be a 'file name'.<br/>/// The source string will be compiled into SPIR-V binary and a<br/>/// shaderc_compilation_result will be returned to hold the results.<br/>/// The entry_point_name null-terminated string defines the name of the entry<br/>/// point to associate with this GLSL source. If the additional_options<br/>/// parameter is not null, then the compilation is modified by any options<br/>/// present.  May be safely called from multiple threads without explicit<br/>/// synchronization. If there was failure in allocating the compiler object,<br/>/// null will be returned.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpv(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] byte* sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] ulong sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] byte* inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] ref byte entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			fixed (byte* pentryPointName = &entryPointName)
			{
				ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvNative(compiler, sourceText, sourceTextSize, shaderKind, inputFileName, (byte*)pentryPointName, additionalOptions);
				return ret;
			}
		}

		/// <summary>/// Takes a GLSL source string and the associated shader kind, input file<br/>/// name, compiles it according to the given additional_options. If the shader<br/>/// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,<br/>/// the compiler will try to deduce the shader kind from the source<br/>/// string and a failure in deducing will generate an error. Currently only<br/>/// #pragma annotation is supported. If the shader kind is set to one of the<br/>/// default shader kinds, the compiler will fall back to the default shader<br/>/// kind in case it failed to deduce the shader kind from source string.<br/>/// The input_file_name is a null-termintated string. It is used as a tag to<br/>/// identify the source string in cases like emitting error messages. It<br/>/// doesn't have to be a 'file name'.<br/>/// The source string will be compiled into SPIR-V binary and a<br/>/// shaderc_compilation_result will be returned to hold the results.<br/>/// The entry_point_name null-terminated string defines the name of the entry<br/>/// point to associate with this GLSL source. If the additional_options<br/>/// parameter is not null, then the compilation is modified by any options<br/>/// present.  May be safely called from multiple threads without explicit<br/>/// synchronization. If there was failure in allocating the compiler object,<br/>/// null will be returned.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpv(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] byte* sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] ulong sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] byte* inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] string entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (entryPointName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(entryPointName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(entryPointName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvNative(compiler, sourceText, sourceTextSize, shaderKind, inputFileName, pStr0, additionalOptions);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// Takes a GLSL source string and the associated shader kind, input file<br/>/// name, compiles it according to the given additional_options. If the shader<br/>/// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,<br/>/// the compiler will try to deduce the shader kind from the source<br/>/// string and a failure in deducing will generate an error. Currently only<br/>/// #pragma annotation is supported. If the shader kind is set to one of the<br/>/// default shader kinds, the compiler will fall back to the default shader<br/>/// kind in case it failed to deduce the shader kind from source string.<br/>/// The input_file_name is a null-termintated string. It is used as a tag to<br/>/// identify the source string in cases like emitting error messages. It<br/>/// doesn't have to be a 'file name'.<br/>/// The source string will be compiled into SPIR-V binary and a<br/>/// shaderc_compilation_result will be returned to hold the results.<br/>/// The entry_point_name null-terminated string defines the name of the entry<br/>/// point to associate with this GLSL source. If the additional_options<br/>/// parameter is not null, then the compilation is modified by any options<br/>/// present.  May be safely called from multiple threads without explicit<br/>/// synchronization. If there was failure in allocating the compiler object,<br/>/// null will be returned.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpv(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] ref byte sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] ulong sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] byte* inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] ref byte entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			fixed (byte* psourceText = &sourceText)
			{
				fixed (byte* pentryPointName = &entryPointName)
				{
					ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvNative(compiler, (byte*)psourceText, sourceTextSize, shaderKind, inputFileName, (byte*)pentryPointName, additionalOptions);
					return ret;
				}
			}
		}

		/// <summary>/// Takes a GLSL source string and the associated shader kind, input file<br/>/// name, compiles it according to the given additional_options. If the shader<br/>/// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,<br/>/// the compiler will try to deduce the shader kind from the source<br/>/// string and a failure in deducing will generate an error. Currently only<br/>/// #pragma annotation is supported. If the shader kind is set to one of the<br/>/// default shader kinds, the compiler will fall back to the default shader<br/>/// kind in case it failed to deduce the shader kind from source string.<br/>/// The input_file_name is a null-termintated string. It is used as a tag to<br/>/// identify the source string in cases like emitting error messages. It<br/>/// doesn't have to be a 'file name'.<br/>/// The source string will be compiled into SPIR-V binary and a<br/>/// shaderc_compilation_result will be returned to hold the results.<br/>/// The entry_point_name null-terminated string defines the name of the entry<br/>/// point to associate with this GLSL source. If the additional_options<br/>/// parameter is not null, then the compilation is modified by any options<br/>/// present.  May be safely called from multiple threads without explicit<br/>/// synchronization. If there was failure in allocating the compiler object,<br/>/// null will be returned.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpv(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] string sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] ulong sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] byte* inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] string entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (sourceText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(sourceText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(sourceText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (entryPointName != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(entryPointName);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(entryPointName, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvNative(compiler, pStr0, sourceTextSize, shaderKind, inputFileName, pStr1, additionalOptions);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// Takes a GLSL source string and the associated shader kind, input file<br/>/// name, compiles it according to the given additional_options. If the shader<br/>/// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,<br/>/// the compiler will try to deduce the shader kind from the source<br/>/// string and a failure in deducing will generate an error. Currently only<br/>/// #pragma annotation is supported. If the shader kind is set to one of the<br/>/// default shader kinds, the compiler will fall back to the default shader<br/>/// kind in case it failed to deduce the shader kind from source string.<br/>/// The input_file_name is a null-termintated string. It is used as a tag to<br/>/// identify the source string in cases like emitting error messages. It<br/>/// doesn't have to be a 'file name'.<br/>/// The source string will be compiled into SPIR-V binary and a<br/>/// shaderc_compilation_result will be returned to hold the results.<br/>/// The entry_point_name null-terminated string defines the name of the entry<br/>/// point to associate with this GLSL source. If the additional_options<br/>/// parameter is not null, then the compilation is modified by any options<br/>/// present.  May be safely called from multiple threads without explicit<br/>/// synchronization. If there was failure in allocating the compiler object,<br/>/// null will be returned.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpv(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] byte* sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] nuint sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] byte* inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] ref byte entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			fixed (byte* pentryPointName = &entryPointName)
			{
				ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvNative(compiler, sourceText, sourceTextSize, shaderKind, inputFileName, (byte*)pentryPointName, additionalOptions);
				return ret;
			}
		}

		/// <summary>/// Takes a GLSL source string and the associated shader kind, input file<br/>/// name, compiles it according to the given additional_options. If the shader<br/>/// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,<br/>/// the compiler will try to deduce the shader kind from the source<br/>/// string and a failure in deducing will generate an error. Currently only<br/>/// #pragma annotation is supported. If the shader kind is set to one of the<br/>/// default shader kinds, the compiler will fall back to the default shader<br/>/// kind in case it failed to deduce the shader kind from source string.<br/>/// The input_file_name is a null-termintated string. It is used as a tag to<br/>/// identify the source string in cases like emitting error messages. It<br/>/// doesn't have to be a 'file name'.<br/>/// The source string will be compiled into SPIR-V binary and a<br/>/// shaderc_compilation_result will be returned to hold the results.<br/>/// The entry_point_name null-terminated string defines the name of the entry<br/>/// point to associate with this GLSL source. If the additional_options<br/>/// parameter is not null, then the compilation is modified by any options<br/>/// present.  May be safely called from multiple threads without explicit<br/>/// synchronization. If there was failure in allocating the compiler object,<br/>/// null will be returned.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpv(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] byte* sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] nuint sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] byte* inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] string entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (entryPointName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(entryPointName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(entryPointName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvNative(compiler, sourceText, sourceTextSize, shaderKind, inputFileName, pStr0, additionalOptions);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// Takes a GLSL source string and the associated shader kind, input file<br/>/// name, compiles it according to the given additional_options. If the shader<br/>/// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,<br/>/// the compiler will try to deduce the shader kind from the source<br/>/// string and a failure in deducing will generate an error. Currently only<br/>/// #pragma annotation is supported. If the shader kind is set to one of the<br/>/// default shader kinds, the compiler will fall back to the default shader<br/>/// kind in case it failed to deduce the shader kind from source string.<br/>/// The input_file_name is a null-termintated string. It is used as a tag to<br/>/// identify the source string in cases like emitting error messages. It<br/>/// doesn't have to be a 'file name'.<br/>/// The source string will be compiled into SPIR-V binary and a<br/>/// shaderc_compilation_result will be returned to hold the results.<br/>/// The entry_point_name null-terminated string defines the name of the entry<br/>/// point to associate with this GLSL source. If the additional_options<br/>/// parameter is not null, then the compilation is modified by any options<br/>/// present.  May be safely called from multiple threads without explicit<br/>/// synchronization. If there was failure in allocating the compiler object,<br/>/// null will be returned.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpv(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] ref byte sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] nuint sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] byte* inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] ref byte entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			fixed (byte* psourceText = &sourceText)
			{
				fixed (byte* pentryPointName = &entryPointName)
				{
					ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvNative(compiler, (byte*)psourceText, sourceTextSize, shaderKind, inputFileName, (byte*)pentryPointName, additionalOptions);
					return ret;
				}
			}
		}

		/// <summary>/// Takes a GLSL source string and the associated shader kind, input file<br/>/// name, compiles it according to the given additional_options. If the shader<br/>/// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,<br/>/// the compiler will try to deduce the shader kind from the source<br/>/// string and a failure in deducing will generate an error. Currently only<br/>/// #pragma annotation is supported. If the shader kind is set to one of the<br/>/// default shader kinds, the compiler will fall back to the default shader<br/>/// kind in case it failed to deduce the shader kind from source string.<br/>/// The input_file_name is a null-termintated string. It is used as a tag to<br/>/// identify the source string in cases like emitting error messages. It<br/>/// doesn't have to be a 'file name'.<br/>/// The source string will be compiled into SPIR-V binary and a<br/>/// shaderc_compilation_result will be returned to hold the results.<br/>/// The entry_point_name null-terminated string defines the name of the entry<br/>/// point to associate with this GLSL source. If the additional_options<br/>/// parameter is not null, then the compilation is modified by any options<br/>/// present.  May be safely called from multiple threads without explicit<br/>/// synchronization. If there was failure in allocating the compiler object,<br/>/// null will be returned.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpv(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] string sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] nuint sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] byte* inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] string entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (sourceText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(sourceText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(sourceText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (entryPointName != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(entryPointName);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(entryPointName, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvNative(compiler, pStr0, sourceTextSize, shaderKind, inputFileName, pStr1, additionalOptions);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// Takes a GLSL source string and the associated shader kind, input file<br/>/// name, compiles it according to the given additional_options. If the shader<br/>/// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,<br/>/// the compiler will try to deduce the shader kind from the source<br/>/// string and a failure in deducing will generate an error. Currently only<br/>/// #pragma annotation is supported. If the shader kind is set to one of the<br/>/// default shader kinds, the compiler will fall back to the default shader<br/>/// kind in case it failed to deduce the shader kind from source string.<br/>/// The input_file_name is a null-termintated string. It is used as a tag to<br/>/// identify the source string in cases like emitting error messages. It<br/>/// doesn't have to be a 'file name'.<br/>/// The source string will be compiled into SPIR-V binary and a<br/>/// shaderc_compilation_result will be returned to hold the results.<br/>/// The entry_point_name null-terminated string defines the name of the entry<br/>/// point to associate with this GLSL source. If the additional_options<br/>/// parameter is not null, then the compilation is modified by any options<br/>/// present.  May be safely called from multiple threads without explicit<br/>/// synchronization. If there was failure in allocating the compiler object,<br/>/// null will be returned.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpv(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] byte* sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] ulong sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] ref byte inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] ref byte entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			fixed (byte* pinputFileName = &inputFileName)
			{
				fixed (byte* pentryPointName = &entryPointName)
				{
					ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvNative(compiler, sourceText, sourceTextSize, shaderKind, (byte*)pinputFileName, (byte*)pentryPointName, additionalOptions);
					return ret;
				}
			}
		}

		/// <summary>/// Takes a GLSL source string and the associated shader kind, input file<br/>/// name, compiles it according to the given additional_options. If the shader<br/>/// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,<br/>/// the compiler will try to deduce the shader kind from the source<br/>/// string and a failure in deducing will generate an error. Currently only<br/>/// #pragma annotation is supported. If the shader kind is set to one of the<br/>/// default shader kinds, the compiler will fall back to the default shader<br/>/// kind in case it failed to deduce the shader kind from source string.<br/>/// The input_file_name is a null-termintated string. It is used as a tag to<br/>/// identify the source string in cases like emitting error messages. It<br/>/// doesn't have to be a 'file name'.<br/>/// The source string will be compiled into SPIR-V binary and a<br/>/// shaderc_compilation_result will be returned to hold the results.<br/>/// The entry_point_name null-terminated string defines the name of the entry<br/>/// point to associate with this GLSL source. If the additional_options<br/>/// parameter is not null, then the compilation is modified by any options<br/>/// present.  May be safely called from multiple threads without explicit<br/>/// synchronization. If there was failure in allocating the compiler object,<br/>/// null will be returned.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpv(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] byte* sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] ulong sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] string inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] string entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inputFileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inputFileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inputFileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (entryPointName != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(entryPointName);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(entryPointName, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvNative(compiler, sourceText, sourceTextSize, shaderKind, pStr0, pStr1, additionalOptions);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// Takes a GLSL source string and the associated shader kind, input file<br/>/// name, compiles it according to the given additional_options. If the shader<br/>/// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,<br/>/// the compiler will try to deduce the shader kind from the source<br/>/// string and a failure in deducing will generate an error. Currently only<br/>/// #pragma annotation is supported. If the shader kind is set to one of the<br/>/// default shader kinds, the compiler will fall back to the default shader<br/>/// kind in case it failed to deduce the shader kind from source string.<br/>/// The input_file_name is a null-termintated string. It is used as a tag to<br/>/// identify the source string in cases like emitting error messages. It<br/>/// doesn't have to be a 'file name'.<br/>/// The source string will be compiled into SPIR-V binary and a<br/>/// shaderc_compilation_result will be returned to hold the results.<br/>/// The entry_point_name null-terminated string defines the name of the entry<br/>/// point to associate with this GLSL source. If the additional_options<br/>/// parameter is not null, then the compilation is modified by any options<br/>/// present.  May be safely called from multiple threads without explicit<br/>/// synchronization. If there was failure in allocating the compiler object,<br/>/// null will be returned.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpv(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] ref byte sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] ulong sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] ref byte inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] ref byte entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			fixed (byte* psourceText = &sourceText)
			{
				fixed (byte* pinputFileName = &inputFileName)
				{
					fixed (byte* pentryPointName = &entryPointName)
					{
						ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvNative(compiler, (byte*)psourceText, sourceTextSize, shaderKind, (byte*)pinputFileName, (byte*)pentryPointName, additionalOptions);
						return ret;
					}
				}
			}
		}

		/// <summary>/// Takes a GLSL source string and the associated shader kind, input file<br/>/// name, compiles it according to the given additional_options. If the shader<br/>/// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,<br/>/// the compiler will try to deduce the shader kind from the source<br/>/// string and a failure in deducing will generate an error. Currently only<br/>/// #pragma annotation is supported. If the shader kind is set to one of the<br/>/// default shader kinds, the compiler will fall back to the default shader<br/>/// kind in case it failed to deduce the shader kind from source string.<br/>/// The input_file_name is a null-termintated string. It is used as a tag to<br/>/// identify the source string in cases like emitting error messages. It<br/>/// doesn't have to be a 'file name'.<br/>/// The source string will be compiled into SPIR-V binary and a<br/>/// shaderc_compilation_result will be returned to hold the results.<br/>/// The entry_point_name null-terminated string defines the name of the entry<br/>/// point to associate with this GLSL source. If the additional_options<br/>/// parameter is not null, then the compilation is modified by any options<br/>/// present.  May be safely called from multiple threads without explicit<br/>/// synchronization. If there was failure in allocating the compiler object,<br/>/// null will be returned.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpv(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] string sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] ulong sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] string inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] string entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (sourceText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(sourceText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(sourceText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (inputFileName != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(inputFileName);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(inputFileName, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (entryPointName != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(entryPointName);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(entryPointName, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvNative(compiler, pStr0, sourceTextSize, shaderKind, pStr1, pStr2, additionalOptions);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// Takes a GLSL source string and the associated shader kind, input file<br/>/// name, compiles it according to the given additional_options. If the shader<br/>/// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,<br/>/// the compiler will try to deduce the shader kind from the source<br/>/// string and a failure in deducing will generate an error. Currently only<br/>/// #pragma annotation is supported. If the shader kind is set to one of the<br/>/// default shader kinds, the compiler will fall back to the default shader<br/>/// kind in case it failed to deduce the shader kind from source string.<br/>/// The input_file_name is a null-termintated string. It is used as a tag to<br/>/// identify the source string in cases like emitting error messages. It<br/>/// doesn't have to be a 'file name'.<br/>/// The source string will be compiled into SPIR-V binary and a<br/>/// shaderc_compilation_result will be returned to hold the results.<br/>/// The entry_point_name null-terminated string defines the name of the entry<br/>/// point to associate with this GLSL source. If the additional_options<br/>/// parameter is not null, then the compilation is modified by any options<br/>/// present.  May be safely called from multiple threads without explicit<br/>/// synchronization. If there was failure in allocating the compiler object,<br/>/// null will be returned.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpv(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] byte* sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] nuint sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] ref byte inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] ref byte entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			fixed (byte* pinputFileName = &inputFileName)
			{
				fixed (byte* pentryPointName = &entryPointName)
				{
					ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvNative(compiler, sourceText, sourceTextSize, shaderKind, (byte*)pinputFileName, (byte*)pentryPointName, additionalOptions);
					return ret;
				}
			}
		}

		/// <summary>/// Takes a GLSL source string and the associated shader kind, input file<br/>/// name, compiles it according to the given additional_options. If the shader<br/>/// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,<br/>/// the compiler will try to deduce the shader kind from the source<br/>/// string and a failure in deducing will generate an error. Currently only<br/>/// #pragma annotation is supported. If the shader kind is set to one of the<br/>/// default shader kinds, the compiler will fall back to the default shader<br/>/// kind in case it failed to deduce the shader kind from source string.<br/>/// The input_file_name is a null-termintated string. It is used as a tag to<br/>/// identify the source string in cases like emitting error messages. It<br/>/// doesn't have to be a 'file name'.<br/>/// The source string will be compiled into SPIR-V binary and a<br/>/// shaderc_compilation_result will be returned to hold the results.<br/>/// The entry_point_name null-terminated string defines the name of the entry<br/>/// point to associate with this GLSL source. If the additional_options<br/>/// parameter is not null, then the compilation is modified by any options<br/>/// present.  May be safely called from multiple threads without explicit<br/>/// synchronization. If there was failure in allocating the compiler object,<br/>/// null will be returned.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpv(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] byte* sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] nuint sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] string inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] string entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inputFileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inputFileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inputFileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (entryPointName != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(entryPointName);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(entryPointName, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvNative(compiler, sourceText, sourceTextSize, shaderKind, pStr0, pStr1, additionalOptions);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// Takes a GLSL source string and the associated shader kind, input file<br/>/// name, compiles it according to the given additional_options. If the shader<br/>/// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,<br/>/// the compiler will try to deduce the shader kind from the source<br/>/// string and a failure in deducing will generate an error. Currently only<br/>/// #pragma annotation is supported. If the shader kind is set to one of the<br/>/// default shader kinds, the compiler will fall back to the default shader<br/>/// kind in case it failed to deduce the shader kind from source string.<br/>/// The input_file_name is a null-termintated string. It is used as a tag to<br/>/// identify the source string in cases like emitting error messages. It<br/>/// doesn't have to be a 'file name'.<br/>/// The source string will be compiled into SPIR-V binary and a<br/>/// shaderc_compilation_result will be returned to hold the results.<br/>/// The entry_point_name null-terminated string defines the name of the entry<br/>/// point to associate with this GLSL source. If the additional_options<br/>/// parameter is not null, then the compilation is modified by any options<br/>/// present.  May be safely called from multiple threads without explicit<br/>/// synchronization. If there was failure in allocating the compiler object,<br/>/// null will be returned.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpv(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] ref byte sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] nuint sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] ref byte inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] ref byte entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			fixed (byte* psourceText = &sourceText)
			{
				fixed (byte* pinputFileName = &inputFileName)
				{
					fixed (byte* pentryPointName = &entryPointName)
					{
						ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvNative(compiler, (byte*)psourceText, sourceTextSize, shaderKind, (byte*)pinputFileName, (byte*)pentryPointName, additionalOptions);
						return ret;
					}
				}
			}
		}

		/// <summary>/// Takes a GLSL source string and the associated shader kind, input file<br/>/// name, compiles it according to the given additional_options. If the shader<br/>/// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,<br/>/// the compiler will try to deduce the shader kind from the source<br/>/// string and a failure in deducing will generate an error. Currently only<br/>/// #pragma annotation is supported. If the shader kind is set to one of the<br/>/// default shader kinds, the compiler will fall back to the default shader<br/>/// kind in case it failed to deduce the shader kind from source string.<br/>/// The input_file_name is a null-termintated string. It is used as a tag to<br/>/// identify the source string in cases like emitting error messages. It<br/>/// doesn't have to be a 'file name'.<br/>/// The source string will be compiled into SPIR-V binary and a<br/>/// shaderc_compilation_result will be returned to hold the results.<br/>/// The entry_point_name null-terminated string defines the name of the entry<br/>/// point to associate with this GLSL source. If the additional_options<br/>/// parameter is not null, then the compilation is modified by any options<br/>/// present.  May be safely called from multiple threads without explicit<br/>/// synchronization. If there was failure in allocating the compiler object,<br/>/// null will be returned.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpv(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] string sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] nuint sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] string inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] string entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (sourceText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(sourceText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(sourceText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (inputFileName != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(inputFileName);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(inputFileName, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (entryPointName != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(entryPointName);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(entryPointName, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvNative(compiler, pStr0, sourceTextSize, shaderKind, pStr1, pStr2, additionalOptions);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text<br/>/// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined<br/>/// by the SPIRV-Tools open source project.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv_assembly")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpvAssembly(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] byte* sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] ulong sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] byte* inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] byte* entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvAssemblyNative(compiler, sourceText, sourceTextSize, shaderKind, inputFileName, entryPointName, additionalOptions);
			return ret;
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text<br/>/// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined<br/>/// by the SPIRV-Tools open source project.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv_assembly")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpvAssembly(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] ref byte sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] ulong sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] byte* inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] byte* entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			fixed (byte* psourceText = &sourceText)
			{
				ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvAssemblyNative(compiler, (byte*)psourceText, sourceTextSize, shaderKind, inputFileName, entryPointName, additionalOptions);
				return ret;
			}
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text<br/>/// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined<br/>/// by the SPIRV-Tools open source project.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv_assembly")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpvAssembly(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] string sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] ulong sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] byte* inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] byte* entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (sourceText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(sourceText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(sourceText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvAssemblyNative(compiler, pStr0, sourceTextSize, shaderKind, inputFileName, entryPointName, additionalOptions);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text<br/>/// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined<br/>/// by the SPIRV-Tools open source project.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv_assembly")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpvAssembly(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] byte* sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] nuint sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] byte* inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] byte* entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvAssemblyNative(compiler, sourceText, sourceTextSize, shaderKind, inputFileName, entryPointName, additionalOptions);
			return ret;
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text<br/>/// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined<br/>/// by the SPIRV-Tools open source project.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv_assembly")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpvAssembly(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] ref byte sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] nuint sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] byte* inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] byte* entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			fixed (byte* psourceText = &sourceText)
			{
				ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvAssemblyNative(compiler, (byte*)psourceText, sourceTextSize, shaderKind, inputFileName, entryPointName, additionalOptions);
				return ret;
			}
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text<br/>/// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined<br/>/// by the SPIRV-Tools open source project.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv_assembly")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpvAssembly(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] string sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] nuint sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] byte* inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] byte* entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (sourceText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(sourceText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(sourceText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvAssemblyNative(compiler, pStr0, sourceTextSize, shaderKind, inputFileName, entryPointName, additionalOptions);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text<br/>/// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined<br/>/// by the SPIRV-Tools open source project.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv_assembly")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpvAssembly(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] byte* sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] ulong sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] ref byte inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] byte* entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			fixed (byte* pinputFileName = &inputFileName)
			{
				ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvAssemblyNative(compiler, sourceText, sourceTextSize, shaderKind, (byte*)pinputFileName, entryPointName, additionalOptions);
				return ret;
			}
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text<br/>/// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined<br/>/// by the SPIRV-Tools open source project.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv_assembly")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpvAssembly(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] byte* sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] ulong sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] string inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] byte* entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inputFileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inputFileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inputFileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvAssemblyNative(compiler, sourceText, sourceTextSize, shaderKind, pStr0, entryPointName, additionalOptions);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text<br/>/// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined<br/>/// by the SPIRV-Tools open source project.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv_assembly")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpvAssembly(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] ref byte sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] ulong sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] ref byte inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] byte* entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			fixed (byte* psourceText = &sourceText)
			{
				fixed (byte* pinputFileName = &inputFileName)
				{
					ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvAssemblyNative(compiler, (byte*)psourceText, sourceTextSize, shaderKind, (byte*)pinputFileName, entryPointName, additionalOptions);
					return ret;
				}
			}
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text<br/>/// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined<br/>/// by the SPIRV-Tools open source project.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv_assembly")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpvAssembly(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] string sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] ulong sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] string inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] byte* entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (sourceText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(sourceText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(sourceText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (inputFileName != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(inputFileName);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(inputFileName, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvAssemblyNative(compiler, pStr0, sourceTextSize, shaderKind, pStr1, entryPointName, additionalOptions);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text<br/>/// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined<br/>/// by the SPIRV-Tools open source project.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv_assembly")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpvAssembly(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] byte* sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] nuint sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] ref byte inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] byte* entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			fixed (byte* pinputFileName = &inputFileName)
			{
				ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvAssemblyNative(compiler, sourceText, sourceTextSize, shaderKind, (byte*)pinputFileName, entryPointName, additionalOptions);
				return ret;
			}
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text<br/>/// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined<br/>/// by the SPIRV-Tools open source project.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv_assembly")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpvAssembly(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] byte* sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] nuint sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] string inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] byte* entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inputFileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inputFileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inputFileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvAssemblyNative(compiler, sourceText, sourceTextSize, shaderKind, pStr0, entryPointName, additionalOptions);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text<br/>/// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined<br/>/// by the SPIRV-Tools open source project.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv_assembly")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpvAssembly(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] ref byte sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] nuint sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] ref byte inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] byte* entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			fixed (byte* psourceText = &sourceText)
			{
				fixed (byte* pinputFileName = &inputFileName)
				{
					ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvAssemblyNative(compiler, (byte*)psourceText, sourceTextSize, shaderKind, (byte*)pinputFileName, entryPointName, additionalOptions);
					return ret;
				}
			}
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text<br/>/// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined<br/>/// by the SPIRV-Tools open source project.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv_assembly")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpvAssembly(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] string sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] nuint sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] string inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] byte* entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (sourceText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(sourceText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(sourceText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (inputFileName != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(inputFileName);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(inputFileName, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvAssemblyNative(compiler, pStr0, sourceTextSize, shaderKind, pStr1, entryPointName, additionalOptions);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text<br/>/// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined<br/>/// by the SPIRV-Tools open source project.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv_assembly")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpvAssembly(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] byte* sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] ulong sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] byte* inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] ref byte entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			fixed (byte* pentryPointName = &entryPointName)
			{
				ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvAssemblyNative(compiler, sourceText, sourceTextSize, shaderKind, inputFileName, (byte*)pentryPointName, additionalOptions);
				return ret;
			}
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text<br/>/// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined<br/>/// by the SPIRV-Tools open source project.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv_assembly")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpvAssembly(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] byte* sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] ulong sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] byte* inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] string entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (entryPointName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(entryPointName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(entryPointName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvAssemblyNative(compiler, sourceText, sourceTextSize, shaderKind, inputFileName, pStr0, additionalOptions);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text<br/>/// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined<br/>/// by the SPIRV-Tools open source project.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv_assembly")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpvAssembly(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] ref byte sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] ulong sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] byte* inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] ref byte entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			fixed (byte* psourceText = &sourceText)
			{
				fixed (byte* pentryPointName = &entryPointName)
				{
					ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvAssemblyNative(compiler, (byte*)psourceText, sourceTextSize, shaderKind, inputFileName, (byte*)pentryPointName, additionalOptions);
					return ret;
				}
			}
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text<br/>/// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined<br/>/// by the SPIRV-Tools open source project.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv_assembly")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpvAssembly(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] string sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] ulong sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] byte* inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] string entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (sourceText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(sourceText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(sourceText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (entryPointName != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(entryPointName);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(entryPointName, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvAssemblyNative(compiler, pStr0, sourceTextSize, shaderKind, inputFileName, pStr1, additionalOptions);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text<br/>/// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined<br/>/// by the SPIRV-Tools open source project.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv_assembly")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpvAssembly(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] byte* sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] nuint sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] byte* inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] ref byte entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			fixed (byte* pentryPointName = &entryPointName)
			{
				ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvAssemblyNative(compiler, sourceText, sourceTextSize, shaderKind, inputFileName, (byte*)pentryPointName, additionalOptions);
				return ret;
			}
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text<br/>/// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined<br/>/// by the SPIRV-Tools open source project.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv_assembly")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpvAssembly(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] byte* sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] nuint sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] byte* inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] string entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (entryPointName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(entryPointName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(entryPointName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvAssemblyNative(compiler, sourceText, sourceTextSize, shaderKind, inputFileName, pStr0, additionalOptions);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text<br/>/// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined<br/>/// by the SPIRV-Tools open source project.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv_assembly")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpvAssembly(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] ref byte sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] nuint sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] byte* inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] ref byte entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			fixed (byte* psourceText = &sourceText)
			{
				fixed (byte* pentryPointName = &entryPointName)
				{
					ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvAssemblyNative(compiler, (byte*)psourceText, sourceTextSize, shaderKind, inputFileName, (byte*)pentryPointName, additionalOptions);
					return ret;
				}
			}
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text<br/>/// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined<br/>/// by the SPIRV-Tools open source project.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv_assembly")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpvAssembly(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] string sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] nuint sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] byte* inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] string entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (sourceText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(sourceText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(sourceText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (entryPointName != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(entryPointName);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(entryPointName, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvAssemblyNative(compiler, pStr0, sourceTextSize, shaderKind, inputFileName, pStr1, additionalOptions);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text<br/>/// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined<br/>/// by the SPIRV-Tools open source project.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv_assembly")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpvAssembly(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] byte* sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] ulong sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] ref byte inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] ref byte entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			fixed (byte* pinputFileName = &inputFileName)
			{
				fixed (byte* pentryPointName = &entryPointName)
				{
					ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvAssemblyNative(compiler, sourceText, sourceTextSize, shaderKind, (byte*)pinputFileName, (byte*)pentryPointName, additionalOptions);
					return ret;
				}
			}
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text<br/>/// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined<br/>/// by the SPIRV-Tools open source project.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv_assembly")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpvAssembly(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] byte* sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] ulong sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] string inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] string entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inputFileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inputFileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inputFileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (entryPointName != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(entryPointName);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(entryPointName, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvAssemblyNative(compiler, sourceText, sourceTextSize, shaderKind, pStr0, pStr1, additionalOptions);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text<br/>/// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined<br/>/// by the SPIRV-Tools open source project.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv_assembly")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpvAssembly(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] ref byte sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] ulong sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] ref byte inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] ref byte entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			fixed (byte* psourceText = &sourceText)
			{
				fixed (byte* pinputFileName = &inputFileName)
				{
					fixed (byte* pentryPointName = &entryPointName)
					{
						ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvAssemblyNative(compiler, (byte*)psourceText, sourceTextSize, shaderKind, (byte*)pinputFileName, (byte*)pentryPointName, additionalOptions);
						return ret;
					}
				}
			}
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text<br/>/// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined<br/>/// by the SPIRV-Tools open source project.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv_assembly")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpvAssembly(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] string sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] ulong sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] string inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] string entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (sourceText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(sourceText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(sourceText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (inputFileName != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(inputFileName);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(inputFileName, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (entryPointName != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(entryPointName);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(entryPointName, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvAssemblyNative(compiler, pStr0, sourceTextSize, shaderKind, pStr1, pStr2, additionalOptions);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text<br/>/// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined<br/>/// by the SPIRV-Tools open source project.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv_assembly")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpvAssembly(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] byte* sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] nuint sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] ref byte inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] ref byte entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			fixed (byte* pinputFileName = &inputFileName)
			{
				fixed (byte* pentryPointName = &entryPointName)
				{
					ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvAssemblyNative(compiler, sourceText, sourceTextSize, shaderKind, (byte*)pinputFileName, (byte*)pentryPointName, additionalOptions);
					return ret;
				}
			}
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text<br/>/// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined<br/>/// by the SPIRV-Tools open source project.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv_assembly")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpvAssembly(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] byte* sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] nuint sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] string inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] string entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inputFileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inputFileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inputFileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (entryPointName != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(entryPointName);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(entryPointName, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvAssemblyNative(compiler, sourceText, sourceTextSize, shaderKind, pStr0, pStr1, additionalOptions);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text<br/>/// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined<br/>/// by the SPIRV-Tools open source project.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv_assembly")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpvAssembly(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] ref byte sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] nuint sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] ref byte inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] ref byte entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			fixed (byte* psourceText = &sourceText)
			{
				fixed (byte* pinputFileName = &inputFileName)
				{
					fixed (byte* pentryPointName = &entryPointName)
					{
						ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvAssemblyNative(compiler, (byte*)psourceText, sourceTextSize, shaderKind, (byte*)pinputFileName, (byte*)pentryPointName, additionalOptions);
						return ret;
					}
				}
			}
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text<br/>/// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined<br/>/// by the SPIRV-Tools open source project.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_spv_assembly")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoSpvAssembly(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] string sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] nuint sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] string inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] string entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (sourceText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(sourceText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(sourceText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (inputFileName != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(inputFileName);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(inputFileName, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (entryPointName != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(entryPointName);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(entryPointName, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			ShadercCompilationResult ret = Shaderc.ShadercCompileIntoSpvAssemblyNative(compiler, pStr0, sourceTextSize, shaderKind, pStr1, pStr2, additionalOptions);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains preprocessed source<br/>/// code instead of a SPIR-V binary module<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_preprocessed_text")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoPreprocessedText(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] byte* sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] ulong sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] byte* inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] byte* entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			ShadercCompilationResult ret = Shaderc.ShadercCompileIntoPreprocessedTextNative(compiler, sourceText, sourceTextSize, shaderKind, inputFileName, entryPointName, additionalOptions);
			return ret;
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains preprocessed source<br/>/// code instead of a SPIR-V binary module<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_preprocessed_text")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoPreprocessedText(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] ref byte sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] ulong sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] byte* inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] byte* entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			fixed (byte* psourceText = &sourceText)
			{
				ShadercCompilationResult ret = Shaderc.ShadercCompileIntoPreprocessedTextNative(compiler, (byte*)psourceText, sourceTextSize, shaderKind, inputFileName, entryPointName, additionalOptions);
				return ret;
			}
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains preprocessed source<br/>/// code instead of a SPIR-V binary module<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_preprocessed_text")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoPreprocessedText(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] string sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] ulong sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] byte* inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] byte* entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (sourceText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(sourceText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(sourceText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShadercCompilationResult ret = Shaderc.ShadercCompileIntoPreprocessedTextNative(compiler, pStr0, sourceTextSize, shaderKind, inputFileName, entryPointName, additionalOptions);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains preprocessed source<br/>/// code instead of a SPIR-V binary module<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_preprocessed_text")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoPreprocessedText(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] byte* sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] nuint sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] byte* inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] byte* entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			ShadercCompilationResult ret = Shaderc.ShadercCompileIntoPreprocessedTextNative(compiler, sourceText, sourceTextSize, shaderKind, inputFileName, entryPointName, additionalOptions);
			return ret;
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains preprocessed source<br/>/// code instead of a SPIR-V binary module<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_preprocessed_text")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoPreprocessedText(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] ref byte sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] nuint sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] byte* inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] byte* entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			fixed (byte* psourceText = &sourceText)
			{
				ShadercCompilationResult ret = Shaderc.ShadercCompileIntoPreprocessedTextNative(compiler, (byte*)psourceText, sourceTextSize, shaderKind, inputFileName, entryPointName, additionalOptions);
				return ret;
			}
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains preprocessed source<br/>/// code instead of a SPIR-V binary module<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_preprocessed_text")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoPreprocessedText(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] string sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] nuint sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] byte* inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] byte* entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (sourceText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(sourceText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(sourceText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShadercCompilationResult ret = Shaderc.ShadercCompileIntoPreprocessedTextNative(compiler, pStr0, sourceTextSize, shaderKind, inputFileName, entryPointName, additionalOptions);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains preprocessed source<br/>/// code instead of a SPIR-V binary module<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_preprocessed_text")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoPreprocessedText(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] byte* sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] ulong sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] ref byte inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] byte* entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			fixed (byte* pinputFileName = &inputFileName)
			{
				ShadercCompilationResult ret = Shaderc.ShadercCompileIntoPreprocessedTextNative(compiler, sourceText, sourceTextSize, shaderKind, (byte*)pinputFileName, entryPointName, additionalOptions);
				return ret;
			}
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains preprocessed source<br/>/// code instead of a SPIR-V binary module<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_preprocessed_text")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoPreprocessedText(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] byte* sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] ulong sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] string inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] byte* entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inputFileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inputFileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inputFileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShadercCompilationResult ret = Shaderc.ShadercCompileIntoPreprocessedTextNative(compiler, sourceText, sourceTextSize, shaderKind, pStr0, entryPointName, additionalOptions);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains preprocessed source<br/>/// code instead of a SPIR-V binary module<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_preprocessed_text")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoPreprocessedText(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] ref byte sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] ulong sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] ref byte inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] byte* entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			fixed (byte* psourceText = &sourceText)
			{
				fixed (byte* pinputFileName = &inputFileName)
				{
					ShadercCompilationResult ret = Shaderc.ShadercCompileIntoPreprocessedTextNative(compiler, (byte*)psourceText, sourceTextSize, shaderKind, (byte*)pinputFileName, entryPointName, additionalOptions);
					return ret;
				}
			}
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains preprocessed source<br/>/// code instead of a SPIR-V binary module<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_preprocessed_text")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoPreprocessedText(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] string sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] ulong sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] string inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] byte* entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (sourceText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(sourceText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(sourceText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (inputFileName != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(inputFileName);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(inputFileName, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ShadercCompilationResult ret = Shaderc.ShadercCompileIntoPreprocessedTextNative(compiler, pStr0, sourceTextSize, shaderKind, pStr1, entryPointName, additionalOptions);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains preprocessed source<br/>/// code instead of a SPIR-V binary module<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_preprocessed_text")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoPreprocessedText(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] byte* sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] nuint sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] ref byte inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] byte* entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			fixed (byte* pinputFileName = &inputFileName)
			{
				ShadercCompilationResult ret = Shaderc.ShadercCompileIntoPreprocessedTextNative(compiler, sourceText, sourceTextSize, shaderKind, (byte*)pinputFileName, entryPointName, additionalOptions);
				return ret;
			}
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains preprocessed source<br/>/// code instead of a SPIR-V binary module<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_preprocessed_text")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoPreprocessedText(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] byte* sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] nuint sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] string inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] byte* entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inputFileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inputFileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inputFileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShadercCompilationResult ret = Shaderc.ShadercCompileIntoPreprocessedTextNative(compiler, sourceText, sourceTextSize, shaderKind, pStr0, entryPointName, additionalOptions);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains preprocessed source<br/>/// code instead of a SPIR-V binary module<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_preprocessed_text")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoPreprocessedText(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] ref byte sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] nuint sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] ref byte inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] byte* entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			fixed (byte* psourceText = &sourceText)
			{
				fixed (byte* pinputFileName = &inputFileName)
				{
					ShadercCompilationResult ret = Shaderc.ShadercCompileIntoPreprocessedTextNative(compiler, (byte*)psourceText, sourceTextSize, shaderKind, (byte*)pinputFileName, entryPointName, additionalOptions);
					return ret;
				}
			}
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains preprocessed source<br/>/// code instead of a SPIR-V binary module<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_preprocessed_text")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoPreprocessedText(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] string sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] nuint sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] string inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] byte* entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (sourceText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(sourceText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(sourceText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (inputFileName != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(inputFileName);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(inputFileName, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ShadercCompilationResult ret = Shaderc.ShadercCompileIntoPreprocessedTextNative(compiler, pStr0, sourceTextSize, shaderKind, pStr1, entryPointName, additionalOptions);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains preprocessed source<br/>/// code instead of a SPIR-V binary module<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_preprocessed_text")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoPreprocessedText(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] byte* sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] ulong sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] byte* inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] ref byte entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			fixed (byte* pentryPointName = &entryPointName)
			{
				ShadercCompilationResult ret = Shaderc.ShadercCompileIntoPreprocessedTextNative(compiler, sourceText, sourceTextSize, shaderKind, inputFileName, (byte*)pentryPointName, additionalOptions);
				return ret;
			}
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains preprocessed source<br/>/// code instead of a SPIR-V binary module<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_preprocessed_text")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoPreprocessedText(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] byte* sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] ulong sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] byte* inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] string entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (entryPointName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(entryPointName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(entryPointName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShadercCompilationResult ret = Shaderc.ShadercCompileIntoPreprocessedTextNative(compiler, sourceText, sourceTextSize, shaderKind, inputFileName, pStr0, additionalOptions);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains preprocessed source<br/>/// code instead of a SPIR-V binary module<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_preprocessed_text")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoPreprocessedText(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] ref byte sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] ulong sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] byte* inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] ref byte entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			fixed (byte* psourceText = &sourceText)
			{
				fixed (byte* pentryPointName = &entryPointName)
				{
					ShadercCompilationResult ret = Shaderc.ShadercCompileIntoPreprocessedTextNative(compiler, (byte*)psourceText, sourceTextSize, shaderKind, inputFileName, (byte*)pentryPointName, additionalOptions);
					return ret;
				}
			}
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains preprocessed source<br/>/// code instead of a SPIR-V binary module<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_preprocessed_text")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoPreprocessedText(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] string sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] ulong sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] byte* inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] string entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (sourceText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(sourceText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(sourceText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (entryPointName != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(entryPointName);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(entryPointName, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ShadercCompilationResult ret = Shaderc.ShadercCompileIntoPreprocessedTextNative(compiler, pStr0, sourceTextSize, shaderKind, inputFileName, pStr1, additionalOptions);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains preprocessed source<br/>/// code instead of a SPIR-V binary module<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_preprocessed_text")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoPreprocessedText(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] byte* sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] nuint sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] byte* inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] ref byte entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			fixed (byte* pentryPointName = &entryPointName)
			{
				ShadercCompilationResult ret = Shaderc.ShadercCompileIntoPreprocessedTextNative(compiler, sourceText, sourceTextSize, shaderKind, inputFileName, (byte*)pentryPointName, additionalOptions);
				return ret;
			}
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains preprocessed source<br/>/// code instead of a SPIR-V binary module<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_preprocessed_text")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoPreprocessedText(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] byte* sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] nuint sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] byte* inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] string entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (entryPointName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(entryPointName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(entryPointName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShadercCompilationResult ret = Shaderc.ShadercCompileIntoPreprocessedTextNative(compiler, sourceText, sourceTextSize, shaderKind, inputFileName, pStr0, additionalOptions);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains preprocessed source<br/>/// code instead of a SPIR-V binary module<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_preprocessed_text")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoPreprocessedText(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] ref byte sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] nuint sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] byte* inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] ref byte entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			fixed (byte* psourceText = &sourceText)
			{
				fixed (byte* pentryPointName = &entryPointName)
				{
					ShadercCompilationResult ret = Shaderc.ShadercCompileIntoPreprocessedTextNative(compiler, (byte*)psourceText, sourceTextSize, shaderKind, inputFileName, (byte*)pentryPointName, additionalOptions);
					return ret;
				}
			}
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains preprocessed source<br/>/// code instead of a SPIR-V binary module<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_preprocessed_text")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoPreprocessedText(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] string sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] nuint sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] byte* inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] string entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (sourceText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(sourceText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(sourceText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (entryPointName != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(entryPointName);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(entryPointName, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ShadercCompilationResult ret = Shaderc.ShadercCompileIntoPreprocessedTextNative(compiler, pStr0, sourceTextSize, shaderKind, inputFileName, pStr1, additionalOptions);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains preprocessed source<br/>/// code instead of a SPIR-V binary module<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_preprocessed_text")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoPreprocessedText(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] byte* sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] ulong sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] ref byte inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] ref byte entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			fixed (byte* pinputFileName = &inputFileName)
			{
				fixed (byte* pentryPointName = &entryPointName)
				{
					ShadercCompilationResult ret = Shaderc.ShadercCompileIntoPreprocessedTextNative(compiler, sourceText, sourceTextSize, shaderKind, (byte*)pinputFileName, (byte*)pentryPointName, additionalOptions);
					return ret;
				}
			}
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains preprocessed source<br/>/// code instead of a SPIR-V binary module<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_preprocessed_text")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoPreprocessedText(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] byte* sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] ulong sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] string inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] string entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inputFileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inputFileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inputFileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (entryPointName != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(entryPointName);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(entryPointName, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ShadercCompilationResult ret = Shaderc.ShadercCompileIntoPreprocessedTextNative(compiler, sourceText, sourceTextSize, shaderKind, pStr0, pStr1, additionalOptions);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains preprocessed source<br/>/// code instead of a SPIR-V binary module<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_preprocessed_text")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoPreprocessedText(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] ref byte sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] ulong sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] ref byte inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] ref byte entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			fixed (byte* psourceText = &sourceText)
			{
				fixed (byte* pinputFileName = &inputFileName)
				{
					fixed (byte* pentryPointName = &entryPointName)
					{
						ShadercCompilationResult ret = Shaderc.ShadercCompileIntoPreprocessedTextNative(compiler, (byte*)psourceText, sourceTextSize, shaderKind, (byte*)pinputFileName, (byte*)pentryPointName, additionalOptions);
						return ret;
					}
				}
			}
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains preprocessed source<br/>/// code instead of a SPIR-V binary module<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_preprocessed_text")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoPreprocessedText(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] string sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] ulong sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] string inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] string entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (sourceText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(sourceText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(sourceText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (inputFileName != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(inputFileName);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(inputFileName, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (entryPointName != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(entryPointName);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(entryPointName, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			ShadercCompilationResult ret = Shaderc.ShadercCompileIntoPreprocessedTextNative(compiler, pStr0, sourceTextSize, shaderKind, pStr1, pStr2, additionalOptions);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains preprocessed source<br/>/// code instead of a SPIR-V binary module<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_preprocessed_text")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoPreprocessedText(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] byte* sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] nuint sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] ref byte inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] ref byte entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			fixed (byte* pinputFileName = &inputFileName)
			{
				fixed (byte* pentryPointName = &entryPointName)
				{
					ShadercCompilationResult ret = Shaderc.ShadercCompileIntoPreprocessedTextNative(compiler, sourceText, sourceTextSize, shaderKind, (byte*)pinputFileName, (byte*)pentryPointName, additionalOptions);
					return ret;
				}
			}
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains preprocessed source<br/>/// code instead of a SPIR-V binary module<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_preprocessed_text")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoPreprocessedText(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] byte* sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] nuint sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] string inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] string entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inputFileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inputFileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inputFileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (entryPointName != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(entryPointName);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(entryPointName, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ShadercCompilationResult ret = Shaderc.ShadercCompileIntoPreprocessedTextNative(compiler, sourceText, sourceTextSize, shaderKind, pStr0, pStr1, additionalOptions);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains preprocessed source<br/>/// code instead of a SPIR-V binary module<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_preprocessed_text")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoPreprocessedText(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] ref byte sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] nuint sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] ref byte inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] ref byte entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			fixed (byte* psourceText = &sourceText)
			{
				fixed (byte* pinputFileName = &inputFileName)
				{
					fixed (byte* pentryPointName = &entryPointName)
					{
						ShadercCompilationResult ret = Shaderc.ShadercCompileIntoPreprocessedTextNative(compiler, (byte*)psourceText, sourceTextSize, shaderKind, (byte*)pinputFileName, (byte*)pentryPointName, additionalOptions);
						return ret;
					}
				}
			}
		}

		/// <summary>/// Like shaderc_compile_into_spv, but the result contains preprocessed source<br/>/// code instead of a SPIR-V binary module<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_into_preprocessed_text")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult CompileIntoPreprocessedText(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_text")] [NativeName(NativeNameType.Type, "const char*")] string sourceText, [NativeName(NativeNameType.Param, "source_text_size")] [NativeName(NativeNameType.Type, "size_t")] nuint sourceTextSize, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "input_file_name")] [NativeName(NativeNameType.Type, "const char*")] string inputFileName, [NativeName(NativeNameType.Param, "entry_point_name")] [NativeName(NativeNameType.Type, "const char*")] string entryPointName, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (sourceText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(sourceText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(sourceText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (inputFileName != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(inputFileName);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(inputFileName, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (entryPointName != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(entryPointName);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(entryPointName, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			ShadercCompilationResult ret = Shaderc.ShadercCompileIntoPreprocessedTextNative(compiler, pStr0, sourceTextSize, shaderKind, pStr1, pStr2, additionalOptions);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// Takes an assembly string of the format defined in the SPIRV-Tools project<br/>/// (https://github.com/KhronosGroup/SPIRV-Tools/blob/master/syntax.md),<br/>/// assembles it into SPIR-V binary and a shaderc_compilation_result will be<br/>/// returned to hold the results.<br/>/// The assembling will pick options suitable for assembling specified in the<br/>/// additional_options parameter.<br/>/// May be safely called from multiple threads without explicit synchronization.<br/>/// If there was failure in allocating the compiler object, null will be<br/>/// returned.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_assemble_into_spv")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult AssembleIntoSpv(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_assembly")] [NativeName(NativeNameType.Type, "const char*")] byte* sourceAssembly, [NativeName(NativeNameType.Param, "source_assembly_size")] [NativeName(NativeNameType.Type, "size_t")] ulong sourceAssemblySize, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			ShadercCompilationResult ret = Shaderc.ShadercAssembleIntoSpvNative(compiler, sourceAssembly, sourceAssemblySize, additionalOptions);
			return ret;
		}

		/// <summary>/// Takes an assembly string of the format defined in the SPIRV-Tools project<br/>/// (https://github.com/KhronosGroup/SPIRV-Tools/blob/master/syntax.md),<br/>/// assembles it into SPIR-V binary and a shaderc_compilation_result will be<br/>/// returned to hold the results.<br/>/// The assembling will pick options suitable for assembling specified in the<br/>/// additional_options parameter.<br/>/// May be safely called from multiple threads without explicit synchronization.<br/>/// If there was failure in allocating the compiler object, null will be<br/>/// returned.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_assemble_into_spv")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult AssembleIntoSpv(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_assembly")] [NativeName(NativeNameType.Type, "const char*")] ref byte sourceAssembly, [NativeName(NativeNameType.Param, "source_assembly_size")] [NativeName(NativeNameType.Type, "size_t")] ulong sourceAssemblySize, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			fixed (byte* psourceAssembly = &sourceAssembly)
			{
				ShadercCompilationResult ret = Shaderc.ShadercAssembleIntoSpvNative(compiler, (byte*)psourceAssembly, sourceAssemblySize, additionalOptions);
				return ret;
			}
		}

		/// <summary>/// Takes an assembly string of the format defined in the SPIRV-Tools project<br/>/// (https://github.com/KhronosGroup/SPIRV-Tools/blob/master/syntax.md),<br/>/// assembles it into SPIR-V binary and a shaderc_compilation_result will be<br/>/// returned to hold the results.<br/>/// The assembling will pick options suitable for assembling specified in the<br/>/// additional_options parameter.<br/>/// May be safely called from multiple threads without explicit synchronization.<br/>/// If there was failure in allocating the compiler object, null will be<br/>/// returned.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_assemble_into_spv")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult AssembleIntoSpv(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_assembly")] [NativeName(NativeNameType.Type, "const char*")] string sourceAssembly, [NativeName(NativeNameType.Param, "source_assembly_size")] [NativeName(NativeNameType.Type, "size_t")] ulong sourceAssemblySize, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (sourceAssembly != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(sourceAssembly);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(sourceAssembly, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShadercCompilationResult ret = Shaderc.ShadercAssembleIntoSpvNative(compiler, pStr0, sourceAssemblySize, additionalOptions);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// Takes an assembly string of the format defined in the SPIRV-Tools project<br/>/// (https://github.com/KhronosGroup/SPIRV-Tools/blob/master/syntax.md),<br/>/// assembles it into SPIR-V binary and a shaderc_compilation_result will be<br/>/// returned to hold the results.<br/>/// The assembling will pick options suitable for assembling specified in the<br/>/// additional_options parameter.<br/>/// May be safely called from multiple threads without explicit synchronization.<br/>/// If there was failure in allocating the compiler object, null will be<br/>/// returned.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_assemble_into_spv")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult AssembleIntoSpv(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_assembly")] [NativeName(NativeNameType.Type, "const char*")] byte* sourceAssembly, [NativeName(NativeNameType.Param, "source_assembly_size")] [NativeName(NativeNameType.Type, "size_t")] nuint sourceAssemblySize, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			ShadercCompilationResult ret = Shaderc.ShadercAssembleIntoSpvNative(compiler, sourceAssembly, sourceAssemblySize, additionalOptions);
			return ret;
		}

		/// <summary>/// Takes an assembly string of the format defined in the SPIRV-Tools project<br/>/// (https://github.com/KhronosGroup/SPIRV-Tools/blob/master/syntax.md),<br/>/// assembles it into SPIR-V binary and a shaderc_compilation_result will be<br/>/// returned to hold the results.<br/>/// The assembling will pick options suitable for assembling specified in the<br/>/// additional_options parameter.<br/>/// May be safely called from multiple threads without explicit synchronization.<br/>/// If there was failure in allocating the compiler object, null will be<br/>/// returned.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_assemble_into_spv")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult AssembleIntoSpv(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_assembly")] [NativeName(NativeNameType.Type, "const char*")] ref byte sourceAssembly, [NativeName(NativeNameType.Param, "source_assembly_size")] [NativeName(NativeNameType.Type, "size_t")] nuint sourceAssemblySize, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			fixed (byte* psourceAssembly = &sourceAssembly)
			{
				ShadercCompilationResult ret = Shaderc.ShadercAssembleIntoSpvNative(compiler, (byte*)psourceAssembly, sourceAssemblySize, additionalOptions);
				return ret;
			}
		}

		/// <summary>/// Takes an assembly string of the format defined in the SPIRV-Tools project<br/>/// (https://github.com/KhronosGroup/SPIRV-Tools/blob/master/syntax.md),<br/>/// assembles it into SPIR-V binary and a shaderc_compilation_result will be<br/>/// returned to hold the results.<br/>/// The assembling will pick options suitable for assembling specified in the<br/>/// additional_options parameter.<br/>/// May be safely called from multiple threads without explicit synchronization.<br/>/// If there was failure in allocating the compiler object, null will be<br/>/// returned.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_assemble_into_spv")]
		[return: NativeName(NativeNameType.Type, "shaderc_compilation_result_t")]
		public static ShadercCompilationResult AssembleIntoSpv(this ShadercCompiler compiler, [NativeName(NativeNameType.Param, "source_assembly")] [NativeName(NativeNameType.Type, "const char*")] string sourceAssembly, [NativeName(NativeNameType.Param, "source_assembly_size")] [NativeName(NativeNameType.Type, "size_t")] nuint sourceAssemblySize, [NativeName(NativeNameType.Param, "additional_options")] [NativeName(NativeNameType.Type, "const shaderc_compile_options_t")] ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (sourceAssembly != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(sourceAssembly);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(sourceAssembly, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShadercCompilationResult ret = Shaderc.ShadercAssembleIntoSpvNative(compiler, pStr0, sourceAssemblySize, additionalOptions);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// Returns a copy of the given shaderc_compile_options_t.<br/>/// If NULL is passed as the parameter the call is the same as<br/>/// shaderc_compile_options_init.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_clone")]
		[return: NativeName(NativeNameType.Type, "shaderc_compile_options_t")]
		public static ShadercCompileOptions Clone(this ShadercCompileOptions options)
		{
			ShadercCompileOptions ret = Shaderc.ShadercCompileOptionsCloneNative(options);
			return ret;
		}

		/// <summary>/// Releases the compilation options. It is invalid to use the given<br/>/// shaderc_compile_options_t object in any future calls. It is safe to pass<br/>/// NULL to this function, and doing such will have no effect.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_release")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Release(this ShadercCompileOptions options)
		{
			Shaderc.ShadercCompileOptionsReleaseNative(options);
		}

		/// <summary>/// Adds a predefined macro to the compilation options. This has the same<br/>/// effect as passing -Dname=value to the command-line compiler.  If value<br/>/// is NULL, it has the same effect as passing -Dname to the command-line<br/>/// compiler. If a macro definition with the same name has previously been<br/>/// added, the value is replaced with the new value. The macro name and<br/>/// value are passed in with char pointers, which point to their data, and<br/>/// the lengths of their data. The strings that the name and value pointers<br/>/// point to must remain valid for the duration of the call, but can be<br/>/// modified or deleted after this function has returned. In case of adding<br/>/// a valueless macro, the value argument should be a null pointer or the<br/>/// value_length should be 0u.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_add_macro_definition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void AddMacroDefinition(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name, [NativeName(NativeNameType.Param, "name_length")] [NativeName(NativeNameType.Type, "size_t")] ulong nameLength, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const char*")] byte* value, [NativeName(NativeNameType.Param, "value_length")] [NativeName(NativeNameType.Type, "size_t")] ulong valueLength)
		{
			Shaderc.ShadercCompileOptionsAddMacroDefinitionNative(options, name, nameLength, value, valueLength);
		}

		/// <summary>/// Adds a predefined macro to the compilation options. This has the same<br/>/// effect as passing -Dname=value to the command-line compiler.  If value<br/>/// is NULL, it has the same effect as passing -Dname to the command-line<br/>/// compiler. If a macro definition with the same name has previously been<br/>/// added, the value is replaced with the new value. The macro name and<br/>/// value are passed in with char pointers, which point to their data, and<br/>/// the lengths of their data. The strings that the name and value pointers<br/>/// point to must remain valid for the duration of the call, but can be<br/>/// modified or deleted after this function has returned. In case of adding<br/>/// a valueless macro, the value argument should be a null pointer or the<br/>/// value_length should be 0u.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_add_macro_definition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void AddMacroDefinition(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] ref byte name, [NativeName(NativeNameType.Param, "name_length")] [NativeName(NativeNameType.Type, "size_t")] ulong nameLength, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const char*")] byte* value, [NativeName(NativeNameType.Param, "value_length")] [NativeName(NativeNameType.Type, "size_t")] ulong valueLength)
		{
			fixed (byte* pname = &name)
			{
				Shaderc.ShadercCompileOptionsAddMacroDefinitionNative(options, (byte*)pname, nameLength, value, valueLength);
			}
		}

		/// <summary>/// Adds a predefined macro to the compilation options. This has the same<br/>/// effect as passing -Dname=value to the command-line compiler.  If value<br/>/// is NULL, it has the same effect as passing -Dname to the command-line<br/>/// compiler. If a macro definition with the same name has previously been<br/>/// added, the value is replaced with the new value. The macro name and<br/>/// value are passed in with char pointers, which point to their data, and<br/>/// the lengths of their data. The strings that the name and value pointers<br/>/// point to must remain valid for the duration of the call, but can be<br/>/// modified or deleted after this function has returned. In case of adding<br/>/// a valueless macro, the value argument should be a null pointer or the<br/>/// value_length should be 0u.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_add_macro_definition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void AddMacroDefinition(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] string name, [NativeName(NativeNameType.Param, "name_length")] [NativeName(NativeNameType.Type, "size_t")] ulong nameLength, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const char*")] byte* value, [NativeName(NativeNameType.Param, "value_length")] [NativeName(NativeNameType.Type, "size_t")] ulong valueLength)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Shaderc.ShadercCompileOptionsAddMacroDefinitionNative(options, pStr0, nameLength, value, valueLength);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>/// Adds a predefined macro to the compilation options. This has the same<br/>/// effect as passing -Dname=value to the command-line compiler.  If value<br/>/// is NULL, it has the same effect as passing -Dname to the command-line<br/>/// compiler. If a macro definition with the same name has previously been<br/>/// added, the value is replaced with the new value. The macro name and<br/>/// value are passed in with char pointers, which point to their data, and<br/>/// the lengths of their data. The strings that the name and value pointers<br/>/// point to must remain valid for the duration of the call, but can be<br/>/// modified or deleted after this function has returned. In case of adding<br/>/// a valueless macro, the value argument should be a null pointer or the<br/>/// value_length should be 0u.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_add_macro_definition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void AddMacroDefinition(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name, [NativeName(NativeNameType.Param, "name_length")] [NativeName(NativeNameType.Type, "size_t")] nuint nameLength, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const char*")] byte* value, [NativeName(NativeNameType.Param, "value_length")] [NativeName(NativeNameType.Type, "size_t")] ulong valueLength)
		{
			Shaderc.ShadercCompileOptionsAddMacroDefinitionNative(options, name, nameLength, value, valueLength);
		}

		/// <summary>/// Adds a predefined macro to the compilation options. This has the same<br/>/// effect as passing -Dname=value to the command-line compiler.  If value<br/>/// is NULL, it has the same effect as passing -Dname to the command-line<br/>/// compiler. If a macro definition with the same name has previously been<br/>/// added, the value is replaced with the new value. The macro name and<br/>/// value are passed in with char pointers, which point to their data, and<br/>/// the lengths of their data. The strings that the name and value pointers<br/>/// point to must remain valid for the duration of the call, but can be<br/>/// modified or deleted after this function has returned. In case of adding<br/>/// a valueless macro, the value argument should be a null pointer or the<br/>/// value_length should be 0u.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_add_macro_definition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void AddMacroDefinition(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] ref byte name, [NativeName(NativeNameType.Param, "name_length")] [NativeName(NativeNameType.Type, "size_t")] nuint nameLength, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const char*")] byte* value, [NativeName(NativeNameType.Param, "value_length")] [NativeName(NativeNameType.Type, "size_t")] ulong valueLength)
		{
			fixed (byte* pname = &name)
			{
				Shaderc.ShadercCompileOptionsAddMacroDefinitionNative(options, (byte*)pname, nameLength, value, valueLength);
			}
		}

		/// <summary>/// Adds a predefined macro to the compilation options. This has the same<br/>/// effect as passing -Dname=value to the command-line compiler.  If value<br/>/// is NULL, it has the same effect as passing -Dname to the command-line<br/>/// compiler. If a macro definition with the same name has previously been<br/>/// added, the value is replaced with the new value. The macro name and<br/>/// value are passed in with char pointers, which point to their data, and<br/>/// the lengths of their data. The strings that the name and value pointers<br/>/// point to must remain valid for the duration of the call, but can be<br/>/// modified or deleted after this function has returned. In case of adding<br/>/// a valueless macro, the value argument should be a null pointer or the<br/>/// value_length should be 0u.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_add_macro_definition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void AddMacroDefinition(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] string name, [NativeName(NativeNameType.Param, "name_length")] [NativeName(NativeNameType.Type, "size_t")] nuint nameLength, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const char*")] byte* value, [NativeName(NativeNameType.Param, "value_length")] [NativeName(NativeNameType.Type, "size_t")] ulong valueLength)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Shaderc.ShadercCompileOptionsAddMacroDefinitionNative(options, pStr0, nameLength, value, valueLength);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>/// Adds a predefined macro to the compilation options. This has the same<br/>/// effect as passing -Dname=value to the command-line compiler.  If value<br/>/// is NULL, it has the same effect as passing -Dname to the command-line<br/>/// compiler. If a macro definition with the same name has previously been<br/>/// added, the value is replaced with the new value. The macro name and<br/>/// value are passed in with char pointers, which point to their data, and<br/>/// the lengths of their data. The strings that the name and value pointers<br/>/// point to must remain valid for the duration of the call, but can be<br/>/// modified or deleted after this function has returned. In case of adding<br/>/// a valueless macro, the value argument should be a null pointer or the<br/>/// value_length should be 0u.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_add_macro_definition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void AddMacroDefinition(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name, [NativeName(NativeNameType.Param, "name_length")] [NativeName(NativeNameType.Type, "size_t")] ulong nameLength, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const char*")] ref byte value, [NativeName(NativeNameType.Param, "value_length")] [NativeName(NativeNameType.Type, "size_t")] ulong valueLength)
		{
			fixed (byte* pvalue = &value)
			{
				Shaderc.ShadercCompileOptionsAddMacroDefinitionNative(options, name, nameLength, (byte*)pvalue, valueLength);
			}
		}

		/// <summary>/// Adds a predefined macro to the compilation options. This has the same<br/>/// effect as passing -Dname=value to the command-line compiler.  If value<br/>/// is NULL, it has the same effect as passing -Dname to the command-line<br/>/// compiler. If a macro definition with the same name has previously been<br/>/// added, the value is replaced with the new value. The macro name and<br/>/// value are passed in with char pointers, which point to their data, and<br/>/// the lengths of their data. The strings that the name and value pointers<br/>/// point to must remain valid for the duration of the call, but can be<br/>/// modified or deleted after this function has returned. In case of adding<br/>/// a valueless macro, the value argument should be a null pointer or the<br/>/// value_length should be 0u.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_add_macro_definition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void AddMacroDefinition(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name, [NativeName(NativeNameType.Param, "name_length")] [NativeName(NativeNameType.Type, "size_t")] ulong nameLength, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const char*")] string value, [NativeName(NativeNameType.Param, "value_length")] [NativeName(NativeNameType.Type, "size_t")] ulong valueLength)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (value != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(value);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(value, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Shaderc.ShadercCompileOptionsAddMacroDefinitionNative(options, name, nameLength, pStr0, valueLength);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>/// Adds a predefined macro to the compilation options. This has the same<br/>/// effect as passing -Dname=value to the command-line compiler.  If value<br/>/// is NULL, it has the same effect as passing -Dname to the command-line<br/>/// compiler. If a macro definition with the same name has previously been<br/>/// added, the value is replaced with the new value. The macro name and<br/>/// value are passed in with char pointers, which point to their data, and<br/>/// the lengths of their data. The strings that the name and value pointers<br/>/// point to must remain valid for the duration of the call, but can be<br/>/// modified or deleted after this function has returned. In case of adding<br/>/// a valueless macro, the value argument should be a null pointer or the<br/>/// value_length should be 0u.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_add_macro_definition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void AddMacroDefinition(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] ref byte name, [NativeName(NativeNameType.Param, "name_length")] [NativeName(NativeNameType.Type, "size_t")] ulong nameLength, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const char*")] ref byte value, [NativeName(NativeNameType.Param, "value_length")] [NativeName(NativeNameType.Type, "size_t")] ulong valueLength)
		{
			fixed (byte* pname = &name)
			{
				fixed (byte* pvalue = &value)
				{
					Shaderc.ShadercCompileOptionsAddMacroDefinitionNative(options, (byte*)pname, nameLength, (byte*)pvalue, valueLength);
				}
			}
		}

		/// <summary>/// Adds a predefined macro to the compilation options. This has the same<br/>/// effect as passing -Dname=value to the command-line compiler.  If value<br/>/// is NULL, it has the same effect as passing -Dname to the command-line<br/>/// compiler. If a macro definition with the same name has previously been<br/>/// added, the value is replaced with the new value. The macro name and<br/>/// value are passed in with char pointers, which point to their data, and<br/>/// the lengths of their data. The strings that the name and value pointers<br/>/// point to must remain valid for the duration of the call, but can be<br/>/// modified or deleted after this function has returned. In case of adding<br/>/// a valueless macro, the value argument should be a null pointer or the<br/>/// value_length should be 0u.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_add_macro_definition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void AddMacroDefinition(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] string name, [NativeName(NativeNameType.Param, "name_length")] [NativeName(NativeNameType.Type, "size_t")] ulong nameLength, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const char*")] string value, [NativeName(NativeNameType.Param, "value_length")] [NativeName(NativeNameType.Type, "size_t")] ulong valueLength)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (value != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(value);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(value, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			Shaderc.ShadercCompileOptionsAddMacroDefinitionNative(options, pStr0, nameLength, pStr1, valueLength);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>/// Adds a predefined macro to the compilation options. This has the same<br/>/// effect as passing -Dname=value to the command-line compiler.  If value<br/>/// is NULL, it has the same effect as passing -Dname to the command-line<br/>/// compiler. If a macro definition with the same name has previously been<br/>/// added, the value is replaced with the new value. The macro name and<br/>/// value are passed in with char pointers, which point to their data, and<br/>/// the lengths of their data. The strings that the name and value pointers<br/>/// point to must remain valid for the duration of the call, but can be<br/>/// modified or deleted after this function has returned. In case of adding<br/>/// a valueless macro, the value argument should be a null pointer or the<br/>/// value_length should be 0u.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_add_macro_definition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void AddMacroDefinition(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name, [NativeName(NativeNameType.Param, "name_length")] [NativeName(NativeNameType.Type, "size_t")] nuint nameLength, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const char*")] ref byte value, [NativeName(NativeNameType.Param, "value_length")] [NativeName(NativeNameType.Type, "size_t")] ulong valueLength)
		{
			fixed (byte* pvalue = &value)
			{
				Shaderc.ShadercCompileOptionsAddMacroDefinitionNative(options, name, nameLength, (byte*)pvalue, valueLength);
			}
		}

		/// <summary>/// Adds a predefined macro to the compilation options. This has the same<br/>/// effect as passing -Dname=value to the command-line compiler.  If value<br/>/// is NULL, it has the same effect as passing -Dname to the command-line<br/>/// compiler. If a macro definition with the same name has previously been<br/>/// added, the value is replaced with the new value. The macro name and<br/>/// value are passed in with char pointers, which point to their data, and<br/>/// the lengths of their data. The strings that the name and value pointers<br/>/// point to must remain valid for the duration of the call, but can be<br/>/// modified or deleted after this function has returned. In case of adding<br/>/// a valueless macro, the value argument should be a null pointer or the<br/>/// value_length should be 0u.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_add_macro_definition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void AddMacroDefinition(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name, [NativeName(NativeNameType.Param, "name_length")] [NativeName(NativeNameType.Type, "size_t")] nuint nameLength, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const char*")] string value, [NativeName(NativeNameType.Param, "value_length")] [NativeName(NativeNameType.Type, "size_t")] ulong valueLength)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (value != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(value);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(value, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Shaderc.ShadercCompileOptionsAddMacroDefinitionNative(options, name, nameLength, pStr0, valueLength);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>/// Adds a predefined macro to the compilation options. This has the same<br/>/// effect as passing -Dname=value to the command-line compiler.  If value<br/>/// is NULL, it has the same effect as passing -Dname to the command-line<br/>/// compiler. If a macro definition with the same name has previously been<br/>/// added, the value is replaced with the new value. The macro name and<br/>/// value are passed in with char pointers, which point to their data, and<br/>/// the lengths of their data. The strings that the name and value pointers<br/>/// point to must remain valid for the duration of the call, but can be<br/>/// modified or deleted after this function has returned. In case of adding<br/>/// a valueless macro, the value argument should be a null pointer or the<br/>/// value_length should be 0u.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_add_macro_definition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void AddMacroDefinition(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] ref byte name, [NativeName(NativeNameType.Param, "name_length")] [NativeName(NativeNameType.Type, "size_t")] nuint nameLength, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const char*")] ref byte value, [NativeName(NativeNameType.Param, "value_length")] [NativeName(NativeNameType.Type, "size_t")] ulong valueLength)
		{
			fixed (byte* pname = &name)
			{
				fixed (byte* pvalue = &value)
				{
					Shaderc.ShadercCompileOptionsAddMacroDefinitionNative(options, (byte*)pname, nameLength, (byte*)pvalue, valueLength);
				}
			}
		}

		/// <summary>/// Adds a predefined macro to the compilation options. This has the same<br/>/// effect as passing -Dname=value to the command-line compiler.  If value<br/>/// is NULL, it has the same effect as passing -Dname to the command-line<br/>/// compiler. If a macro definition with the same name has previously been<br/>/// added, the value is replaced with the new value. The macro name and<br/>/// value are passed in with char pointers, which point to their data, and<br/>/// the lengths of their data. The strings that the name and value pointers<br/>/// point to must remain valid for the duration of the call, but can be<br/>/// modified or deleted after this function has returned. In case of adding<br/>/// a valueless macro, the value argument should be a null pointer or the<br/>/// value_length should be 0u.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_add_macro_definition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void AddMacroDefinition(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] string name, [NativeName(NativeNameType.Param, "name_length")] [NativeName(NativeNameType.Type, "size_t")] nuint nameLength, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const char*")] string value, [NativeName(NativeNameType.Param, "value_length")] [NativeName(NativeNameType.Type, "size_t")] ulong valueLength)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (value != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(value);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(value, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			Shaderc.ShadercCompileOptionsAddMacroDefinitionNative(options, pStr0, nameLength, pStr1, valueLength);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>/// Adds a predefined macro to the compilation options. This has the same<br/>/// effect as passing -Dname=value to the command-line compiler.  If value<br/>/// is NULL, it has the same effect as passing -Dname to the command-line<br/>/// compiler. If a macro definition with the same name has previously been<br/>/// added, the value is replaced with the new value. The macro name and<br/>/// value are passed in with char pointers, which point to their data, and<br/>/// the lengths of their data. The strings that the name and value pointers<br/>/// point to must remain valid for the duration of the call, but can be<br/>/// modified or deleted after this function has returned. In case of adding<br/>/// a valueless macro, the value argument should be a null pointer or the<br/>/// value_length should be 0u.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_add_macro_definition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void AddMacroDefinition(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name, [NativeName(NativeNameType.Param, "name_length")] [NativeName(NativeNameType.Type, "size_t")] ulong nameLength, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const char*")] byte* value, [NativeName(NativeNameType.Param, "value_length")] [NativeName(NativeNameType.Type, "size_t")] nuint valueLength)
		{
			Shaderc.ShadercCompileOptionsAddMacroDefinitionNative(options, name, nameLength, value, valueLength);
		}

		/// <summary>/// Adds a predefined macro to the compilation options. This has the same<br/>/// effect as passing -Dname=value to the command-line compiler.  If value<br/>/// is NULL, it has the same effect as passing -Dname to the command-line<br/>/// compiler. If a macro definition with the same name has previously been<br/>/// added, the value is replaced with the new value. The macro name and<br/>/// value are passed in with char pointers, which point to their data, and<br/>/// the lengths of their data. The strings that the name and value pointers<br/>/// point to must remain valid for the duration of the call, but can be<br/>/// modified or deleted after this function has returned. In case of adding<br/>/// a valueless macro, the value argument should be a null pointer or the<br/>/// value_length should be 0u.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_add_macro_definition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void AddMacroDefinition(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] ref byte name, [NativeName(NativeNameType.Param, "name_length")] [NativeName(NativeNameType.Type, "size_t")] ulong nameLength, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const char*")] byte* value, [NativeName(NativeNameType.Param, "value_length")] [NativeName(NativeNameType.Type, "size_t")] nuint valueLength)
		{
			fixed (byte* pname = &name)
			{
				Shaderc.ShadercCompileOptionsAddMacroDefinitionNative(options, (byte*)pname, nameLength, value, valueLength);
			}
		}

		/// <summary>/// Adds a predefined macro to the compilation options. This has the same<br/>/// effect as passing -Dname=value to the command-line compiler.  If value<br/>/// is NULL, it has the same effect as passing -Dname to the command-line<br/>/// compiler. If a macro definition with the same name has previously been<br/>/// added, the value is replaced with the new value. The macro name and<br/>/// value are passed in with char pointers, which point to their data, and<br/>/// the lengths of their data. The strings that the name and value pointers<br/>/// point to must remain valid for the duration of the call, but can be<br/>/// modified or deleted after this function has returned. In case of adding<br/>/// a valueless macro, the value argument should be a null pointer or the<br/>/// value_length should be 0u.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_add_macro_definition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void AddMacroDefinition(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] string name, [NativeName(NativeNameType.Param, "name_length")] [NativeName(NativeNameType.Type, "size_t")] ulong nameLength, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const char*")] byte* value, [NativeName(NativeNameType.Param, "value_length")] [NativeName(NativeNameType.Type, "size_t")] nuint valueLength)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Shaderc.ShadercCompileOptionsAddMacroDefinitionNative(options, pStr0, nameLength, value, valueLength);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>/// Adds a predefined macro to the compilation options. This has the same<br/>/// effect as passing -Dname=value to the command-line compiler.  If value<br/>/// is NULL, it has the same effect as passing -Dname to the command-line<br/>/// compiler. If a macro definition with the same name has previously been<br/>/// added, the value is replaced with the new value. The macro name and<br/>/// value are passed in with char pointers, which point to their data, and<br/>/// the lengths of their data. The strings that the name and value pointers<br/>/// point to must remain valid for the duration of the call, but can be<br/>/// modified or deleted after this function has returned. In case of adding<br/>/// a valueless macro, the value argument should be a null pointer or the<br/>/// value_length should be 0u.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_add_macro_definition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void AddMacroDefinition(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name, [NativeName(NativeNameType.Param, "name_length")] [NativeName(NativeNameType.Type, "size_t")] nuint nameLength, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const char*")] byte* value, [NativeName(NativeNameType.Param, "value_length")] [NativeName(NativeNameType.Type, "size_t")] nuint valueLength)
		{
			Shaderc.ShadercCompileOptionsAddMacroDefinitionNative(options, name, nameLength, value, valueLength);
		}

		/// <summary>/// Adds a predefined macro to the compilation options. This has the same<br/>/// effect as passing -Dname=value to the command-line compiler.  If value<br/>/// is NULL, it has the same effect as passing -Dname to the command-line<br/>/// compiler. If a macro definition with the same name has previously been<br/>/// added, the value is replaced with the new value. The macro name and<br/>/// value are passed in with char pointers, which point to their data, and<br/>/// the lengths of their data. The strings that the name and value pointers<br/>/// point to must remain valid for the duration of the call, but can be<br/>/// modified or deleted after this function has returned. In case of adding<br/>/// a valueless macro, the value argument should be a null pointer or the<br/>/// value_length should be 0u.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_add_macro_definition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void AddMacroDefinition(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] ref byte name, [NativeName(NativeNameType.Param, "name_length")] [NativeName(NativeNameType.Type, "size_t")] nuint nameLength, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const char*")] byte* value, [NativeName(NativeNameType.Param, "value_length")] [NativeName(NativeNameType.Type, "size_t")] nuint valueLength)
		{
			fixed (byte* pname = &name)
			{
				Shaderc.ShadercCompileOptionsAddMacroDefinitionNative(options, (byte*)pname, nameLength, value, valueLength);
			}
		}

		/// <summary>/// Adds a predefined macro to the compilation options. This has the same<br/>/// effect as passing -Dname=value to the command-line compiler.  If value<br/>/// is NULL, it has the same effect as passing -Dname to the command-line<br/>/// compiler. If a macro definition with the same name has previously been<br/>/// added, the value is replaced with the new value. The macro name and<br/>/// value are passed in with char pointers, which point to their data, and<br/>/// the lengths of their data. The strings that the name and value pointers<br/>/// point to must remain valid for the duration of the call, but can be<br/>/// modified or deleted after this function has returned. In case of adding<br/>/// a valueless macro, the value argument should be a null pointer or the<br/>/// value_length should be 0u.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_add_macro_definition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void AddMacroDefinition(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] string name, [NativeName(NativeNameType.Param, "name_length")] [NativeName(NativeNameType.Type, "size_t")] nuint nameLength, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const char*")] byte* value, [NativeName(NativeNameType.Param, "value_length")] [NativeName(NativeNameType.Type, "size_t")] nuint valueLength)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Shaderc.ShadercCompileOptionsAddMacroDefinitionNative(options, pStr0, nameLength, value, valueLength);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>/// Adds a predefined macro to the compilation options. This has the same<br/>/// effect as passing -Dname=value to the command-line compiler.  If value<br/>/// is NULL, it has the same effect as passing -Dname to the command-line<br/>/// compiler. If a macro definition with the same name has previously been<br/>/// added, the value is replaced with the new value. The macro name and<br/>/// value are passed in with char pointers, which point to their data, and<br/>/// the lengths of their data. The strings that the name and value pointers<br/>/// point to must remain valid for the duration of the call, but can be<br/>/// modified or deleted after this function has returned. In case of adding<br/>/// a valueless macro, the value argument should be a null pointer or the<br/>/// value_length should be 0u.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_add_macro_definition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void AddMacroDefinition(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name, [NativeName(NativeNameType.Param, "name_length")] [NativeName(NativeNameType.Type, "size_t")] ulong nameLength, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const char*")] ref byte value, [NativeName(NativeNameType.Param, "value_length")] [NativeName(NativeNameType.Type, "size_t")] nuint valueLength)
		{
			fixed (byte* pvalue = &value)
			{
				Shaderc.ShadercCompileOptionsAddMacroDefinitionNative(options, name, nameLength, (byte*)pvalue, valueLength);
			}
		}

		/// <summary>/// Adds a predefined macro to the compilation options. This has the same<br/>/// effect as passing -Dname=value to the command-line compiler.  If value<br/>/// is NULL, it has the same effect as passing -Dname to the command-line<br/>/// compiler. If a macro definition with the same name has previously been<br/>/// added, the value is replaced with the new value. The macro name and<br/>/// value are passed in with char pointers, which point to their data, and<br/>/// the lengths of their data. The strings that the name and value pointers<br/>/// point to must remain valid for the duration of the call, but can be<br/>/// modified or deleted after this function has returned. In case of adding<br/>/// a valueless macro, the value argument should be a null pointer or the<br/>/// value_length should be 0u.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_add_macro_definition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void AddMacroDefinition(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name, [NativeName(NativeNameType.Param, "name_length")] [NativeName(NativeNameType.Type, "size_t")] ulong nameLength, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const char*")] string value, [NativeName(NativeNameType.Param, "value_length")] [NativeName(NativeNameType.Type, "size_t")] nuint valueLength)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (value != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(value);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(value, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Shaderc.ShadercCompileOptionsAddMacroDefinitionNative(options, name, nameLength, pStr0, valueLength);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>/// Adds a predefined macro to the compilation options. This has the same<br/>/// effect as passing -Dname=value to the command-line compiler.  If value<br/>/// is NULL, it has the same effect as passing -Dname to the command-line<br/>/// compiler. If a macro definition with the same name has previously been<br/>/// added, the value is replaced with the new value. The macro name and<br/>/// value are passed in with char pointers, which point to their data, and<br/>/// the lengths of their data. The strings that the name and value pointers<br/>/// point to must remain valid for the duration of the call, but can be<br/>/// modified or deleted after this function has returned. In case of adding<br/>/// a valueless macro, the value argument should be a null pointer or the<br/>/// value_length should be 0u.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_add_macro_definition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void AddMacroDefinition(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] ref byte name, [NativeName(NativeNameType.Param, "name_length")] [NativeName(NativeNameType.Type, "size_t")] ulong nameLength, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const char*")] ref byte value, [NativeName(NativeNameType.Param, "value_length")] [NativeName(NativeNameType.Type, "size_t")] nuint valueLength)
		{
			fixed (byte* pname = &name)
			{
				fixed (byte* pvalue = &value)
				{
					Shaderc.ShadercCompileOptionsAddMacroDefinitionNative(options, (byte*)pname, nameLength, (byte*)pvalue, valueLength);
				}
			}
		}

		/// <summary>/// Adds a predefined macro to the compilation options. This has the same<br/>/// effect as passing -Dname=value to the command-line compiler.  If value<br/>/// is NULL, it has the same effect as passing -Dname to the command-line<br/>/// compiler. If a macro definition with the same name has previously been<br/>/// added, the value is replaced with the new value. The macro name and<br/>/// value are passed in with char pointers, which point to their data, and<br/>/// the lengths of their data. The strings that the name and value pointers<br/>/// point to must remain valid for the duration of the call, but can be<br/>/// modified or deleted after this function has returned. In case of adding<br/>/// a valueless macro, the value argument should be a null pointer or the<br/>/// value_length should be 0u.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_add_macro_definition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void AddMacroDefinition(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] string name, [NativeName(NativeNameType.Param, "name_length")] [NativeName(NativeNameType.Type, "size_t")] ulong nameLength, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const char*")] string value, [NativeName(NativeNameType.Param, "value_length")] [NativeName(NativeNameType.Type, "size_t")] nuint valueLength)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (value != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(value);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(value, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			Shaderc.ShadercCompileOptionsAddMacroDefinitionNative(options, pStr0, nameLength, pStr1, valueLength);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>/// Adds a predefined macro to the compilation options. This has the same<br/>/// effect as passing -Dname=value to the command-line compiler.  If value<br/>/// is NULL, it has the same effect as passing -Dname to the command-line<br/>/// compiler. If a macro definition with the same name has previously been<br/>/// added, the value is replaced with the new value. The macro name and<br/>/// value are passed in with char pointers, which point to their data, and<br/>/// the lengths of their data. The strings that the name and value pointers<br/>/// point to must remain valid for the duration of the call, but can be<br/>/// modified or deleted after this function has returned. In case of adding<br/>/// a valueless macro, the value argument should be a null pointer or the<br/>/// value_length should be 0u.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_add_macro_definition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void AddMacroDefinition(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name, [NativeName(NativeNameType.Param, "name_length")] [NativeName(NativeNameType.Type, "size_t")] nuint nameLength, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const char*")] ref byte value, [NativeName(NativeNameType.Param, "value_length")] [NativeName(NativeNameType.Type, "size_t")] nuint valueLength)
		{
			fixed (byte* pvalue = &value)
			{
				Shaderc.ShadercCompileOptionsAddMacroDefinitionNative(options, name, nameLength, (byte*)pvalue, valueLength);
			}
		}

		/// <summary>/// Adds a predefined macro to the compilation options. This has the same<br/>/// effect as passing -Dname=value to the command-line compiler.  If value<br/>/// is NULL, it has the same effect as passing -Dname to the command-line<br/>/// compiler. If a macro definition with the same name has previously been<br/>/// added, the value is replaced with the new value. The macro name and<br/>/// value are passed in with char pointers, which point to their data, and<br/>/// the lengths of their data. The strings that the name and value pointers<br/>/// point to must remain valid for the duration of the call, but can be<br/>/// modified or deleted after this function has returned. In case of adding<br/>/// a valueless macro, the value argument should be a null pointer or the<br/>/// value_length should be 0u.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_add_macro_definition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void AddMacroDefinition(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name, [NativeName(NativeNameType.Param, "name_length")] [NativeName(NativeNameType.Type, "size_t")] nuint nameLength, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const char*")] string value, [NativeName(NativeNameType.Param, "value_length")] [NativeName(NativeNameType.Type, "size_t")] nuint valueLength)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (value != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(value);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(value, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Shaderc.ShadercCompileOptionsAddMacroDefinitionNative(options, name, nameLength, pStr0, valueLength);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>/// Adds a predefined macro to the compilation options. This has the same<br/>/// effect as passing -Dname=value to the command-line compiler.  If value<br/>/// is NULL, it has the same effect as passing -Dname to the command-line<br/>/// compiler. If a macro definition with the same name has previously been<br/>/// added, the value is replaced with the new value. The macro name and<br/>/// value are passed in with char pointers, which point to their data, and<br/>/// the lengths of their data. The strings that the name and value pointers<br/>/// point to must remain valid for the duration of the call, but can be<br/>/// modified or deleted after this function has returned. In case of adding<br/>/// a valueless macro, the value argument should be a null pointer or the<br/>/// value_length should be 0u.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_add_macro_definition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void AddMacroDefinition(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] ref byte name, [NativeName(NativeNameType.Param, "name_length")] [NativeName(NativeNameType.Type, "size_t")] nuint nameLength, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const char*")] ref byte value, [NativeName(NativeNameType.Param, "value_length")] [NativeName(NativeNameType.Type, "size_t")] nuint valueLength)
		{
			fixed (byte* pname = &name)
			{
				fixed (byte* pvalue = &value)
				{
					Shaderc.ShadercCompileOptionsAddMacroDefinitionNative(options, (byte*)pname, nameLength, (byte*)pvalue, valueLength);
				}
			}
		}

		/// <summary>/// Adds a predefined macro to the compilation options. This has the same<br/>/// effect as passing -Dname=value to the command-line compiler.  If value<br/>/// is NULL, it has the same effect as passing -Dname to the command-line<br/>/// compiler. If a macro definition with the same name has previously been<br/>/// added, the value is replaced with the new value. The macro name and<br/>/// value are passed in with char pointers, which point to their data, and<br/>/// the lengths of their data. The strings that the name and value pointers<br/>/// point to must remain valid for the duration of the call, but can be<br/>/// modified or deleted after this function has returned. In case of adding<br/>/// a valueless macro, the value argument should be a null pointer or the<br/>/// value_length should be 0u.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_add_macro_definition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void AddMacroDefinition(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] string name, [NativeName(NativeNameType.Param, "name_length")] [NativeName(NativeNameType.Type, "size_t")] nuint nameLength, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const char*")] string value, [NativeName(NativeNameType.Param, "value_length")] [NativeName(NativeNameType.Type, "size_t")] nuint valueLength)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (value != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(value);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(value, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			Shaderc.ShadercCompileOptionsAddMacroDefinitionNative(options, pStr0, nameLength, pStr1, valueLength);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>/// Sets the source language.  The default is GLSL.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_set_source_language")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetSourceLanguage(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "lang")] [NativeName(NativeNameType.Type, "shaderc_source_language")] ShadercSourceLanguage lang)
		{
			Shaderc.ShadercCompileOptionsSetSourceLanguageNative(options, lang);
		}

		/// <summary>/// Sets the compiler mode to generate debug information in the output.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_set_generate_debug_info")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGenerateDebugInfo(this ShadercCompileOptions options)
		{
			Shaderc.ShadercCompileOptionsSetGenerateDebugInfoNative(options);
		}

		/// <summary>/// Sets the compiler optimization level to the given level. Only the last one<br/>/// takes effect if multiple calls of this function exist.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_set_optimization_level")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetOptimizationLevel(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "level")] [NativeName(NativeNameType.Type, "shaderc_optimization_level")] ShadercOptimizationLevel level)
		{
			Shaderc.ShadercCompileOptionsSetOptimizationLevelNative(options, level);
		}

		/// <summary>/// Forces the GLSL language version and profile to a given pair. The version<br/>/// number is the same as would appear in the #version annotation in the source.<br/>/// Version and profile specified here overrides the #version annotation in the<br/>/// source. Use profile: 'shaderc_profile_none' for GLSL versions that do not<br/>/// define profiles, e.g. versions below 150.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_set_forced_version_profile")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetForcedVersionProfile(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "version")] [NativeName(NativeNameType.Type, "int")] int version, [NativeName(NativeNameType.Param, "profile")] [NativeName(NativeNameType.Type, "shaderc_profile")] ShadercProfile profile)
		{
			Shaderc.ShadercCompileOptionsSetForcedVersionProfileNative(options, version, profile);
		}

		/// <summary>/// Sets includer callback functions.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_set_include_callbacks")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetIncludeCallbacks(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "resolver")] [NativeName(NativeNameType.Type, "shaderc_include_resolve_fn")] ShadercIncludeResolveFn resolver, [NativeName(NativeNameType.Param, "result_releaser")] [NativeName(NativeNameType.Type, "shaderc_include_result_release_fn")] ShadercIncludeResultReleaseFn resultReleaser, [NativeName(NativeNameType.Param, "user_data")] [NativeName(NativeNameType.Type, "void*")] void* userData)
		{
			Shaderc.ShadercCompileOptionsSetIncludeCallbacksNative(options, resolver, resultReleaser, userData);
		}

		/// <summary>/// Sets the compiler mode to suppress warnings, overriding warnings-as-errors<br/>/// mode. When both suppress-warnings and warnings-as-errors modes are<br/>/// turned on, warning messages will be inhibited, and will not be emitted<br/>/// as error messages.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_set_suppress_warnings")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetSuppressWarnings(this ShadercCompileOptions options)
		{
			Shaderc.ShadercCompileOptionsSetSuppressWarningsNative(options);
		}

		/// <summary>/// Sets the target shader environment, affecting which warnings or errors will<br/>/// be issued.  The version will be for distinguishing between different versions<br/>/// of the target environment.  The version value should be either 0 or<br/>/// a value listed in shaderc_env_version.  The 0 value maps to Vulkan 1.0 if<br/>/// |target| is Vulkan, and it maps to OpenGL 4.5 if |target| is OpenGL.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_set_target_env")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetTargetEnv(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "shaderc_target_env")] ShadercTargetEnv target, [NativeName(NativeNameType.Param, "version")] [NativeName(NativeNameType.Type, "uint32_t")] uint version)
		{
			Shaderc.ShadercCompileOptionsSetTargetEnvNative(options, target, version);
		}

		/// <summary>/// Sets the target SPIR-V version. The generated module will use this version<br/>/// of SPIR-V.  Each target environment determines what versions of SPIR-V<br/>/// it can consume.  Defaults to the highest version of SPIR-V 1.0 which is<br/>/// required to be supported by the target environment.  E.g. Default to SPIR-V<br/>/// 1.0 for Vulkan 1.0 and SPIR-V 1.3 for Vulkan 1.1.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_set_target_spirv")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetTargetSpirv(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "version")] [NativeName(NativeNameType.Type, "shaderc_spirv_version")] ShadercSpirvVersion version)
		{
			Shaderc.ShadercCompileOptionsSetTargetSpirvNative(options, version);
		}

		/// <summary>/// Sets the compiler mode to treat all warnings as errors. Note the<br/>/// suppress-warnings mode overrides this option, i.e. if both<br/>/// warning-as-errors and suppress-warnings modes are set, warnings will not<br/>/// be emitted as error messages.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_set_warnings_as_errors")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetWarningsAsErrors(this ShadercCompileOptions options)
		{
			Shaderc.ShadercCompileOptionsSetWarningsAsErrorsNative(options);
		}

		/// <summary>/// Sets a resource limit.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_set_limit")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetLimit(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "limit")] [NativeName(NativeNameType.Type, "shaderc_limit")] ShadercLimit limit, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "int")] int value)
		{
			Shaderc.ShadercCompileOptionsSetLimitNative(options, limit, value);
		}

		/// <summary>/// Sets whether the compiler should automatically assign bindings to uniforms<br/>/// that aren't already explicitly bound in the shader source.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_set_auto_bind_uniforms")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetAutoBindUniforms(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "auto_bind")] [NativeName(NativeNameType.Type, "bool")] bool autoBind)
		{
			Shaderc.ShadercCompileOptionsSetAutoBindUniformsNative(options, autoBind ? (byte)1 : (byte)0);
		}

		/// <summary>/// Sets whether the compiler should automatically remove sampler variables<br/>/// and convert image variables to combined image-sampler variables.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_set_auto_combined_image_sampler")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetAutoCombinedImageSampler(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "upgrade")] [NativeName(NativeNameType.Type, "bool")] bool upgrade)
		{
			Shaderc.ShadercCompileOptionsSetAutoCombinedImageSamplerNative(options, upgrade ? (byte)1 : (byte)0);
		}

		/// <summary>/// Sets whether the compiler should use HLSL IO mapping rules for bindings.<br/>/// Defaults to false.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_set_hlsl_io_mapping")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetHlslIoMapping(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "hlsl_iomap")] [NativeName(NativeNameType.Type, "bool")] bool hlslIomap)
		{
			Shaderc.ShadercCompileOptionsSetHlslIoMappingNative(options, hlslIomap ? (byte)1 : (byte)0);
		}

		/// <summary>/// Sets whether the compiler should determine block member offsets using HLSL<br/>/// packing rules instead of standard GLSL rules.  Defaults to false.  Only<br/>/// affects GLSL compilation.  HLSL rules are always used when compiling HLSL.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_set_hlsl_offsets")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetHlslOffsets(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "hlsl_offsets")] [NativeName(NativeNameType.Type, "bool")] bool hlslOffsets)
		{
			Shaderc.ShadercCompileOptionsSetHlslOffsetsNative(options, hlslOffsets ? (byte)1 : (byte)0);
		}

		/// <summary>/// Sets the base binding number used for for a uniform resource type when<br/>/// automatically assigning bindings.  For GLSL compilation, sets the lowest<br/>/// automatically assigned number.  For HLSL compilation, the regsiter number<br/>/// assigned to the resource is added to this specified base.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_set_binding_base")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetBindingBase(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "kind")] [NativeName(NativeNameType.Type, "shaderc_uniform_kind")] ShadercUniformKind kind, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "uint32_t")] uint baseValue)
		{
			Shaderc.ShadercCompileOptionsSetBindingBaseNative(options, kind, baseValue);
		}

		/// <summary>/// Like shaderc_compile_options_set_binding_base, but only takes effect when<br/>/// compiling a given shader stage.  The stage is assumed to be one of vertex,<br/>/// fragment, tessellation evaluation, tesselation control, geometry, or compute.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_set_binding_base_for_stage")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetBindingBaseForStage(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "kind")] [NativeName(NativeNameType.Type, "shaderc_uniform_kind")] ShadercUniformKind kind, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "uint32_t")] uint baseValue)
		{
			Shaderc.ShadercCompileOptionsSetBindingBaseForStageNative(options, shaderKind, kind, baseValue);
		}

		/// <summary>/// Sets whether the compiler should preserve all bindings, even when those<br/>/// bindings are not used.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_set_preserve_bindings")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetPreserveBindings(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "preserve_bindings")] [NativeName(NativeNameType.Type, "bool")] bool preserveBindings)
		{
			Shaderc.ShadercCompileOptionsSetPreserveBindingsNative(options, preserveBindings ? (byte)1 : (byte)0);
		}

		/// <summary>/// Sets whether the compiler should automatically assign locations to<br/>/// uniform variables that don't have explicit locations in the shader source.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_set_auto_map_locations")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetAutoMapLocations(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "auto_map")] [NativeName(NativeNameType.Type, "bool")] bool autoMap)
		{
			Shaderc.ShadercCompileOptionsSetAutoMapLocationsNative(options, autoMap ? (byte)1 : (byte)0);
		}

		/// <summary>/// Sets a descriptor set and binding for an HLSL register in the given stage.<br/>/// This method keeps a copy of the string data.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetHlslRegisterSetAndBindingForStage(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "reg")] [NativeName(NativeNameType.Type, "const char*")] byte* reg, [NativeName(NativeNameType.Param, "set")] [NativeName(NativeNameType.Type, "const char*")] byte* set, [NativeName(NativeNameType.Param, "binding")] [NativeName(NativeNameType.Type, "const char*")] byte* binding)
		{
			Shaderc.ShadercCompileOptionsSetHlslRegisterSetAndBindingForStageNative(options, shaderKind, reg, set, binding);
		}

		/// <summary>/// Sets a descriptor set and binding for an HLSL register in the given stage.<br/>/// This method keeps a copy of the string data.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetHlslRegisterSetAndBindingForStage(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "reg")] [NativeName(NativeNameType.Type, "const char*")] ref byte reg, [NativeName(NativeNameType.Param, "set")] [NativeName(NativeNameType.Type, "const char*")] byte* set, [NativeName(NativeNameType.Param, "binding")] [NativeName(NativeNameType.Type, "const char*")] byte* binding)
		{
			fixed (byte* preg = &reg)
			{
				Shaderc.ShadercCompileOptionsSetHlslRegisterSetAndBindingForStageNative(options, shaderKind, (byte*)preg, set, binding);
			}
		}

		/// <summary>/// Sets a descriptor set and binding for an HLSL register in the given stage.<br/>/// This method keeps a copy of the string data.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetHlslRegisterSetAndBindingForStage(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "reg")] [NativeName(NativeNameType.Type, "const char*")] string reg, [NativeName(NativeNameType.Param, "set")] [NativeName(NativeNameType.Type, "const char*")] byte* set, [NativeName(NativeNameType.Param, "binding")] [NativeName(NativeNameType.Type, "const char*")] byte* binding)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (reg != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(reg);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(reg, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Shaderc.ShadercCompileOptionsSetHlslRegisterSetAndBindingForStageNative(options, shaderKind, pStr0, set, binding);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>/// Sets a descriptor set and binding for an HLSL register in the given stage.<br/>/// This method keeps a copy of the string data.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetHlslRegisterSetAndBindingForStage(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "reg")] [NativeName(NativeNameType.Type, "const char*")] byte* reg, [NativeName(NativeNameType.Param, "set")] [NativeName(NativeNameType.Type, "const char*")] ref byte set, [NativeName(NativeNameType.Param, "binding")] [NativeName(NativeNameType.Type, "const char*")] byte* binding)
		{
			fixed (byte* pset = &set)
			{
				Shaderc.ShadercCompileOptionsSetHlslRegisterSetAndBindingForStageNative(options, shaderKind, reg, (byte*)pset, binding);
			}
		}

		/// <summary>/// Sets a descriptor set and binding for an HLSL register in the given stage.<br/>/// This method keeps a copy of the string data.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetHlslRegisterSetAndBindingForStage(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "reg")] [NativeName(NativeNameType.Type, "const char*")] byte* reg, [NativeName(NativeNameType.Param, "set")] [NativeName(NativeNameType.Type, "const char*")] string set, [NativeName(NativeNameType.Param, "binding")] [NativeName(NativeNameType.Type, "const char*")] byte* binding)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (set != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(set);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(set, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Shaderc.ShadercCompileOptionsSetHlslRegisterSetAndBindingForStageNative(options, shaderKind, reg, pStr0, binding);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>/// Sets a descriptor set and binding for an HLSL register in the given stage.<br/>/// This method keeps a copy of the string data.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetHlslRegisterSetAndBindingForStage(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "reg")] [NativeName(NativeNameType.Type, "const char*")] ref byte reg, [NativeName(NativeNameType.Param, "set")] [NativeName(NativeNameType.Type, "const char*")] ref byte set, [NativeName(NativeNameType.Param, "binding")] [NativeName(NativeNameType.Type, "const char*")] byte* binding)
		{
			fixed (byte* preg = &reg)
			{
				fixed (byte* pset = &set)
				{
					Shaderc.ShadercCompileOptionsSetHlslRegisterSetAndBindingForStageNative(options, shaderKind, (byte*)preg, (byte*)pset, binding);
				}
			}
		}

		/// <summary>/// Sets a descriptor set and binding for an HLSL register in the given stage.<br/>/// This method keeps a copy of the string data.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetHlslRegisterSetAndBindingForStage(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "reg")] [NativeName(NativeNameType.Type, "const char*")] string reg, [NativeName(NativeNameType.Param, "set")] [NativeName(NativeNameType.Type, "const char*")] string set, [NativeName(NativeNameType.Param, "binding")] [NativeName(NativeNameType.Type, "const char*")] byte* binding)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (reg != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(reg);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(reg, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (set != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(set);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(set, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			Shaderc.ShadercCompileOptionsSetHlslRegisterSetAndBindingForStageNative(options, shaderKind, pStr0, pStr1, binding);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>/// Sets a descriptor set and binding for an HLSL register in the given stage.<br/>/// This method keeps a copy of the string data.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetHlslRegisterSetAndBindingForStage(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "reg")] [NativeName(NativeNameType.Type, "const char*")] byte* reg, [NativeName(NativeNameType.Param, "set")] [NativeName(NativeNameType.Type, "const char*")] byte* set, [NativeName(NativeNameType.Param, "binding")] [NativeName(NativeNameType.Type, "const char*")] ref byte binding)
		{
			fixed (byte* pbinding = &binding)
			{
				Shaderc.ShadercCompileOptionsSetHlslRegisterSetAndBindingForStageNative(options, shaderKind, reg, set, (byte*)pbinding);
			}
		}

		/// <summary>/// Sets a descriptor set and binding for an HLSL register in the given stage.<br/>/// This method keeps a copy of the string data.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetHlslRegisterSetAndBindingForStage(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "reg")] [NativeName(NativeNameType.Type, "const char*")] byte* reg, [NativeName(NativeNameType.Param, "set")] [NativeName(NativeNameType.Type, "const char*")] byte* set, [NativeName(NativeNameType.Param, "binding")] [NativeName(NativeNameType.Type, "const char*")] string binding)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (binding != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(binding);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(binding, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Shaderc.ShadercCompileOptionsSetHlslRegisterSetAndBindingForStageNative(options, shaderKind, reg, set, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>/// Sets a descriptor set and binding for an HLSL register in the given stage.<br/>/// This method keeps a copy of the string data.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetHlslRegisterSetAndBindingForStage(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "reg")] [NativeName(NativeNameType.Type, "const char*")] ref byte reg, [NativeName(NativeNameType.Param, "set")] [NativeName(NativeNameType.Type, "const char*")] byte* set, [NativeName(NativeNameType.Param, "binding")] [NativeName(NativeNameType.Type, "const char*")] ref byte binding)
		{
			fixed (byte* preg = &reg)
			{
				fixed (byte* pbinding = &binding)
				{
					Shaderc.ShadercCompileOptionsSetHlslRegisterSetAndBindingForStageNative(options, shaderKind, (byte*)preg, set, (byte*)pbinding);
				}
			}
		}

		/// <summary>/// Sets a descriptor set and binding for an HLSL register in the given stage.<br/>/// This method keeps a copy of the string data.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetHlslRegisterSetAndBindingForStage(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "reg")] [NativeName(NativeNameType.Type, "const char*")] string reg, [NativeName(NativeNameType.Param, "set")] [NativeName(NativeNameType.Type, "const char*")] byte* set, [NativeName(NativeNameType.Param, "binding")] [NativeName(NativeNameType.Type, "const char*")] string binding)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (reg != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(reg);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(reg, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (binding != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(binding);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(binding, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			Shaderc.ShadercCompileOptionsSetHlslRegisterSetAndBindingForStageNative(options, shaderKind, pStr0, set, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>/// Sets a descriptor set and binding for an HLSL register in the given stage.<br/>/// This method keeps a copy of the string data.<br/>/// </summary>		[NativeName(NativeNameType.Func, "shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetHlslRegisterSetAndBindingForStage(this ShadercCompileOptions options, [NativeName(NativeNameType.Param, "shader_kind")] [NativeName(NativeNameType.Type, "shaderc_shader_kind")] ShadercShaderKind shaderKind, [NativeName(NativeNameType.Param, "reg")] [NativeName(NativeNameType.Type, "const char*")] byte* reg, [NativeName(NativeNameType.Param, "set")] [NativeName(NativeNameType.Type, "const char*")] ref byte set, [NativeName(NativeNameType.Param, "binding")] [NativeName(NativeNameType.Type, "const char*")] ref byte binding)
		{
			fixed (byte* pset = &set)
			{
				fixed (byte* pbinding = &binding)
				{
					Shaderc.ShadercCompileOptionsSetHlslRegisterSetAndBindingForStageNative(options, shaderKind, reg, (byte*)pset, (byte*)pbinding);
				}
			}
		}
	}
}
