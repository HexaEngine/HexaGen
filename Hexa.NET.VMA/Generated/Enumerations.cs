// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using HexaGen.Runtime;

namespace Hexa.NET.VMA
{
	/// <summary>	/// Flags for created #VmaAllocator.<br/>	/// </summary>	[NativeName(NativeNameType.Enum, "VmaAllocatorCreateFlagBits")]
	public enum VmaAllocatorCreateFlagBits
	{
		/// <summary>		/// <br/>		/// Using this flag may increase performance because internal mutexes are not used.<br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_ALLOCATOR_CREATE_EXTERNALLY_SYNCHRONIZED_BIT")]
		[NativeName(NativeNameType.Value, "1")]
		ExternallySynchronized = unchecked(1),

		/// <summary>		/// <br/>		/// The flag works only if VmaAllocatorCreateInfo::vulkanApiVersion `== VK_API_VERSION_1_0`.<br/>		/// When it is `VK_API_VERSION_1_1`, the flag is ignored because the extension has been promoted to Vulkan 1.1.<br/>		/// Using this extension will automatically allocate dedicated blocks of memory for<br/>		/// some buffers and images instead of suballocating place for them out of bigger<br/>		/// memory blocks (as if you explicitly used #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT<br/>		/// flag) when it is recommended by the driver. It may improve performance on some<br/>		/// GPUs.<br/>		/// You may set this flag only if you found out that following device extensions are<br/>		/// supported, you enabled them while creating Vulkan device passed as<br/>		/// VmaAllocatorCreateInfo::device, and you want them to be used internally by this<br/>		/// library:<br/>		/// - VK_KHR_get_memory_requirements2 (device extension)<br/>		/// - VK_KHR_dedicated_allocation (device extension)<br/>		/// When this flag is set, you can experience following warnings reported by Vulkan<br/>		/// validation layer. You can ignore them.<br/>		/// > vkBindBufferMemory(): Binding memory to buffer 0x2d but vkGetBufferMemoryRequirements() has not been called on that buffer.<br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT")]
		[NativeName(NativeNameType.Value, "2")]
		KhrDedicatedAllocation = unchecked(2),

		/// <summary>		/// Enables usage of VK_KHR_bind_memory2 extension.<br/>		/// The flag works only if VmaAllocatorCreateInfo::vulkanApiVersion `== VK_API_VERSION_1_0`.<br/>		/// When it is `VK_API_VERSION_1_1`, the flag is ignored because the extension has been promoted to Vulkan 1.1.<br/>		/// You may set this flag only if you found out that this device extension is supported,<br/>		/// you enabled it while creating Vulkan device passed as VmaAllocatorCreateInfo::device,<br/>		/// and you want it to be used internally by this library.<br/>		/// The extension provides functions `vkBindBufferMemory2KHR` and `vkBindImageMemory2KHR`,<br/>		/// which allow to pass a chain of `pNext` structures while binding.<br/>		/// This flag is required if you use `pNext` parameter in vmaBindBufferMemory2() or vmaBindImageMemory2().<br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT")]
		[NativeName(NativeNameType.Value, "4")]
		KhrBindMemory2 = unchecked(4),

		/// <summary>		/// Enables usage of VK_EXT_memory_budget extension.<br/>		/// You may set this flag only if you found out that this device extension is supported,<br/>		/// you enabled it while creating Vulkan device passed as VmaAllocatorCreateInfo::device,<br/>		/// and you want it to be used internally by this library, along with another instance extension<br/>		/// VK_KHR_get_physical_device_properties2, which is required by it (or Vulkan 1.1, where this extension is promoted).<br/>		/// The extension provides query for current memory usage and budget, which will probably<br/>		/// be more accurate than an estimation used by the library otherwise.<br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT")]
		[NativeName(NativeNameType.Value, "8")]
		ExtMemoryBudget = unchecked(8),

		/// <summary>		/// Enables usage of VK_AMD_device_coherent_memory extension.<br/>		/// You may set this flag only if you:<br/>		/// - found out that this device extension is supported and enabled it while creating Vulkan device passed as VmaAllocatorCreateInfo::device,<br/>		/// - checked that `VkPhysicalDeviceCoherentMemoryFeaturesAMD::deviceCoherentMemory` is true and set it while creating the Vulkan device,<br/>		/// - want it to be used internally by this library.<br/>		/// The extension and accompanying device feature provide access to memory types with<br/>		/// `VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD` and `VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD` flags.<br/>		/// They are useful mostly for writing breadcrumb markers - a common method for debugging GPU crash/hang/TDR.<br/>		/// When the extension is not enabled, such memory types are still enumerated, but their usage is illegal.<br/>		/// To protect from this error, if you don't create the allocator with this flag, it will refuse to allocate any memory or create a custom pool in such memory type,<br/>		/// returning `VK_ERROR_FEATURE_NOT_PRESENT`.<br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_ALLOCATOR_CREATE_AMD_DEVICE_COHERENT_MEMORY_BIT")]
		[NativeName(NativeNameType.Value, "16")]
		AmdDeviceCoherentMemory = unchecked(16),

		/// <summary>		/// Enables usage of "buffer device address" feature, which allows you to use function<br/>		/// `vkGetBufferDeviceAddress*` to get raw GPU pointer to a buffer and pass it for usage inside a shader.<br/>		/// You may set this flag only if you:<br/>		/// 1. (For Vulkan version <br/>		/// <<br/>		/// 1.2) Found as available and enabled device extension<br/>		/// VK_KHR_buffer_device_address.<br/>		/// This extension is promoted to core Vulkan 1.2.<br/>		/// 2. Found as available and enabled device feature `VkPhysicalDeviceBufferDeviceAddressFeatures::bufferDeviceAddress`.<br/>		/// When this flag is set, you can create buffers with `VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT` using VMA.<br/>		/// The library automatically adds `VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT` to<br/>		/// allocated memory blocks wherever it might be needed.<br/>		/// For more information, see documentation chapter <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_ALLOCATOR_CREATE_BUFFER_DEVICE_ADDRESS_BIT")]
		[NativeName(NativeNameType.Value, "32")]
		BufferDeviceAddress = unchecked(32),

		/// <summary>		/// Enables usage of VK_EXT_memory_priority extension in the library.<br/>		/// You may set this flag only if you found available and enabled this device extension,<br/>		/// along with `VkPhysicalDeviceMemoryPriorityFeaturesEXT::memoryPriority == VK_TRUE`,<br/>		/// while creating Vulkan device passed as VmaAllocatorCreateInfo::device.<br/>		/// When this flag is used, VmaAllocationCreateInfo::priority and VmaPoolCreateInfo::priority<br/>		/// are used to set priorities of allocated Vulkan memory. Without it, these variables are ignored.<br/>		/// A priority must be a floating-point value between 0 and 1, indicating the priority of the allocation relative to other memory allocations.<br/>		/// Larger values are higher priority. The granularity of the priorities is implementation-dependent.<br/>		/// It is automatically passed to every call to `vkAllocateMemory` done by the library using structure `VkMemoryPriorityAllocateInfoEXT`.<br/>		/// The value to be used for default priority is 0.5.<br/>		/// For more details, see the documentation of the VK_EXT_memory_priority extension.<br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_ALLOCATOR_CREATE_EXT_MEMORY_PRIORITY_BIT")]
		[NativeName(NativeNameType.Value, "64")]
		ExtMemoryPriority = unchecked(64),

		/// <summary>		/// Enables usage of VK_KHR_maintenance4 extension in the library.<br/>		/// You may set this flag only if you found available and enabled this device extension,<br/>		/// while creating Vulkan device passed as VmaAllocatorCreateInfo::device.<br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_ALLOCATOR_CREATE_KHR_MAINTENANCE4_BIT")]
		[NativeName(NativeNameType.Value, "128")]
		KhrMaintenance4 = unchecked(128),

		/// <summary>		/// Enables usage of VK_KHR_maintenance5 extension in the library.<br/>		/// You should set this flag if you found available and enabled this device extension,<br/>		/// while creating Vulkan device passed as VmaAllocatorCreateInfo::device.<br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_ALLOCATOR_CREATE_KHR_MAINTENANCE5_BIT")]
		[NativeName(NativeNameType.Value, "256")]
		KhrMaintenance5 = unchecked(256),

		/// <summary>		/// Enables usage of VK_KHR_maintenance5 extension in the library.<br/>		/// You should set this flag if you found available and enabled this device extension,<br/>		/// while creating Vulkan device passed as VmaAllocatorCreateInfo::device.<br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_ALLOCATOR_CREATE_FLAG_BITS_MAX_ENUM")]
		[NativeName(NativeNameType.Value, "2147483647")]
		MaxEnum = unchecked(2147483647),

	}

	/// <summary>	/// <br/>	/// </summary>	[NativeName(NativeNameType.Enum, "VmaMemoryUsage")]
	public enum VmaMemoryUsage
	{
		/// <summary>		/// No intended memory usage specified.<br/>		/// Use other members of VmaAllocationCreateInfo to specify your requirements.<br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_MEMORY_USAGE_UNKNOWN")]
		[NativeName(NativeNameType.Value, "0")]
		Unknown = unchecked(0),

		/// <summary>		/// <br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_MEMORY_USAGE_GPU_ONLY")]
		[NativeName(NativeNameType.Value, "1")]
		GpuOnly = unchecked(1),

		/// <summary>		/// <br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_MEMORY_USAGE_CPU_ONLY")]
		[NativeName(NativeNameType.Value, "2")]
		CpuOnly = unchecked(2),

		/// <summary>		/// <br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_MEMORY_USAGE_CPU_TO_GPU")]
		[NativeName(NativeNameType.Value, "3")]
		CpuToGpu = unchecked(3),

		/// <summary>		/// <br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_MEMORY_USAGE_GPU_TO_CPU")]
		[NativeName(NativeNameType.Value, "4")]
		GpuToCpu = unchecked(4),

		/// <summary>		/// <br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_MEMORY_USAGE_CPU_COPY")]
		[NativeName(NativeNameType.Value, "5")]
		CpuCopy = unchecked(5),

		/// <summary>		/// Lazily allocated GPU memory having `VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT`.<br/>		/// Exists mostly on mobile platforms. Using it on desktop PC or other GPUs with no such memory type present will fail the allocation.<br/>		/// Usage: Memory for transient attachment images (color attachments, depth attachments etc.), created with `VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT`.<br/>		/// Allocations with this usage are always created as dedicated - it implies #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_MEMORY_USAGE_GPU_LAZILY_ALLOCATED")]
		[NativeName(NativeNameType.Value, "6")]
		GpuLazilyAllocated = unchecked(6),

		/// <summary>		/// Selects best memory type automatically.<br/>		/// This flag is recommended for most common use cases.<br/>		/// When using this flag, if you want to map the allocation (using vmaMapMemory() or #VMA_ALLOCATION_CREATE_MAPPED_BIT),<br/>		/// you must pass one of the flags: #VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT or #VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT<br/>		/// in VmaAllocationCreateInfo::flags.<br/>		/// It can be used only with functions that let the library know `VkBufferCreateInfo` or `VkImageCreateInfo`, e.g.<br/>		/// vmaCreateBuffer(), vmaCreateImage(), vmaFindMemoryTypeIndexForBufferInfo(), vmaFindMemoryTypeIndexForImageInfo()<br/>		/// and not with generic memory allocation functions.<br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_MEMORY_USAGE_AUTO")]
		[NativeName(NativeNameType.Value, "7")]
		Auto = unchecked(7),

		/// <summary>		/// Selects best memory type automatically with preference for GPU (device) memory.<br/>		/// When using this flag, if you want to map the allocation (using vmaMapMemory() or #VMA_ALLOCATION_CREATE_MAPPED_BIT),<br/>		/// you must pass one of the flags: #VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT or #VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT<br/>		/// in VmaAllocationCreateInfo::flags.<br/>		/// It can be used only with functions that let the library know `VkBufferCreateInfo` or `VkImageCreateInfo`, e.g.<br/>		/// vmaCreateBuffer(), vmaCreateImage(), vmaFindMemoryTypeIndexForBufferInfo(), vmaFindMemoryTypeIndexForImageInfo()<br/>		/// and not with generic memory allocation functions.<br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_MEMORY_USAGE_AUTO_PREFER_DEVICE")]
		[NativeName(NativeNameType.Value, "8")]
		AutoPreferDevice = unchecked(8),

		/// <summary>		/// Selects best memory type automatically with preference for CPU (host) memory.<br/>		/// When using this flag, if you want to map the allocation (using vmaMapMemory() or #VMA_ALLOCATION_CREATE_MAPPED_BIT),<br/>		/// you must pass one of the flags: #VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT or #VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT<br/>		/// in VmaAllocationCreateInfo::flags.<br/>		/// It can be used only with functions that let the library know `VkBufferCreateInfo` or `VkImageCreateInfo`, e.g.<br/>		/// vmaCreateBuffer(), vmaCreateImage(), vmaFindMemoryTypeIndexForBufferInfo(), vmaFindMemoryTypeIndexForImageInfo()<br/>		/// and not with generic memory allocation functions.<br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_MEMORY_USAGE_AUTO_PREFER_HOST")]
		[NativeName(NativeNameType.Value, "9")]
		AutoPreferHost = unchecked(9),

		/// <summary>		/// Selects best memory type automatically with preference for CPU (host) memory.<br/>		/// When using this flag, if you want to map the allocation (using vmaMapMemory() or #VMA_ALLOCATION_CREATE_MAPPED_BIT),<br/>		/// you must pass one of the flags: #VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT or #VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT<br/>		/// in VmaAllocationCreateInfo::flags.<br/>		/// It can be used only with functions that let the library know `VkBufferCreateInfo` or `VkImageCreateInfo`, e.g.<br/>		/// vmaCreateBuffer(), vmaCreateImage(), vmaFindMemoryTypeIndexForBufferInfo(), vmaFindMemoryTypeIndexForImageInfo()<br/>		/// and not with generic memory allocation functions.<br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_MEMORY_USAGE_MAX_ENUM")]
		[NativeName(NativeNameType.Value, "2147483647")]
		MaxEnum = unchecked(2147483647),

	}

	/// <summary>	/// Flags to be passed as VmaAllocationCreateInfo::flags.<br/>	/// </summary>	[NativeName(NativeNameType.Enum, "VmaAllocationCreateFlagBits")]
	public enum VmaAllocationCreateFlagBits
	{
		/// <summary>		/// <br/>		/// Use it for special, big resources, like fullscreen images used as attachments.<br/>		/// If you use this flag while creating a buffer or an image, `VkMemoryDedicatedAllocateInfo`<br/>		/// structure is applied if possible.<br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT")]
		[NativeName(NativeNameType.Value, "1")]
		DedicatedMemory = unchecked(1),

		/// <summary>		/// <br/>		/// If new allocation cannot be placed in any of the existing blocks, allocation<br/>		/// fails with `VK_ERROR_OUT_OF_DEVICE_MEMORY` error.<br/>		/// You should not use #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT and<br/>		/// #VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT at the same time. It makes no sense.<br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT")]
		[NativeName(NativeNameType.Value, "2")]
		NeverAllocate = unchecked(2),

		/// <summary>		/// <br/>		/// Pointer to mapped memory will be returned through VmaAllocationInfo::pMappedData.<br/>		/// It is valid to use this flag for allocation made from memory type that is not<br/>		/// `HOST_VISIBLE`. This flag is then ignored and memory is not mapped. This is<br/>		/// useful if you need an allocation that is efficient to use on GPU<br/>		/// (`DEVICE_LOCAL`) and still want to map it directly if possible on platforms that<br/>		/// support it (e.g. Intel GPU).<br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_ALLOCATION_CREATE_MAPPED_BIT")]
		[NativeName(NativeNameType.Value, "4")]
		Mapped = unchecked(4),

		/// <summary>		/// <br/>		/// Set this flag to treat VmaAllocationCreateInfo::pUserData as pointer to a<br/>		/// null-terminated string. Instead of copying pointer value, a local copy of the<br/>		/// string is made and stored in allocation's `pName`. The string is automatically<br/>		/// freed together with the allocation. It is also used in vmaBuildStatsString().<br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT")]
		[NativeName(NativeNameType.Value, "32")]
		UserDataCopyString = unchecked(32),

		/// <summary>		/// Allocation will be created from upper stack in a double stack pool.<br/>		/// This flag is only allowed for custom pools created with #VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT flag.<br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT")]
		[NativeName(NativeNameType.Value, "64")]
		UpperAddress = unchecked(64),

		/// <summary>		/// Create both buffer/image and allocation, but don't bind them together.<br/>		/// It is useful when you want to bind yourself to do some more advanced binding, e.g. using some extensions.<br/>		/// The flag is meaningful only with functions that bind by default: vmaCreateBuffer(), vmaCreateImage().<br/>		/// Otherwise it is ignored.<br/>		/// If you want to make sure the new buffer/image is not tied to the new memory allocation<br/>		/// through `VkMemoryDedicatedAllocateInfoKHR` structure in case the allocation ends up in its own memory block,<br/>		/// use also flag #VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT.<br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_ALLOCATION_CREATE_DONT_BIND_BIT")]
		[NativeName(NativeNameType.Value, "128")]
		DontBind = unchecked(128),

		/// <summary>		/// Create allocation only if additional device memory required for it, if any, won't exceed<br/>		/// memory budget. Otherwise return `VK_ERROR_OUT_OF_DEVICE_MEMORY`.<br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_ALLOCATION_CREATE_WITHIN_BUDGET_BIT")]
		[NativeName(NativeNameType.Value, "256")]
		WithinBudget = unchecked(256),

		/// <summary>		/// <br/>		/// Usage of this flag prevents supplying `VkMemoryDedicatedAllocateInfoKHR` when #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT is specified.<br/>		/// Otherwise created dedicated memory will not be suitable for aliasing resources, resulting in Vulkan Validation Layer errors.<br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT")]
		[NativeName(NativeNameType.Value, "512")]
		CanAlias = unchecked(512),

		/// <summary>		/// Requests possibility to map the allocation (using vmaMapMemory() or #VMA_ALLOCATION_CREATE_MAPPED_BIT).<br/>		/// - If you use #VMA_MEMORY_USAGE_AUTO or other `VMA_MEMORY_USAGE_AUTO*` value,<br/>		/// you must use this flag to be able to map the allocation. Otherwise, mapping is incorrect.<br/>		/// - If you use other value of #VmaMemoryUsage, this flag is ignored and mapping is always possible in memory types that are `HOST_VISIBLE`.<br/>		/// This includes allocations created in <br/>		/// Declares that mapped memory will only be written sequentially, e.g. using `memcpy()` or a loop writing number-by-number,<br/>		/// never read or accessed randomly, so a memory type can be selected that is uncached and write-combined.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT")]
		[NativeName(NativeNameType.Value, "1024")]
		HostAccessSequentialWrite = unchecked(1024),

		/// <summary>		/// Requests possibility to map the allocation (using vmaMapMemory() or #VMA_ALLOCATION_CREATE_MAPPED_BIT).<br/>		/// - If you use #VMA_MEMORY_USAGE_AUTO or other `VMA_MEMORY_USAGE_AUTO*` value,<br/>		/// you must use this flag to be able to map the allocation. Otherwise, mapping is incorrect.<br/>		/// - If you use other value of #VmaMemoryUsage, this flag is ignored and mapping is always possible in memory types that are `HOST_VISIBLE`.<br/>		/// This includes allocations created in <br/>		/// Declares that mapped memory can be read, written, and accessed in random order,<br/>		/// so a `HOST_CACHED` memory type is preferred.<br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT")]
		[NativeName(NativeNameType.Value, "2048")]
		HostAccessRandom = unchecked(2048),

		/// <summary>		/// Together with #VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT or #VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT,<br/>		/// it says that despite request for host access, a not-`HOST_VISIBLE` memory type can be selected<br/>		/// if it may improve performance.<br/>		/// By using this flag, you declare that you will check if the allocation ended up in a `HOST_VISIBLE` memory type<br/>		/// (e.g. using vmaGetAllocationMemoryProperties()) and if not, you will create some "staging" buffer and<br/>		/// issue an explicit transfer to write/read your data.<br/>		/// To prepare for this possibility, don't forget to add appropriate flags like<br/>		/// `VK_BUFFER_USAGE_TRANSFER_DST_BIT`, `VK_BUFFER_USAGE_TRANSFER_SRC_BIT` to the parameters of created buffer or image.<br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT")]
		[NativeName(NativeNameType.Value, "4096")]
		HostAccessAllowTransferInstead = unchecked(4096),

		/// <summary>		/// Allocation strategy that chooses smallest possible free range for the allocation<br/>		/// to minimize memory usage and fragmentation, possibly at the expense of allocation time.<br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT")]
		[NativeName(NativeNameType.Value, "65536")]
		StrategyMinMemory = unchecked(65536),

		/// <summary>		/// Allocation strategy that chooses first suitable free range for the allocation -<br/>		/// not necessarily in terms of the smallest offset but the one that is easiest and fastest to find<br/>		/// to minimize allocation time, possibly at the expense of allocation quality.<br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT")]
		[NativeName(NativeNameType.Value, "131072")]
		StrategyMinTime = unchecked(131072),

		/// <summary>		/// Allocation strategy that chooses always the lowest offset in available space.<br/>		/// This is not the most efficient strategy but achieves highly packed data.<br/>		/// Used internally by defragmentation, not recommended in typical usage.<br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT")]
		[NativeName(NativeNameType.Value, "262144")]
		StrategyMinOffset = unchecked(262144),

		/// <summary>		/// Alias to #VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT.<br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT")]
		[NativeName(NativeNameType.Value, "VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT")]
		StrategyBestFit = StrategyMinMemory,

		/// <summary>		/// Alias to #VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT.<br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT")]
		[NativeName(NativeNameType.Value, "VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT")]
		StrategyFirstFit = StrategyMinTime,

		/// <summary>		/// A bit mask to extract only `STRATEGY` bits from entire set of flags.<br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_ALLOCATION_CREATE_STRATEGY_MASK")]
		[NativeName(NativeNameType.Value, "458752")]
		StrategyMask = unchecked(458752),

		/// <summary>		/// A bit mask to extract only `STRATEGY` bits from entire set of flags.<br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_ALLOCATION_CREATE_FLAG_BITS_MAX_ENUM")]
		[NativeName(NativeNameType.Value, "2147483647")]
		MaxEnum = unchecked(2147483647),

	}

	/// <summary>	/// Flags to be passed as VmaPoolCreateInfo::flags.<br/>	/// </summary>	[NativeName(NativeNameType.Enum, "VmaPoolCreateFlagBits")]
	public enum VmaPoolCreateFlagBits
	{
		/// <summary>		/// <br/>		/// This is an optional optimization flag.<br/>		/// If you always allocate using vmaCreateBuffer(), vmaCreateImage(),<br/>		/// vmaAllocateMemoryForBuffer(), then you don't need to use it because allocator<br/>		/// knows exact type of your allocations so it can handle Buffer-Image Granularity<br/>		/// in the optimal way.<br/>		/// If you also allocate using vmaAllocateMemoryForImage() or vmaAllocateMemory(),<br/>		/// exact type of such allocations is not known, so allocator must be conservative<br/>		/// in handling Buffer-Image Granularity, which can lead to suboptimal allocation<br/>		/// (wasted memory). In that case, if you can make sure you always allocate only<br/>		/// buffers and linear images or only optimal images out of this pool, use this flag<br/>		/// to make allocator disregard Buffer-Image Granularity and so make allocations<br/>		/// faster and more optimal.<br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_POOL_CREATE_IGNORE_BUFFER_IMAGE_GRANULARITY_BIT")]
		[NativeName(NativeNameType.Value, "2")]
		IgnoreBufferImageGranularity = unchecked(2),

		/// <summary>		/// <br/>		/// Specify this flag to enable linear allocation algorithm, which always creates<br/>		/// new allocations after last one and doesn't reuse space from allocations freed in<br/>		/// between. It trades memory consumption for simplified algorithm and data<br/>		/// structure, which has better performance and uses less memory for metadata.<br/>		/// By using this flag, you can achieve behavior of free-at-once, stack,<br/>		/// ring buffer, and double stack.<br/>		/// For details, see documentation chapter <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT")]
		[NativeName(NativeNameType.Value, "4")]
		LinearAlgorithm = unchecked(4),

		/// <summary>		/// Bit mask to extract only `ALGORITHM` bits from entire set of flags.<br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_POOL_CREATE_ALGORITHM_MASK")]
		[NativeName(NativeNameType.Value, "VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT")]
		AlgorithmMask = LinearAlgorithm,

		/// <summary>		/// Bit mask to extract only `ALGORITHM` bits from entire set of flags.<br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_POOL_CREATE_FLAG_BITS_MAX_ENUM")]
		[NativeName(NativeNameType.Value, "2147483647")]
		MaxEnum = unchecked(2147483647),

	}

	/// <summary>	/// Flags to be passed as VmaDefragmentationInfo::flags.<br/>	/// </summary>	[NativeName(NativeNameType.Enum, "VmaDefragmentationFlagBits")]
	public enum VmaDefragmentationFlagBits
	{
		/// <summary>		/// <br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FAST_BIT")]
		[NativeName(NativeNameType.Value, "1")]
		AlgorithmFast = unchecked(1),

		/// <summary>		/// <br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_DEFRAGMENTATION_FLAG_ALGORITHM_BALANCED_BIT")]
		[NativeName(NativeNameType.Value, "2")]
		AlgorithmBalanced = unchecked(2),

		/// <summary>		/// <br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FULL_BIT")]
		[NativeName(NativeNameType.Value, "4")]
		AlgorithmFull = unchecked(4),

		/// <summary>		/// <br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_DEFRAGMENTATION_FLAG_ALGORITHM_EXTENSIVE_BIT")]
		[NativeName(NativeNameType.Value, "8")]
		AlgorithmExtensive = unchecked(8),

		/// <summary>		/// A bit mask to extract only `ALGORITHM` bits from entire set of flags.<br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_DEFRAGMENTATION_FLAG_ALGORITHM_MASK")]
		[NativeName(NativeNameType.Value, "15")]
		AlgorithmMask = unchecked(15),

		/// <summary>		/// A bit mask to extract only `ALGORITHM` bits from entire set of flags.<br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_DEFRAGMENTATION_FLAG_BITS_MAX_ENUM")]
		[NativeName(NativeNameType.Value, "2147483647")]
		MaxEnum = unchecked(2147483647),

	}

	/// <summary>	/// Operation performed on single defragmentation move. See structure #VmaDefragmentationMove.<br/>	/// </summary>	[NativeName(NativeNameType.Enum, "VmaDefragmentationMoveOperation")]
	public enum VmaDefragmentationMoveOperation
	{
		/// <summary>		/// Buffer/image has been recreated at `dstTmpAllocation`, data has been copied, old buffer/image has been destroyed. `srcAllocation` should be changed to point to the new place. This is the default value set by vmaBeginDefragmentationPass().<br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_DEFRAGMENTATION_MOVE_OPERATION_COPY")]
		[NativeName(NativeNameType.Value, "0")]
		Copy = unchecked(0),

		/// <summary>		/// Set this value if you cannot move the allocation. New place reserved at `dstTmpAllocation` will be freed. `srcAllocation` will remain unchanged.<br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_DEFRAGMENTATION_MOVE_OPERATION_IGNORE")]
		[NativeName(NativeNameType.Value, "1")]
		Ignore = unchecked(1),

		/// <summary>		/// Set this value if you decide to abandon the allocation and you destroyed the buffer/image. New place reserved at `dstTmpAllocation` will be freed, along with `srcAllocation`, which will be destroyed.<br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_DEFRAGMENTATION_MOVE_OPERATION_DESTROY")]
		[NativeName(NativeNameType.Value, "2")]
		Destroy = unchecked(2),

	}

	/// <summary>	/// Flags to be passed as VmaVirtualBlockCreateInfo::flags.<br/>	/// </summary>	[NativeName(NativeNameType.Enum, "VmaVirtualBlockCreateFlagBits")]
	public enum VmaVirtualBlockCreateFlagBits
	{
		/// <summary>		/// <br/>		/// Specify this flag to enable linear allocation algorithm, which always creates<br/>		/// new allocations after last one and doesn't reuse space from allocations freed in<br/>		/// between. It trades memory consumption for simplified algorithm and data<br/>		/// structure, which has better performance and uses less memory for metadata.<br/>		/// By using this flag, you can achieve behavior of free-at-once, stack,<br/>		/// ring buffer, and double stack.<br/>		/// For details, see documentation chapter <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_VIRTUAL_BLOCK_CREATE_LINEAR_ALGORITHM_BIT")]
		[NativeName(NativeNameType.Value, "1")]
		LinearAlgorithm = unchecked(1),

		/// <summary>		/// <br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_VIRTUAL_BLOCK_CREATE_ALGORITHM_MASK")]
		[NativeName(NativeNameType.Value, "VMA_VIRTUAL_BLOCK_CREATE_LINEAR_ALGORITHM_BIT")]
		AlgorithmMask = LinearAlgorithm,

		/// <summary>		/// <br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_VIRTUAL_BLOCK_CREATE_FLAG_BITS_MAX_ENUM")]
		[NativeName(NativeNameType.Value, "2147483647")]
		MaxEnum = unchecked(2147483647),

	}

	/// <summary>	/// Flags to be passed as VmaVirtualAllocationCreateInfo::flags.<br/>	/// </summary>	[NativeName(NativeNameType.Enum, "VmaVirtualAllocationCreateFlagBits")]
	public enum VmaVirtualAllocationCreateFlagBits
	{
		/// <summary>		/// <br/>		/// This flag is only allowed for virtual blocks created with #VMA_VIRTUAL_BLOCK_CREATE_LINEAR_ALGORITHM_BIT flag.<br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_VIRTUAL_ALLOCATION_CREATE_UPPER_ADDRESS_BIT")]
		[NativeName(NativeNameType.Value, "VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT")]
		UpperAddress = unchecked((int)UpperAddress),

		/// <summary>		/// <br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT")]
		[NativeName(NativeNameType.Value, "VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT")]
		StrategyMinMemory = unchecked((int)StrategyMinMemory),

		/// <summary>		/// <br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT")]
		[NativeName(NativeNameType.Value, "VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT")]
		StrategyMinTime = unchecked((int)StrategyMinTime),

		/// <summary>		/// Allocation strategy that chooses always the lowest offset in available space.<br/>		/// This is not the most efficient strategy but achieves highly packed data.<br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT")]
		[NativeName(NativeNameType.Value, "VMA_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT")]
		StrategyMinOffset = unchecked((int)StrategyMinOffset),

		/// <summary>		/// <br/>		/// These strategy flags are binary compatible with equivalent flags in #VmaAllocationCreateFlagBits.<br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MASK")]
		[NativeName(NativeNameType.Value, "VMA_ALLOCATION_CREATE_STRATEGY_MASK")]
		StrategyMask = unchecked((int)StrategyMask),

		/// <summary>		/// <br/>		/// These strategy flags are binary compatible with equivalent flags in #VmaAllocationCreateFlagBits.<br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "VMA_VIRTUAL_ALLOCATION_CREATE_FLAG_BITS_MAX_ENUM")]
		[NativeName(NativeNameType.Value, "2147483647")]
		MaxEnum = unchecked(2147483647),

	}

	[NativeName(NativeNameType.Enum, "VmaSuballocationType")]
	public enum VmaSuballocationType
	{
		[NativeName(NativeNameType.EnumItem, "VMA_SUBALLOCATION_TYPE_FREE")]
		[NativeName(NativeNameType.Value, "0")]
		Free = unchecked(0),
		[NativeName(NativeNameType.EnumItem, "VMA_SUBALLOCATION_TYPE_UNKNOWN")]
		[NativeName(NativeNameType.Value, "1")]
		Unknown = unchecked(1),
		[NativeName(NativeNameType.EnumItem, "VMA_SUBALLOCATION_TYPE_BUFFER")]
		[NativeName(NativeNameType.Value, "2")]
		Buffer = unchecked(2),
		[NativeName(NativeNameType.EnumItem, "VMA_SUBALLOCATION_TYPE_IMAGE_UNKNOWN")]
		[NativeName(NativeNameType.Value, "3")]
		ImageUnknown = unchecked(3),
		[NativeName(NativeNameType.EnumItem, "VMA_SUBALLOCATION_TYPE_IMAGE_LINEAR")]
		[NativeName(NativeNameType.Value, "4")]
		ImageLinear = unchecked(4),
		[NativeName(NativeNameType.EnumItem, "VMA_SUBALLOCATION_TYPE_IMAGE_OPTIMAL")]
		[NativeName(NativeNameType.Value, "5")]
		ImageOptimal = unchecked(5),
		[NativeName(NativeNameType.EnumItem, "VMA_SUBALLOCATION_TYPE_MAX_ENUM")]
		[NativeName(NativeNameType.Value, "2147483647")]
		MaxEnum = unchecked(2147483647),
	}

	[NativeName(NativeNameType.Enum, "VmaAllocationRequestType")]
	public enum VmaAllocationRequestType
	{
		[NativeName(NativeNameType.EnumItem, "Normal")]
		[NativeName(NativeNameType.Value, "0")]
		Normal = unchecked(0),
		[NativeName(NativeNameType.EnumItem, "TLSF")]
		[NativeName(NativeNameType.Value, "1")]
		Tlsf = unchecked(1),
		/// <summary>		/// Used by "Linear" algorithm.<br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "UpperAddress")]
		[NativeName(NativeNameType.Value, "2")]
		UpperAddress = unchecked(2),

		/// <summary>		/// Used by "Linear" algorithm.<br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "EndOf1st")]
		[NativeName(NativeNameType.Value, "3")]
		EndOf1St = unchecked(3),

		/// <summary>		/// Used by "Linear" algorithm.<br/>		/// </summary>		[NativeName(NativeNameType.EnumItem, "EndOf2nd")]
		[NativeName(NativeNameType.Value, "4")]
		EndOf2Nd = unchecked(4),

	}

	[NativeName(NativeNameType.Enum, "VMA_CACHE_OPERATION")]
	public enum VmaCacheOperation
	{
		[NativeName(NativeNameType.EnumItem, "VMA_CACHE_FLUSH")]
		[NativeName(NativeNameType.Value, "0")]
		Flush = unchecked(0),
		[NativeName(NativeNameType.EnumItem, "VMA_CACHE_INVALIDATE")]
		[NativeName(NativeNameType.Value, "1")]
		Invalidate = unchecked(1),
	}

}
