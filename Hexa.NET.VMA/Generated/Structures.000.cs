// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using Hexa.NET.Vulkan;

namespace Hexa.NET.VMA
{
	/// <summary>
	/// <br/>
	/// Provided for informative purpose, e.g. to gather statistics about number of<br/>
	/// allocations or total amount of memory allocated in Vulkan.<br/>
	/// Used in VmaAllocatorCreateInfo::pDeviceMemoryCallbacks.<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "VmaDeviceMemoryCallbacks")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct VmaDeviceMemoryCallbacks
	{
		/// <summary>
		/// Optional, can be null.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "pfnAllocate")]
		[NativeName(NativeNameType.Type, "void (*)()*")]
		public unsafe void* PfnAllocate;

		/// <summary>
		/// Optional, can be null.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "pfnFree")]
		[NativeName(NativeNameType.Type, "void (*)()*")]
		public unsafe void* PfnFree;

		/// <summary>
		/// Optional, can be null.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "pUserData")]
		[NativeName(NativeNameType.Type, "void*")]
		public unsafe void* PUserData;


		public unsafe VmaDeviceMemoryCallbacks(delegate*<void> pfnAllocate = default, delegate*<void> pfnFree = default, void* pUserData = default)
		{
			PfnAllocate = (void*)pfnAllocate;
			PfnFree = (void*)pfnFree;
			PUserData = pUserData;
		}


	}

	/// <summary>
	/// Parameters of an existing virtual allocation, returned by vmaGetVirtualAllocationInfo().<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "VmaVirtualAllocationInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct VmaVirtualAllocationInfo
	{
		/// <summary>
		/// <br/>
		/// Offset at which the allocation was made.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "offset")]
		[NativeName(NativeNameType.Type, "VkDeviceSize")]
		public ulong Offset;

		/// <summary>
		/// <br/>
		/// Same value as passed in VmaVirtualAllocationCreateInfo::size.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "size")]
		[NativeName(NativeNameType.Type, "VkDeviceSize")]
		public ulong Size;

		/// <summary>
		/// <br/>
		/// Same value as passed in VmaVirtualAllocationCreateInfo::pUserData or to vmaSetVirtualAllocationUserData().<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "pUserData")]
		[NativeName(NativeNameType.Type, "void*")]
		public unsafe void* PUserData;


		public unsafe VmaVirtualAllocationInfo(ulong offset = default, ulong size = default, void* pUserData = default)
		{
			Offset = offset;
			Size = size;
			PUserData = pUserData;
		}


	}

	/// <summary>
	/// <br/>
	/// These are slower to calculate. Use for debugging purposes.<br/>
	/// See functions: vmaCalculateStatistics(), vmaCalculatePoolStatistics().<br/>
	/// Previous version of the statistics API provided averages, but they have been removed<br/>
	/// because they can be easily calculated as:<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "VmaDetailedStatistics")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct VmaDetailedStatistics
	{
		/// <summary>
		/// Basic statistics.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "statistics")]
		[NativeName(NativeNameType.Type, "VmaStatistics")]
		public VmaStatistics Statistics;

		/// <summary>
		/// Number of free ranges of memory between allocations.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "unusedRangeCount")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint UnusedRangeCount;

		/// <summary>
		/// Smallest allocation size. `VK_WHOLE_SIZE` if there are 0 allocations.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "allocationSizeMin")]
		[NativeName(NativeNameType.Type, "VkDeviceSize")]
		public ulong AllocationSizeMin;

		/// <summary>
		/// Largest allocation size. 0 if there are 0 allocations.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "allocationSizeMax")]
		[NativeName(NativeNameType.Type, "VkDeviceSize")]
		public ulong AllocationSizeMax;

		/// <summary>
		/// Smallest empty range size. `VK_WHOLE_SIZE` if there are 0 empty ranges.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "unusedRangeSizeMin")]
		[NativeName(NativeNameType.Type, "VkDeviceSize")]
		public ulong UnusedRangeSizeMin;

		/// <summary>
		/// Largest empty range size. 0 if there are 0 empty ranges.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "unusedRangeSizeMax")]
		[NativeName(NativeNameType.Type, "VkDeviceSize")]
		public ulong UnusedRangeSizeMax;


		public unsafe VmaDetailedStatistics(VmaStatistics statistics = default, uint unusedRangeCount = default, ulong allocationSizeMin = default, ulong allocationSizeMax = default, ulong unusedRangeSizeMin = default, ulong unusedRangeSizeMax = default)
		{
			Statistics = statistics;
			UnusedRangeCount = unusedRangeCount;
			AllocationSizeMin = allocationSizeMin;
			AllocationSizeMax = allocationSizeMax;
			UnusedRangeSizeMin = unusedRangeSizeMin;
			UnusedRangeSizeMax = unusedRangeSizeMax;
		}


	}

	/// <summary>
	/// <br/>
	/// These are fast to calculate.<br/>
	/// See functions: vmaGetHeapBudgets(), vmaGetPoolStatistics().<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "VmaStatistics")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct VmaStatistics
	{
		/// <summary>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "blockCount")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint BlockCount;

		/// <summary>
		/// <br/>
		/// Dedicated allocations have their own blocks, so each one adds 1 to `allocationCount` as well as `blockCount`.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "allocationCount")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint AllocationCount;

		/// <summary>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "blockBytes")]
		[NativeName(NativeNameType.Type, "VkDeviceSize")]
		public ulong BlockBytes;

		/// <summary>
		/// <br/>
		/// Always less or equal than `blockBytes`.<br/>
		/// Difference `(blockBytes - allocationBytes)` is the amount of memory allocated from Vulkan<br/>
		/// but unused by any #VmaAllocation.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "allocationBytes")]
		[NativeName(NativeNameType.Type, "VkDeviceSize")]
		public ulong AllocationBytes;


		public unsafe VmaStatistics(uint blockCount = default, uint allocationCount = default, ulong blockBytes = default, ulong allocationBytes = default)
		{
			BlockCount = blockCount;
			AllocationCount = allocationCount;
			BlockBytes = blockBytes;
			AllocationBytes = allocationBytes;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "VmaStlAllocator<char>")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct VmaStlAllocator
	{


	}

	/// <summary>
	/// Parameters of planned allocation inside a VmaDeviceMemoryBlock.<br/>
	/// item points to a FREE suballocation.<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "VmaAllocationRequest")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct VmaAllocationRequest
	{
		[NativeName(NativeNameType.Field, "allocHandle")]
		[NativeName(NativeNameType.Type, "VmaAllocHandle_T*")]
		public unsafe VmaAllocHandle* AllocHandle;
		[NativeName(NativeNameType.Field, "size")]
		[NativeName(NativeNameType.Type, "VkDeviceSize")]
		public ulong Size;
		[NativeName(NativeNameType.Field, "item")]
		[NativeName(NativeNameType.Type, "iterator")]
		public Iterator Item;
		[NativeName(NativeNameType.Field, "customData")]
		[NativeName(NativeNameType.Type, "void*")]
		public unsafe void* CustomData;
		[NativeName(NativeNameType.Field, "algorithmData")]
		[NativeName(NativeNameType.Type, "uint64_t")]
		public ulong AlgorithmData;
		[NativeName(NativeNameType.Field, "type")]
		[NativeName(NativeNameType.Type, "VmaAllocationRequestType")]
		public VmaAllocationRequestType Type;

		public unsafe VmaAllocationRequest(VmaAllocHandle* allocHandle = default, ulong size = default, Iterator item = default, void* customData = default, ulong algorithmData = default, VmaAllocationRequestType type = default)
		{
			AllocHandle = allocHandle;
			Size = size;
			Item = item;
			CustomData = customData;
			AlgorithmData = algorithmData;
			Type = type;
		}


	}

	/// <summary>
	/// Represents a region of VmaDeviceMemoryBlock that is either assigned and returned as<br/>
	/// allocated memory block or free.<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "VmaSuballocation")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct VmaSuballocation
	{
		[NativeName(NativeNameType.Field, "offset")]
		[NativeName(NativeNameType.Type, "VkDeviceSize")]
		public ulong Offset;
		[NativeName(NativeNameType.Field, "size")]
		[NativeName(NativeNameType.Type, "VkDeviceSize")]
		public ulong Size;
		[NativeName(NativeNameType.Field, "userData")]
		[NativeName(NativeNameType.Type, "void*")]
		public unsafe void* UserData;
		[NativeName(NativeNameType.Field, "type")]
		[NativeName(NativeNameType.Type, "VmaSuballocationType")]
		public VmaSuballocationType Type;

		public unsafe VmaSuballocation(ulong offset = default, ulong size = default, void* userData = default, VmaSuballocationType type = default)
		{
			Offset = offset;
			Size = size;
			UserData = userData;
			Type = type;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "VmaListItem<VmaSuballocation>")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct VmaListItem
	{


	}

	/// <summary>
	/// <br/>
	/// To be used with functions like vmaCreateBuffer(), vmaCreateImage(), and many others.<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "VmaAllocationCreateInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct VmaAllocationCreateInfo
	{
		/// <summary>
		/// Use #VmaAllocationCreateFlagBits enum.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "flags")]
		[NativeName(NativeNameType.Type, "VmaAllocationCreateFlags")]
		public VmaAllocationCreateFlags Flags;

		/// <summary>
		/// <br/>
		/// You can leave #VMA_MEMORY_USAGE_UNKNOWN if you specify memory requirements in other way. <br/>
		/// If `pool` is not null, this member is ignored.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "usage")]
		[NativeName(NativeNameType.Type, "VmaMemoryUsage")]
		public VmaMemoryUsage Usage;

		/// <summary>
		/// <br/>
		/// Leave 0 if you specify memory requirements in other way. <br/>
		/// If `pool` is not null, this member is ignored.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "requiredFlags")]
		[NativeName(NativeNameType.Type, "VkMemoryPropertyFlags")]
		public uint RequiredFlags;

		/// <summary>
		/// <br/>
		/// Set to 0 if no additional flags are preferred. <br/>
		/// If `pool` is not null, this member is ignored. <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "preferredFlags")]
		[NativeName(NativeNameType.Type, "VkMemoryPropertyFlags")]
		public uint PreferredFlags;

		/// <summary>
		/// <br/>
		/// Value 0 is equivalent to `UINT32_MAX` - it means any memory type is accepted if<br/>
		/// it meets other requirements specified by this structure, with no further<br/>
		/// restrictions on memory type index. <br/>
		/// If `pool` is not null, this member is ignored.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "memoryTypeBits")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint MemoryTypeBits;

		/// <summary>
		/// <br/>
		/// Leave `VK_NULL_HANDLE` to allocate from default pool. If not null, members:<br/>
		/// `usage`, `requiredFlags`, `preferredFlags`, `memoryTypeBits` are ignored.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "pool")]
		[NativeName(NativeNameType.Type, "VmaPool_T*")]
		public unsafe VmaPool* Pool;

		/// <summary>
		/// <br/>
		/// If #VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT is used, it must be either<br/>
		/// null or pointer to a null-terminated string. The string will be then copied to<br/>
		/// internal buffer, so it doesn't need to be valid after allocation call.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "pUserData")]
		[NativeName(NativeNameType.Type, "void*")]
		public unsafe void* PUserData;

		/// <summary>
		/// <br/>
		/// It is used only when #VMA_ALLOCATOR_CREATE_EXT_MEMORY_PRIORITY_BIT flag was used during creation of the #VmaAllocator object<br/>
		/// and this allocation ends up as dedicated or is explicitly forced as dedicated using #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>
		/// Otherwise, it has the priority of a memory block where it is placed and this variable is ignored.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "priority")]
		[NativeName(NativeNameType.Type, "float")]
		public float Priority;


		public unsafe VmaAllocationCreateInfo(VmaAllocationCreateFlags flags = default, VmaMemoryUsage usage = default, uint requiredFlags = default, uint preferredFlags = default, uint memoryTypeBits = default, VmaPool* pool = default, void* pUserData = default, float priority = default)
		{
			Flags = flags;
			Usage = usage;
			RequiredFlags = requiredFlags;
			PreferredFlags = preferredFlags;
			MemoryTypeBits = memoryTypeBits;
			Pool = pool;
			PUserData = pUserData;
			Priority = priority;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "VmaDedicatedAllocationListItemTraits")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct VmaDedicatedAllocationListItemTraits
	{


	}

	/// <summary>
	/// Describes parameter of created #VmaPool.<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "VmaPoolCreateInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct VmaPoolCreateInfo
	{
		/// <summary>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "memoryTypeIndex")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint MemoryTypeIndex;

		/// <summary>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "flags")]
		[NativeName(NativeNameType.Type, "VmaPoolCreateFlags")]
		public VmaPoolCreateFlags Flags;

		/// <summary>
		/// <br/>
		/// Specify nonzero to set explicit, constant size of memory blocks used by this<br/>
		/// pool.<br/>
		/// Leave 0 to use default and let the library manage block sizes automatically.<br/>
		/// Sizes of particular blocks may vary.<br/>
		/// In this case, the pool will also support dedicated allocations.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "blockSize")]
		[NativeName(NativeNameType.Type, "VkDeviceSize")]
		public ulong BlockSize;

		/// <summary>
		/// <br/>
		/// Set to 0 to have no preallocated blocks and allow the pool be completely empty.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "minBlockCount")]
		[NativeName(NativeNameType.Type, "size_t")]
		public ulong MinBlockCount;

		/// <summary>
		/// <br/>
		/// Set to 0 to use default, which is `SIZE_MAX`, which means no limit.<br/>
		/// Set to same value as VmaPoolCreateInfo::minBlockCount to have fixed amount of memory allocated<br/>
		/// throughout whole lifetime of this pool.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "maxBlockCount")]
		[NativeName(NativeNameType.Type, "size_t")]
		public ulong MaxBlockCount;

		/// <summary>
		/// <br/>
		/// It is used only when #VMA_ALLOCATOR_CREATE_EXT_MEMORY_PRIORITY_BIT flag was used during creation of the #VmaAllocator object.<br/>
		/// Otherwise, this variable is ignored.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "priority")]
		[NativeName(NativeNameType.Type, "float")]
		public float Priority;

		/// <summary>
		/// <br/>
		/// Leave 0 (default) not to impose any additional alignment. If not 0, it must be a power of two.<br/>
		/// It can be useful in cases where alignment returned by Vulkan by functions like `vkGetBufferMemoryRequirements` is not enough,<br/>
		/// e.g. when doing interop with OpenGL.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "minAllocationAlignment")]
		[NativeName(NativeNameType.Type, "VkDeviceSize")]
		public ulong MinAllocationAlignment;

		/// <summary>
		/// <br/>
		/// Optional, can be null. If not null, it must point to a `pNext` chain of structures that can be attached to `VkMemoryAllocateInfo`.<br/>
		/// It can be useful for special needs such as adding `VkExportMemoryAllocateInfoKHR`.<br/>
		/// Structures pointed by this member must remain alive and unchanged for the whole lifetime of the custom pool.<br/>
		/// Please note that some structures, e.g. `VkMemoryPriorityAllocateInfoEXT`, `VkMemoryDedicatedAllocateInfoKHR`,<br/>
		/// can be attached automatically by this library when using other, more convenient of its features.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "pMemoryAllocateNext")]
		[NativeName(NativeNameType.Type, "void*")]
		public unsafe void* PMemoryAllocateNext;


		public unsafe VmaPoolCreateInfo(uint memoryTypeIndex = default, VmaPoolCreateFlags flags = default, ulong blockSize = default, ulong minBlockCount = default, ulong maxBlockCount = default, float priority = default, ulong minAllocationAlignment = default, void* pMemoryAllocateNext = default)
		{
			MemoryTypeIndex = memoryTypeIndex;
			Flags = flags;
			BlockSize = blockSize;
			MinBlockCount = minBlockCount;
			MaxBlockCount = maxBlockCount;
			Priority = priority;
			MinAllocationAlignment = minAllocationAlignment;
			PMemoryAllocateNext = pMemoryAllocateNext;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "_Mtx_internal_imp_t")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct MtxInternalImp
	{
		[NativeName(NativeNameType.StructOrClass, "_Mtx_internal_imp_t::")]
		[StructLayout(LayoutKind.Explicit)]
		public partial struct MtxInternalImpUnion
		{
			[NativeName(NativeNameType.Field, "_Critical_section")]
			[NativeName(NativeNameType.Type, "_Stl_critical_section")]
			[FieldOffset(0)]
			public StlCriticalSection CriticalSection;
			[NativeName(NativeNameType.Field, "_Cs_storage")]
			[NativeName(NativeNameType.Type, "_Align_type")]
			[FieldOffset(0)]
			public AlignType CsStorage;

			public unsafe MtxInternalImpUnion(StlCriticalSection criticalSection = default, AlignType csstorage = default)
			{
				CriticalSection = criticalSection;
				CsStorage = csstorage;
			}


		}

		[NativeName(NativeNameType.Field, "_Critical_section_size")]
		[NativeName(NativeNameType.Type, "const size_t")]
		public ulong CriticalSectionSize;
		[NativeName(NativeNameType.Field, "_Critical_section_align")]
		[NativeName(NativeNameType.Type, "const size_t")]
		public ulong CriticalSectionAlign;
		[NativeName(NativeNameType.Field, "_Type")]
		[NativeName(NativeNameType.Type, "int")]
		public int Type;
		[NativeName(NativeNameType.Field, "")]
		[NativeName(NativeNameType.Type, "")]
		public MtxInternalImpUnion Union;
		[NativeName(NativeNameType.Field, "_Thread_id")]
		[NativeName(NativeNameType.Type, "int")]
		public int ThreadId;
		[NativeName(NativeNameType.Field, "_Count")]
		[NativeName(NativeNameType.Type, "int")]
		public int Count;

		public unsafe MtxInternalImp(ulong criticalSectionSize = default, ulong criticalSectionAlign = default, int type = default, MtxInternalImpUnion union = default, int threadId = default, int count = default)
		{
			CriticalSectionSize = criticalSectionSize;
			CriticalSectionAlign = criticalSectionAlign;
			Type = type;
			Union = union;
			ThreadId = threadId;
			Count = count;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "_Stl_critical_section")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct StlCriticalSection
	{
		[NativeName(NativeNameType.Field, "_Unused")]
		[NativeName(NativeNameType.Type, "void*")]
		public unsafe void* Unused;
		[NativeName(NativeNameType.Field, "_M_srw_lock")]
		[NativeName(NativeNameType.Type, "void*")]
		public unsafe void* MSrwLock;

		public unsafe StlCriticalSection(void* unused = default, void* mSrwLock = default)
		{
			Unused = unused;
			MSrwLock = mSrwLock;
		}


	}

	/// <summary>
	/// An abstraction over buffer or image `usage` flags, depending on available extensions.<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "VmaBufferImageUsage")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct VmaBufferImageUsage
	{
		[NativeName(NativeNameType.Field, "UNKNOWN")]
		[NativeName(NativeNameType.Type, "const VmaBufferImageUsage")]
		public VmaBufferImageUsage UNKNOWN;
		[NativeName(NativeNameType.Field, "Value")]
		[NativeName(NativeNameType.Type, "BaseType")]
		public BaseType Value;

		public unsafe VmaBufferImageUsage(VmaBufferImageUsage unknown = default, BaseType value = default)
		{
			UNKNOWN = unknown;
			Value = value;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "VmaCurrentBudgetData")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct VmaCurrentBudgetData
	{
		[NativeName(NativeNameType.Field, "m_BlockCount")]
		[NativeName(NativeNameType.Type, "atomic[16]")]
		public Atomic MBlockCount_0;
		public Atomic MBlockCount_1;
		public Atomic MBlockCount_2;
		public Atomic MBlockCount_3;
		public Atomic MBlockCount_4;
		public Atomic MBlockCount_5;
		public Atomic MBlockCount_6;
		public Atomic MBlockCount_7;
		public Atomic MBlockCount_8;
		public Atomic MBlockCount_9;
		public Atomic MBlockCount_10;
		public Atomic MBlockCount_11;
		public Atomic MBlockCount_12;
		public Atomic MBlockCount_13;
		public Atomic MBlockCount_14;
		public Atomic MBlockCount_15;
		[NativeName(NativeNameType.Field, "m_AllocationCount")]
		[NativeName(NativeNameType.Type, "atomic[16]")]
		public Atomic MAllocationCount_0;
		public Atomic MAllocationCount_1;
		public Atomic MAllocationCount_2;
		public Atomic MAllocationCount_3;
		public Atomic MAllocationCount_4;
		public Atomic MAllocationCount_5;
		public Atomic MAllocationCount_6;
		public Atomic MAllocationCount_7;
		public Atomic MAllocationCount_8;
		public Atomic MAllocationCount_9;
		public Atomic MAllocationCount_10;
		public Atomic MAllocationCount_11;
		public Atomic MAllocationCount_12;
		public Atomic MAllocationCount_13;
		public Atomic MAllocationCount_14;
		public Atomic MAllocationCount_15;
		[NativeName(NativeNameType.Field, "m_BlockBytes")]
		[NativeName(NativeNameType.Type, "atomic[16]")]
		public Atomic MBlockBytes_0;
		public Atomic MBlockBytes_1;
		public Atomic MBlockBytes_2;
		public Atomic MBlockBytes_3;
		public Atomic MBlockBytes_4;
		public Atomic MBlockBytes_5;
		public Atomic MBlockBytes_6;
		public Atomic MBlockBytes_7;
		public Atomic MBlockBytes_8;
		public Atomic MBlockBytes_9;
		public Atomic MBlockBytes_10;
		public Atomic MBlockBytes_11;
		public Atomic MBlockBytes_12;
		public Atomic MBlockBytes_13;
		public Atomic MBlockBytes_14;
		public Atomic MBlockBytes_15;
		[NativeName(NativeNameType.Field, "m_AllocationBytes")]
		[NativeName(NativeNameType.Type, "atomic[16]")]
		public Atomic MAllocationBytes_0;
		public Atomic MAllocationBytes_1;
		public Atomic MAllocationBytes_2;
		public Atomic MAllocationBytes_3;
		public Atomic MAllocationBytes_4;
		public Atomic MAllocationBytes_5;
		public Atomic MAllocationBytes_6;
		public Atomic MAllocationBytes_7;
		public Atomic MAllocationBytes_8;
		public Atomic MAllocationBytes_9;
		public Atomic MAllocationBytes_10;
		public Atomic MAllocationBytes_11;
		public Atomic MAllocationBytes_12;
		public Atomic MAllocationBytes_13;
		public Atomic MAllocationBytes_14;
		public Atomic MAllocationBytes_15;
		[NativeName(NativeNameType.Field, "m_OperationsSinceBudgetFetch")]
		[NativeName(NativeNameType.Type, "atomic")]
		public Atomic MOperationsSinceBudgetFetch;
		[NativeName(NativeNameType.Field, "m_BudgetMutex")]
		[NativeName(NativeNameType.Type, "VmaRWMutex")]
		public VmaRWMutex MBudgetMutex;
		[NativeName(NativeNameType.Field, "m_VulkanUsage")]
		[NativeName(NativeNameType.Type, "uint64_t[16]")]
		public ulong MVulkanUsage_0;
		public ulong MVulkanUsage_1;
		public ulong MVulkanUsage_2;
		public ulong MVulkanUsage_3;
		public ulong MVulkanUsage_4;
		public ulong MVulkanUsage_5;
		public ulong MVulkanUsage_6;
		public ulong MVulkanUsage_7;
		public ulong MVulkanUsage_8;
		public ulong MVulkanUsage_9;
		public ulong MVulkanUsage_10;
		public ulong MVulkanUsage_11;
		public ulong MVulkanUsage_12;
		public ulong MVulkanUsage_13;
		public ulong MVulkanUsage_14;
		public ulong MVulkanUsage_15;
		[NativeName(NativeNameType.Field, "m_VulkanBudget")]
		[NativeName(NativeNameType.Type, "uint64_t[16]")]
		public ulong MVulkanBudget_0;
		public ulong MVulkanBudget_1;
		public ulong MVulkanBudget_2;
		public ulong MVulkanBudget_3;
		public ulong MVulkanBudget_4;
		public ulong MVulkanBudget_5;
		public ulong MVulkanBudget_6;
		public ulong MVulkanBudget_7;
		public ulong MVulkanBudget_8;
		public ulong MVulkanBudget_9;
		public ulong MVulkanBudget_10;
		public ulong MVulkanBudget_11;
		public ulong MVulkanBudget_12;
		public ulong MVulkanBudget_13;
		public ulong MVulkanBudget_14;
		public ulong MVulkanBudget_15;
		[NativeName(NativeNameType.Field, "m_BlockBytesAtBudgetFetch")]
		[NativeName(NativeNameType.Type, "uint64_t[16]")]
		public ulong MBlockBytesAtBudgetFetch_0;
		public ulong MBlockBytesAtBudgetFetch_1;
		public ulong MBlockBytesAtBudgetFetch_2;
		public ulong MBlockBytesAtBudgetFetch_3;
		public ulong MBlockBytesAtBudgetFetch_4;
		public ulong MBlockBytesAtBudgetFetch_5;
		public ulong MBlockBytesAtBudgetFetch_6;
		public ulong MBlockBytesAtBudgetFetch_7;
		public ulong MBlockBytesAtBudgetFetch_8;
		public ulong MBlockBytesAtBudgetFetch_9;
		public ulong MBlockBytesAtBudgetFetch_10;
		public ulong MBlockBytesAtBudgetFetch_11;
		public ulong MBlockBytesAtBudgetFetch_12;
		public ulong MBlockBytesAtBudgetFetch_13;
		public ulong MBlockBytesAtBudgetFetch_14;
		public ulong MBlockBytesAtBudgetFetch_15;

		public unsafe VmaCurrentBudgetData(Atomic* mBlockcount = default, Atomic* mAllocationcount = default, Atomic* mBlockbytes = default, Atomic* mAllocationbytes = default, Atomic mOperationssincebudgetfetch = default, VmaRWMutex mBudgetmutex = default, ulong* mVulkanusage = default, ulong* mVulkanbudget = default, ulong* mBlockbytesatbudgetfetch = default)
		{
			if (mBlockcount != default)
			{
				MBlockCount_0 = mBlockcount[0];
				MBlockCount_1 = mBlockcount[1];
				MBlockCount_2 = mBlockcount[2];
				MBlockCount_3 = mBlockcount[3];
				MBlockCount_4 = mBlockcount[4];
				MBlockCount_5 = mBlockcount[5];
				MBlockCount_6 = mBlockcount[6];
				MBlockCount_7 = mBlockcount[7];
				MBlockCount_8 = mBlockcount[8];
				MBlockCount_9 = mBlockcount[9];
				MBlockCount_10 = mBlockcount[10];
				MBlockCount_11 = mBlockcount[11];
				MBlockCount_12 = mBlockcount[12];
				MBlockCount_13 = mBlockcount[13];
				MBlockCount_14 = mBlockcount[14];
				MBlockCount_15 = mBlockcount[15];
			}
			if (mAllocationcount != default)
			{
				MAllocationCount_0 = mAllocationcount[0];
				MAllocationCount_1 = mAllocationcount[1];
				MAllocationCount_2 = mAllocationcount[2];
				MAllocationCount_3 = mAllocationcount[3];
				MAllocationCount_4 = mAllocationcount[4];
				MAllocationCount_5 = mAllocationcount[5];
				MAllocationCount_6 = mAllocationcount[6];
				MAllocationCount_7 = mAllocationcount[7];
				MAllocationCount_8 = mAllocationcount[8];
				MAllocationCount_9 = mAllocationcount[9];
				MAllocationCount_10 = mAllocationcount[10];
				MAllocationCount_11 = mAllocationcount[11];
				MAllocationCount_12 = mAllocationcount[12];
				MAllocationCount_13 = mAllocationcount[13];
				MAllocationCount_14 = mAllocationcount[14];
				MAllocationCount_15 = mAllocationcount[15];
			}
			if (mBlockbytes != default)
			{
				MBlockBytes_0 = mBlockbytes[0];
				MBlockBytes_1 = mBlockbytes[1];
				MBlockBytes_2 = mBlockbytes[2];
				MBlockBytes_3 = mBlockbytes[3];
				MBlockBytes_4 = mBlockbytes[4];
				MBlockBytes_5 = mBlockbytes[5];
				MBlockBytes_6 = mBlockbytes[6];
				MBlockBytes_7 = mBlockbytes[7];
				MBlockBytes_8 = mBlockbytes[8];
				MBlockBytes_9 = mBlockbytes[9];
				MBlockBytes_10 = mBlockbytes[10];
				MBlockBytes_11 = mBlockbytes[11];
				MBlockBytes_12 = mBlockbytes[12];
				MBlockBytes_13 = mBlockbytes[13];
				MBlockBytes_14 = mBlockbytes[14];
				MBlockBytes_15 = mBlockbytes[15];
			}
			if (mAllocationbytes != default)
			{
				MAllocationBytes_0 = mAllocationbytes[0];
				MAllocationBytes_1 = mAllocationbytes[1];
				MAllocationBytes_2 = mAllocationbytes[2];
				MAllocationBytes_3 = mAllocationbytes[3];
				MAllocationBytes_4 = mAllocationbytes[4];
				MAllocationBytes_5 = mAllocationbytes[5];
				MAllocationBytes_6 = mAllocationbytes[6];
				MAllocationBytes_7 = mAllocationbytes[7];
				MAllocationBytes_8 = mAllocationbytes[8];
				MAllocationBytes_9 = mAllocationbytes[9];
				MAllocationBytes_10 = mAllocationbytes[10];
				MAllocationBytes_11 = mAllocationbytes[11];
				MAllocationBytes_12 = mAllocationbytes[12];
				MAllocationBytes_13 = mAllocationbytes[13];
				MAllocationBytes_14 = mAllocationbytes[14];
				MAllocationBytes_15 = mAllocationbytes[15];
			}
			MOperationsSinceBudgetFetch = mOperationssincebudgetfetch;
			MBudgetMutex = mBudgetmutex;
			if (mVulkanusage != default)
			{
				MVulkanUsage_0 = mVulkanusage[0];
				MVulkanUsage_1 = mVulkanusage[1];
				MVulkanUsage_2 = mVulkanusage[2];
				MVulkanUsage_3 = mVulkanusage[3];
				MVulkanUsage_4 = mVulkanusage[4];
				MVulkanUsage_5 = mVulkanusage[5];
				MVulkanUsage_6 = mVulkanusage[6];
				MVulkanUsage_7 = mVulkanusage[7];
				MVulkanUsage_8 = mVulkanusage[8];
				MVulkanUsage_9 = mVulkanusage[9];
				MVulkanUsage_10 = mVulkanusage[10];
				MVulkanUsage_11 = mVulkanusage[11];
				MVulkanUsage_12 = mVulkanusage[12];
				MVulkanUsage_13 = mVulkanusage[13];
				MVulkanUsage_14 = mVulkanusage[14];
				MVulkanUsage_15 = mVulkanusage[15];
			}
			if (mVulkanbudget != default)
			{
				MVulkanBudget_0 = mVulkanbudget[0];
				MVulkanBudget_1 = mVulkanbudget[1];
				MVulkanBudget_2 = mVulkanbudget[2];
				MVulkanBudget_3 = mVulkanbudget[3];
				MVulkanBudget_4 = mVulkanbudget[4];
				MVulkanBudget_5 = mVulkanbudget[5];
				MVulkanBudget_6 = mVulkanbudget[6];
				MVulkanBudget_7 = mVulkanbudget[7];
				MVulkanBudget_8 = mVulkanbudget[8];
				MVulkanBudget_9 = mVulkanbudget[9];
				MVulkanBudget_10 = mVulkanbudget[10];
				MVulkanBudget_11 = mVulkanbudget[11];
				MVulkanBudget_12 = mVulkanbudget[12];
				MVulkanBudget_13 = mVulkanbudget[13];
				MVulkanBudget_14 = mVulkanbudget[14];
				MVulkanBudget_15 = mVulkanbudget[15];
			}
			if (mBlockbytesatbudgetfetch != default)
			{
				MBlockBytesAtBudgetFetch_0 = mBlockbytesatbudgetfetch[0];
				MBlockBytesAtBudgetFetch_1 = mBlockbytesatbudgetfetch[1];
				MBlockBytesAtBudgetFetch_2 = mBlockbytesatbudgetfetch[2];
				MBlockBytesAtBudgetFetch_3 = mBlockbytesatbudgetfetch[3];
				MBlockBytesAtBudgetFetch_4 = mBlockbytesatbudgetfetch[4];
				MBlockBytesAtBudgetFetch_5 = mBlockbytesatbudgetfetch[5];
				MBlockBytesAtBudgetFetch_6 = mBlockbytesatbudgetfetch[6];
				MBlockBytesAtBudgetFetch_7 = mBlockbytesatbudgetfetch[7];
				MBlockBytesAtBudgetFetch_8 = mBlockbytesatbudgetfetch[8];
				MBlockBytesAtBudgetFetch_9 = mBlockbytesatbudgetfetch[9];
				MBlockBytesAtBudgetFetch_10 = mBlockbytesatbudgetfetch[10];
				MBlockBytesAtBudgetFetch_11 = mBlockbytesatbudgetfetch[11];
				MBlockBytesAtBudgetFetch_12 = mBlockbytesatbudgetfetch[12];
				MBlockBytesAtBudgetFetch_13 = mBlockbytesatbudgetfetch[13];
				MBlockBytesAtBudgetFetch_14 = mBlockbytesatbudgetfetch[14];
				MBlockBytesAtBudgetFetch_15 = mBlockbytesatbudgetfetch[15];
			}
		}

		public unsafe VmaCurrentBudgetData(Span<Atomic> mBlockcount = default, Span<Atomic> mAllocationcount = default, Span<Atomic> mBlockbytes = default, Span<Atomic> mAllocationbytes = default, Atomic mOperationssincebudgetfetch = default, VmaRWMutex mBudgetmutex = default, Span<ulong> mVulkanusage = default, Span<ulong> mVulkanbudget = default, Span<ulong> mBlockbytesatbudgetfetch = default)
		{
			if (mBlockcount != default)
			{
				MBlockCount_0 = mBlockcount[0];
				MBlockCount_1 = mBlockcount[1];
				MBlockCount_2 = mBlockcount[2];
				MBlockCount_3 = mBlockcount[3];
				MBlockCount_4 = mBlockcount[4];
				MBlockCount_5 = mBlockcount[5];
				MBlockCount_6 = mBlockcount[6];
				MBlockCount_7 = mBlockcount[7];
				MBlockCount_8 = mBlockcount[8];
				MBlockCount_9 = mBlockcount[9];
				MBlockCount_10 = mBlockcount[10];
				MBlockCount_11 = mBlockcount[11];
				MBlockCount_12 = mBlockcount[12];
				MBlockCount_13 = mBlockcount[13];
				MBlockCount_14 = mBlockcount[14];
				MBlockCount_15 = mBlockcount[15];
			}
			if (mAllocationcount != default)
			{
				MAllocationCount_0 = mAllocationcount[0];
				MAllocationCount_1 = mAllocationcount[1];
				MAllocationCount_2 = mAllocationcount[2];
				MAllocationCount_3 = mAllocationcount[3];
				MAllocationCount_4 = mAllocationcount[4];
				MAllocationCount_5 = mAllocationcount[5];
				MAllocationCount_6 = mAllocationcount[6];
				MAllocationCount_7 = mAllocationcount[7];
				MAllocationCount_8 = mAllocationcount[8];
				MAllocationCount_9 = mAllocationcount[9];
				MAllocationCount_10 = mAllocationcount[10];
				MAllocationCount_11 = mAllocationcount[11];
				MAllocationCount_12 = mAllocationcount[12];
				MAllocationCount_13 = mAllocationcount[13];
				MAllocationCount_14 = mAllocationcount[14];
				MAllocationCount_15 = mAllocationcount[15];
			}
			if (mBlockbytes != default)
			{
				MBlockBytes_0 = mBlockbytes[0];
				MBlockBytes_1 = mBlockbytes[1];
				MBlockBytes_2 = mBlockbytes[2];
				MBlockBytes_3 = mBlockbytes[3];
				MBlockBytes_4 = mBlockbytes[4];
				MBlockBytes_5 = mBlockbytes[5];
				MBlockBytes_6 = mBlockbytes[6];
				MBlockBytes_7 = mBlockbytes[7];
				MBlockBytes_8 = mBlockbytes[8];
				MBlockBytes_9 = mBlockbytes[9];
				MBlockBytes_10 = mBlockbytes[10];
				MBlockBytes_11 = mBlockbytes[11];
				MBlockBytes_12 = mBlockbytes[12];
				MBlockBytes_13 = mBlockbytes[13];
				MBlockBytes_14 = mBlockbytes[14];
				MBlockBytes_15 = mBlockbytes[15];
			}
			if (mAllocationbytes != default)
			{
				MAllocationBytes_0 = mAllocationbytes[0];
				MAllocationBytes_1 = mAllocationbytes[1];
				MAllocationBytes_2 = mAllocationbytes[2];
				MAllocationBytes_3 = mAllocationbytes[3];
				MAllocationBytes_4 = mAllocationbytes[4];
				MAllocationBytes_5 = mAllocationbytes[5];
				MAllocationBytes_6 = mAllocationbytes[6];
				MAllocationBytes_7 = mAllocationbytes[7];
				MAllocationBytes_8 = mAllocationbytes[8];
				MAllocationBytes_9 = mAllocationbytes[9];
				MAllocationBytes_10 = mAllocationbytes[10];
				MAllocationBytes_11 = mAllocationbytes[11];
				MAllocationBytes_12 = mAllocationbytes[12];
				MAllocationBytes_13 = mAllocationbytes[13];
				MAllocationBytes_14 = mAllocationbytes[14];
				MAllocationBytes_15 = mAllocationbytes[15];
			}
			MOperationsSinceBudgetFetch = mOperationssincebudgetfetch;
			MBudgetMutex = mBudgetmutex;
			if (mVulkanusage != default)
			{
				MVulkanUsage_0 = mVulkanusage[0];
				MVulkanUsage_1 = mVulkanusage[1];
				MVulkanUsage_2 = mVulkanusage[2];
				MVulkanUsage_3 = mVulkanusage[3];
				MVulkanUsage_4 = mVulkanusage[4];
				MVulkanUsage_5 = mVulkanusage[5];
				MVulkanUsage_6 = mVulkanusage[6];
				MVulkanUsage_7 = mVulkanusage[7];
				MVulkanUsage_8 = mVulkanusage[8];
				MVulkanUsage_9 = mVulkanusage[9];
				MVulkanUsage_10 = mVulkanusage[10];
				MVulkanUsage_11 = mVulkanusage[11];
				MVulkanUsage_12 = mVulkanusage[12];
				MVulkanUsage_13 = mVulkanusage[13];
				MVulkanUsage_14 = mVulkanusage[14];
				MVulkanUsage_15 = mVulkanusage[15];
			}
			if (mVulkanbudget != default)
			{
				MVulkanBudget_0 = mVulkanbudget[0];
				MVulkanBudget_1 = mVulkanbudget[1];
				MVulkanBudget_2 = mVulkanbudget[2];
				MVulkanBudget_3 = mVulkanbudget[3];
				MVulkanBudget_4 = mVulkanbudget[4];
				MVulkanBudget_5 = mVulkanbudget[5];
				MVulkanBudget_6 = mVulkanbudget[6];
				MVulkanBudget_7 = mVulkanbudget[7];
				MVulkanBudget_8 = mVulkanbudget[8];
				MVulkanBudget_9 = mVulkanbudget[9];
				MVulkanBudget_10 = mVulkanbudget[10];
				MVulkanBudget_11 = mVulkanbudget[11];
				MVulkanBudget_12 = mVulkanbudget[12];
				MVulkanBudget_13 = mVulkanbudget[13];
				MVulkanBudget_14 = mVulkanbudget[14];
				MVulkanBudget_15 = mVulkanbudget[15];
			}
			if (mBlockbytesatbudgetfetch != default)
			{
				MBlockBytesAtBudgetFetch_0 = mBlockbytesatbudgetfetch[0];
				MBlockBytesAtBudgetFetch_1 = mBlockbytesatbudgetfetch[1];
				MBlockBytesAtBudgetFetch_2 = mBlockbytesatbudgetfetch[2];
				MBlockBytesAtBudgetFetch_3 = mBlockbytesatbudgetfetch[3];
				MBlockBytesAtBudgetFetch_4 = mBlockbytesatbudgetfetch[4];
				MBlockBytesAtBudgetFetch_5 = mBlockbytesatbudgetfetch[5];
				MBlockBytesAtBudgetFetch_6 = mBlockbytesatbudgetfetch[6];
				MBlockBytesAtBudgetFetch_7 = mBlockbytesatbudgetfetch[7];
				MBlockBytesAtBudgetFetch_8 = mBlockbytesatbudgetfetch[8];
				MBlockBytesAtBudgetFetch_9 = mBlockbytesatbudgetfetch[9];
				MBlockBytesAtBudgetFetch_10 = mBlockbytesatbudgetfetch[10];
				MBlockBytesAtBudgetFetch_11 = mBlockbytesatbudgetfetch[11];
				MBlockBytesAtBudgetFetch_12 = mBlockbytesatbudgetfetch[12];
				MBlockBytesAtBudgetFetch_13 = mBlockbytesatbudgetfetch[13];
				MBlockBytesAtBudgetFetch_14 = mBlockbytesatbudgetfetch[14];
				MBlockBytesAtBudgetFetch_15 = mBlockbytesatbudgetfetch[15];
			}
		}


		public unsafe Span<Atomic> MBlockCount
		
		{
			get
			{
				fixed (Atomic* p = &this.MBlockCount_0)
				{
					return new Span<Atomic>(p, 16);
				}
			}
		}
		public unsafe Span<Atomic> MAllocationCount
		
		{
			get
			{
				fixed (Atomic* p = &this.MAllocationCount_0)
				{
					return new Span<Atomic>(p, 16);
				}
			}
		}
		public unsafe Span<Atomic> MBlockBytes
		
		{
			get
			{
				fixed (Atomic* p = &this.MBlockBytes_0)
				{
					return new Span<Atomic>(p, 16);
				}
			}
		}
		public unsafe Span<Atomic> MAllocationBytes
		
		{
			get
			{
				fixed (Atomic* p = &this.MAllocationBytes_0)
				{
					return new Span<Atomic>(p, 16);
				}
			}
		}
	}

	/// <summary>
	/// Description of a Allocator to be created.<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "VmaAllocatorCreateInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct VmaAllocatorCreateInfo
	{
		/// <summary>
		/// Flags for created allocator. Use #VmaAllocatorCreateFlagBits enum.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "flags")]
		[NativeName(NativeNameType.Type, "VmaAllocatorCreateFlags")]
		public VmaAllocatorCreateFlags Flags;

		/// <summary>
		/// Vulkan physical device.<br/>
		/// It must be valid throughout whole lifetime of created allocator. <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "physicalDevice")]
		[NativeName(NativeNameType.Type, "VkPhysicalDevice")]
		public VkPhysicalDevice PhysicalDevice;

		/// <summary>
		/// Vulkan device.<br/>
		/// It must be valid throughout whole lifetime of created allocator. <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "device")]
		[NativeName(NativeNameType.Type, "VkDevice")]
		public VkDevice Device;

		/// <summary>
		/// Preferred size of a single `VkDeviceMemory` block to be allocated from large heaps > 1 GiB. Optional.<br/>
		/// Set to 0 to use default, which is currently 256 MiB. <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "preferredLargeHeapBlockSize")]
		[NativeName(NativeNameType.Type, "VkDeviceSize")]
		public ulong PreferredLargeHeapBlockSize;

		/// <summary>
		/// Custom CPU memory allocation callbacks. Optional.<br/>
		/// Optional, can be null. When specified, will also be used for all CPU-side memory allocations. <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "pAllocationCallbacks")]
		[NativeName(NativeNameType.Type, "const VkAllocationCallbacks*")]
		public unsafe VkAllocationCallbacks* PAllocationCallbacks;

		/// <summary>
		/// Informative callbacks for `vkAllocateMemory`, `vkFreeMemory`. Optional.<br/>
		/// Optional, can be null. <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "pDeviceMemoryCallbacks")]
		[NativeName(NativeNameType.Type, "const VmaDeviceMemoryCallbacks*")]
		public unsafe VmaDeviceMemoryCallbacks* PDeviceMemoryCallbacks;

		/// <summary>
		/// <br/>
		/// If not NULL, it must be a pointer to an array of<br/>
		/// `VkPhysicalDeviceMemoryProperties::memoryHeapCount` elements, defining limit on<br/>
		/// maximum number of bytes that can be allocated out of particular Vulkan memory<br/>
		/// heap.<br/>
		/// Any of the elements may be equal to `VK_WHOLE_SIZE`, which means no limit on that<br/>
		/// heap. This is also the default in case of `pHeapSizeLimit` = NULL.<br/>
		/// If there is a limit defined for a heap:<br/>
		/// - If user tries to allocate more memory from that heap using this allocator,<br/>
		/// the allocation fails with `VK_ERROR_OUT_OF_DEVICE_MEMORY`.<br/>
		/// - If the limit is smaller than heap size reported in `VkMemoryHeap::size`, the<br/>
		/// value of this limit will be reported instead when using vmaGetMemoryProperties().<br/>
		/// Warning! Using this feature may not be equivalent to installing a GPU with<br/>
		/// smaller amount of memory, because graphics driver doesn't necessary fail new<br/>
		/// allocations with `VK_ERROR_OUT_OF_DEVICE_MEMORY` result when memory capacity is<br/>
		/// exceeded. It may return success and just silently migrate some device memory<br/>
		/// blocks to system RAM. This driver behavior can also be controlled using<br/>
		/// VK_AMD_memory_overallocation_behavior extension.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "pHeapSizeLimit")]
		[NativeName(NativeNameType.Type, "const VkDeviceSize*")]
		public unsafe ulong* PHeapSizeLimit;

		/// <summary>
		/// <br/>
		/// For details see [Pointers to Vulkan functions](<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "pVulkanFunctions")]
		[NativeName(NativeNameType.Type, "const VmaVulkanFunctions*")]
		public unsafe VmaVulkanFunctions* PVulkanFunctions;

		/// <summary>
		/// <br/>
		/// Starting from version 3.0.0 this member is no longer optional, it must be set!<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "instance")]
		[NativeName(NativeNameType.Type, "VkInstance")]
		public VkInstance Instance;

		/// <summary>
		/// <br/>
		/// It must be a value in the format as created by macro `VK_MAKE_VERSION` or a constant like: `VK_API_VERSION_1_1`, `VK_API_VERSION_1_0`.<br/>
		/// The patch version number specified is ignored. Only the major and minor versions are considered.<br/>
		/// Only versions 1.0, 1.1, 1.2, 1.3 are supported by the current implementation.<br/>
		/// Leaving it initialized to zero is equivalent to `VK_API_VERSION_1_0`.<br/>
		/// It must match the Vulkan version used by the application and supported on the selected physical device,<br/>
		/// so it must be no higher than `VkApplicationInfo::apiVersion` passed to `vkCreateInstance`<br/>
		/// and no higher than `VkPhysicalDeviceProperties::apiVersion` found on the physical device used.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "vulkanApiVersion")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint VulkanApiVersion;

		/// <summary>
		/// <br/>
		/// If not NULL, it must be a pointer to an array of `VkPhysicalDeviceMemoryProperties::memoryTypeCount`<br/>
		/// elements, defining external memory handle types of particular Vulkan memory type,<br/>
		/// to be passed using `VkExportMemoryAllocateInfoKHR`.<br/>
		/// Any of the elements may be equal to 0, which means not to use `VkExportMemoryAllocateInfoKHR` on this memory type.<br/>
		/// This is also the default in case of `pTypeExternalMemoryHandleTypes` = NULL.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "pTypeExternalMemoryHandleTypes")]
		[NativeName(NativeNameType.Type, "const VkExternalMemoryHandleTypeFlagsKHR*")]
		public unsafe VkExternalMemoryHandleTypeFlagsKHR* PTypeExternalMemoryHandleTypes;


		public unsafe VmaAllocatorCreateInfo(VmaAllocatorCreateFlags flags = default, VkPhysicalDevice physicalDevice = default, VkDevice device = default, ulong preferredLargeHeapBlockSize = default, VkAllocationCallbacks* pAllocationCallbacks = default, VmaDeviceMemoryCallbacks* pDeviceMemoryCallbacks = default, ulong* pHeapSizeLimit = default, VmaVulkanFunctions* pVulkanFunctions = default, VkInstance instance = default, uint vulkanApiVersion = default, VkExternalMemoryHandleTypeFlagsKHR* pTypeExternalMemoryHandleTypes = default)
		{
			Flags = flags;
			PhysicalDevice = physicalDevice;
			Device = device;
			PreferredLargeHeapBlockSize = preferredLargeHeapBlockSize;
			PAllocationCallbacks = pAllocationCallbacks;
			PDeviceMemoryCallbacks = pDeviceMemoryCallbacks;
			PHeapSizeLimit = pHeapSizeLimit;
			PVulkanFunctions = pVulkanFunctions;
			Instance = instance;
			VulkanApiVersion = vulkanApiVersion;
			PTypeExternalMemoryHandleTypes = pTypeExternalMemoryHandleTypes;
		}


	}

	/// <summary>
	/// <br/>
	/// Used in VmaAllocatorCreateInfo::pVulkanFunctions.<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "VmaVulkanFunctions")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct VmaVulkanFunctions
	{
		/// <summary>
		/// Required when using VMA_DYNAMIC_VULKAN_FUNCTIONS.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "vkGetInstanceProcAddr")]
		[NativeName(NativeNameType.Type, "PFN_vkGetInstanceProcAddr")]
		public unsafe void* VkGetInstanceProcAddr;
		/// <summary>
		/// Required when using VMA_DYNAMIC_VULKAN_FUNCTIONS.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "vkGetDeviceProcAddr")]
		[NativeName(NativeNameType.Type, "PFN_vkGetDeviceProcAddr")]
		public unsafe void* VkGetDeviceProcAddr;
		[NativeName(NativeNameType.Field, "vkGetPhysicalDeviceProperties")]
		[NativeName(NativeNameType.Type, "PFN_vkGetPhysicalDeviceProperties")]
		public unsafe void* VkGetPhysicalDeviceProperties;
		[NativeName(NativeNameType.Field, "vkGetPhysicalDeviceMemoryProperties")]
		[NativeName(NativeNameType.Type, "PFN_vkGetPhysicalDeviceMemoryProperties")]
		public unsafe void* VkGetPhysicalDeviceMemoryProperties;
		[NativeName(NativeNameType.Field, "vkAllocateMemory")]
		[NativeName(NativeNameType.Type, "PFN_vkAllocateMemory")]
		public unsafe void* VkAllocateMemory;
		[NativeName(NativeNameType.Field, "vkFreeMemory")]
		[NativeName(NativeNameType.Type, "PFN_vkFreeMemory")]
		public unsafe void* VkFreeMemory;
		[NativeName(NativeNameType.Field, "vkMapMemory")]
		[NativeName(NativeNameType.Type, "PFN_vkMapMemory")]
		public unsafe void* VkMapMemory;
		[NativeName(NativeNameType.Field, "vkUnmapMemory")]
		[NativeName(NativeNameType.Type, "PFN_vkUnmapMemory")]
		public unsafe void* VkUnmapMemory;
		[NativeName(NativeNameType.Field, "vkFlushMappedMemoryRanges")]
		[NativeName(NativeNameType.Type, "PFN_vkFlushMappedMemoryRanges")]
		public unsafe void* VkFlushMappedMemoryRanges;
		[NativeName(NativeNameType.Field, "vkInvalidateMappedMemoryRanges")]
		[NativeName(NativeNameType.Type, "PFN_vkInvalidateMappedMemoryRanges")]
		public unsafe void* VkInvalidateMappedMemoryRanges;
		[NativeName(NativeNameType.Field, "vkBindBufferMemory")]
		[NativeName(NativeNameType.Type, "PFN_vkBindBufferMemory")]
		public unsafe void* VkBindBufferMemory;
		[NativeName(NativeNameType.Field, "vkBindImageMemory")]
		[NativeName(NativeNameType.Type, "PFN_vkBindImageMemory")]
		public unsafe void* VkBindImageMemory;
		[NativeName(NativeNameType.Field, "vkGetBufferMemoryRequirements")]
		[NativeName(NativeNameType.Type, "PFN_vkGetBufferMemoryRequirements")]
		public unsafe void* VkGetBufferMemoryRequirements;
		[NativeName(NativeNameType.Field, "vkGetImageMemoryRequirements")]
		[NativeName(NativeNameType.Type, "PFN_vkGetImageMemoryRequirements")]
		public unsafe void* VkGetImageMemoryRequirements;
		[NativeName(NativeNameType.Field, "vkCreateBuffer")]
		[NativeName(NativeNameType.Type, "PFN_vkCreateBuffer")]
		public unsafe void* VkCreateBuffer;
		[NativeName(NativeNameType.Field, "vkDestroyBuffer")]
		[NativeName(NativeNameType.Type, "PFN_vkDestroyBuffer")]
		public unsafe void* VkDestroyBuffer;
		[NativeName(NativeNameType.Field, "vkCreateImage")]
		[NativeName(NativeNameType.Type, "PFN_vkCreateImage")]
		public unsafe void* VkCreateImage;
		[NativeName(NativeNameType.Field, "vkDestroyImage")]
		[NativeName(NativeNameType.Type, "PFN_vkDestroyImage")]
		public unsafe void* VkDestroyImage;
		[NativeName(NativeNameType.Field, "vkCmdCopyBuffer")]
		[NativeName(NativeNameType.Type, "PFN_vkCmdCopyBuffer")]
		public unsafe void* VkCmdCopyBuffer;
		/// <summary>
		/// Fetch "vkGetBufferMemoryRequirements2" on Vulkan >= 1.1, fetch "vkGetBufferMemoryRequirements2KHR" when using VK_KHR_dedicated_allocation extension.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "vkGetBufferMemoryRequirements2KHR")]
		[NativeName(NativeNameType.Type, "PFN_vkGetBufferMemoryRequirements2KHR")]
		public unsafe void* VkGetBufferMemoryRequirements2KHR;
		/// <summary>
		/// Fetch "vkGetImageMemoryRequirements2" on Vulkan >= 1.1, fetch "vkGetImageMemoryRequirements2KHR" when using VK_KHR_dedicated_allocation extension.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "vkGetImageMemoryRequirements2KHR")]
		[NativeName(NativeNameType.Type, "PFN_vkGetImageMemoryRequirements2KHR")]
		public unsafe void* VkGetImageMemoryRequirements2KHR;
		/// <summary>
		/// Fetch "vkBindBufferMemory2" on Vulkan >= 1.1, fetch "vkBindBufferMemory2KHR" when using VK_KHR_bind_memory2 extension.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "vkBindBufferMemory2KHR")]
		[NativeName(NativeNameType.Type, "PFN_vkBindBufferMemory2KHR")]
		public unsafe void* VkBindBufferMemory2KHR;
		/// <summary>
		/// Fetch "vkBindImageMemory2" on Vulkan >= 1.1, fetch "vkBindImageMemory2KHR" when using VK_KHR_bind_memory2 extension.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "vkBindImageMemory2KHR")]
		[NativeName(NativeNameType.Type, "PFN_vkBindImageMemory2KHR")]
		public unsafe void* VkBindImageMemory2KHR;
		/// <summary>
		/// Fetch from "vkGetPhysicalDeviceMemoryProperties2" on Vulkan >= 1.1, but you can also fetch it from "vkGetPhysicalDeviceMemoryProperties2KHR" if you enabled extension VK_KHR_get_physical_device_properties2.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "vkGetPhysicalDeviceMemoryProperties2KHR")]
		[NativeName(NativeNameType.Type, "PFN_vkGetPhysicalDeviceMemoryProperties2KHR")]
		public unsafe void* VkGetPhysicalDeviceMemoryProperties2KHR;
		/// <summary>
		/// Fetch from "vkGetDeviceBufferMemoryRequirements" on Vulkan >= 1.3, but you can also fetch it from "vkGetDeviceBufferMemoryRequirementsKHR" if you enabled extension VK_KHR_maintenance4.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "vkGetDeviceBufferMemoryRequirements")]
		[NativeName(NativeNameType.Type, "PFN_vkGetDeviceBufferMemoryRequirementsKHR")]
		public unsafe void* VkGetDeviceBufferMemoryRequirements;
		/// <summary>
		/// Fetch from "vkGetDeviceImageMemoryRequirements" on Vulkan >= 1.3, but you can also fetch it from "vkGetDeviceImageMemoryRequirementsKHR" if you enabled extension VK_KHR_maintenance4.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "vkGetDeviceImageMemoryRequirements")]
		[NativeName(NativeNameType.Type, "PFN_vkGetDeviceImageMemoryRequirementsKHR")]
		public unsafe void* VkGetDeviceImageMemoryRequirements;

		public unsafe VmaVulkanFunctions(PfnGetInstanceProcAddr vkGetInstanceProcAddr = default, PfnGetDeviceProcAddr vkGetDeviceProcAddr = default, PFNVkGetPhysicalDeviceProperties vkGetPhysicalDeviceProperties = default, PFNVkGetPhysicalDeviceMemoryProperties vkGetPhysicalDeviceMemoryProperties = default, PFNVkAllocateMemory vkAllocateMemory = default, PFNVkFreeMemory vkFreeMemory = default, PFNVkMapMemory vkMapMemory = default, PFNVkUnmapMemory vkUnmapMemory = default, PFNVkFlushMappedMemoryRanges vkFlushMappedMemoryRanges = default, PFNVkInvalidateMappedMemoryRanges vkInvalidateMappedMemoryRanges = default, PFNVkBindBufferMemory vkBindBufferMemory = default, PFNVkBindImageMemory vkBindImageMemory = default, PFNVkGetBufferMemoryRequirements vkGetBufferMemoryRequirements = default, PFNVkGetImageMemoryRequirements vkGetImageMemoryRequirements = default, PFNVkCreateBuffer vkCreateBuffer = default, PFNVkDestroyBuffer vkDestroyBuffer = default, PFNVkCreateImage vkCreateImage = default, PFNVkDestroyImage vkDestroyImage = default, PFNVkCmdCopyBuffer vkCmdCopyBuffer = default, PFNVkGetBufferMemoryRequirements2KHR vkGetBufferMemoryRequirements2KHR = default, PFNVkGetImageMemoryRequirements2KHR vkGetImageMemoryRequirements2KHR = default, PFNVkBindBufferMemory2KHR vkBindBufferMemory2KHR = default, PFNVkBindImageMemory2KHR vkBindImageMemory2KHR = default, PFNVkGetPhysicalDeviceMemoryProperties2KHR vkGetPhysicalDeviceMemoryProperties2KHR = default, PFNVkGetDeviceBufferMemoryRequirementsKHR vkGetDeviceBufferMemoryRequirements = default, PFNVkGetDeviceImageMemoryRequirementsKHR vkGetDeviceImageMemoryRequirements = default)
		{
			VkGetInstanceProcAddr = (void*)Marshal.GetFunctionPointerForDelegate(vkGetInstanceProcAddr);
			VkGetDeviceProcAddr = (void*)Marshal.GetFunctionPointerForDelegate(vkGetDeviceProcAddr);
			VkGetPhysicalDeviceProperties = (void*)Marshal.GetFunctionPointerForDelegate(vkGetPhysicalDeviceProperties);
			VkGetPhysicalDeviceMemoryProperties = (void*)Marshal.GetFunctionPointerForDelegate(vkGetPhysicalDeviceMemoryProperties);
			VkAllocateMemory = (void*)Marshal.GetFunctionPointerForDelegate(vkAllocateMemory);
			VkFreeMemory = (void*)Marshal.GetFunctionPointerForDelegate(vkFreeMemory);
			VkMapMemory = (void*)Marshal.GetFunctionPointerForDelegate(vkMapMemory);
			VkUnmapMemory = (void*)Marshal.GetFunctionPointerForDelegate(vkUnmapMemory);
			VkFlushMappedMemoryRanges = (void*)Marshal.GetFunctionPointerForDelegate(vkFlushMappedMemoryRanges);
			VkInvalidateMappedMemoryRanges = (void*)Marshal.GetFunctionPointerForDelegate(vkInvalidateMappedMemoryRanges);
			VkBindBufferMemory = (void*)Marshal.GetFunctionPointerForDelegate(vkBindBufferMemory);
			VkBindImageMemory = (void*)Marshal.GetFunctionPointerForDelegate(vkBindImageMemory);
			VkGetBufferMemoryRequirements = (void*)Marshal.GetFunctionPointerForDelegate(vkGetBufferMemoryRequirements);
			VkGetImageMemoryRequirements = (void*)Marshal.GetFunctionPointerForDelegate(vkGetImageMemoryRequirements);
			VkCreateBuffer = (void*)Marshal.GetFunctionPointerForDelegate(vkCreateBuffer);
			VkDestroyBuffer = (void*)Marshal.GetFunctionPointerForDelegate(vkDestroyBuffer);
			VkCreateImage = (void*)Marshal.GetFunctionPointerForDelegate(vkCreateImage);
			VkDestroyImage = (void*)Marshal.GetFunctionPointerForDelegate(vkDestroyImage);
			VkCmdCopyBuffer = (void*)Marshal.GetFunctionPointerForDelegate(vkCmdCopyBuffer);
			VkGetBufferMemoryRequirements2KHR = (void*)Marshal.GetFunctionPointerForDelegate(vkGetBufferMemoryRequirements2KHR);
			VkGetImageMemoryRequirements2KHR = (void*)Marshal.GetFunctionPointerForDelegate(vkGetImageMemoryRequirements2KHR);
			VkBindBufferMemory2KHR = (void*)Marshal.GetFunctionPointerForDelegate(vkBindBufferMemory2KHR);
			VkBindImageMemory2KHR = (void*)Marshal.GetFunctionPointerForDelegate(vkBindImageMemory2KHR);
			VkGetPhysicalDeviceMemoryProperties2KHR = (void*)Marshal.GetFunctionPointerForDelegate(vkGetPhysicalDeviceMemoryProperties2KHR);
			VkGetDeviceBufferMemoryRequirements = (void*)Marshal.GetFunctionPointerForDelegate(vkGetDeviceBufferMemoryRequirements);
			VkGetDeviceImageMemoryRequirements = (void*)Marshal.GetFunctionPointerForDelegate(vkGetDeviceImageMemoryRequirements);
		}


	}

	/// <summary>
	/// <br/>
	/// These are slower to calculate. Use for debugging purposes.<br/>
	/// See function vmaCalculateStatistics().<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "VmaTotalStatistics")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct VmaTotalStatistics
	{
		[NativeName(NativeNameType.Field, "memoryType")]
		[NativeName(NativeNameType.Type, "VmaDetailedStatistics[32]")]
		public VmaDetailedStatistics MemoryType_0;
		public VmaDetailedStatistics MemoryType_1;
		public VmaDetailedStatistics MemoryType_2;
		public VmaDetailedStatistics MemoryType_3;
		public VmaDetailedStatistics MemoryType_4;
		public VmaDetailedStatistics MemoryType_5;
		public VmaDetailedStatistics MemoryType_6;
		public VmaDetailedStatistics MemoryType_7;
		public VmaDetailedStatistics MemoryType_8;
		public VmaDetailedStatistics MemoryType_9;
		public VmaDetailedStatistics MemoryType_10;
		public VmaDetailedStatistics MemoryType_11;
		public VmaDetailedStatistics MemoryType_12;
		public VmaDetailedStatistics MemoryType_13;
		public VmaDetailedStatistics MemoryType_14;
		public VmaDetailedStatistics MemoryType_15;
		public VmaDetailedStatistics MemoryType_16;
		public VmaDetailedStatistics MemoryType_17;
		public VmaDetailedStatistics MemoryType_18;
		public VmaDetailedStatistics MemoryType_19;
		public VmaDetailedStatistics MemoryType_20;
		public VmaDetailedStatistics MemoryType_21;
		public VmaDetailedStatistics MemoryType_22;
		public VmaDetailedStatistics MemoryType_23;
		public VmaDetailedStatistics MemoryType_24;
		public VmaDetailedStatistics MemoryType_25;
		public VmaDetailedStatistics MemoryType_26;
		public VmaDetailedStatistics MemoryType_27;
		public VmaDetailedStatistics MemoryType_28;
		public VmaDetailedStatistics MemoryType_29;
		public VmaDetailedStatistics MemoryType_30;
		public VmaDetailedStatistics MemoryType_31;
		[NativeName(NativeNameType.Field, "memoryHeap")]
		[NativeName(NativeNameType.Type, "VmaDetailedStatistics[16]")]
		public VmaDetailedStatistics MemoryHeap_0;
		public VmaDetailedStatistics MemoryHeap_1;
		public VmaDetailedStatistics MemoryHeap_2;
		public VmaDetailedStatistics MemoryHeap_3;
		public VmaDetailedStatistics MemoryHeap_4;
		public VmaDetailedStatistics MemoryHeap_5;
		public VmaDetailedStatistics MemoryHeap_6;
		public VmaDetailedStatistics MemoryHeap_7;
		public VmaDetailedStatistics MemoryHeap_8;
		public VmaDetailedStatistics MemoryHeap_9;
		public VmaDetailedStatistics MemoryHeap_10;
		public VmaDetailedStatistics MemoryHeap_11;
		public VmaDetailedStatistics MemoryHeap_12;
		public VmaDetailedStatistics MemoryHeap_13;
		public VmaDetailedStatistics MemoryHeap_14;
		public VmaDetailedStatistics MemoryHeap_15;
		[NativeName(NativeNameType.Field, "total")]
		[NativeName(NativeNameType.Type, "VmaDetailedStatistics")]
		public VmaDetailedStatistics Total;

		public unsafe VmaTotalStatistics(VmaDetailedStatistics* memoryType = default, VmaDetailedStatistics* memoryHeap = default, VmaDetailedStatistics total = default)
		{
			if (memoryType != default)
			{
				MemoryType_0 = memoryType[0];
				MemoryType_1 = memoryType[1];
				MemoryType_2 = memoryType[2];
				MemoryType_3 = memoryType[3];
				MemoryType_4 = memoryType[4];
				MemoryType_5 = memoryType[5];
				MemoryType_6 = memoryType[6];
				MemoryType_7 = memoryType[7];
				MemoryType_8 = memoryType[8];
				MemoryType_9 = memoryType[9];
				MemoryType_10 = memoryType[10];
				MemoryType_11 = memoryType[11];
				MemoryType_12 = memoryType[12];
				MemoryType_13 = memoryType[13];
				MemoryType_14 = memoryType[14];
				MemoryType_15 = memoryType[15];
				MemoryType_16 = memoryType[16];
				MemoryType_17 = memoryType[17];
				MemoryType_18 = memoryType[18];
				MemoryType_19 = memoryType[19];
				MemoryType_20 = memoryType[20];
				MemoryType_21 = memoryType[21];
				MemoryType_22 = memoryType[22];
				MemoryType_23 = memoryType[23];
				MemoryType_24 = memoryType[24];
				MemoryType_25 = memoryType[25];
				MemoryType_26 = memoryType[26];
				MemoryType_27 = memoryType[27];
				MemoryType_28 = memoryType[28];
				MemoryType_29 = memoryType[29];
				MemoryType_30 = memoryType[30];
				MemoryType_31 = memoryType[31];
			}
			if (memoryHeap != default)
			{
				MemoryHeap_0 = memoryHeap[0];
				MemoryHeap_1 = memoryHeap[1];
				MemoryHeap_2 = memoryHeap[2];
				MemoryHeap_3 = memoryHeap[3];
				MemoryHeap_4 = memoryHeap[4];
				MemoryHeap_5 = memoryHeap[5];
				MemoryHeap_6 = memoryHeap[6];
				MemoryHeap_7 = memoryHeap[7];
				MemoryHeap_8 = memoryHeap[8];
				MemoryHeap_9 = memoryHeap[9];
				MemoryHeap_10 = memoryHeap[10];
				MemoryHeap_11 = memoryHeap[11];
				MemoryHeap_12 = memoryHeap[12];
				MemoryHeap_13 = memoryHeap[13];
				MemoryHeap_14 = memoryHeap[14];
				MemoryHeap_15 = memoryHeap[15];
			}
			Total = total;
		}

		public unsafe VmaTotalStatistics(Span<VmaDetailedStatistics> memoryType = default, Span<VmaDetailedStatistics> memoryHeap = default, VmaDetailedStatistics total = default)
		{
			if (memoryType != default)
			{
				MemoryType_0 = memoryType[0];
				MemoryType_1 = memoryType[1];
				MemoryType_2 = memoryType[2];
				MemoryType_3 = memoryType[3];
				MemoryType_4 = memoryType[4];
				MemoryType_5 = memoryType[5];
				MemoryType_6 = memoryType[6];
				MemoryType_7 = memoryType[7];
				MemoryType_8 = memoryType[8];
				MemoryType_9 = memoryType[9];
				MemoryType_10 = memoryType[10];
				MemoryType_11 = memoryType[11];
				MemoryType_12 = memoryType[12];
				MemoryType_13 = memoryType[13];
				MemoryType_14 = memoryType[14];
				MemoryType_15 = memoryType[15];
				MemoryType_16 = memoryType[16];
				MemoryType_17 = memoryType[17];
				MemoryType_18 = memoryType[18];
				MemoryType_19 = memoryType[19];
				MemoryType_20 = memoryType[20];
				MemoryType_21 = memoryType[21];
				MemoryType_22 = memoryType[22];
				MemoryType_23 = memoryType[23];
				MemoryType_24 = memoryType[24];
				MemoryType_25 = memoryType[25];
				MemoryType_26 = memoryType[26];
				MemoryType_27 = memoryType[27];
				MemoryType_28 = memoryType[28];
				MemoryType_29 = memoryType[29];
				MemoryType_30 = memoryType[30];
				MemoryType_31 = memoryType[31];
			}
			if (memoryHeap != default)
			{
				MemoryHeap_0 = memoryHeap[0];
				MemoryHeap_1 = memoryHeap[1];
				MemoryHeap_2 = memoryHeap[2];
				MemoryHeap_3 = memoryHeap[3];
				MemoryHeap_4 = memoryHeap[4];
				MemoryHeap_5 = memoryHeap[5];
				MemoryHeap_6 = memoryHeap[6];
				MemoryHeap_7 = memoryHeap[7];
				MemoryHeap_8 = memoryHeap[8];
				MemoryHeap_9 = memoryHeap[9];
				MemoryHeap_10 = memoryHeap[10];
				MemoryHeap_11 = memoryHeap[11];
				MemoryHeap_12 = memoryHeap[12];
				MemoryHeap_13 = memoryHeap[13];
				MemoryHeap_14 = memoryHeap[14];
				MemoryHeap_15 = memoryHeap[15];
			}
			Total = total;
		}


		public unsafe Span<VmaDetailedStatistics> MemoryType
		
		{
			get
			{
				fixed (VmaDetailedStatistics* p = &this.MemoryType_0)
				{
					return new Span<VmaDetailedStatistics>(p, 32);
				}
			}
		}
		public unsafe Span<VmaDetailedStatistics> MemoryHeap
		
		{
			get
			{
				fixed (VmaDetailedStatistics* p = &this.MemoryHeap_0)
				{
					return new Span<VmaDetailedStatistics>(p, 16);
				}
			}
		}
	}

	/// <summary>
	/// <br/>
	/// These are fast to calculate.<br/>
	/// See function vmaGetHeapBudgets().<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "VmaBudget")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct VmaBudget
	{
		/// <summary>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "statistics")]
		[NativeName(NativeNameType.Type, "VmaStatistics")]
		public VmaStatistics Statistics;

		/// <summary>
		/// <br/>
		/// Fetched from system using VK_EXT_memory_budget extension if enabled.<br/>
		/// It might be different than `statistics.blockBytes` (usually higher) due to additional implicit objects<br/>
		/// also occupying the memory, like swapchain, pipelines, descriptor heaps, command buffers, or<br/>
		/// `VkDeviceMemory` blocks allocated outside of this library, if any.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "usage")]
		[NativeName(NativeNameType.Type, "VkDeviceSize")]
		public ulong Usage;

		/// <summary>
		/// <br/>
		/// Fetched from system using VK_EXT_memory_budget extension if enabled.<br/>
		/// It might be different (most probably smaller) than `VkMemoryHeap::size[heapIndex]` due to factors<br/>
		/// external to the program, decided by the operating system.<br/>
		/// Difference `budget - usage` is the amount of additional memory that can probably<br/>
		/// be allocated without problems. Exceeding the budget may result in various problems.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "budget")]
		[NativeName(NativeNameType.Type, "VkDeviceSize")]
		public ulong Budget;


		public unsafe VmaBudget(VmaStatistics statistics = default, ulong usage = default, ulong budget = default)
		{
			Statistics = statistics;
			Usage = usage;
			Budget = budget;
		}


	}

	/// <summary>
	/// Parameters of #VmaAllocation objects, that can be retrieved using function vmaGetAllocationInfo().<br/>
	/// There is also an extended version of this structure that carries additional parameters: #VmaAllocationInfo2.<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "VmaAllocationInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct VmaAllocationInfo
	{
		/// <summary>
		/// <br/>
		/// It never changes.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "memoryType")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint MemoryType;

		/// <summary>
		/// <br/>
		/// Same memory object can be shared by multiple allocations.<br/>
		/// It can change after the allocation is moved during <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "deviceMemory")]
		[NativeName(NativeNameType.Type, "VkDeviceMemory")]
		public VkDeviceMemory DeviceMemory;

		/// <summary>
		/// <br/>
		/// You usually don't need to use this offset. If you create a buffer or an image together with the allocation using e.g. function<br/>
		/// vmaCreateBuffer(), vmaCreateImage(), functions that operate on these resources refer to the beginning of the buffer or image,<br/>
		/// not entire device memory block. Functions like vmaMapMemory(), vmaBindBufferMemory() also refer to the beginning of the allocation<br/>
		/// and apply this offset automatically.<br/>
		/// It can change after the allocation is moved during <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "offset")]
		[NativeName(NativeNameType.Type, "VkDeviceSize")]
		public ulong Offset;

		/// <summary>
		/// <br/>
		/// It never changes.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "size")]
		[NativeName(NativeNameType.Type, "VkDeviceSize")]
		public ulong Size;

		/// <summary>
		/// <br/>
		/// If the allocation hasn't been mapped using vmaMapMemory() and hasn't been<br/>
		/// created with #VMA_ALLOCATION_CREATE_MAPPED_BIT flag, this value is null.<br/>
		/// It can change after call to vmaMapMemory(), vmaUnmapMemory().<br/>
		/// It can also change after the allocation is moved during <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "pMappedData")]
		[NativeName(NativeNameType.Type, "void*")]
		public unsafe void* PMappedData;

		/// <summary>
		/// <br/>
		/// It can change after call to vmaSetAllocationUserData() for this allocation.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "pUserData")]
		[NativeName(NativeNameType.Type, "void*")]
		public unsafe void* PUserData;

		/// <summary>
		/// <br/>
		/// It can change after call to vmaSetAllocationName() for this allocation.<br/>
		/// Another way to set custom name is to pass it in VmaAllocationCreateInfo::pUserData with<br/>
		/// additional flag #VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT set [DEPRECATED].<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "pName")]
		[NativeName(NativeNameType.Type, "const char*")]
		public unsafe byte* PName;


		public unsafe VmaAllocationInfo(uint memoryType = default, VkDeviceMemory deviceMemory = default, ulong offset = default, ulong size = default, void* pMappedData = default, void* pUserData = default, byte* pName = default)
		{
			MemoryType = memoryType;
			DeviceMemory = deviceMemory;
			Offset = offset;
			Size = size;
			PMappedData = pMappedData;
			PUserData = pUserData;
			PName = pName;
		}


	}

	/// <summary>
	/// Extended parameters of a #VmaAllocation object that can be retrieved using function vmaGetAllocationInfo2().<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "VmaAllocationInfo2")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct VmaAllocationInfo2
	{
		/// <summary>
		/// <br/>
		/// If you need only these, you can use function vmaGetAllocationInfo() and structure #VmaAllocationInfo instead.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "allocationInfo")]
		[NativeName(NativeNameType.Type, "VmaAllocationInfo")]
		public VmaAllocationInfo AllocationInfo;

		/// <summary>
		/// <br/>
		/// In case of an allocation with dedicated memory, it will be equal to `allocationInfo.size`.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "blockSize")]
		[NativeName(NativeNameType.Type, "VkDeviceSize")]
		public ulong BlockSize;

		/// <summary>
		/// <br/>
		/// When `VK_TRUE`, it also means `VkMemoryDedicatedAllocateInfo` was used when creating the allocation<br/>
		/// (if VK_KHR_dedicated_allocation extension or Vulkan version >= 1.1 is enabled).<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "dedicatedMemory")]
		[NativeName(NativeNameType.Type, "VkBool32")]
		public uint DedicatedMemory;


		public unsafe VmaAllocationInfo2(VmaAllocationInfo allocationInfo = default, ulong blockSize = default, uint dedicatedMemory = default)
		{
			AllocationInfo = allocationInfo;
			BlockSize = blockSize;
			DedicatedMemory = dedicatedMemory;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "VmaPoolListItemTraits")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct VmaPoolListItemTraits
	{


	}

	/// <summary>
	/// <br/>
	/// To be used with function vmaBeginDefragmentation().<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "VmaDefragmentationInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct VmaDefragmentationInfo
	{
		/// <summary>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "flags")]
		[NativeName(NativeNameType.Type, "VmaDefragmentationFlags")]
		public VmaDefragmentationFlags Flags;

		/// <summary>
		/// <br/>
		/// If null then default pools will undergo defragmentation process.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "pool")]
		[NativeName(NativeNameType.Type, "VmaPool")]
		public VmaPool Pool;

		/// <summary>
		/// <br/>
		/// `0` means no limit.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "maxBytesPerPass")]
		[NativeName(NativeNameType.Type, "VkDeviceSize")]
		public ulong MaxBytesPerPass;

		/// <summary>
		/// <br/>
		/// `0` means no limit.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "maxAllocationsPerPass")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint MaxAllocationsPerPass;

		/// <summary>
		/// <br/>
		/// Have to return true for breaking current defragmentation pass.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "pfnBreakCallback")]
		[NativeName(NativeNameType.Type, "unsigned int (*)()*")]
		public unsafe void* PfnBreakCallback;

		/// <summary>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "pBreakCallbackUserData")]
		[NativeName(NativeNameType.Type, "void*")]
		public unsafe void* PBreakCallbackUserData;


		public unsafe VmaDefragmentationInfo(VmaDefragmentationFlags flags = default, VmaPool pool = default, ulong maxBytesPerPass = default, uint maxAllocationsPerPass = default, delegate*<uint> pfnBreakCallback = default, void* pBreakCallbackUserData = default)
		{
			Flags = flags;
			Pool = pool;
			MaxBytesPerPass = maxBytesPerPass;
			MaxAllocationsPerPass = maxAllocationsPerPass;
			PfnBreakCallback = (void*)pfnBreakCallback;
			PBreakCallbackUserData = pBreakCallbackUserData;
		}


	}

	/// <summary>
	/// Statistics returned for defragmentation process in function vmaEndDefragmentation().<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "VmaDefragmentationStats")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct VmaDefragmentationStats
	{
		/// <summary>
		/// Total number of bytes that have been copied while moving allocations to different places.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "bytesMoved")]
		[NativeName(NativeNameType.Type, "VkDeviceSize")]
		public ulong BytesMoved;

		/// <summary>
		/// Total number of bytes that have been released to the system by freeing empty `VkDeviceMemory` objects.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "bytesFreed")]
		[NativeName(NativeNameType.Type, "VkDeviceSize")]
		public ulong BytesFreed;

		/// <summary>
		/// Number of allocations that have been moved to different places.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "allocationsMoved")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint AllocationsMoved;

		/// <summary>
		/// Number of empty `VkDeviceMemory` objects that have been released to the system.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "deviceMemoryBlocksFreed")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint DeviceMemoryBlocksFreed;


		public unsafe VmaDefragmentationStats(ulong bytesMoved = default, ulong bytesFreed = default, uint allocationsMoved = default, uint deviceMemoryBlocksFreed = default)
		{
			BytesMoved = bytesMoved;
			BytesFreed = bytesFreed;
			AllocationsMoved = allocationsMoved;
			DeviceMemoryBlocksFreed = deviceMemoryBlocksFreed;
		}


	}

	/// <summary>
	/// <br/>
	/// To be used with function vmaBeginDefragmentationPass().<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "VmaDefragmentationPassMoveInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct VmaDefragmentationPassMoveInfo
	{
		/// <summary>
		/// Number of elements in the `pMoves` array.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "moveCount")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint MoveCount;

		/// <summary>
		/// <br/>
		/// Pointer to an array of `moveCount` elements, owned by VMA, created in vmaBeginDefragmentationPass(), destroyed in vmaEndDefragmentationPass().<br/>
		/// For each element, you should:<br/>
		/// 1. Create a new buffer/image in the place pointed by VmaDefragmentationMove::dstMemory + VmaDefragmentationMove::dstOffset.<br/>
		/// 2. Copy data from the VmaDefragmentationMove::srcAllocation e.g. using `vkCmdCopyBuffer`, `vkCmdCopyImage`.<br/>
		/// 3. Make sure these commands finished executing on the GPU.<br/>
		/// 4. Destroy the old buffer/image.<br/>
		/// Only then you can finish defragmentation pass by calling vmaEndDefragmentationPass().<br/>
		/// After this call, the allocation will point to the new place in memory.<br/>
		/// Alternatively, if you cannot move specific allocation, you can set VmaDefragmentationMove::operation to #VMA_DEFRAGMENTATION_MOVE_OPERATION_IGNORE.<br/>
		/// Alternatively, if you decide you want to completely remove the allocation:<br/>
		/// 1. Destroy its buffer/image.<br/>
		/// 2. Set VmaDefragmentationMove::operation to #VMA_DEFRAGMENTATION_MOVE_OPERATION_DESTROY.<br/>
		/// Then, after vmaEndDefragmentationPass() the allocation will be freed.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "pMoves")]
		[NativeName(NativeNameType.Type, "VmaDefragmentationMove*")]
		public unsafe VmaDefragmentationMove* PMoves;


		public unsafe VmaDefragmentationPassMoveInfo(uint moveCount = default, VmaDefragmentationMove* pMoves = default)
		{
			MoveCount = moveCount;
			PMoves = pMoves;
		}


	}

	/// <summary>
	/// Single move of an allocation to be done for defragmentation.<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "VmaDefragmentationMove")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct VmaDefragmentationMove
	{
		/// <summary>
		/// Operation to be performed on the allocation by vmaEndDefragmentationPass(). Default value is #VMA_DEFRAGMENTATION_MOVE_OPERATION_COPY. You can modify it.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "operation")]
		[NativeName(NativeNameType.Type, "VmaDefragmentationMoveOperation")]
		public VmaDefragmentationMoveOperation Operation;

		/// <summary>
		/// Allocation that should be moved.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "srcAllocation")]
		[NativeName(NativeNameType.Type, "VmaAllocation")]
		public VmaAllocation SrcAllocation;

		/// <summary>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "dstTmpAllocation")]
		[NativeName(NativeNameType.Type, "VmaAllocation")]
		public VmaAllocation DstTmpAllocation;


		public unsafe VmaDefragmentationMove(VmaDefragmentationMoveOperation operation = default, VmaAllocation srcAllocation = default, VmaAllocation dstTmpAllocation = default)
		{
			Operation = operation;
			SrcAllocation = srcAllocation;
			DstTmpAllocation = dstTmpAllocation;
		}


	}

	/// <summary>
	/// Parameters of created #VmaVirtualBlock object to be passed to vmaCreateVirtualBlock().<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "VmaVirtualBlockCreateInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct VmaVirtualBlockCreateInfo
	{
		/// <summary>
		/// <br/>
		/// Sizes can be expressed in bytes or any units you want as long as you are consistent in using them.<br/>
		/// For example, if you allocate from some array of structures, 1 can mean single instance of entire structure.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "size")]
		[NativeName(NativeNameType.Type, "VkDeviceSize")]
		public ulong Size;

		/// <summary>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "flags")]
		[NativeName(NativeNameType.Type, "VmaVirtualBlockCreateFlags")]
		public VmaVirtualBlockCreateFlags Flags;

		/// <summary>
		/// <br/>
		/// Optional, can be null. When specified, they will be used for all CPU-side memory allocations.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "pAllocationCallbacks")]
		[NativeName(NativeNameType.Type, "const VkAllocationCallbacks*")]
		public unsafe VkAllocationCallbacks* PAllocationCallbacks;


		public unsafe VmaVirtualBlockCreateInfo(ulong size = default, VmaVirtualBlockCreateFlags flags = default, VkAllocationCallbacks* pAllocationCallbacks = default)
		{
			Size = size;
			Flags = flags;
			PAllocationCallbacks = pAllocationCallbacks;
		}


	}

	/// <summary>
	/// Parameters of created virtual allocation to be passed to vmaVirtualAllocate().<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "VmaVirtualAllocationCreateInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct VmaVirtualAllocationCreateInfo
	{
		/// <summary>
		/// <br/>
		/// Cannot be zero.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "size")]
		[NativeName(NativeNameType.Type, "VkDeviceSize")]
		public ulong Size;

		/// <summary>
		/// <br/>
		/// Must be power of two. Special value 0 has the same meaning as 1 - means no special alignment is required, so allocation can start at any offset.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "alignment")]
		[NativeName(NativeNameType.Type, "VkDeviceSize")]
		public ulong Alignment;

		/// <summary>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "flags")]
		[NativeName(NativeNameType.Type, "VmaVirtualAllocationCreateFlags")]
		public VmaVirtualAllocationCreateFlags Flags;

		/// <summary>
		/// <br/>
		/// It can be any value and can be used for user-defined purposes. It can be fetched or changed later.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "pUserData")]
		[NativeName(NativeNameType.Type, "void*")]
		public unsafe void* PUserData;


		public unsafe VmaVirtualAllocationCreateInfo(ulong size = default, ulong alignment = default, VmaVirtualAllocationCreateFlags flags = default, void* pUserData = default)
		{
			Size = size;
			Alignment = alignment;
			Flags = flags;
			PUserData = pUserData;
		}


	}

	/// <summary>
	/// Information about existing #VmaAllocator object.<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "VmaAllocatorInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct VmaAllocatorInfo
	{
		/// <summary>
		/// <br/>
		/// This is the same value as has been passed through VmaAllocatorCreateInfo::instance.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "instance")]
		[NativeName(NativeNameType.Type, "VkInstance")]
		public VkInstance Instance;

		/// <summary>
		/// <br/>
		/// This is the same value as has been passed through VmaAllocatorCreateInfo::physicalDevice.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "physicalDevice")]
		[NativeName(NativeNameType.Type, "VkPhysicalDevice")]
		public VkPhysicalDevice PhysicalDevice;

		/// <summary>
		/// <br/>
		/// This is the same value as has been passed through VmaAllocatorCreateInfo::device.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "device")]
		[NativeName(NativeNameType.Type, "VkDevice")]
		public VkDevice Device;


		public unsafe VmaAllocatorInfo(VkInstance instance = default, VkPhysicalDevice physicalDevice = default, VkDevice device = default)
		{
			Instance = instance;
			PhysicalDevice = physicalDevice;
			Device = device;
		}


	}

	/// <summary>
	/// Helper RAII class to lock a mutex in constructor and unlock it in destructor (at the end of scope).<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "VmaMutexLock")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct VmaMutexLock
	{
		[NativeName(NativeNameType.Field, "m_pMutex")]
		[NativeName(NativeNameType.Type, "VmaMutex*")]
		public unsafe VmaMutex* MPMutex;

		public unsafe VmaMutexLock(VmaMutex* mPmutex = default)
		{
			MPMutex = mPmutex;
		}


	}

	/// <summary>
	/// Helper RAII class to lock a RW mutex in constructor and unlock it in destructor (at the end of scope), for reading.<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "VmaMutexLockRead")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct VmaMutexLockRead
	{
		[NativeName(NativeNameType.Field, "m_pMutex")]
		[NativeName(NativeNameType.Type, "VmaRWMutex*")]
		public unsafe VmaRWMutex* MPMutex;

		public unsafe VmaMutexLockRead(VmaRWMutex* mPmutex = default)
		{
			MPMutex = mPmutex;
		}


	}

	/// <summary>
	/// Helper RAII class to lock a RW mutex in constructor and unlock it in destructor (at the end of scope), for writing.<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "VmaMutexLockWrite")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct VmaMutexLockWrite
	{
		[NativeName(NativeNameType.Field, "m_pMutex")]
		[NativeName(NativeNameType.Type, "VmaRWMutex*")]
		public unsafe VmaRWMutex* MPMutex;

		public unsafe VmaMutexLockWrite(VmaRWMutex* mPmutex = default)
		{
			MPMutex = mPmutex;
		}


	}

	/// <summary>
	/// Comparator for offsets.<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "VmaSuballocationOffsetLess")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct VmaSuballocationOffsetLess
	{


	}

	[NativeName(NativeNameType.StructOrClass, "VmaSuballocationOffsetGreater")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct VmaSuballocationOffsetGreater
	{


	}

	[NativeName(NativeNameType.StructOrClass, "VmaSuballocationItemSizeLess")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct VmaSuballocationItemSizeLess
	{


	}

}
