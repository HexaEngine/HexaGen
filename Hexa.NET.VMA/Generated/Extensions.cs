// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.VMA
{
	public static unsafe class Extensions
	{
		/// <summary>		/// Destroys allocator object.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaDestroyAllocator")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroyAllocator(this VmaAllocator allocator)
		{
			VMA.VmaDestroyAllocatorNative(allocator);
		}

		/// <summary>		/// <br/>		/// It might be useful if you want to keep just the #VmaAllocator handle and fetch other required handles to<br/>		/// `VkPhysicalDevice`, `VkDevice` etc. every time using this function.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaGetAllocatorInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetAllocatorInfo(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pAllocatorInfo")] [NativeName(NativeNameType.Type, "VmaAllocatorInfo*")] VmaAllocatorInfo* pAllocatorInfo)
		{
			VMA.VmaGetAllocatorInfoNative(allocator, pAllocatorInfo);
		}

		/// <summary>		/// <br/>		/// It might be useful if you want to keep just the #VmaAllocator handle and fetch other required handles to<br/>		/// `VkPhysicalDevice`, `VkDevice` etc. every time using this function.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaGetAllocatorInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetAllocatorInfo(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pAllocatorInfo")] [NativeName(NativeNameType.Type, "VmaAllocatorInfo*")] ref VmaAllocatorInfo pAllocatorInfo)
		{
			fixed (VmaAllocatorInfo* ppAllocatorInfo = &pAllocatorInfo)
			{
				VMA.VmaGetAllocatorInfoNative(allocator, (VmaAllocatorInfo*)ppAllocatorInfo);
			}
		}

		/// <summary>		/// PhysicalDeviceProperties are fetched from physicalDevice by the allocator.<br/>		/// You can access it here, without fetching it again on your own.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaGetPhysicalDeviceProperties")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetPhysicalDeviceProperties(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "ppPhysicalDeviceProperties")] [NativeName(NativeNameType.Type, "const VkPhysicalDeviceProperties**")] VkPhysicalDeviceProperties** ppPhysicalDeviceProperties)
		{
			VMA.VmaGetPhysicalDevicePropertiesNative(allocator, ppPhysicalDeviceProperties);
		}

		/// <summary>		/// PhysicalDeviceProperties are fetched from physicalDevice by the allocator.<br/>		/// You can access it here, without fetching it again on your own.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaGetPhysicalDeviceProperties")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetPhysicalDeviceProperties(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "ppPhysicalDeviceProperties")] [NativeName(NativeNameType.Type, "const VkPhysicalDeviceProperties**")] ref VkPhysicalDeviceProperties* ppPhysicalDeviceProperties)
		{
			fixed (VkPhysicalDeviceProperties** pppPhysicalDeviceProperties = &ppPhysicalDeviceProperties)
			{
				VMA.VmaGetPhysicalDevicePropertiesNative(allocator, (VkPhysicalDeviceProperties**)pppPhysicalDeviceProperties);
			}
		}

		/// <summary>		/// PhysicalDeviceMemoryProperties are fetched from physicalDevice by the allocator.<br/>		/// You can access it here, without fetching it again on your own.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaGetMemoryProperties")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetMemoryProperties(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "ppPhysicalDeviceMemoryProperties")] [NativeName(NativeNameType.Type, "const VkPhysicalDeviceMemoryProperties**")] VkPhysicalDeviceMemoryProperties** ppPhysicalDeviceMemoryProperties)
		{
			VMA.VmaGetMemoryPropertiesNative(allocator, ppPhysicalDeviceMemoryProperties);
		}

		/// <summary>		/// PhysicalDeviceMemoryProperties are fetched from physicalDevice by the allocator.<br/>		/// You can access it here, without fetching it again on your own.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaGetMemoryProperties")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetMemoryProperties(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "ppPhysicalDeviceMemoryProperties")] [NativeName(NativeNameType.Type, "const VkPhysicalDeviceMemoryProperties**")] ref VkPhysicalDeviceMemoryProperties* ppPhysicalDeviceMemoryProperties)
		{
			fixed (VkPhysicalDeviceMemoryProperties** pppPhysicalDeviceMemoryProperties = &ppPhysicalDeviceMemoryProperties)
			{
				VMA.VmaGetMemoryPropertiesNative(allocator, (VkPhysicalDeviceMemoryProperties**)pppPhysicalDeviceMemoryProperties);
			}
		}

		/// <summary>		/// This is just a convenience function. Same information can be obtained using<br/>		/// vmaGetMemoryProperties().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaGetMemoryTypeProperties")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetMemoryTypeProperties(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "memoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t")] uint memoryTypeIndex, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "VkMemoryPropertyFlags*")] VkMemoryPropertyFlags* pFlags)
		{
			VMA.VmaGetMemoryTypePropertiesNative(allocator, memoryTypeIndex, pFlags);
		}

		/// <summary>		/// This is just a convenience function. Same information can be obtained using<br/>		/// vmaGetMemoryProperties().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaGetMemoryTypeProperties")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetMemoryTypeProperties(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "memoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t")] uint memoryTypeIndex, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "VkMemoryPropertyFlags*")] ref VkMemoryPropertyFlags pFlags)
		{
			fixed (VkMemoryPropertyFlags* ppFlags = &pFlags)
			{
				VMA.VmaGetMemoryTypePropertiesNative(allocator, memoryTypeIndex, (VkMemoryPropertyFlags*)ppFlags);
			}
		}

		/// <summary>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaSetCurrentFrameIndex")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetCurrentFrameIndex(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "frameIndex")] [NativeName(NativeNameType.Type, "uint32_t")] uint frameIndex)
		{
			VMA.VmaSetCurrentFrameIndexNative(allocator, frameIndex);
		}

		/// <summary>		/// <br/>		/// This function is called "calculate" not "get" because it has to traverse all<br/>		/// internal data structures, so it may be quite slow. Use it for debugging purposes.<br/>		/// For faster but more brief statistics suitable to be called every frame or every allocation,<br/>		/// use vmaGetHeapBudgets().<br/>		/// Note that when using allocator from multiple threads, returned information may immediately<br/>		/// become outdated.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCalculateStatistics")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalculateStatistics(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pStats")] [NativeName(NativeNameType.Type, "VmaTotalStatistics*")] VmaTotalStatistics* pStats)
		{
			VMA.VmaCalculateStatisticsNative(allocator, pStats);
		}

		/// <summary>		/// <br/>		/// This function is called "calculate" not "get" because it has to traverse all<br/>		/// internal data structures, so it may be quite slow. Use it for debugging purposes.<br/>		/// For faster but more brief statistics suitable to be called every frame or every allocation,<br/>		/// use vmaGetHeapBudgets().<br/>		/// Note that when using allocator from multiple threads, returned information may immediately<br/>		/// become outdated.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCalculateStatistics")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalculateStatistics(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pStats")] [NativeName(NativeNameType.Type, "VmaTotalStatistics*")] ref VmaTotalStatistics pStats)
		{
			fixed (VmaTotalStatistics* ppStats = &pStats)
			{
				VMA.VmaCalculateStatisticsNative(allocator, (VmaTotalStatistics*)ppStats);
			}
		}

		/// <summary>		/// <br/>		/// This function is called "get" not "calculate" because it is very fast, suitable to be called<br/>		/// every frame or every allocation. For more detailed statistics use vmaCalculateStatistics().<br/>		/// Note that when using allocator from multiple threads, returned information may immediately<br/>		/// become outdated.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaGetHeapBudgets")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetHeapBudgets(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBudgets")] [NativeName(NativeNameType.Type, "VmaBudget*")] VmaBudget* pBudgets)
		{
			VMA.VmaGetHeapBudgetsNative(allocator, pBudgets);
		}

		/// <summary>		/// <br/>		/// This function is called "get" not "calculate" because it is very fast, suitable to be called<br/>		/// every frame or every allocation. For more detailed statistics use vmaCalculateStatistics().<br/>		/// Note that when using allocator from multiple threads, returned information may immediately<br/>		/// become outdated.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaGetHeapBudgets")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetHeapBudgets(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBudgets")] [NativeName(NativeNameType.Type, "VmaBudget*")] ref VmaBudget pBudgets)
		{
			fixed (VmaBudget* ppBudgets = &pBudgets)
			{
				VMA.VmaGetHeapBudgetsNative(allocator, (VmaBudget*)ppBudgets);
			}
		}

		/// <summary>		/// This algorithm tries to find a memory type that:<br/>		/// - Is allowed by memoryTypeBits.<br/>		/// - Contains all the flags from pAllocationCreateInfo->requiredFlags.<br/>		/// - Matches intended usage.<br/>		/// - Has as many flags from pAllocationCreateInfo->preferredFlags as possible.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndex")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int FindMemoryTypeIndex(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "memoryTypeBits")] [NativeName(NativeNameType.Type, "uint32_t")] uint memoryTypeBits, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] uint* pMemoryTypeIndex)
		{
			int ret = VMA.VmaFindMemoryTypeIndexNative(allocator, memoryTypeBits, pAllocationCreateInfo, pMemoryTypeIndex);
			return ret;
		}

		/// <summary>		/// This algorithm tries to find a memory type that:<br/>		/// - Is allowed by memoryTypeBits.<br/>		/// - Contains all the flags from pAllocationCreateInfo->requiredFlags.<br/>		/// - Matches intended usage.<br/>		/// - Has as many flags from pAllocationCreateInfo->preferredFlags as possible.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndex")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int FindMemoryTypeIndex(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "memoryTypeBits")] [NativeName(NativeNameType.Type, "uint32_t")] uint memoryTypeBits, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] uint* pMemoryTypeIndex)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				int ret = VMA.VmaFindMemoryTypeIndexNative(allocator, memoryTypeBits, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, pMemoryTypeIndex);
				return ret;
			}
		}

		/// <summary>		/// This algorithm tries to find a memory type that:<br/>		/// - Is allowed by memoryTypeBits.<br/>		/// - Contains all the flags from pAllocationCreateInfo->requiredFlags.<br/>		/// - Matches intended usage.<br/>		/// - Has as many flags from pAllocationCreateInfo->preferredFlags as possible.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndex")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int FindMemoryTypeIndex(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "memoryTypeBits")] [NativeName(NativeNameType.Type, "uint32_t")] uint memoryTypeBits, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] ref uint pMemoryTypeIndex)
		{
			fixed (uint* ppMemoryTypeIndex = &pMemoryTypeIndex)
			{
				int ret = VMA.VmaFindMemoryTypeIndexNative(allocator, memoryTypeBits, pAllocationCreateInfo, (uint*)ppMemoryTypeIndex);
				return ret;
			}
		}

		/// <summary>		/// This algorithm tries to find a memory type that:<br/>		/// - Is allowed by memoryTypeBits.<br/>		/// - Contains all the flags from pAllocationCreateInfo->requiredFlags.<br/>		/// - Matches intended usage.<br/>		/// - Has as many flags from pAllocationCreateInfo->preferredFlags as possible.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndex")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int FindMemoryTypeIndex(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "memoryTypeBits")] [NativeName(NativeNameType.Type, "uint32_t")] uint memoryTypeBits, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] ref uint pMemoryTypeIndex)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (uint* ppMemoryTypeIndex = &pMemoryTypeIndex)
				{
					int ret = VMA.VmaFindMemoryTypeIndexNative(allocator, memoryTypeBits, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, (uint*)ppMemoryTypeIndex);
					return ret;
				}
			}
		}

		/// <summary>		/// It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.<br/>		/// It internally creates a temporary, dummy buffer that never has memory bound.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndexForBufferInfo")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int FindMemoryTypeIndexForBufferInfo(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] uint* pMemoryTypeIndex)
		{
			int ret = VMA.VmaFindMemoryTypeIndexForBufferInfoNative(allocator, pBufferCreateInfo, pAllocationCreateInfo, pMemoryTypeIndex);
			return ret;
		}

		/// <summary>		/// It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.<br/>		/// It internally creates a temporary, dummy buffer that never has memory bound.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndexForBufferInfo")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int FindMemoryTypeIndexForBufferInfo(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] uint* pMemoryTypeIndex)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				int ret = VMA.VmaFindMemoryTypeIndexForBufferInfoNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, pAllocationCreateInfo, pMemoryTypeIndex);
				return ret;
			}
		}

		/// <summary>		/// It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.<br/>		/// It internally creates a temporary, dummy buffer that never has memory bound.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndexForBufferInfo")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int FindMemoryTypeIndexForBufferInfo(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] uint* pMemoryTypeIndex)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				int ret = VMA.VmaFindMemoryTypeIndexForBufferInfoNative(allocator, pBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, pMemoryTypeIndex);
				return ret;
			}
		}

		/// <summary>		/// It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.<br/>		/// It internally creates a temporary, dummy buffer that never has memory bound.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndexForBufferInfo")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int FindMemoryTypeIndexForBufferInfo(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] uint* pMemoryTypeIndex)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					int ret = VMA.VmaFindMemoryTypeIndexForBufferInfoNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, pMemoryTypeIndex);
					return ret;
				}
			}
		}

		/// <summary>		/// It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.<br/>		/// It internally creates a temporary, dummy buffer that never has memory bound.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndexForBufferInfo")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int FindMemoryTypeIndexForBufferInfo(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] ref uint pMemoryTypeIndex)
		{
			fixed (uint* ppMemoryTypeIndex = &pMemoryTypeIndex)
			{
				int ret = VMA.VmaFindMemoryTypeIndexForBufferInfoNative(allocator, pBufferCreateInfo, pAllocationCreateInfo, (uint*)ppMemoryTypeIndex);
				return ret;
			}
		}

		/// <summary>		/// It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.<br/>		/// It internally creates a temporary, dummy buffer that never has memory bound.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndexForBufferInfo")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int FindMemoryTypeIndexForBufferInfo(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] ref uint pMemoryTypeIndex)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (uint* ppMemoryTypeIndex = &pMemoryTypeIndex)
				{
					int ret = VMA.VmaFindMemoryTypeIndexForBufferInfoNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, pAllocationCreateInfo, (uint*)ppMemoryTypeIndex);
					return ret;
				}
			}
		}

		/// <summary>		/// It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.<br/>		/// It internally creates a temporary, dummy buffer that never has memory bound.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndexForBufferInfo")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int FindMemoryTypeIndexForBufferInfo(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] ref uint pMemoryTypeIndex)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (uint* ppMemoryTypeIndex = &pMemoryTypeIndex)
				{
					int ret = VMA.VmaFindMemoryTypeIndexForBufferInfoNative(allocator, pBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, (uint*)ppMemoryTypeIndex);
					return ret;
				}
			}
		}

		/// <summary>		/// It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.<br/>		/// It internally creates a temporary, dummy buffer that never has memory bound.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndexForBufferInfo")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int FindMemoryTypeIndexForBufferInfo(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] ref uint pMemoryTypeIndex)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					fixed (uint* ppMemoryTypeIndex = &pMemoryTypeIndex)
					{
						int ret = VMA.VmaFindMemoryTypeIndexForBufferInfoNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, (uint*)ppMemoryTypeIndex);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.<br/>		/// It internally creates a temporary, dummy image that never has memory bound.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndexForImageInfo")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int FindMemoryTypeIndexForImageInfo(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] uint* pMemoryTypeIndex)
		{
			int ret = VMA.VmaFindMemoryTypeIndexForImageInfoNative(allocator, pImageCreateInfo, pAllocationCreateInfo, pMemoryTypeIndex);
			return ret;
		}

		/// <summary>		/// It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.<br/>		/// It internally creates a temporary, dummy image that never has memory bound.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndexForImageInfo")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int FindMemoryTypeIndexForImageInfo(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] ref VkImageCreateInfo pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] uint* pMemoryTypeIndex)
		{
			fixed (VkImageCreateInfo* ppImageCreateInfo = &pImageCreateInfo)
			{
				int ret = VMA.VmaFindMemoryTypeIndexForImageInfoNative(allocator, (VkImageCreateInfo*)ppImageCreateInfo, pAllocationCreateInfo, pMemoryTypeIndex);
				return ret;
			}
		}

		/// <summary>		/// It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.<br/>		/// It internally creates a temporary, dummy image that never has memory bound.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndexForImageInfo")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int FindMemoryTypeIndexForImageInfo(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] uint* pMemoryTypeIndex)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				int ret = VMA.VmaFindMemoryTypeIndexForImageInfoNative(allocator, pImageCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, pMemoryTypeIndex);
				return ret;
			}
		}

		/// <summary>		/// It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.<br/>		/// It internally creates a temporary, dummy image that never has memory bound.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndexForImageInfo")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int FindMemoryTypeIndexForImageInfo(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] ref VkImageCreateInfo pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] uint* pMemoryTypeIndex)
		{
			fixed (VkImageCreateInfo* ppImageCreateInfo = &pImageCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					int ret = VMA.VmaFindMemoryTypeIndexForImageInfoNative(allocator, (VkImageCreateInfo*)ppImageCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, pMemoryTypeIndex);
					return ret;
				}
			}
		}

		/// <summary>		/// It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.<br/>		/// It internally creates a temporary, dummy image that never has memory bound.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndexForImageInfo")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int FindMemoryTypeIndexForImageInfo(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] ref uint pMemoryTypeIndex)
		{
			fixed (uint* ppMemoryTypeIndex = &pMemoryTypeIndex)
			{
				int ret = VMA.VmaFindMemoryTypeIndexForImageInfoNative(allocator, pImageCreateInfo, pAllocationCreateInfo, (uint*)ppMemoryTypeIndex);
				return ret;
			}
		}

		/// <summary>		/// It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.<br/>		/// It internally creates a temporary, dummy image that never has memory bound.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndexForImageInfo")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int FindMemoryTypeIndexForImageInfo(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] ref VkImageCreateInfo pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] ref uint pMemoryTypeIndex)
		{
			fixed (VkImageCreateInfo* ppImageCreateInfo = &pImageCreateInfo)
			{
				fixed (uint* ppMemoryTypeIndex = &pMemoryTypeIndex)
				{
					int ret = VMA.VmaFindMemoryTypeIndexForImageInfoNative(allocator, (VkImageCreateInfo*)ppImageCreateInfo, pAllocationCreateInfo, (uint*)ppMemoryTypeIndex);
					return ret;
				}
			}
		}

		/// <summary>		/// It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.<br/>		/// It internally creates a temporary, dummy image that never has memory bound.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndexForImageInfo")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int FindMemoryTypeIndexForImageInfo(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] ref uint pMemoryTypeIndex)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (uint* ppMemoryTypeIndex = &pMemoryTypeIndex)
				{
					int ret = VMA.VmaFindMemoryTypeIndexForImageInfoNative(allocator, pImageCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, (uint*)ppMemoryTypeIndex);
					return ret;
				}
			}
		}

		/// <summary>		/// It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.<br/>		/// It internally creates a temporary, dummy image that never has memory bound.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndexForImageInfo")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int FindMemoryTypeIndexForImageInfo(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] ref VkImageCreateInfo pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] ref uint pMemoryTypeIndex)
		{
			fixed (VkImageCreateInfo* ppImageCreateInfo = &pImageCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					fixed (uint* ppMemoryTypeIndex = &pMemoryTypeIndex)
					{
						int ret = VMA.VmaFindMemoryTypeIndexForImageInfoNative(allocator, (VkImageCreateInfo*)ppImageCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, (uint*)ppMemoryTypeIndex);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreatePool")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreatePool(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaPoolCreateInfo*")] VmaPoolCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pPool")] [NativeName(NativeNameType.Type, "VmaPool*")] VmaPool* pPool)
		{
			int ret = VMA.VmaCreatePoolNative(allocator, pCreateInfo, pPool);
			return ret;
		}

		/// <summary>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreatePool")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreatePool(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaPoolCreateInfo*")] ref VmaPoolCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pPool")] [NativeName(NativeNameType.Type, "VmaPool*")] VmaPool* pPool)
		{
			fixed (VmaPoolCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				int ret = VMA.VmaCreatePoolNative(allocator, (VmaPoolCreateInfo*)ppCreateInfo, pPool);
				return ret;
			}
		}

		/// <summary>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreatePool")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreatePool(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaPoolCreateInfo*")] VmaPoolCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pPool")] [NativeName(NativeNameType.Type, "VmaPool*")] ref VmaPool pPool)
		{
			fixed (VmaPool* ppPool = &pPool)
			{
				int ret = VMA.VmaCreatePoolNative(allocator, pCreateInfo, (VmaPool*)ppPool);
				return ret;
			}
		}

		/// <summary>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreatePool")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreatePool(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaPoolCreateInfo*")] ref VmaPoolCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pPool")] [NativeName(NativeNameType.Type, "VmaPool*")] ref VmaPool pPool)
		{
			fixed (VmaPoolCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VmaPool* ppPool = &pPool)
				{
					int ret = VMA.VmaCreatePoolNative(allocator, (VmaPoolCreateInfo*)ppCreateInfo, (VmaPool*)ppPool);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaDestroyPool")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroyPool(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pool")] [NativeName(NativeNameType.Type, "VmaPool")] VmaPool pool)
		{
			VMA.VmaDestroyPoolNative(allocator, pool);
		}

		/// <summary>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaGetPoolStatistics")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetPoolStatistics(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pool")] [NativeName(NativeNameType.Type, "VmaPool")] VmaPool pool, [NativeName(NativeNameType.Param, "pPoolStats")] [NativeName(NativeNameType.Type, "VmaStatistics*")] VmaStatistics* pPoolStats)
		{
			VMA.VmaGetPoolStatisticsNative(allocator, pool, pPoolStats);
		}

		/// <summary>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaGetPoolStatistics")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetPoolStatistics(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pool")] [NativeName(NativeNameType.Type, "VmaPool")] VmaPool pool, [NativeName(NativeNameType.Param, "pPoolStats")] [NativeName(NativeNameType.Type, "VmaStatistics*")] ref VmaStatistics pPoolStats)
		{
			fixed (VmaStatistics* ppPoolStats = &pPoolStats)
			{
				VMA.VmaGetPoolStatisticsNative(allocator, pool, (VmaStatistics*)ppPoolStats);
			}
		}

		/// <summary>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCalculatePoolStatistics")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalculatePoolStatistics(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pool")] [NativeName(NativeNameType.Type, "VmaPool")] VmaPool pool, [NativeName(NativeNameType.Param, "pPoolStats")] [NativeName(NativeNameType.Type, "VmaDetailedStatistics*")] VmaDetailedStatistics* pPoolStats)
		{
			VMA.VmaCalculatePoolStatisticsNative(allocator, pool, pPoolStats);
		}

		/// <summary>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCalculatePoolStatistics")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalculatePoolStatistics(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pool")] [NativeName(NativeNameType.Type, "VmaPool")] VmaPool pool, [NativeName(NativeNameType.Param, "pPoolStats")] [NativeName(NativeNameType.Type, "VmaDetailedStatistics*")] ref VmaDetailedStatistics pPoolStats)
		{
			fixed (VmaDetailedStatistics* ppPoolStats = &pPoolStats)
			{
				VMA.VmaCalculatePoolStatisticsNative(allocator, pool, (VmaDetailedStatistics*)ppPoolStats);
			}
		}

		/// <summary>		/// <br/>		/// Corruption detection is enabled only when `VMA_DEBUG_DETECT_CORRUPTION` macro is defined to nonzero,<br/>		/// `VMA_DEBUG_MARGIN` is defined to nonzero and the pool is created in memory type that is<br/>		/// `HOST_VISIBLE` and `HOST_COHERENT`. For more information, see [Corruption detection](<br/>		/// Possible return values:<br/>		/// - `VK_ERROR_FEATURE_NOT_PRESENT` - corruption detection is not enabled for specified pool.<br/>		/// - `VK_SUCCESS` - corruption detection has been performed and succeeded.<br/>		/// - `VK_ERROR_UNKNOWN` - corruption detection has been performed and found memory corruptions around one of the allocations.<br/>		/// `VMA_ASSERT` is also fired in that case.<br/>		/// - Other value: Error returned by Vulkan, e.g. memory mapping failure.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCheckPoolCorruption")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CheckPoolCorruption(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pool")] [NativeName(NativeNameType.Type, "VmaPool")] VmaPool pool)
		{
			int ret = VMA.VmaCheckPoolCorruptionNative(allocator, pool);
			return ret;
		}

		/// <summary>		/// <br/>		/// After the call `ppName` is either null or points to an internally-owned null-terminated string<br/>		/// containing name of the pool that was previously set. The pointer becomes invalid when the pool is<br/>		/// destroyed or its name is changed using vmaSetPoolName().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaGetPoolName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetPoolName(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pool")] [NativeName(NativeNameType.Type, "VmaPool")] VmaPool pool, [NativeName(NativeNameType.Param, "ppName")] [NativeName(NativeNameType.Type, "const char**")] byte** ppName)
		{
			VMA.VmaGetPoolNameNative(allocator, pool, ppName);
		}

		/// <summary>		/// <br/>		/// After the call `ppName` is either null or points to an internally-owned null-terminated string<br/>		/// containing name of the pool that was previously set. The pointer becomes invalid when the pool is<br/>		/// destroyed or its name is changed using vmaSetPoolName().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaGetPoolName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetPoolName(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pool")] [NativeName(NativeNameType.Type, "VmaPool")] VmaPool pool, [NativeName(NativeNameType.Param, "ppName")] [NativeName(NativeNameType.Type, "const char**")] ref byte* ppName)
		{
			fixed (byte** pppName = &ppName)
			{
				VMA.VmaGetPoolNameNative(allocator, pool, (byte**)pppName);
			}
		}

		/// <summary>		/// <br/>		/// `pName` can be either null or pointer to a null-terminated string with new name for the pool.<br/>		/// Function makes internal copy of the string, so it can be changed or freed immediately after this call.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaSetPoolName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetPoolName(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pool")] [NativeName(NativeNameType.Type, "VmaPool")] VmaPool pool, [NativeName(NativeNameType.Param, "pName")] [NativeName(NativeNameType.Type, "const char*")] byte* pName)
		{
			VMA.VmaSetPoolNameNative(allocator, pool, pName);
		}

		/// <summary>		/// <br/>		/// `pName` can be either null or pointer to a null-terminated string with new name for the pool.<br/>		/// Function makes internal copy of the string, so it can be changed or freed immediately after this call.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaSetPoolName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetPoolName(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pool")] [NativeName(NativeNameType.Type, "VmaPool")] VmaPool pool, [NativeName(NativeNameType.Param, "pName")] [NativeName(NativeNameType.Type, "const char*")] ref byte pName)
		{
			fixed (byte* ppName = &pName)
			{
				VMA.VmaSetPoolNameNative(allocator, pool, (byte*)ppName);
			}
		}

		/// <summary>		/// <br/>		/// `pName` can be either null or pointer to a null-terminated string with new name for the pool.<br/>		/// Function makes internal copy of the string, so it can be changed or freed immediately after this call.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaSetPoolName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetPoolName(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pool")] [NativeName(NativeNameType.Type, "VmaPool")] VmaPool pool, [NativeName(NativeNameType.Param, "pName")] [NativeName(NativeNameType.Type, "const char*")] string pName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			VMA.VmaSetPoolNameNative(allocator, pool, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>		/// <br/>		/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>		/// It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),<br/>		/// vmaCreateBuffer(), vmaCreateImage() instead whenever possible.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemory(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			int ret = VMA.VmaAllocateMemoryNative(allocator, pVkMemoryRequirements, pCreateInfo, pAllocation, pAllocationInfo);
			return ret;
		}

		/// <summary>		/// <br/>		/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>		/// It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),<br/>		/// vmaCreateBuffer(), vmaCreateImage() instead whenever possible.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemory(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				int ret = VMA.VmaAllocateMemoryNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, pCreateInfo, pAllocation, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>		/// <br/>		/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>		/// It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),<br/>		/// vmaCreateBuffer(), vmaCreateImage() instead whenever possible.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemory(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				int ret = VMA.VmaAllocateMemoryNative(allocator, pVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, pAllocation, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>		/// <br/>		/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>		/// It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),<br/>		/// vmaCreateBuffer(), vmaCreateImage() instead whenever possible.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemory(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
				{
					int ret = VMA.VmaAllocateMemoryNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, pAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>		/// It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),<br/>		/// vmaCreateBuffer(), vmaCreateImage() instead whenever possible.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemory(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocation* ppAllocation = &pAllocation)
			{
				int ret = VMA.VmaAllocateMemoryNative(allocator, pVkMemoryRequirements, pCreateInfo, (VmaAllocation*)ppAllocation, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>		/// <br/>		/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>		/// It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),<br/>		/// vmaCreateBuffer(), vmaCreateImage() instead whenever possible.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemory(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					int ret = VMA.VmaAllocateMemoryNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, pCreateInfo, (VmaAllocation*)ppAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>		/// It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),<br/>		/// vmaCreateBuffer(), vmaCreateImage() instead whenever possible.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemory(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					int ret = VMA.VmaAllocateMemoryNative(allocator, pVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, (VmaAllocation*)ppAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>		/// It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),<br/>		/// vmaCreateBuffer(), vmaCreateImage() instead whenever possible.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemory(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
				{
					fixed (VmaAllocation* ppAllocation = &pAllocation)
					{
						int ret = VMA.VmaAllocateMemoryNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, (VmaAllocation*)ppAllocation, pAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// <br/>		/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>		/// It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),<br/>		/// vmaCreateBuffer(), vmaCreateImage() instead whenever possible.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemory(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
			{
				int ret = VMA.VmaAllocateMemoryNative(allocator, pVkMemoryRequirements, pCreateInfo, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
				return ret;
			}
		}

		/// <summary>		/// <br/>		/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>		/// It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),<br/>		/// vmaCreateBuffer(), vmaCreateImage() instead whenever possible.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemory(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					int ret = VMA.VmaAllocateMemoryNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, pCreateInfo, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>		/// It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),<br/>		/// vmaCreateBuffer(), vmaCreateImage() instead whenever possible.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemory(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					int ret = VMA.VmaAllocateMemoryNative(allocator, pVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>		/// It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),<br/>		/// vmaCreateBuffer(), vmaCreateImage() instead whenever possible.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemory(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						int ret = VMA.VmaAllocateMemoryNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// <br/>		/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>		/// It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),<br/>		/// vmaCreateBuffer(), vmaCreateImage() instead whenever possible.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemory(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocation* ppAllocation = &pAllocation)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					int ret = VMA.VmaAllocateMemoryNative(allocator, pVkMemoryRequirements, pCreateInfo, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>		/// It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),<br/>		/// vmaCreateBuffer(), vmaCreateImage() instead whenever possible.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemory(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						int ret = VMA.VmaAllocateMemoryNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, pCreateInfo, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// <br/>		/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>		/// It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),<br/>		/// vmaCreateBuffer(), vmaCreateImage() instead whenever possible.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemory(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						int ret = VMA.VmaAllocateMemoryNative(allocator, pVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// <br/>		/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>		/// It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),<br/>		/// vmaCreateBuffer(), vmaCreateImage() instead whenever possible.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemory(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
				{
					fixed (VmaAllocation* ppAllocation = &pAllocation)
					{
						fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
						{
							int ret = VMA.VmaAllocateMemoryNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// <br/>		/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>		/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>		/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>		/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>		/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>		/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>		/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			int ret = VMA.VmaAllocateMemoryPagesNative(allocator, pVkMemoryRequirements, pCreateInfo, allocationCount, pAllocations, pAllocationInfo);
			return ret;
		}

		/// <summary>		/// <br/>		/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>		/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>		/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>		/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>		/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>		/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>		/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				int ret = VMA.VmaAllocateMemoryPagesNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, pCreateInfo, allocationCount, pAllocations, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>		/// <br/>		/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>		/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>		/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>		/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>		/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>		/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>		/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				int ret = VMA.VmaAllocateMemoryPagesNative(allocator, pVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, allocationCount, pAllocations, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>		/// <br/>		/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>		/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>		/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>		/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>		/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>		/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>		/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
				{
					int ret = VMA.VmaAllocateMemoryPagesNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, allocationCount, pAllocations, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>		/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>		/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>		/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>		/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>		/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>		/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] nuint allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			int ret = VMA.VmaAllocateMemoryPagesNative(allocator, pVkMemoryRequirements, pCreateInfo, allocationCount, pAllocations, pAllocationInfo);
			return ret;
		}

		/// <summary>		/// <br/>		/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>		/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>		/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>		/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>		/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>		/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>		/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] nuint allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				int ret = VMA.VmaAllocateMemoryPagesNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, pCreateInfo, allocationCount, pAllocations, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>		/// <br/>		/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>		/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>		/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>		/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>		/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>		/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>		/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] nuint allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				int ret = VMA.VmaAllocateMemoryPagesNative(allocator, pVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, allocationCount, pAllocations, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>		/// <br/>		/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>		/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>		/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>		/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>		/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>		/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>		/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] nuint allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
				{
					int ret = VMA.VmaAllocateMemoryPagesNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, allocationCount, pAllocations, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>		/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>		/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>		/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>		/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>		/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>		/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocation* ppAllocations = &pAllocations)
			{
				int ret = VMA.VmaAllocateMemoryPagesNative(allocator, pVkMemoryRequirements, pCreateInfo, allocationCount, (VmaAllocation*)ppAllocations, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>		/// <br/>		/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>		/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>		/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>		/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>		/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>		/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>		/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocation* ppAllocations = &pAllocations)
				{
					int ret = VMA.VmaAllocateMemoryPagesNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, pCreateInfo, allocationCount, (VmaAllocation*)ppAllocations, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>		/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>		/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>		/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>		/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>		/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>		/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VmaAllocation* ppAllocations = &pAllocations)
				{
					int ret = VMA.VmaAllocateMemoryPagesNative(allocator, pVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, allocationCount, (VmaAllocation*)ppAllocations, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>		/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>		/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>		/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>		/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>		/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>		/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
				{
					fixed (VmaAllocation* ppAllocations = &pAllocations)
					{
						int ret = VMA.VmaAllocateMemoryPagesNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, allocationCount, (VmaAllocation*)ppAllocations, pAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// <br/>		/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>		/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>		/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>		/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>		/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>		/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>		/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] nuint allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocation* ppAllocations = &pAllocations)
			{
				int ret = VMA.VmaAllocateMemoryPagesNative(allocator, pVkMemoryRequirements, pCreateInfo, allocationCount, (VmaAllocation*)ppAllocations, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>		/// <br/>		/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>		/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>		/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>		/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>		/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>		/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>		/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] nuint allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocation* ppAllocations = &pAllocations)
				{
					int ret = VMA.VmaAllocateMemoryPagesNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, pCreateInfo, allocationCount, (VmaAllocation*)ppAllocations, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>		/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>		/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>		/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>		/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>		/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>		/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] nuint allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VmaAllocation* ppAllocations = &pAllocations)
				{
					int ret = VMA.VmaAllocateMemoryPagesNative(allocator, pVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, allocationCount, (VmaAllocation*)ppAllocations, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>		/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>		/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>		/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>		/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>		/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>		/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] nuint allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
				{
					fixed (VmaAllocation* ppAllocations = &pAllocations)
					{
						int ret = VMA.VmaAllocateMemoryPagesNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, allocationCount, (VmaAllocation*)ppAllocations, pAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// <br/>		/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>		/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>		/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>		/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>		/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>		/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>		/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
			{
				int ret = VMA.VmaAllocateMemoryPagesNative(allocator, pVkMemoryRequirements, pCreateInfo, allocationCount, pAllocations, (VmaAllocationInfo*)ppAllocationInfo);
				return ret;
			}
		}

		/// <summary>		/// <br/>		/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>		/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>		/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>		/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>		/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>		/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>		/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					int ret = VMA.VmaAllocateMemoryPagesNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, pCreateInfo, allocationCount, pAllocations, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>		/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>		/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>		/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>		/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>		/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>		/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					int ret = VMA.VmaAllocateMemoryPagesNative(allocator, pVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, allocationCount, pAllocations, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>		/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>		/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>		/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>		/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>		/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>		/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						int ret = VMA.VmaAllocateMemoryPagesNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, allocationCount, pAllocations, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// <br/>		/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>		/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>		/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>		/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>		/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>		/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>		/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] nuint allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
			{
				int ret = VMA.VmaAllocateMemoryPagesNative(allocator, pVkMemoryRequirements, pCreateInfo, allocationCount, pAllocations, (VmaAllocationInfo*)ppAllocationInfo);
				return ret;
			}
		}

		/// <summary>		/// <br/>		/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>		/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>		/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>		/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>		/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>		/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>		/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] nuint allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					int ret = VMA.VmaAllocateMemoryPagesNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, pCreateInfo, allocationCount, pAllocations, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>		/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>		/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>		/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>		/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>		/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>		/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] nuint allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					int ret = VMA.VmaAllocateMemoryPagesNative(allocator, pVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, allocationCount, pAllocations, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>		/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>		/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>		/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>		/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>		/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>		/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] nuint allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						int ret = VMA.VmaAllocateMemoryPagesNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, allocationCount, pAllocations, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// <br/>		/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>		/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>		/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>		/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>		/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>		/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>		/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocation* ppAllocations = &pAllocations)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					int ret = VMA.VmaAllocateMemoryPagesNative(allocator, pVkMemoryRequirements, pCreateInfo, allocationCount, (VmaAllocation*)ppAllocations, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>		/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>		/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>		/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>		/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>		/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>		/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocation* ppAllocations = &pAllocations)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						int ret = VMA.VmaAllocateMemoryPagesNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, pCreateInfo, allocationCount, (VmaAllocation*)ppAllocations, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// <br/>		/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>		/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>		/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>		/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>		/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>		/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>		/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VmaAllocation* ppAllocations = &pAllocations)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						int ret = VMA.VmaAllocateMemoryPagesNative(allocator, pVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, allocationCount, (VmaAllocation*)ppAllocations, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// <br/>		/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>		/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>		/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>		/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>		/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>		/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>		/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
				{
					fixed (VmaAllocation* ppAllocations = &pAllocations)
					{
						fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
						{
							int ret = VMA.VmaAllocateMemoryPagesNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, allocationCount, (VmaAllocation*)ppAllocations, (VmaAllocationInfo*)ppAllocationInfo);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// <br/>		/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>		/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>		/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>		/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>		/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>		/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>		/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] nuint allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocation* ppAllocations = &pAllocations)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					int ret = VMA.VmaAllocateMemoryPagesNative(allocator, pVkMemoryRequirements, pCreateInfo, allocationCount, (VmaAllocation*)ppAllocations, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>		/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>		/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>		/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>		/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>		/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>		/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] nuint allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocation* ppAllocations = &pAllocations)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						int ret = VMA.VmaAllocateMemoryPagesNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, pCreateInfo, allocationCount, (VmaAllocation*)ppAllocations, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// <br/>		/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>		/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>		/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>		/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>		/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>		/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>		/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] nuint allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VmaAllocation* ppAllocations = &pAllocations)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						int ret = VMA.VmaAllocateMemoryPagesNative(allocator, pVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, allocationCount, (VmaAllocation*)ppAllocations, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// <br/>		/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>		/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>		/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>		/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>		/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>		/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>		/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] nuint allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
				{
					fixed (VmaAllocation* ppAllocations = &pAllocations)
					{
						fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
						{
							int ret = VMA.VmaAllocateMemoryPagesNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, allocationCount, (VmaAllocation*)ppAllocations, (VmaAllocationInfo*)ppAllocationInfo);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// <br/>		/// It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindBufferMemory().<br/>		/// This is a special-purpose function. In most cases you should use vmaCreateBuffer().<br/>		/// You must free the allocation using vmaFreeMemory() when no longer needed.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryForBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemoryForBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "VkBuffer")] VkBuffer buffer, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			int ret = VMA.VmaAllocateMemoryForBufferNative(allocator, buffer, pCreateInfo, pAllocation, pAllocationInfo);
			return ret;
		}

		/// <summary>		/// <br/>		/// It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindBufferMemory().<br/>		/// This is a special-purpose function. In most cases you should use vmaCreateBuffer().<br/>		/// You must free the allocation using vmaFreeMemory() when no longer needed.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryForBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemoryForBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "VkBuffer")] VkBuffer buffer, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				int ret = VMA.VmaAllocateMemoryForBufferNative(allocator, buffer, (VmaAllocationCreateInfo*)ppCreateInfo, pAllocation, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>		/// <br/>		/// It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindBufferMemory().<br/>		/// This is a special-purpose function. In most cases you should use vmaCreateBuffer().<br/>		/// You must free the allocation using vmaFreeMemory() when no longer needed.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryForBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemoryForBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "VkBuffer")] VkBuffer buffer, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocation* ppAllocation = &pAllocation)
			{
				int ret = VMA.VmaAllocateMemoryForBufferNative(allocator, buffer, pCreateInfo, (VmaAllocation*)ppAllocation, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>		/// <br/>		/// It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindBufferMemory().<br/>		/// This is a special-purpose function. In most cases you should use vmaCreateBuffer().<br/>		/// You must free the allocation using vmaFreeMemory() when no longer needed.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryForBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemoryForBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "VkBuffer")] VkBuffer buffer, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					int ret = VMA.VmaAllocateMemoryForBufferNative(allocator, buffer, (VmaAllocationCreateInfo*)ppCreateInfo, (VmaAllocation*)ppAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindBufferMemory().<br/>		/// This is a special-purpose function. In most cases you should use vmaCreateBuffer().<br/>		/// You must free the allocation using vmaFreeMemory() when no longer needed.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryForBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemoryForBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "VkBuffer")] VkBuffer buffer, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
			{
				int ret = VMA.VmaAllocateMemoryForBufferNative(allocator, buffer, pCreateInfo, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
				return ret;
			}
		}

		/// <summary>		/// <br/>		/// It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindBufferMemory().<br/>		/// This is a special-purpose function. In most cases you should use vmaCreateBuffer().<br/>		/// You must free the allocation using vmaFreeMemory() when no longer needed.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryForBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemoryForBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "VkBuffer")] VkBuffer buffer, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					int ret = VMA.VmaAllocateMemoryForBufferNative(allocator, buffer, (VmaAllocationCreateInfo*)ppCreateInfo, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindBufferMemory().<br/>		/// This is a special-purpose function. In most cases you should use vmaCreateBuffer().<br/>		/// You must free the allocation using vmaFreeMemory() when no longer needed.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryForBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemoryForBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "VkBuffer")] VkBuffer buffer, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocation* ppAllocation = &pAllocation)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					int ret = VMA.VmaAllocateMemoryForBufferNative(allocator, buffer, pCreateInfo, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindBufferMemory().<br/>		/// This is a special-purpose function. In most cases you should use vmaCreateBuffer().<br/>		/// You must free the allocation using vmaFreeMemory() when no longer needed.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryForBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemoryForBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "VkBuffer")] VkBuffer buffer, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						int ret = VMA.VmaAllocateMemoryForBufferNative(allocator, buffer, (VmaAllocationCreateInfo*)ppCreateInfo, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// <br/>		/// It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindImageMemory().<br/>		/// This is a special-purpose function. In most cases you should use vmaCreateImage().<br/>		/// You must free the allocation using vmaFreeMemory() when no longer needed.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryForImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemoryForImage(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "image")] [NativeName(NativeNameType.Type, "VkImage")] VkImage image, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			int ret = VMA.VmaAllocateMemoryForImageNative(allocator, image, pCreateInfo, pAllocation, pAllocationInfo);
			return ret;
		}

		/// <summary>		/// <br/>		/// It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindImageMemory().<br/>		/// This is a special-purpose function. In most cases you should use vmaCreateImage().<br/>		/// You must free the allocation using vmaFreeMemory() when no longer needed.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryForImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemoryForImage(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "image")] [NativeName(NativeNameType.Type, "VkImage")] VkImage image, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				int ret = VMA.VmaAllocateMemoryForImageNative(allocator, image, (VmaAllocationCreateInfo*)ppCreateInfo, pAllocation, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>		/// <br/>		/// It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindImageMemory().<br/>		/// This is a special-purpose function. In most cases you should use vmaCreateImage().<br/>		/// You must free the allocation using vmaFreeMemory() when no longer needed.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryForImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemoryForImage(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "image")] [NativeName(NativeNameType.Type, "VkImage")] VkImage image, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocation* ppAllocation = &pAllocation)
			{
				int ret = VMA.VmaAllocateMemoryForImageNative(allocator, image, pCreateInfo, (VmaAllocation*)ppAllocation, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>		/// <br/>		/// It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindImageMemory().<br/>		/// This is a special-purpose function. In most cases you should use vmaCreateImage().<br/>		/// You must free the allocation using vmaFreeMemory() when no longer needed.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryForImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemoryForImage(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "image")] [NativeName(NativeNameType.Type, "VkImage")] VkImage image, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					int ret = VMA.VmaAllocateMemoryForImageNative(allocator, image, (VmaAllocationCreateInfo*)ppCreateInfo, (VmaAllocation*)ppAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindImageMemory().<br/>		/// This is a special-purpose function. In most cases you should use vmaCreateImage().<br/>		/// You must free the allocation using vmaFreeMemory() when no longer needed.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryForImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemoryForImage(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "image")] [NativeName(NativeNameType.Type, "VkImage")] VkImage image, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
			{
				int ret = VMA.VmaAllocateMemoryForImageNative(allocator, image, pCreateInfo, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
				return ret;
			}
		}

		/// <summary>		/// <br/>		/// It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindImageMemory().<br/>		/// This is a special-purpose function. In most cases you should use vmaCreateImage().<br/>		/// You must free the allocation using vmaFreeMemory() when no longer needed.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryForImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemoryForImage(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "image")] [NativeName(NativeNameType.Type, "VkImage")] VkImage image, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					int ret = VMA.VmaAllocateMemoryForImageNative(allocator, image, (VmaAllocationCreateInfo*)ppCreateInfo, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindImageMemory().<br/>		/// This is a special-purpose function. In most cases you should use vmaCreateImage().<br/>		/// You must free the allocation using vmaFreeMemory() when no longer needed.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryForImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemoryForImage(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "image")] [NativeName(NativeNameType.Type, "VkImage")] VkImage image, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocation* ppAllocation = &pAllocation)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					int ret = VMA.VmaAllocateMemoryForImageNative(allocator, image, pCreateInfo, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindImageMemory().<br/>		/// This is a special-purpose function. In most cases you should use vmaCreateImage().<br/>		/// You must free the allocation using vmaFreeMemory() when no longer needed.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryForImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int AllocateMemoryForImage(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "image")] [NativeName(NativeNameType.Type, "VkImage")] VkImage image, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						int ret = VMA.VmaAllocateMemoryForImageNative(allocator, image, (VmaAllocationCreateInfo*)ppCreateInfo, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// <br/>		/// Passing `VK_NULL_HANDLE` as `allocation` is valid. Such function call is just skipped.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaFreeMemory")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void FreeMemory(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "const VmaAllocation")] VmaAllocation allocation)
		{
			VMA.VmaFreeMemoryNative(allocator, allocation);
		}

		/// <summary>		/// <br/>		/// Word "pages" is just a suggestion to use this function to free pieces of memory used for sparse binding.<br/>		/// It is just a general purpose function to free memory and destroy allocations made using e.g. vmaAllocateMemory(),<br/>		/// vmaAllocateMemoryPages() and other functions.<br/>		/// It may be internally optimized to be more efficient than calling vmaFreeMemory() `allocationCount` times.<br/>		/// Allocations in `pAllocations` array can come from any memory pools and types.<br/>		/// Passing `VK_NULL_HANDLE` as elements of `pAllocations` array is valid. Such entries are just skipped.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaFreeMemoryPages")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void FreeMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] VmaAllocation* pAllocations)
		{
			VMA.VmaFreeMemoryPagesNative(allocator, allocationCount, pAllocations);
		}

		/// <summary>		/// <br/>		/// Word "pages" is just a suggestion to use this function to free pieces of memory used for sparse binding.<br/>		/// It is just a general purpose function to free memory and destroy allocations made using e.g. vmaAllocateMemory(),<br/>		/// vmaAllocateMemoryPages() and other functions.<br/>		/// It may be internally optimized to be more efficient than calling vmaFreeMemory() `allocationCount` times.<br/>		/// Allocations in `pAllocations` array can come from any memory pools and types.<br/>		/// Passing `VK_NULL_HANDLE` as elements of `pAllocations` array is valid. Such entries are just skipped.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaFreeMemoryPages")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void FreeMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] nuint allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] VmaAllocation* pAllocations)
		{
			VMA.VmaFreeMemoryPagesNative(allocator, allocationCount, pAllocations);
		}

		/// <summary>		/// <br/>		/// Word "pages" is just a suggestion to use this function to free pieces of memory used for sparse binding.<br/>		/// It is just a general purpose function to free memory and destroy allocations made using e.g. vmaAllocateMemory(),<br/>		/// vmaAllocateMemoryPages() and other functions.<br/>		/// It may be internally optimized to be more efficient than calling vmaFreeMemory() `allocationCount` times.<br/>		/// Allocations in `pAllocations` array can come from any memory pools and types.<br/>		/// Passing `VK_NULL_HANDLE` as elements of `pAllocations` array is valid. Such entries are just skipped.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaFreeMemoryPages")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void FreeMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] ref VmaAllocation pAllocations)
		{
			fixed (VmaAllocation* ppAllocations = &pAllocations)
			{
				VMA.VmaFreeMemoryPagesNative(allocator, allocationCount, (VmaAllocation*)ppAllocations);
			}
		}

		/// <summary>		/// <br/>		/// Word "pages" is just a suggestion to use this function to free pieces of memory used for sparse binding.<br/>		/// It is just a general purpose function to free memory and destroy allocations made using e.g. vmaAllocateMemory(),<br/>		/// vmaAllocateMemoryPages() and other functions.<br/>		/// It may be internally optimized to be more efficient than calling vmaFreeMemory() `allocationCount` times.<br/>		/// Allocations in `pAllocations` array can come from any memory pools and types.<br/>		/// Passing `VK_NULL_HANDLE` as elements of `pAllocations` array is valid. Such entries are just skipped.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaFreeMemoryPages")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void FreeMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] nuint allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] ref VmaAllocation pAllocations)
		{
			fixed (VmaAllocation* ppAllocations = &pAllocations)
			{
				VMA.VmaFreeMemoryPagesNative(allocator, allocationCount, (VmaAllocation*)ppAllocations);
			}
		}

		/// <summary>		/// <br/>		/// Current parameters of given allocation are returned in `pAllocationInfo`.<br/>		/// Although this function doesn't lock any mutex, so it should be quite efficient,<br/>		/// you should avoid calling it too often.<br/>		/// You can retrieve same VmaAllocationInfo structure while creating your resource, from function<br/>		/// vmaCreateBuffer(), vmaCreateImage(). You can remember it if you are sure parameters don't change<br/>		/// (e.g. due to defragmentation).<br/>		/// There is also a new function vmaGetAllocationInfo2() that offers extended information<br/>		/// about the allocation, returned using new structure #VmaAllocationInfo2.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaGetAllocationInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetAllocationInfo(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			VMA.VmaGetAllocationInfoNative(allocator, allocation, pAllocationInfo);
		}

		/// <summary>		/// <br/>		/// Current parameters of given allocation are returned in `pAllocationInfo`.<br/>		/// Although this function doesn't lock any mutex, so it should be quite efficient,<br/>		/// you should avoid calling it too often.<br/>		/// You can retrieve same VmaAllocationInfo structure while creating your resource, from function<br/>		/// vmaCreateBuffer(), vmaCreateImage(). You can remember it if you are sure parameters don't change<br/>		/// (e.g. due to defragmentation).<br/>		/// There is also a new function vmaGetAllocationInfo2() that offers extended information<br/>		/// about the allocation, returned using new structure #VmaAllocationInfo2.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaGetAllocationInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetAllocationInfo(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
			{
				VMA.VmaGetAllocationInfoNative(allocator, allocation, (VmaAllocationInfo*)ppAllocationInfo);
			}
		}

		/// <summary>		/// <br/>		/// Current parameters of given allocation are returned in `pAllocationInfo`.<br/>		/// Extended parameters in structure #VmaAllocationInfo2 include memory block size<br/>		/// and a flag telling whether the allocation has dedicated memory.<br/>		/// It can be useful e.g. for interop with OpenGL.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaGetAllocationInfo2")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetAllocationInfo2(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo2*")] VmaAllocationInfo2* pAllocationInfo)
		{
			VMA.VmaGetAllocationInfo2Native(allocator, allocation, pAllocationInfo);
		}

		/// <summary>		/// <br/>		/// Current parameters of given allocation are returned in `pAllocationInfo`.<br/>		/// Extended parameters in structure #VmaAllocationInfo2 include memory block size<br/>		/// and a flag telling whether the allocation has dedicated memory.<br/>		/// It can be useful e.g. for interop with OpenGL.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaGetAllocationInfo2")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetAllocationInfo2(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo2*")] ref VmaAllocationInfo2 pAllocationInfo)
		{
			fixed (VmaAllocationInfo2* ppAllocationInfo = &pAllocationInfo)
			{
				VMA.VmaGetAllocationInfo2Native(allocator, allocation, (VmaAllocationInfo2*)ppAllocationInfo);
			}
		}

		/// <summary>		/// <br/>		/// The value of pointer `pUserData` is copied to allocation's `pUserData`.<br/>		/// It is opaque, so you can use it however you want - e.g.<br/>		/// as a pointer, ordinal number or some handle to you own data.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaSetAllocationUserData")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetAllocationUserData(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "pUserData")] [NativeName(NativeNameType.Type, "void*")] void* pUserData)
		{
			VMA.VmaSetAllocationUserDataNative(allocator, allocation, pUserData);
		}

		/// <summary>		/// <br/>		/// `pName` must be either null, or pointer to a null-terminated string. The function<br/>		/// makes local copy of the string and sets it as allocation's `pName`. String<br/>		/// passed as pName doesn't need to be valid for whole lifetime of the allocation -<br/>		/// you can free it after this call. String previously pointed by allocation's<br/>		/// `pName` is freed from memory.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaSetAllocationName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetAllocationName(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "pName")] [NativeName(NativeNameType.Type, "const char*")] byte* pName)
		{
			VMA.VmaSetAllocationNameNative(allocator, allocation, pName);
		}

		/// <summary>		/// <br/>		/// `pName` must be either null, or pointer to a null-terminated string. The function<br/>		/// makes local copy of the string and sets it as allocation's `pName`. String<br/>		/// passed as pName doesn't need to be valid for whole lifetime of the allocation -<br/>		/// you can free it after this call. String previously pointed by allocation's<br/>		/// `pName` is freed from memory.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaSetAllocationName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetAllocationName(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "pName")] [NativeName(NativeNameType.Type, "const char*")] ref byte pName)
		{
			fixed (byte* ppName = &pName)
			{
				VMA.VmaSetAllocationNameNative(allocator, allocation, (byte*)ppName);
			}
		}

		/// <summary>		/// <br/>		/// `pName` must be either null, or pointer to a null-terminated string. The function<br/>		/// makes local copy of the string and sets it as allocation's `pName`. String<br/>		/// passed as pName doesn't need to be valid for whole lifetime of the allocation -<br/>		/// you can free it after this call. String previously pointed by allocation's<br/>		/// `pName` is freed from memory.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaSetAllocationName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetAllocationName(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "pName")] [NativeName(NativeNameType.Type, "const char*")] string pName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			VMA.VmaSetAllocationNameNative(allocator, allocation, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>		/// This is just a convenience function. Same information can be obtained using<br/>		/// vmaGetAllocationInfo() + vmaGetMemoryProperties().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaGetAllocationMemoryProperties")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetAllocationMemoryProperties(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "VkMemoryPropertyFlags*")] VkMemoryPropertyFlags* pFlags)
		{
			VMA.VmaGetAllocationMemoryPropertiesNative(allocator, allocation, pFlags);
		}

		/// <summary>		/// This is just a convenience function. Same information can be obtained using<br/>		/// vmaGetAllocationInfo() + vmaGetMemoryProperties().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaGetAllocationMemoryProperties")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetAllocationMemoryProperties(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "VkMemoryPropertyFlags*")] ref VkMemoryPropertyFlags pFlags)
		{
			fixed (VkMemoryPropertyFlags* ppFlags = &pFlags)
			{
				VMA.VmaGetAllocationMemoryPropertiesNative(allocator, allocation, (VkMemoryPropertyFlags*)ppFlags);
			}
		}

		/// <summary>		/// <br/>		/// Maps memory represented by given allocation to make it accessible to CPU code.<br/>		/// When succeeded, `*ppData` contains pointer to first byte of this memory.<br/>		/// Mapping is internally reference-counted and synchronized, so despite raw Vulkan<br/>		/// function `vkMapMemory()` cannot be used to map same block of `VkDeviceMemory`<br/>		/// multiple times simultaneously, it is safe to call this function on allocations<br/>		/// assigned to the same memory block. Actual Vulkan memory will be mapped on first<br/>		/// mapping and unmapped on last unmapping.<br/>		/// If the function succeeded, you must call vmaUnmapMemory() to unmap the<br/>		/// allocation when mapping is no longer needed or before freeing the allocation, at<br/>		/// the latest.<br/>		/// It also safe to call this function multiple times on the same allocation. You<br/>		/// must call vmaUnmapMemory() same number of times as you called vmaMapMemory().<br/>		/// It is also safe to call this function on allocation created with<br/>		/// #VMA_ALLOCATION_CREATE_MAPPED_BIT flag. Its memory stays mapped all the time.<br/>		/// You must still call vmaUnmapMemory() same number of times as you called<br/>		/// vmaMapMemory(). You must not call vmaUnmapMemory() additional time to free the<br/>		/// "0-th" mapping made automatically due to #VMA_ALLOCATION_CREATE_MAPPED_BIT flag.<br/>		/// This function fails when used on allocation made in memory type that is not<br/>		/// `HOST_VISIBLE`.<br/>		/// This function doesn't automatically flush or invalidate caches.<br/>		/// If the allocation is made from a memory types that is not `HOST_COHERENT`,<br/>		/// you also need to use vmaInvalidateAllocation() / vmaFlushAllocation(), as required by Vulkan specification.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaMapMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int MapMemory(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "ppData")] [NativeName(NativeNameType.Type, "void**")] void** ppData)
		{
			int ret = VMA.VmaMapMemoryNative(allocator, allocation, ppData);
			return ret;
		}

		/// <summary>		/// <br/>		/// For details, see description of vmaMapMemory().<br/>		/// This function doesn't automatically flush or invalidate caches.<br/>		/// If the allocation is made from a memory types that is not `HOST_COHERENT`,<br/>		/// you also need to use vmaInvalidateAllocation() / vmaFlushAllocation(), as required by Vulkan specification.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaUnmapMemory")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnmapMemory(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation)
		{
			VMA.VmaUnmapMemoryNative(allocator, allocation);
		}

		/// <summary>		/// <br/>		/// Calls `vkFlushMappedMemoryRanges()` for memory associated with given range of given allocation.<br/>		/// It needs to be called after writing to a mapped memory for memory types that are not `HOST_COHERENT`.<br/>		/// Unmap operation doesn't do that automatically.<br/>		/// - `offset` must be relative to the beginning of allocation.<br/>		/// - `size` can be `VK_WHOLE_SIZE`. It means all memory from `offset` the the end of given allocation.<br/>		/// - `offset` and `size` don't have to be aligned.<br/>		/// They are internally rounded down/up to multiply of `nonCoherentAtomSize`.<br/>		/// - If `size` is 0, this call is ignored.<br/>		/// - If memory type that the `allocation` belongs to is not `HOST_VISIBLE` or it is `HOST_COHERENT`,<br/>		/// this call is ignored.<br/>		/// Warning! `offset` and `size` are relative to the contents of given `allocation`.<br/>		/// If you mean whole allocation, you can pass 0 and `VK_WHOLE_SIZE`, respectively.<br/>		/// Do not pass allocation's offset as `offset`!!!<br/>		/// This function returns the `VkResult` from `vkFlushMappedMemoryRanges` if it is<br/>		/// called, otherwise `VK_SUCCESS`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaFlushAllocation")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int FlushAllocation(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong offset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong size)
		{
			int ret = VMA.VmaFlushAllocationNative(allocator, allocation, offset, size);
			return ret;
		}

		/// <summary>		/// <br/>		/// Calls `vkInvalidateMappedMemoryRanges()` for memory associated with given range of given allocation.<br/>		/// It needs to be called before reading from a mapped memory for memory types that are not `HOST_COHERENT`.<br/>		/// Map operation doesn't do that automatically.<br/>		/// - `offset` must be relative to the beginning of allocation.<br/>		/// - `size` can be `VK_WHOLE_SIZE`. It means all memory from `offset` the the end of given allocation.<br/>		/// - `offset` and `size` don't have to be aligned.<br/>		/// They are internally rounded down/up to multiply of `nonCoherentAtomSize`.<br/>		/// - If `size` is 0, this call is ignored.<br/>		/// - If memory type that the `allocation` belongs to is not `HOST_VISIBLE` or it is `HOST_COHERENT`,<br/>		/// this call is ignored.<br/>		/// Warning! `offset` and `size` are relative to the contents of given `allocation`.<br/>		/// If you mean whole allocation, you can pass 0 and `VK_WHOLE_SIZE`, respectively.<br/>		/// Do not pass allocation's offset as `offset`!!!<br/>		/// This function returns the `VkResult` from `vkInvalidateMappedMemoryRanges` if<br/>		/// it is called, otherwise `VK_SUCCESS`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaInvalidateAllocation")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int InvalidateAllocation(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong offset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong size)
		{
			int ret = VMA.VmaInvalidateAllocationNative(allocator, allocation, offset, size);
			return ret;
		}

		/// <summary>		/// <br/>		/// Calls `vkFlushMappedMemoryRanges()` for memory associated with given ranges of given allocations.<br/>		/// For more information, see documentation of vmaFlushAllocation().<br/>		/// This function returns the `VkResult` from `vkFlushMappedMemoryRanges` if it is<br/>		/// called, otherwise `VK_SUCCESS`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaFlushAllocations")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int FlushAllocations(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint allocationCount, [NativeName(NativeNameType.Param, "allocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] VmaAllocation* allocations, [NativeName(NativeNameType.Param, "offsets")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ulong* offsets, [NativeName(NativeNameType.Param, "sizes")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ulong* sizes)
		{
			int ret = VMA.VmaFlushAllocationsNative(allocator, allocationCount, allocations, offsets, sizes);
			return ret;
		}

		/// <summary>		/// <br/>		/// Calls `vkFlushMappedMemoryRanges()` for memory associated with given ranges of given allocations.<br/>		/// For more information, see documentation of vmaFlushAllocation().<br/>		/// This function returns the `VkResult` from `vkFlushMappedMemoryRanges` if it is<br/>		/// called, otherwise `VK_SUCCESS`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaFlushAllocations")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int FlushAllocations(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint allocationCount, [NativeName(NativeNameType.Param, "allocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] ref VmaAllocation allocations, [NativeName(NativeNameType.Param, "offsets")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ulong* offsets, [NativeName(NativeNameType.Param, "sizes")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ulong* sizes)
		{
			fixed (VmaAllocation* pallocations = &allocations)
			{
				int ret = VMA.VmaFlushAllocationsNative(allocator, allocationCount, (VmaAllocation*)pallocations, offsets, sizes);
				return ret;
			}
		}

		/// <summary>		/// <br/>		/// Calls `vkFlushMappedMemoryRanges()` for memory associated with given ranges of given allocations.<br/>		/// For more information, see documentation of vmaFlushAllocation().<br/>		/// This function returns the `VkResult` from `vkFlushMappedMemoryRanges` if it is<br/>		/// called, otherwise `VK_SUCCESS`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaFlushAllocations")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int FlushAllocations(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint allocationCount, [NativeName(NativeNameType.Param, "allocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] VmaAllocation* allocations, [NativeName(NativeNameType.Param, "offsets")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ref ulong offsets, [NativeName(NativeNameType.Param, "sizes")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ulong* sizes)
		{
			fixed (ulong* poffsets = &offsets)
			{
				int ret = VMA.VmaFlushAllocationsNative(allocator, allocationCount, allocations, (ulong*)poffsets, sizes);
				return ret;
			}
		}

		/// <summary>		/// <br/>		/// Calls `vkFlushMappedMemoryRanges()` for memory associated with given ranges of given allocations.<br/>		/// For more information, see documentation of vmaFlushAllocation().<br/>		/// This function returns the `VkResult` from `vkFlushMappedMemoryRanges` if it is<br/>		/// called, otherwise `VK_SUCCESS`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaFlushAllocations")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int FlushAllocations(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint allocationCount, [NativeName(NativeNameType.Param, "allocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] ref VmaAllocation allocations, [NativeName(NativeNameType.Param, "offsets")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ref ulong offsets, [NativeName(NativeNameType.Param, "sizes")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ulong* sizes)
		{
			fixed (VmaAllocation* pallocations = &allocations)
			{
				fixed (ulong* poffsets = &offsets)
				{
					int ret = VMA.VmaFlushAllocationsNative(allocator, allocationCount, (VmaAllocation*)pallocations, (ulong*)poffsets, sizes);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// Calls `vkFlushMappedMemoryRanges()` for memory associated with given ranges of given allocations.<br/>		/// For more information, see documentation of vmaFlushAllocation().<br/>		/// This function returns the `VkResult` from `vkFlushMappedMemoryRanges` if it is<br/>		/// called, otherwise `VK_SUCCESS`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaFlushAllocations")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int FlushAllocations(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint allocationCount, [NativeName(NativeNameType.Param, "allocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] VmaAllocation* allocations, [NativeName(NativeNameType.Param, "offsets")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ulong* offsets, [NativeName(NativeNameType.Param, "sizes")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ref ulong sizes)
		{
			fixed (ulong* psizes = &sizes)
			{
				int ret = VMA.VmaFlushAllocationsNative(allocator, allocationCount, allocations, offsets, (ulong*)psizes);
				return ret;
			}
		}

		/// <summary>		/// <br/>		/// Calls `vkFlushMappedMemoryRanges()` for memory associated with given ranges of given allocations.<br/>		/// For more information, see documentation of vmaFlushAllocation().<br/>		/// This function returns the `VkResult` from `vkFlushMappedMemoryRanges` if it is<br/>		/// called, otherwise `VK_SUCCESS`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaFlushAllocations")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int FlushAllocations(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint allocationCount, [NativeName(NativeNameType.Param, "allocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] ref VmaAllocation allocations, [NativeName(NativeNameType.Param, "offsets")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ulong* offsets, [NativeName(NativeNameType.Param, "sizes")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ref ulong sizes)
		{
			fixed (VmaAllocation* pallocations = &allocations)
			{
				fixed (ulong* psizes = &sizes)
				{
					int ret = VMA.VmaFlushAllocationsNative(allocator, allocationCount, (VmaAllocation*)pallocations, offsets, (ulong*)psizes);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// Calls `vkFlushMappedMemoryRanges()` for memory associated with given ranges of given allocations.<br/>		/// For more information, see documentation of vmaFlushAllocation().<br/>		/// This function returns the `VkResult` from `vkFlushMappedMemoryRanges` if it is<br/>		/// called, otherwise `VK_SUCCESS`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaFlushAllocations")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int FlushAllocations(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint allocationCount, [NativeName(NativeNameType.Param, "allocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] VmaAllocation* allocations, [NativeName(NativeNameType.Param, "offsets")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ref ulong offsets, [NativeName(NativeNameType.Param, "sizes")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ref ulong sizes)
		{
			fixed (ulong* poffsets = &offsets)
			{
				fixed (ulong* psizes = &sizes)
				{
					int ret = VMA.VmaFlushAllocationsNative(allocator, allocationCount, allocations, (ulong*)poffsets, (ulong*)psizes);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// Calls `vkFlushMappedMemoryRanges()` for memory associated with given ranges of given allocations.<br/>		/// For more information, see documentation of vmaFlushAllocation().<br/>		/// This function returns the `VkResult` from `vkFlushMappedMemoryRanges` if it is<br/>		/// called, otherwise `VK_SUCCESS`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaFlushAllocations")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int FlushAllocations(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint allocationCount, [NativeName(NativeNameType.Param, "allocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] ref VmaAllocation allocations, [NativeName(NativeNameType.Param, "offsets")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ref ulong offsets, [NativeName(NativeNameType.Param, "sizes")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ref ulong sizes)
		{
			fixed (VmaAllocation* pallocations = &allocations)
			{
				fixed (ulong* poffsets = &offsets)
				{
					fixed (ulong* psizes = &sizes)
					{
						int ret = VMA.VmaFlushAllocationsNative(allocator, allocationCount, (VmaAllocation*)pallocations, (ulong*)poffsets, (ulong*)psizes);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// <br/>		/// Calls `vkInvalidateMappedMemoryRanges()` for memory associated with given ranges of given allocations.<br/>		/// For more information, see documentation of vmaInvalidateAllocation().<br/>		/// This function returns the `VkResult` from `vkInvalidateMappedMemoryRanges` if it is<br/>		/// called, otherwise `VK_SUCCESS`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaInvalidateAllocations")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int InvalidateAllocations(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint allocationCount, [NativeName(NativeNameType.Param, "allocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] VmaAllocation* allocations, [NativeName(NativeNameType.Param, "offsets")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ulong* offsets, [NativeName(NativeNameType.Param, "sizes")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ulong* sizes)
		{
			int ret = VMA.VmaInvalidateAllocationsNative(allocator, allocationCount, allocations, offsets, sizes);
			return ret;
		}

		/// <summary>		/// <br/>		/// Calls `vkInvalidateMappedMemoryRanges()` for memory associated with given ranges of given allocations.<br/>		/// For more information, see documentation of vmaInvalidateAllocation().<br/>		/// This function returns the `VkResult` from `vkInvalidateMappedMemoryRanges` if it is<br/>		/// called, otherwise `VK_SUCCESS`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaInvalidateAllocations")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int InvalidateAllocations(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint allocationCount, [NativeName(NativeNameType.Param, "allocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] ref VmaAllocation allocations, [NativeName(NativeNameType.Param, "offsets")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ulong* offsets, [NativeName(NativeNameType.Param, "sizes")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ulong* sizes)
		{
			fixed (VmaAllocation* pallocations = &allocations)
			{
				int ret = VMA.VmaInvalidateAllocationsNative(allocator, allocationCount, (VmaAllocation*)pallocations, offsets, sizes);
				return ret;
			}
		}

		/// <summary>		/// <br/>		/// Calls `vkInvalidateMappedMemoryRanges()` for memory associated with given ranges of given allocations.<br/>		/// For more information, see documentation of vmaInvalidateAllocation().<br/>		/// This function returns the `VkResult` from `vkInvalidateMappedMemoryRanges` if it is<br/>		/// called, otherwise `VK_SUCCESS`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaInvalidateAllocations")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int InvalidateAllocations(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint allocationCount, [NativeName(NativeNameType.Param, "allocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] VmaAllocation* allocations, [NativeName(NativeNameType.Param, "offsets")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ref ulong offsets, [NativeName(NativeNameType.Param, "sizes")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ulong* sizes)
		{
			fixed (ulong* poffsets = &offsets)
			{
				int ret = VMA.VmaInvalidateAllocationsNative(allocator, allocationCount, allocations, (ulong*)poffsets, sizes);
				return ret;
			}
		}

		/// <summary>		/// <br/>		/// Calls `vkInvalidateMappedMemoryRanges()` for memory associated with given ranges of given allocations.<br/>		/// For more information, see documentation of vmaInvalidateAllocation().<br/>		/// This function returns the `VkResult` from `vkInvalidateMappedMemoryRanges` if it is<br/>		/// called, otherwise `VK_SUCCESS`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaInvalidateAllocations")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int InvalidateAllocations(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint allocationCount, [NativeName(NativeNameType.Param, "allocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] ref VmaAllocation allocations, [NativeName(NativeNameType.Param, "offsets")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ref ulong offsets, [NativeName(NativeNameType.Param, "sizes")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ulong* sizes)
		{
			fixed (VmaAllocation* pallocations = &allocations)
			{
				fixed (ulong* poffsets = &offsets)
				{
					int ret = VMA.VmaInvalidateAllocationsNative(allocator, allocationCount, (VmaAllocation*)pallocations, (ulong*)poffsets, sizes);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// Calls `vkInvalidateMappedMemoryRanges()` for memory associated with given ranges of given allocations.<br/>		/// For more information, see documentation of vmaInvalidateAllocation().<br/>		/// This function returns the `VkResult` from `vkInvalidateMappedMemoryRanges` if it is<br/>		/// called, otherwise `VK_SUCCESS`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaInvalidateAllocations")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int InvalidateAllocations(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint allocationCount, [NativeName(NativeNameType.Param, "allocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] VmaAllocation* allocations, [NativeName(NativeNameType.Param, "offsets")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ulong* offsets, [NativeName(NativeNameType.Param, "sizes")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ref ulong sizes)
		{
			fixed (ulong* psizes = &sizes)
			{
				int ret = VMA.VmaInvalidateAllocationsNative(allocator, allocationCount, allocations, offsets, (ulong*)psizes);
				return ret;
			}
		}

		/// <summary>		/// <br/>		/// Calls `vkInvalidateMappedMemoryRanges()` for memory associated with given ranges of given allocations.<br/>		/// For more information, see documentation of vmaInvalidateAllocation().<br/>		/// This function returns the `VkResult` from `vkInvalidateMappedMemoryRanges` if it is<br/>		/// called, otherwise `VK_SUCCESS`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaInvalidateAllocations")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int InvalidateAllocations(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint allocationCount, [NativeName(NativeNameType.Param, "allocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] ref VmaAllocation allocations, [NativeName(NativeNameType.Param, "offsets")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ulong* offsets, [NativeName(NativeNameType.Param, "sizes")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ref ulong sizes)
		{
			fixed (VmaAllocation* pallocations = &allocations)
			{
				fixed (ulong* psizes = &sizes)
				{
					int ret = VMA.VmaInvalidateAllocationsNative(allocator, allocationCount, (VmaAllocation*)pallocations, offsets, (ulong*)psizes);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// Calls `vkInvalidateMappedMemoryRanges()` for memory associated with given ranges of given allocations.<br/>		/// For more information, see documentation of vmaInvalidateAllocation().<br/>		/// This function returns the `VkResult` from `vkInvalidateMappedMemoryRanges` if it is<br/>		/// called, otherwise `VK_SUCCESS`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaInvalidateAllocations")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int InvalidateAllocations(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint allocationCount, [NativeName(NativeNameType.Param, "allocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] VmaAllocation* allocations, [NativeName(NativeNameType.Param, "offsets")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ref ulong offsets, [NativeName(NativeNameType.Param, "sizes")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ref ulong sizes)
		{
			fixed (ulong* poffsets = &offsets)
			{
				fixed (ulong* psizes = &sizes)
				{
					int ret = VMA.VmaInvalidateAllocationsNative(allocator, allocationCount, allocations, (ulong*)poffsets, (ulong*)psizes);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// Calls `vkInvalidateMappedMemoryRanges()` for memory associated with given ranges of given allocations.<br/>		/// For more information, see documentation of vmaInvalidateAllocation().<br/>		/// This function returns the `VkResult` from `vkInvalidateMappedMemoryRanges` if it is<br/>		/// called, otherwise `VK_SUCCESS`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaInvalidateAllocations")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int InvalidateAllocations(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint allocationCount, [NativeName(NativeNameType.Param, "allocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] ref VmaAllocation allocations, [NativeName(NativeNameType.Param, "offsets")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ref ulong offsets, [NativeName(NativeNameType.Param, "sizes")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ref ulong sizes)
		{
			fixed (VmaAllocation* pallocations = &allocations)
			{
				fixed (ulong* poffsets = &offsets)
				{
					fixed (ulong* psizes = &sizes)
					{
						int ret = VMA.VmaInvalidateAllocationsNative(allocator, allocationCount, (VmaAllocation*)pallocations, (ulong*)poffsets, (ulong*)psizes);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// <br/>		/// This is a convenience function that allows to copy data from a host pointer to an allocation easily.<br/>		/// Same behavior can be achieved by calling vmaMapMemory(), `memcpy()`, vmaUnmapMemory(), vmaFlushAllocation().<br/>		/// This function can be called only for allocations created in a memory type that has `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` flag.<br/>		/// It can be ensured e.g. by using #VMA_MEMORY_USAGE_AUTO and #VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT or<br/>		/// #VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT.<br/>		/// Otherwise, the function will fail and generate a Validation Layers error.<br/>		/// `dstAllocationLocalOffset` is relative to the contents of given `dstAllocation`.<br/>		/// If you mean whole allocation, you should pass 0.<br/>		/// Do not pass allocation's offset within device memory block this parameter!<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCopyMemoryToAllocation")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CopyMemoryToAllocation(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pSrcHostPointer")] [NativeName(NativeNameType.Type, "const void*")] void* pSrcHostPointer, [NativeName(NativeNameType.Param, "dstAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation dstAllocation, [NativeName(NativeNameType.Param, "dstAllocationLocalOffset")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong dstAllocationLocalOffset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong size)
		{
			int ret = VMA.VmaCopyMemoryToAllocationNative(allocator, pSrcHostPointer, dstAllocation, dstAllocationLocalOffset, size);
			return ret;
		}

		/// <summary>		/// <br/>		/// This is a convenience function that allows to copy data from an allocation to a host pointer easily.<br/>		/// Same behavior can be achieved by calling vmaInvalidateAllocation(), vmaMapMemory(), `memcpy()`, vmaUnmapMemory().<br/>		/// This function should be called only for allocations created in a memory type that has `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT`<br/>		/// and `VK_MEMORY_PROPERTY_HOST_CACHED_BIT` flag.<br/>		/// It can be ensured e.g. by using #VMA_MEMORY_USAGE_AUTO and #VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT.<br/>		/// Otherwise, the function may fail and generate a Validation Layers error.<br/>		/// It may also work very slowly when reading from an uncached memory.<br/>		/// `srcAllocationLocalOffset` is relative to the contents of given `srcAllocation`.<br/>		/// If you mean whole allocation, you should pass 0.<br/>		/// Do not pass allocation's offset within device memory block as this parameter!<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCopyAllocationToMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CopyAllocationToMemory(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "srcAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation srcAllocation, [NativeName(NativeNameType.Param, "srcAllocationLocalOffset")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong srcAllocationLocalOffset, [NativeName(NativeNameType.Param, "pDstHostPointer")] [NativeName(NativeNameType.Type, "void*")] void* pDstHostPointer, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong size)
		{
			int ret = VMA.VmaCopyAllocationToMemoryNative(allocator, srcAllocation, srcAllocationLocalOffset, pDstHostPointer, size);
			return ret;
		}

		/// <summary>		/// <br/>		/// Corruption detection is enabled only when `VMA_DEBUG_DETECT_CORRUPTION` macro is defined to nonzero,<br/>		/// `VMA_DEBUG_MARGIN` is defined to nonzero and only for memory types that are<br/>		/// `HOST_VISIBLE` and `HOST_COHERENT`. For more information, see [Corruption detection](<br/>		/// Possible return values:<br/>		/// - `VK_ERROR_FEATURE_NOT_PRESENT` - corruption detection is not enabled for any of specified memory types.<br/>		/// - `VK_SUCCESS` - corruption detection has been performed and succeeded.<br/>		/// - `VK_ERROR_UNKNOWN` - corruption detection has been performed and found memory corruptions around one of the allocations.<br/>		/// `VMA_ASSERT` is also fired in that case.<br/>		/// - Other value: Error returned by Vulkan, e.g. memory mapping failure.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCheckCorruption")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CheckCorruption(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "memoryTypeBits")] [NativeName(NativeNameType.Type, "uint32_t")] uint memoryTypeBits)
		{
			int ret = VMA.VmaCheckCorruptionNative(allocator, memoryTypeBits);
			return ret;
		}

		/// <summary>		/// <br/>		/// For more information about defragmentation, see documentation chapter:<br/>		/// [Defragmentation](<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaBeginDefragmentation")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int BeginDefragmentation(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pInfo")] [NativeName(NativeNameType.Type, "const VmaDefragmentationInfo*")] VmaDefragmentationInfo* pInfo, [NativeName(NativeNameType.Param, "pContext")] [NativeName(NativeNameType.Type, "VmaDefragmentationContext*")] VmaDefragmentationContext* pContext)
		{
			int ret = VMA.VmaBeginDefragmentationNative(allocator, pInfo, pContext);
			return ret;
		}

		/// <summary>		/// <br/>		/// For more information about defragmentation, see documentation chapter:<br/>		/// [Defragmentation](<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaBeginDefragmentation")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int BeginDefragmentation(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pInfo")] [NativeName(NativeNameType.Type, "const VmaDefragmentationInfo*")] ref VmaDefragmentationInfo pInfo, [NativeName(NativeNameType.Param, "pContext")] [NativeName(NativeNameType.Type, "VmaDefragmentationContext*")] VmaDefragmentationContext* pContext)
		{
			fixed (VmaDefragmentationInfo* ppInfo = &pInfo)
			{
				int ret = VMA.VmaBeginDefragmentationNative(allocator, (VmaDefragmentationInfo*)ppInfo, pContext);
				return ret;
			}
		}

		/// <summary>		/// <br/>		/// For more information about defragmentation, see documentation chapter:<br/>		/// [Defragmentation](<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaBeginDefragmentation")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int BeginDefragmentation(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pInfo")] [NativeName(NativeNameType.Type, "const VmaDefragmentationInfo*")] VmaDefragmentationInfo* pInfo, [NativeName(NativeNameType.Param, "pContext")] [NativeName(NativeNameType.Type, "VmaDefragmentationContext*")] ref VmaDefragmentationContext pContext)
		{
			fixed (VmaDefragmentationContext* ppContext = &pContext)
			{
				int ret = VMA.VmaBeginDefragmentationNative(allocator, pInfo, (VmaDefragmentationContext*)ppContext);
				return ret;
			}
		}

		/// <summary>		/// <br/>		/// For more information about defragmentation, see documentation chapter:<br/>		/// [Defragmentation](<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaBeginDefragmentation")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int BeginDefragmentation(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pInfo")] [NativeName(NativeNameType.Type, "const VmaDefragmentationInfo*")] ref VmaDefragmentationInfo pInfo, [NativeName(NativeNameType.Param, "pContext")] [NativeName(NativeNameType.Type, "VmaDefragmentationContext*")] ref VmaDefragmentationContext pContext)
		{
			fixed (VmaDefragmentationInfo* ppInfo = &pInfo)
			{
				fixed (VmaDefragmentationContext* ppContext = &pContext)
				{
					int ret = VMA.VmaBeginDefragmentationNative(allocator, (VmaDefragmentationInfo*)ppInfo, (VmaDefragmentationContext*)ppContext);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// Use this function to finish defragmentation started by vmaBeginDefragmentation().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaEndDefragmentation")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void EndDefragmentation(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "VmaDefragmentationContext")] VmaDefragmentationContext context, [NativeName(NativeNameType.Param, "pStats")] [NativeName(NativeNameType.Type, "VmaDefragmentationStats*")] VmaDefragmentationStats* pStats)
		{
			VMA.VmaEndDefragmentationNative(allocator, context, pStats);
		}

		/// <summary>		/// <br/>		/// Use this function to finish defragmentation started by vmaBeginDefragmentation().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaEndDefragmentation")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void EndDefragmentation(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "VmaDefragmentationContext")] VmaDefragmentationContext context, [NativeName(NativeNameType.Param, "pStats")] [NativeName(NativeNameType.Type, "VmaDefragmentationStats*")] ref VmaDefragmentationStats pStats)
		{
			fixed (VmaDefragmentationStats* ppStats = &pStats)
			{
				VMA.VmaEndDefragmentationNative(allocator, context, (VmaDefragmentationStats*)ppStats);
			}
		}

		/// <summary>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaBeginDefragmentationPass")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int BeginDefragmentationPass(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "VmaDefragmentationContext")] VmaDefragmentationContext context, [NativeName(NativeNameType.Param, "pPassInfo")] [NativeName(NativeNameType.Type, "VmaDefragmentationPassMoveInfo*")] VmaDefragmentationPassMoveInfo* pPassInfo)
		{
			int ret = VMA.VmaBeginDefragmentationPassNative(allocator, context, pPassInfo);
			return ret;
		}

		/// <summary>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaBeginDefragmentationPass")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int BeginDefragmentationPass(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "VmaDefragmentationContext")] VmaDefragmentationContext context, [NativeName(NativeNameType.Param, "pPassInfo")] [NativeName(NativeNameType.Type, "VmaDefragmentationPassMoveInfo*")] ref VmaDefragmentationPassMoveInfo pPassInfo)
		{
			fixed (VmaDefragmentationPassMoveInfo* ppPassInfo = &pPassInfo)
			{
				int ret = VMA.VmaBeginDefragmentationPassNative(allocator, context, (VmaDefragmentationPassMoveInfo*)ppPassInfo);
				return ret;
			}
		}

		/// <summary>		/// <br/>		/// Returns `VK_SUCCESS` if no more moves are possible or `VK_INCOMPLETE` if more defragmentations are possible.<br/>		/// Ends incremental defragmentation pass and commits all defragmentation moves from `pPassInfo`.<br/>		/// After this call:<br/>		/// - Allocations at `pPassInfo[i].srcAllocation` that had `pPassInfo[i].operation ==` #VMA_DEFRAGMENTATION_MOVE_OPERATION_COPY<br/>		/// (which is the default) will be pointing to the new destination place.<br/>		/// - Allocation at `pPassInfo[i].srcAllocation` that had `pPassInfo[i].operation ==` #VMA_DEFRAGMENTATION_MOVE_OPERATION_DESTROY<br/>		/// will be freed.<br/>		/// If no more moves are possible you can end whole defragmentation.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaEndDefragmentationPass")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int EndDefragmentationPass(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "VmaDefragmentationContext")] VmaDefragmentationContext context, [NativeName(NativeNameType.Param, "pPassInfo")] [NativeName(NativeNameType.Type, "VmaDefragmentationPassMoveInfo*")] VmaDefragmentationPassMoveInfo* pPassInfo)
		{
			int ret = VMA.VmaEndDefragmentationPassNative(allocator, context, pPassInfo);
			return ret;
		}

		/// <summary>		/// <br/>		/// Returns `VK_SUCCESS` if no more moves are possible or `VK_INCOMPLETE` if more defragmentations are possible.<br/>		/// Ends incremental defragmentation pass and commits all defragmentation moves from `pPassInfo`.<br/>		/// After this call:<br/>		/// - Allocations at `pPassInfo[i].srcAllocation` that had `pPassInfo[i].operation ==` #VMA_DEFRAGMENTATION_MOVE_OPERATION_COPY<br/>		/// (which is the default) will be pointing to the new destination place.<br/>		/// - Allocation at `pPassInfo[i].srcAllocation` that had `pPassInfo[i].operation ==` #VMA_DEFRAGMENTATION_MOVE_OPERATION_DESTROY<br/>		/// will be freed.<br/>		/// If no more moves are possible you can end whole defragmentation.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaEndDefragmentationPass")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int EndDefragmentationPass(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "VmaDefragmentationContext")] VmaDefragmentationContext context, [NativeName(NativeNameType.Param, "pPassInfo")] [NativeName(NativeNameType.Type, "VmaDefragmentationPassMoveInfo*")] ref VmaDefragmentationPassMoveInfo pPassInfo)
		{
			fixed (VmaDefragmentationPassMoveInfo* ppPassInfo = &pPassInfo)
			{
				int ret = VMA.VmaEndDefragmentationPassNative(allocator, context, (VmaDefragmentationPassMoveInfo*)ppPassInfo);
				return ret;
			}
		}

		/// <summary>		/// <br/>		/// Binds specified buffer to region of memory represented by specified allocation.<br/>		/// Gets `VkDeviceMemory` handle and offset from the allocation.<br/>		/// If you want to create a buffer, allocate memory for it and bind them together separately,<br/>		/// you should use this function for binding instead of standard `vkBindBufferMemory()`,<br/>		/// because it ensures proper synchronization so that when a `VkDeviceMemory` object is used by multiple<br/>		/// allocations, calls to `vkBind*Memory()` or `vkMapMemory()` won't happen from multiple threads simultaneously<br/>		/// (which is illegal in Vulkan).<br/>		/// It is recommended to use function vmaCreateBuffer() instead of this one.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaBindBufferMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int BindBufferMemory(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "VkBuffer")] VkBuffer buffer)
		{
			int ret = VMA.VmaBindBufferMemoryNative(allocator, allocation, buffer);
			return ret;
		}

		/// <summary>		/// <br/>		/// This function is similar to vmaBindBufferMemory(), but it provides additional parameters.<br/>		/// If `pNext` is not null, #VmaAllocator object must have been created with #VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT flag<br/>		/// or with VmaAllocatorCreateInfo::vulkanApiVersion `>= VK_API_VERSION_1_1`. Otherwise the call fails.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaBindBufferMemory2")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int BindBufferMemory2(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "allocationLocalOffset")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong allocationLocalOffset, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "VkBuffer")] VkBuffer buffer, [NativeName(NativeNameType.Param, "pNext")] [NativeName(NativeNameType.Type, "const void*")] void* pNext)
		{
			int ret = VMA.VmaBindBufferMemory2Native(allocator, allocation, allocationLocalOffset, buffer, pNext);
			return ret;
		}

		/// <summary>		/// <br/>		/// Binds specified image to region of memory represented by specified allocation.<br/>		/// Gets `VkDeviceMemory` handle and offset from the allocation.<br/>		/// If you want to create an image, allocate memory for it and bind them together separately,<br/>		/// you should use this function for binding instead of standard `vkBindImageMemory()`,<br/>		/// because it ensures proper synchronization so that when a `VkDeviceMemory` object is used by multiple<br/>		/// allocations, calls to `vkBind*Memory()` or `vkMapMemory()` won't happen from multiple threads simultaneously<br/>		/// (which is illegal in Vulkan).<br/>		/// It is recommended to use function vmaCreateImage() instead of this one.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaBindImageMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int BindImageMemory(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "image")] [NativeName(NativeNameType.Type, "VkImage")] VkImage image)
		{
			int ret = VMA.VmaBindImageMemoryNative(allocator, allocation, image);
			return ret;
		}

		/// <summary>		/// <br/>		/// This function is similar to vmaBindImageMemory(), but it provides additional parameters.<br/>		/// If `pNext` is not null, #VmaAllocator object must have been created with #VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT flag<br/>		/// or with VmaAllocatorCreateInfo::vulkanApiVersion `>= VK_API_VERSION_1_1`. Otherwise the call fails.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaBindImageMemory2")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int BindImageMemory2(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "allocationLocalOffset")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong allocationLocalOffset, [NativeName(NativeNameType.Param, "image")] [NativeName(NativeNameType.Type, "VkImage")] VkImage image, [NativeName(NativeNameType.Param, "pNext")] [NativeName(NativeNameType.Type, "const void*")] void* pNext)
		{
			int ret = VMA.VmaBindImageMemory2Native(allocator, allocation, allocationLocalOffset, image, pNext);
			return ret;
		}

		/// <summary>		/// <br/>		/// This function automatically:<br/>		/// -# Creates buffer.<br/>		/// -# Allocates appropriate memory for it.<br/>		/// -# Binds the buffer with the memory.<br/>		/// If any of these operations fail, buffer and allocation are not created,<br/>		/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>		/// If the function succeeded, you must destroy both buffer and allocation when you<br/>		/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>		/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>		/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>		/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>		/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>		/// and if dedicated allocation is possible<br/>		/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>		/// allocation for this buffer, just like when using<br/>		/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			int ret = VMA.VmaCreateBufferNative(allocator, pBufferCreateInfo, pAllocationCreateInfo, pBuffer, pAllocation, pAllocationInfo);
			return ret;
		}

		/// <summary>		/// <br/>		/// This function automatically:<br/>		/// -# Creates buffer.<br/>		/// -# Allocates appropriate memory for it.<br/>		/// -# Binds the buffer with the memory.<br/>		/// If any of these operations fail, buffer and allocation are not created,<br/>		/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>		/// If the function succeeded, you must destroy both buffer and allocation when you<br/>		/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>		/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>		/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>		/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>		/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>		/// and if dedicated allocation is possible<br/>		/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>		/// allocation for this buffer, just like when using<br/>		/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				int ret = VMA.VmaCreateBufferNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, pAllocationCreateInfo, pBuffer, pAllocation, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>		/// <br/>		/// This function automatically:<br/>		/// -# Creates buffer.<br/>		/// -# Allocates appropriate memory for it.<br/>		/// -# Binds the buffer with the memory.<br/>		/// If any of these operations fail, buffer and allocation are not created,<br/>		/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>		/// If the function succeeded, you must destroy both buffer and allocation when you<br/>		/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>		/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>		/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>		/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>		/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>		/// and if dedicated allocation is possible<br/>		/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>		/// allocation for this buffer, just like when using<br/>		/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				int ret = VMA.VmaCreateBufferNative(allocator, pBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, pBuffer, pAllocation, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>		/// <br/>		/// This function automatically:<br/>		/// -# Creates buffer.<br/>		/// -# Allocates appropriate memory for it.<br/>		/// -# Binds the buffer with the memory.<br/>		/// If any of these operations fail, buffer and allocation are not created,<br/>		/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>		/// If the function succeeded, you must destroy both buffer and allocation when you<br/>		/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>		/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>		/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>		/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>		/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>		/// and if dedicated allocation is possible<br/>		/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>		/// allocation for this buffer, just like when using<br/>		/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					int ret = VMA.VmaCreateBufferNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, pBuffer, pAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// This function automatically:<br/>		/// -# Creates buffer.<br/>		/// -# Allocates appropriate memory for it.<br/>		/// -# Binds the buffer with the memory.<br/>		/// If any of these operations fail, buffer and allocation are not created,<br/>		/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>		/// If the function succeeded, you must destroy both buffer and allocation when you<br/>		/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>		/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>		/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>		/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>		/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>		/// and if dedicated allocation is possible<br/>		/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>		/// allocation for this buffer, just like when using<br/>		/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkBuffer* ppBuffer = &pBuffer)
			{
				int ret = VMA.VmaCreateBufferNative(allocator, pBufferCreateInfo, pAllocationCreateInfo, (VkBuffer*)ppBuffer, pAllocation, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>		/// <br/>		/// This function automatically:<br/>		/// -# Creates buffer.<br/>		/// -# Allocates appropriate memory for it.<br/>		/// -# Binds the buffer with the memory.<br/>		/// If any of these operations fail, buffer and allocation are not created,<br/>		/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>		/// If the function succeeded, you must destroy both buffer and allocation when you<br/>		/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>		/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>		/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>		/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>		/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>		/// and if dedicated allocation is possible<br/>		/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>		/// allocation for this buffer, just like when using<br/>		/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VkBuffer* ppBuffer = &pBuffer)
				{
					int ret = VMA.VmaCreateBufferNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, pAllocationCreateInfo, (VkBuffer*)ppBuffer, pAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// This function automatically:<br/>		/// -# Creates buffer.<br/>		/// -# Allocates appropriate memory for it.<br/>		/// -# Binds the buffer with the memory.<br/>		/// If any of these operations fail, buffer and allocation are not created,<br/>		/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>		/// If the function succeeded, you must destroy both buffer and allocation when you<br/>		/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>		/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>		/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>		/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>		/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>		/// and if dedicated allocation is possible<br/>		/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>		/// allocation for this buffer, just like when using<br/>		/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (VkBuffer* ppBuffer = &pBuffer)
				{
					int ret = VMA.VmaCreateBufferNative(allocator, pBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, (VkBuffer*)ppBuffer, pAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// This function automatically:<br/>		/// -# Creates buffer.<br/>		/// -# Allocates appropriate memory for it.<br/>		/// -# Binds the buffer with the memory.<br/>		/// If any of these operations fail, buffer and allocation are not created,<br/>		/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>		/// If the function succeeded, you must destroy both buffer and allocation when you<br/>		/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>		/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>		/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>		/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>		/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>		/// and if dedicated allocation is possible<br/>		/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>		/// allocation for this buffer, just like when using<br/>		/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					fixed (VkBuffer* ppBuffer = &pBuffer)
					{
						int ret = VMA.VmaCreateBufferNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, (VkBuffer*)ppBuffer, pAllocation, pAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// <br/>		/// This function automatically:<br/>		/// -# Creates buffer.<br/>		/// -# Allocates appropriate memory for it.<br/>		/// -# Binds the buffer with the memory.<br/>		/// If any of these operations fail, buffer and allocation are not created,<br/>		/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>		/// If the function succeeded, you must destroy both buffer and allocation when you<br/>		/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>		/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>		/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>		/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>		/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>		/// and if dedicated allocation is possible<br/>		/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>		/// allocation for this buffer, just like when using<br/>		/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocation* ppAllocation = &pAllocation)
			{
				int ret = VMA.VmaCreateBufferNative(allocator, pBufferCreateInfo, pAllocationCreateInfo, pBuffer, (VmaAllocation*)ppAllocation, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>		/// <br/>		/// This function automatically:<br/>		/// -# Creates buffer.<br/>		/// -# Allocates appropriate memory for it.<br/>		/// -# Binds the buffer with the memory.<br/>		/// If any of these operations fail, buffer and allocation are not created,<br/>		/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>		/// If the function succeeded, you must destroy both buffer and allocation when you<br/>		/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>		/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>		/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>		/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>		/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>		/// and if dedicated allocation is possible<br/>		/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>		/// allocation for this buffer, just like when using<br/>		/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					int ret = VMA.VmaCreateBufferNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, pAllocationCreateInfo, pBuffer, (VmaAllocation*)ppAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// This function automatically:<br/>		/// -# Creates buffer.<br/>		/// -# Allocates appropriate memory for it.<br/>		/// -# Binds the buffer with the memory.<br/>		/// If any of these operations fail, buffer and allocation are not created,<br/>		/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>		/// If the function succeeded, you must destroy both buffer and allocation when you<br/>		/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>		/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>		/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>		/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>		/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>		/// and if dedicated allocation is possible<br/>		/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>		/// allocation for this buffer, just like when using<br/>		/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					int ret = VMA.VmaCreateBufferNative(allocator, pBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, pBuffer, (VmaAllocation*)ppAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// This function automatically:<br/>		/// -# Creates buffer.<br/>		/// -# Allocates appropriate memory for it.<br/>		/// -# Binds the buffer with the memory.<br/>		/// If any of these operations fail, buffer and allocation are not created,<br/>		/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>		/// If the function succeeded, you must destroy both buffer and allocation when you<br/>		/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>		/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>		/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>		/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>		/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>		/// and if dedicated allocation is possible<br/>		/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>		/// allocation for this buffer, just like when using<br/>		/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					fixed (VmaAllocation* ppAllocation = &pAllocation)
					{
						int ret = VMA.VmaCreateBufferNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, pBuffer, (VmaAllocation*)ppAllocation, pAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// <br/>		/// This function automatically:<br/>		/// -# Creates buffer.<br/>		/// -# Allocates appropriate memory for it.<br/>		/// -# Binds the buffer with the memory.<br/>		/// If any of these operations fail, buffer and allocation are not created,<br/>		/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>		/// If the function succeeded, you must destroy both buffer and allocation when you<br/>		/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>		/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>		/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>		/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>		/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>		/// and if dedicated allocation is possible<br/>		/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>		/// allocation for this buffer, just like when using<br/>		/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkBuffer* ppBuffer = &pBuffer)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					int ret = VMA.VmaCreateBufferNative(allocator, pBufferCreateInfo, pAllocationCreateInfo, (VkBuffer*)ppBuffer, (VmaAllocation*)ppAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// This function automatically:<br/>		/// -# Creates buffer.<br/>		/// -# Allocates appropriate memory for it.<br/>		/// -# Binds the buffer with the memory.<br/>		/// If any of these operations fail, buffer and allocation are not created,<br/>		/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>		/// If the function succeeded, you must destroy both buffer and allocation when you<br/>		/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>		/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>		/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>		/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>		/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>		/// and if dedicated allocation is possible<br/>		/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>		/// allocation for this buffer, just like when using<br/>		/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VkBuffer* ppBuffer = &pBuffer)
				{
					fixed (VmaAllocation* ppAllocation = &pAllocation)
					{
						int ret = VMA.VmaCreateBufferNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, pAllocationCreateInfo, (VkBuffer*)ppBuffer, (VmaAllocation*)ppAllocation, pAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// <br/>		/// This function automatically:<br/>		/// -# Creates buffer.<br/>		/// -# Allocates appropriate memory for it.<br/>		/// -# Binds the buffer with the memory.<br/>		/// If any of these operations fail, buffer and allocation are not created,<br/>		/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>		/// If the function succeeded, you must destroy both buffer and allocation when you<br/>		/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>		/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>		/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>		/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>		/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>		/// and if dedicated allocation is possible<br/>		/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>		/// allocation for this buffer, just like when using<br/>		/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (VkBuffer* ppBuffer = &pBuffer)
				{
					fixed (VmaAllocation* ppAllocation = &pAllocation)
					{
						int ret = VMA.VmaCreateBufferNative(allocator, pBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, (VkBuffer*)ppBuffer, (VmaAllocation*)ppAllocation, pAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// <br/>		/// This function automatically:<br/>		/// -# Creates buffer.<br/>		/// -# Allocates appropriate memory for it.<br/>		/// -# Binds the buffer with the memory.<br/>		/// If any of these operations fail, buffer and allocation are not created,<br/>		/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>		/// If the function succeeded, you must destroy both buffer and allocation when you<br/>		/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>		/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>		/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>		/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>		/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>		/// and if dedicated allocation is possible<br/>		/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>		/// allocation for this buffer, just like when using<br/>		/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					fixed (VkBuffer* ppBuffer = &pBuffer)
					{
						fixed (VmaAllocation* ppAllocation = &pAllocation)
						{
							int ret = VMA.VmaCreateBufferNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, (VkBuffer*)ppBuffer, (VmaAllocation*)ppAllocation, pAllocationInfo);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// <br/>		/// This function automatically:<br/>		/// -# Creates buffer.<br/>		/// -# Allocates appropriate memory for it.<br/>		/// -# Binds the buffer with the memory.<br/>		/// If any of these operations fail, buffer and allocation are not created,<br/>		/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>		/// If the function succeeded, you must destroy both buffer and allocation when you<br/>		/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>		/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>		/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>		/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>		/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>		/// and if dedicated allocation is possible<br/>		/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>		/// allocation for this buffer, just like when using<br/>		/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
			{
				int ret = VMA.VmaCreateBufferNative(allocator, pBufferCreateInfo, pAllocationCreateInfo, pBuffer, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
				return ret;
			}
		}

		/// <summary>		/// <br/>		/// This function automatically:<br/>		/// -# Creates buffer.<br/>		/// -# Allocates appropriate memory for it.<br/>		/// -# Binds the buffer with the memory.<br/>		/// If any of these operations fail, buffer and allocation are not created,<br/>		/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>		/// If the function succeeded, you must destroy both buffer and allocation when you<br/>		/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>		/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>		/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>		/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>		/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>		/// and if dedicated allocation is possible<br/>		/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>		/// allocation for this buffer, just like when using<br/>		/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					int ret = VMA.VmaCreateBufferNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, pAllocationCreateInfo, pBuffer, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// This function automatically:<br/>		/// -# Creates buffer.<br/>		/// -# Allocates appropriate memory for it.<br/>		/// -# Binds the buffer with the memory.<br/>		/// If any of these operations fail, buffer and allocation are not created,<br/>		/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>		/// If the function succeeded, you must destroy both buffer and allocation when you<br/>		/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>		/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>		/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>		/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>		/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>		/// and if dedicated allocation is possible<br/>		/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>		/// allocation for this buffer, just like when using<br/>		/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					int ret = VMA.VmaCreateBufferNative(allocator, pBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, pBuffer, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// This function automatically:<br/>		/// -# Creates buffer.<br/>		/// -# Allocates appropriate memory for it.<br/>		/// -# Binds the buffer with the memory.<br/>		/// If any of these operations fail, buffer and allocation are not created,<br/>		/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>		/// If the function succeeded, you must destroy both buffer and allocation when you<br/>		/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>		/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>		/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>		/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>		/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>		/// and if dedicated allocation is possible<br/>		/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>		/// allocation for this buffer, just like when using<br/>		/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						int ret = VMA.VmaCreateBufferNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, pBuffer, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// <br/>		/// This function automatically:<br/>		/// -# Creates buffer.<br/>		/// -# Allocates appropriate memory for it.<br/>		/// -# Binds the buffer with the memory.<br/>		/// If any of these operations fail, buffer and allocation are not created,<br/>		/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>		/// If the function succeeded, you must destroy both buffer and allocation when you<br/>		/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>		/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>		/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>		/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>		/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>		/// and if dedicated allocation is possible<br/>		/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>		/// allocation for this buffer, just like when using<br/>		/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkBuffer* ppBuffer = &pBuffer)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					int ret = VMA.VmaCreateBufferNative(allocator, pBufferCreateInfo, pAllocationCreateInfo, (VkBuffer*)ppBuffer, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// This function automatically:<br/>		/// -# Creates buffer.<br/>		/// -# Allocates appropriate memory for it.<br/>		/// -# Binds the buffer with the memory.<br/>		/// If any of these operations fail, buffer and allocation are not created,<br/>		/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>		/// If the function succeeded, you must destroy both buffer and allocation when you<br/>		/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>		/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>		/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>		/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>		/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>		/// and if dedicated allocation is possible<br/>		/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>		/// allocation for this buffer, just like when using<br/>		/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VkBuffer* ppBuffer = &pBuffer)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						int ret = VMA.VmaCreateBufferNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, pAllocationCreateInfo, (VkBuffer*)ppBuffer, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// <br/>		/// This function automatically:<br/>		/// -# Creates buffer.<br/>		/// -# Allocates appropriate memory for it.<br/>		/// -# Binds the buffer with the memory.<br/>		/// If any of these operations fail, buffer and allocation are not created,<br/>		/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>		/// If the function succeeded, you must destroy both buffer and allocation when you<br/>		/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>		/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>		/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>		/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>		/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>		/// and if dedicated allocation is possible<br/>		/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>		/// allocation for this buffer, just like when using<br/>		/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (VkBuffer* ppBuffer = &pBuffer)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						int ret = VMA.VmaCreateBufferNative(allocator, pBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, (VkBuffer*)ppBuffer, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// <br/>		/// This function automatically:<br/>		/// -# Creates buffer.<br/>		/// -# Allocates appropriate memory for it.<br/>		/// -# Binds the buffer with the memory.<br/>		/// If any of these operations fail, buffer and allocation are not created,<br/>		/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>		/// If the function succeeded, you must destroy both buffer and allocation when you<br/>		/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>		/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>		/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>		/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>		/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>		/// and if dedicated allocation is possible<br/>		/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>		/// allocation for this buffer, just like when using<br/>		/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					fixed (VkBuffer* ppBuffer = &pBuffer)
					{
						fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
						{
							int ret = VMA.VmaCreateBufferNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, (VkBuffer*)ppBuffer, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// <br/>		/// This function automatically:<br/>		/// -# Creates buffer.<br/>		/// -# Allocates appropriate memory for it.<br/>		/// -# Binds the buffer with the memory.<br/>		/// If any of these operations fail, buffer and allocation are not created,<br/>		/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>		/// If the function succeeded, you must destroy both buffer and allocation when you<br/>		/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>		/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>		/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>		/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>		/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>		/// and if dedicated allocation is possible<br/>		/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>		/// allocation for this buffer, just like when using<br/>		/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocation* ppAllocation = &pAllocation)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					int ret = VMA.VmaCreateBufferNative(allocator, pBufferCreateInfo, pAllocationCreateInfo, pBuffer, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// This function automatically:<br/>		/// -# Creates buffer.<br/>		/// -# Allocates appropriate memory for it.<br/>		/// -# Binds the buffer with the memory.<br/>		/// If any of these operations fail, buffer and allocation are not created,<br/>		/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>		/// If the function succeeded, you must destroy both buffer and allocation when you<br/>		/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>		/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>		/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>		/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>		/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>		/// and if dedicated allocation is possible<br/>		/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>		/// allocation for this buffer, just like when using<br/>		/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						int ret = VMA.VmaCreateBufferNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, pAllocationCreateInfo, pBuffer, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// <br/>		/// This function automatically:<br/>		/// -# Creates buffer.<br/>		/// -# Allocates appropriate memory for it.<br/>		/// -# Binds the buffer with the memory.<br/>		/// If any of these operations fail, buffer and allocation are not created,<br/>		/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>		/// If the function succeeded, you must destroy both buffer and allocation when you<br/>		/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>		/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>		/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>		/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>		/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>		/// and if dedicated allocation is possible<br/>		/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>		/// allocation for this buffer, just like when using<br/>		/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						int ret = VMA.VmaCreateBufferNative(allocator, pBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, pBuffer, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// <br/>		/// This function automatically:<br/>		/// -# Creates buffer.<br/>		/// -# Allocates appropriate memory for it.<br/>		/// -# Binds the buffer with the memory.<br/>		/// If any of these operations fail, buffer and allocation are not created,<br/>		/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>		/// If the function succeeded, you must destroy both buffer and allocation when you<br/>		/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>		/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>		/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>		/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>		/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>		/// and if dedicated allocation is possible<br/>		/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>		/// allocation for this buffer, just like when using<br/>		/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					fixed (VmaAllocation* ppAllocation = &pAllocation)
					{
						fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
						{
							int ret = VMA.VmaCreateBufferNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, pBuffer, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// <br/>		/// This function automatically:<br/>		/// -# Creates buffer.<br/>		/// -# Allocates appropriate memory for it.<br/>		/// -# Binds the buffer with the memory.<br/>		/// If any of these operations fail, buffer and allocation are not created,<br/>		/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>		/// If the function succeeded, you must destroy both buffer and allocation when you<br/>		/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>		/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>		/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>		/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>		/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>		/// and if dedicated allocation is possible<br/>		/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>		/// allocation for this buffer, just like when using<br/>		/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkBuffer* ppBuffer = &pBuffer)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						int ret = VMA.VmaCreateBufferNative(allocator, pBufferCreateInfo, pAllocationCreateInfo, (VkBuffer*)ppBuffer, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// <br/>		/// This function automatically:<br/>		/// -# Creates buffer.<br/>		/// -# Allocates appropriate memory for it.<br/>		/// -# Binds the buffer with the memory.<br/>		/// If any of these operations fail, buffer and allocation are not created,<br/>		/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>		/// If the function succeeded, you must destroy both buffer and allocation when you<br/>		/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>		/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>		/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>		/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>		/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>		/// and if dedicated allocation is possible<br/>		/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>		/// allocation for this buffer, just like when using<br/>		/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VkBuffer* ppBuffer = &pBuffer)
				{
					fixed (VmaAllocation* ppAllocation = &pAllocation)
					{
						fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
						{
							int ret = VMA.VmaCreateBufferNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, pAllocationCreateInfo, (VkBuffer*)ppBuffer, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// <br/>		/// This function automatically:<br/>		/// -# Creates buffer.<br/>		/// -# Allocates appropriate memory for it.<br/>		/// -# Binds the buffer with the memory.<br/>		/// If any of these operations fail, buffer and allocation are not created,<br/>		/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>		/// If the function succeeded, you must destroy both buffer and allocation when you<br/>		/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>		/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>		/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>		/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>		/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>		/// and if dedicated allocation is possible<br/>		/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>		/// allocation for this buffer, just like when using<br/>		/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (VkBuffer* ppBuffer = &pBuffer)
				{
					fixed (VmaAllocation* ppAllocation = &pAllocation)
					{
						fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
						{
							int ret = VMA.VmaCreateBufferNative(allocator, pBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, (VkBuffer*)ppBuffer, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// <br/>		/// This function automatically:<br/>		/// -# Creates buffer.<br/>		/// -# Allocates appropriate memory for it.<br/>		/// -# Binds the buffer with the memory.<br/>		/// If any of these operations fail, buffer and allocation are not created,<br/>		/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>		/// If the function succeeded, you must destroy both buffer and allocation when you<br/>		/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>		/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>		/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>		/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>		/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>		/// and if dedicated allocation is possible<br/>		/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>		/// allocation for this buffer, just like when using<br/>		/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					fixed (VkBuffer* ppBuffer = &pBuffer)
					{
						fixed (VmaAllocation* ppAllocation = &pAllocation)
						{
							fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
							{
								int ret = VMA.VmaCreateBufferNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, (VkBuffer*)ppBuffer, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>		/// <br/>		/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>		/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>		/// for interop with OpenGL.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBufferWithAlignment(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			int ret = VMA.VmaCreateBufferWithAlignmentNative(allocator, pBufferCreateInfo, pAllocationCreateInfo, minAlignment, pBuffer, pAllocation, pAllocationInfo);
			return ret;
		}

		/// <summary>		/// <br/>		/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>		/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>		/// for interop with OpenGL.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBufferWithAlignment(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				int ret = VMA.VmaCreateBufferWithAlignmentNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, pAllocationCreateInfo, minAlignment, pBuffer, pAllocation, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>		/// <br/>		/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>		/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>		/// for interop with OpenGL.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBufferWithAlignment(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				int ret = VMA.VmaCreateBufferWithAlignmentNative(allocator, pBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, minAlignment, pBuffer, pAllocation, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>		/// <br/>		/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>		/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>		/// for interop with OpenGL.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBufferWithAlignment(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					int ret = VMA.VmaCreateBufferWithAlignmentNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, minAlignment, pBuffer, pAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>		/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>		/// for interop with OpenGL.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBufferWithAlignment(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkBuffer* ppBuffer = &pBuffer)
			{
				int ret = VMA.VmaCreateBufferWithAlignmentNative(allocator, pBufferCreateInfo, pAllocationCreateInfo, minAlignment, (VkBuffer*)ppBuffer, pAllocation, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>		/// <br/>		/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>		/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>		/// for interop with OpenGL.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBufferWithAlignment(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VkBuffer* ppBuffer = &pBuffer)
				{
					int ret = VMA.VmaCreateBufferWithAlignmentNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, pAllocationCreateInfo, minAlignment, (VkBuffer*)ppBuffer, pAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>		/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>		/// for interop with OpenGL.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBufferWithAlignment(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (VkBuffer* ppBuffer = &pBuffer)
				{
					int ret = VMA.VmaCreateBufferWithAlignmentNative(allocator, pBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, minAlignment, (VkBuffer*)ppBuffer, pAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>		/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>		/// for interop with OpenGL.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBufferWithAlignment(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					fixed (VkBuffer* ppBuffer = &pBuffer)
					{
						int ret = VMA.VmaCreateBufferWithAlignmentNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, minAlignment, (VkBuffer*)ppBuffer, pAllocation, pAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// <br/>		/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>		/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>		/// for interop with OpenGL.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBufferWithAlignment(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocation* ppAllocation = &pAllocation)
			{
				int ret = VMA.VmaCreateBufferWithAlignmentNative(allocator, pBufferCreateInfo, pAllocationCreateInfo, minAlignment, pBuffer, (VmaAllocation*)ppAllocation, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>		/// <br/>		/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>		/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>		/// for interop with OpenGL.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBufferWithAlignment(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					int ret = VMA.VmaCreateBufferWithAlignmentNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, pAllocationCreateInfo, minAlignment, pBuffer, (VmaAllocation*)ppAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>		/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>		/// for interop with OpenGL.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBufferWithAlignment(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					int ret = VMA.VmaCreateBufferWithAlignmentNative(allocator, pBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, minAlignment, pBuffer, (VmaAllocation*)ppAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>		/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>		/// for interop with OpenGL.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBufferWithAlignment(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					fixed (VmaAllocation* ppAllocation = &pAllocation)
					{
						int ret = VMA.VmaCreateBufferWithAlignmentNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, minAlignment, pBuffer, (VmaAllocation*)ppAllocation, pAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// <br/>		/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>		/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>		/// for interop with OpenGL.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBufferWithAlignment(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkBuffer* ppBuffer = &pBuffer)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					int ret = VMA.VmaCreateBufferWithAlignmentNative(allocator, pBufferCreateInfo, pAllocationCreateInfo, minAlignment, (VkBuffer*)ppBuffer, (VmaAllocation*)ppAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>		/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>		/// for interop with OpenGL.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBufferWithAlignment(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VkBuffer* ppBuffer = &pBuffer)
				{
					fixed (VmaAllocation* ppAllocation = &pAllocation)
					{
						int ret = VMA.VmaCreateBufferWithAlignmentNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, pAllocationCreateInfo, minAlignment, (VkBuffer*)ppBuffer, (VmaAllocation*)ppAllocation, pAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// <br/>		/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>		/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>		/// for interop with OpenGL.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBufferWithAlignment(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (VkBuffer* ppBuffer = &pBuffer)
				{
					fixed (VmaAllocation* ppAllocation = &pAllocation)
					{
						int ret = VMA.VmaCreateBufferWithAlignmentNative(allocator, pBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, minAlignment, (VkBuffer*)ppBuffer, (VmaAllocation*)ppAllocation, pAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// <br/>		/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>		/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>		/// for interop with OpenGL.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBufferWithAlignment(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					fixed (VkBuffer* ppBuffer = &pBuffer)
					{
						fixed (VmaAllocation* ppAllocation = &pAllocation)
						{
							int ret = VMA.VmaCreateBufferWithAlignmentNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, minAlignment, (VkBuffer*)ppBuffer, (VmaAllocation*)ppAllocation, pAllocationInfo);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// <br/>		/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>		/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>		/// for interop with OpenGL.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBufferWithAlignment(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
			{
				int ret = VMA.VmaCreateBufferWithAlignmentNative(allocator, pBufferCreateInfo, pAllocationCreateInfo, minAlignment, pBuffer, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
				return ret;
			}
		}

		/// <summary>		/// <br/>		/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>		/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>		/// for interop with OpenGL.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBufferWithAlignment(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					int ret = VMA.VmaCreateBufferWithAlignmentNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, pAllocationCreateInfo, minAlignment, pBuffer, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>		/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>		/// for interop with OpenGL.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBufferWithAlignment(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					int ret = VMA.VmaCreateBufferWithAlignmentNative(allocator, pBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, minAlignment, pBuffer, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>		/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>		/// for interop with OpenGL.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBufferWithAlignment(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						int ret = VMA.VmaCreateBufferWithAlignmentNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, minAlignment, pBuffer, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// <br/>		/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>		/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>		/// for interop with OpenGL.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBufferWithAlignment(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkBuffer* ppBuffer = &pBuffer)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					int ret = VMA.VmaCreateBufferWithAlignmentNative(allocator, pBufferCreateInfo, pAllocationCreateInfo, minAlignment, (VkBuffer*)ppBuffer, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>		/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>		/// for interop with OpenGL.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBufferWithAlignment(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VkBuffer* ppBuffer = &pBuffer)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						int ret = VMA.VmaCreateBufferWithAlignmentNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, pAllocationCreateInfo, minAlignment, (VkBuffer*)ppBuffer, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// <br/>		/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>		/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>		/// for interop with OpenGL.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBufferWithAlignment(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (VkBuffer* ppBuffer = &pBuffer)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						int ret = VMA.VmaCreateBufferWithAlignmentNative(allocator, pBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, minAlignment, (VkBuffer*)ppBuffer, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// <br/>		/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>		/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>		/// for interop with OpenGL.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBufferWithAlignment(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					fixed (VkBuffer* ppBuffer = &pBuffer)
					{
						fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
						{
							int ret = VMA.VmaCreateBufferWithAlignmentNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, minAlignment, (VkBuffer*)ppBuffer, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// <br/>		/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>		/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>		/// for interop with OpenGL.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBufferWithAlignment(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocation* ppAllocation = &pAllocation)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					int ret = VMA.VmaCreateBufferWithAlignmentNative(allocator, pBufferCreateInfo, pAllocationCreateInfo, minAlignment, pBuffer, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>		/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>		/// for interop with OpenGL.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBufferWithAlignment(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						int ret = VMA.VmaCreateBufferWithAlignmentNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, pAllocationCreateInfo, minAlignment, pBuffer, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// <br/>		/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>		/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>		/// for interop with OpenGL.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBufferWithAlignment(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						int ret = VMA.VmaCreateBufferWithAlignmentNative(allocator, pBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, minAlignment, pBuffer, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// <br/>		/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>		/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>		/// for interop with OpenGL.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBufferWithAlignment(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					fixed (VmaAllocation* ppAllocation = &pAllocation)
					{
						fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
						{
							int ret = VMA.VmaCreateBufferWithAlignmentNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, minAlignment, pBuffer, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// <br/>		/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>		/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>		/// for interop with OpenGL.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBufferWithAlignment(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkBuffer* ppBuffer = &pBuffer)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						int ret = VMA.VmaCreateBufferWithAlignmentNative(allocator, pBufferCreateInfo, pAllocationCreateInfo, minAlignment, (VkBuffer*)ppBuffer, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// <br/>		/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>		/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>		/// for interop with OpenGL.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBufferWithAlignment(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VkBuffer* ppBuffer = &pBuffer)
				{
					fixed (VmaAllocation* ppAllocation = &pAllocation)
					{
						fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
						{
							int ret = VMA.VmaCreateBufferWithAlignmentNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, pAllocationCreateInfo, minAlignment, (VkBuffer*)ppBuffer, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// <br/>		/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>		/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>		/// for interop with OpenGL.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBufferWithAlignment(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (VkBuffer* ppBuffer = &pBuffer)
				{
					fixed (VmaAllocation* ppAllocation = &pAllocation)
					{
						fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
						{
							int ret = VMA.VmaCreateBufferWithAlignmentNative(allocator, pBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, minAlignment, (VkBuffer*)ppBuffer, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// <br/>		/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>		/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>		/// for interop with OpenGL.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateBufferWithAlignment(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					fixed (VkBuffer* ppBuffer = &pBuffer)
					{
						fixed (VmaAllocation* ppAllocation = &pAllocation)
						{
							fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
							{
								int ret = VMA.VmaCreateBufferWithAlignmentNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, minAlignment, (VkBuffer*)ppBuffer, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>		/// <br/>		/// This function automatically:<br/>		/// -# Creates buffer.<br/>		/// -# Binds the buffer with the supplied memory.<br/>		/// If any of these operations fail, buffer is not created,<br/>		/// returned value is negative error code and `*pBuffer` is null.<br/>		/// If the function succeeded, you must destroy the buffer when you<br/>		/// no longer need it using `vkDestroyBuffer()`. If you want to also destroy the corresponding<br/>		/// allocation you can use convenience function vmaDestroyBuffer().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateAliasingBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateAliasingBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer)
		{
			int ret = VMA.VmaCreateAliasingBufferNative(allocator, allocation, pBufferCreateInfo, pBuffer);
			return ret;
		}

		/// <summary>		/// <br/>		/// This function automatically:<br/>		/// -# Creates buffer.<br/>		/// -# Binds the buffer with the supplied memory.<br/>		/// If any of these operations fail, buffer is not created,<br/>		/// returned value is negative error code and `*pBuffer` is null.<br/>		/// If the function succeeded, you must destroy the buffer when you<br/>		/// no longer need it using `vkDestroyBuffer()`. If you want to also destroy the corresponding<br/>		/// allocation you can use convenience function vmaDestroyBuffer().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateAliasingBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateAliasingBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				int ret = VMA.VmaCreateAliasingBufferNative(allocator, allocation, (VkBufferCreateInfo*)ppBufferCreateInfo, pBuffer);
				return ret;
			}
		}

		/// <summary>		/// <br/>		/// This function automatically:<br/>		/// -# Creates buffer.<br/>		/// -# Binds the buffer with the supplied memory.<br/>		/// If any of these operations fail, buffer is not created,<br/>		/// returned value is negative error code and `*pBuffer` is null.<br/>		/// If the function succeeded, you must destroy the buffer when you<br/>		/// no longer need it using `vkDestroyBuffer()`. If you want to also destroy the corresponding<br/>		/// allocation you can use convenience function vmaDestroyBuffer().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateAliasingBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateAliasingBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer)
		{
			fixed (VkBuffer* ppBuffer = &pBuffer)
			{
				int ret = VMA.VmaCreateAliasingBufferNative(allocator, allocation, pBufferCreateInfo, (VkBuffer*)ppBuffer);
				return ret;
			}
		}

		/// <summary>		/// <br/>		/// This function automatically:<br/>		/// -# Creates buffer.<br/>		/// -# Binds the buffer with the supplied memory.<br/>		/// If any of these operations fail, buffer is not created,<br/>		/// returned value is negative error code and `*pBuffer` is null.<br/>		/// If the function succeeded, you must destroy the buffer when you<br/>		/// no longer need it using `vkDestroyBuffer()`. If you want to also destroy the corresponding<br/>		/// allocation you can use convenience function vmaDestroyBuffer().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateAliasingBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateAliasingBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VkBuffer* ppBuffer = &pBuffer)
				{
					int ret = VMA.VmaCreateAliasingBufferNative(allocator, allocation, (VkBufferCreateInfo*)ppBufferCreateInfo, (VkBuffer*)ppBuffer);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// This function automatically:<br/>		/// -# Creates buffer.<br/>		/// -# Binds the buffer with the supplied memory.<br/>		/// If any of these operations fail, buffer is not created,<br/>		/// returned value is negative error code and `*pBuffer` is null.<br/>		/// If the function succeeded, you must destroy the buffer when you<br/>		/// no longer need it using `vkDestroyBuffer()`. If you want to also destroy the corresponding<br/>		/// allocation you can use convenience function vmaDestroyBuffer().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateAliasingBuffer2")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateAliasingBuffer2(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "allocationLocalOffset")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong allocationLocalOffset, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer)
		{
			int ret = VMA.VmaCreateAliasingBuffer2Native(allocator, allocation, allocationLocalOffset, pBufferCreateInfo, pBuffer);
			return ret;
		}

		/// <summary>		/// <br/>		/// This function automatically:<br/>		/// -# Creates buffer.<br/>		/// -# Binds the buffer with the supplied memory.<br/>		/// If any of these operations fail, buffer is not created,<br/>		/// returned value is negative error code and `*pBuffer` is null.<br/>		/// If the function succeeded, you must destroy the buffer when you<br/>		/// no longer need it using `vkDestroyBuffer()`. If you want to also destroy the corresponding<br/>		/// allocation you can use convenience function vmaDestroyBuffer().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateAliasingBuffer2")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateAliasingBuffer2(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "allocationLocalOffset")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong allocationLocalOffset, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				int ret = VMA.VmaCreateAliasingBuffer2Native(allocator, allocation, allocationLocalOffset, (VkBufferCreateInfo*)ppBufferCreateInfo, pBuffer);
				return ret;
			}
		}

		/// <summary>		/// <br/>		/// This function automatically:<br/>		/// -# Creates buffer.<br/>		/// -# Binds the buffer with the supplied memory.<br/>		/// If any of these operations fail, buffer is not created,<br/>		/// returned value is negative error code and `*pBuffer` is null.<br/>		/// If the function succeeded, you must destroy the buffer when you<br/>		/// no longer need it using `vkDestroyBuffer()`. If you want to also destroy the corresponding<br/>		/// allocation you can use convenience function vmaDestroyBuffer().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateAliasingBuffer2")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateAliasingBuffer2(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "allocationLocalOffset")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong allocationLocalOffset, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer)
		{
			fixed (VkBuffer* ppBuffer = &pBuffer)
			{
				int ret = VMA.VmaCreateAliasingBuffer2Native(allocator, allocation, allocationLocalOffset, pBufferCreateInfo, (VkBuffer*)ppBuffer);
				return ret;
			}
		}

		/// <summary>		/// <br/>		/// This function automatically:<br/>		/// -# Creates buffer.<br/>		/// -# Binds the buffer with the supplied memory.<br/>		/// If any of these operations fail, buffer is not created,<br/>		/// returned value is negative error code and `*pBuffer` is null.<br/>		/// If the function succeeded, you must destroy the buffer when you<br/>		/// no longer need it using `vkDestroyBuffer()`. If you want to also destroy the corresponding<br/>		/// allocation you can use convenience function vmaDestroyBuffer().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateAliasingBuffer2")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateAliasingBuffer2(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "allocationLocalOffset")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong allocationLocalOffset, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VkBuffer* ppBuffer = &pBuffer)
				{
					int ret = VMA.VmaCreateAliasingBuffer2Native(allocator, allocation, allocationLocalOffset, (VkBufferCreateInfo*)ppBufferCreateInfo, (VkBuffer*)ppBuffer);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// This is just a convenience function equivalent to:<br/>		/// It is safe to pass null as buffer and/or allocation.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaDestroyBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroyBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "VkBuffer")] VkBuffer buffer, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation)
		{
			VMA.VmaDestroyBufferNative(allocator, buffer, allocation);
		}

		/// <summary>		/// Function similar to vmaCreateBuffer().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateImage(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] VkImage* pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			int ret = VMA.VmaCreateImageNative(allocator, pImageCreateInfo, pAllocationCreateInfo, pImage, pAllocation, pAllocationInfo);
			return ret;
		}

		/// <summary>		/// Function similar to vmaCreateBuffer().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateImage(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] ref VkImageCreateInfo pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] VkImage* pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkImageCreateInfo* ppImageCreateInfo = &pImageCreateInfo)
			{
				int ret = VMA.VmaCreateImageNative(allocator, (VkImageCreateInfo*)ppImageCreateInfo, pAllocationCreateInfo, pImage, pAllocation, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>		/// Function similar to vmaCreateBuffer().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateImage(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] VkImage* pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				int ret = VMA.VmaCreateImageNative(allocator, pImageCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, pImage, pAllocation, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>		/// Function similar to vmaCreateBuffer().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateImage(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] ref VkImageCreateInfo pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] VkImage* pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkImageCreateInfo* ppImageCreateInfo = &pImageCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					int ret = VMA.VmaCreateImageNative(allocator, (VkImageCreateInfo*)ppImageCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, pImage, pAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>		/// Function similar to vmaCreateBuffer().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateImage(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] ref VkImage pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkImage* ppImage = &pImage)
			{
				int ret = VMA.VmaCreateImageNative(allocator, pImageCreateInfo, pAllocationCreateInfo, (VkImage*)ppImage, pAllocation, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>		/// Function similar to vmaCreateBuffer().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateImage(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] ref VkImageCreateInfo pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] ref VkImage pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkImageCreateInfo* ppImageCreateInfo = &pImageCreateInfo)
			{
				fixed (VkImage* ppImage = &pImage)
				{
					int ret = VMA.VmaCreateImageNative(allocator, (VkImageCreateInfo*)ppImageCreateInfo, pAllocationCreateInfo, (VkImage*)ppImage, pAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>		/// Function similar to vmaCreateBuffer().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateImage(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] ref VkImage pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (VkImage* ppImage = &pImage)
				{
					int ret = VMA.VmaCreateImageNative(allocator, pImageCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, (VkImage*)ppImage, pAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>		/// Function similar to vmaCreateBuffer().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateImage(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] ref VkImageCreateInfo pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] ref VkImage pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkImageCreateInfo* ppImageCreateInfo = &pImageCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					fixed (VkImage* ppImage = &pImage)
					{
						int ret = VMA.VmaCreateImageNative(allocator, (VkImageCreateInfo*)ppImageCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, (VkImage*)ppImage, pAllocation, pAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Function similar to vmaCreateBuffer().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateImage(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] VkImage* pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocation* ppAllocation = &pAllocation)
			{
				int ret = VMA.VmaCreateImageNative(allocator, pImageCreateInfo, pAllocationCreateInfo, pImage, (VmaAllocation*)ppAllocation, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>		/// Function similar to vmaCreateBuffer().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateImage(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] ref VkImageCreateInfo pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] VkImage* pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkImageCreateInfo* ppImageCreateInfo = &pImageCreateInfo)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					int ret = VMA.VmaCreateImageNative(allocator, (VkImageCreateInfo*)ppImageCreateInfo, pAllocationCreateInfo, pImage, (VmaAllocation*)ppAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>		/// Function similar to vmaCreateBuffer().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateImage(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] VkImage* pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					int ret = VMA.VmaCreateImageNative(allocator, pImageCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, pImage, (VmaAllocation*)ppAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>		/// Function similar to vmaCreateBuffer().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateImage(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] ref VkImageCreateInfo pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] VkImage* pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkImageCreateInfo* ppImageCreateInfo = &pImageCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					fixed (VmaAllocation* ppAllocation = &pAllocation)
					{
						int ret = VMA.VmaCreateImageNative(allocator, (VkImageCreateInfo*)ppImageCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, pImage, (VmaAllocation*)ppAllocation, pAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Function similar to vmaCreateBuffer().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateImage(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] ref VkImage pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkImage* ppImage = &pImage)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					int ret = VMA.VmaCreateImageNative(allocator, pImageCreateInfo, pAllocationCreateInfo, (VkImage*)ppImage, (VmaAllocation*)ppAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>		/// Function similar to vmaCreateBuffer().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateImage(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] ref VkImageCreateInfo pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] ref VkImage pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkImageCreateInfo* ppImageCreateInfo = &pImageCreateInfo)
			{
				fixed (VkImage* ppImage = &pImage)
				{
					fixed (VmaAllocation* ppAllocation = &pAllocation)
					{
						int ret = VMA.VmaCreateImageNative(allocator, (VkImageCreateInfo*)ppImageCreateInfo, pAllocationCreateInfo, (VkImage*)ppImage, (VmaAllocation*)ppAllocation, pAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Function similar to vmaCreateBuffer().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateImage(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] ref VkImage pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (VkImage* ppImage = &pImage)
				{
					fixed (VmaAllocation* ppAllocation = &pAllocation)
					{
						int ret = VMA.VmaCreateImageNative(allocator, pImageCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, (VkImage*)ppImage, (VmaAllocation*)ppAllocation, pAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Function similar to vmaCreateBuffer().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateImage(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] ref VkImageCreateInfo pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] ref VkImage pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkImageCreateInfo* ppImageCreateInfo = &pImageCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					fixed (VkImage* ppImage = &pImage)
					{
						fixed (VmaAllocation* ppAllocation = &pAllocation)
						{
							int ret = VMA.VmaCreateImageNative(allocator, (VkImageCreateInfo*)ppImageCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, (VkImage*)ppImage, (VmaAllocation*)ppAllocation, pAllocationInfo);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Function similar to vmaCreateBuffer().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateImage(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] VkImage* pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
			{
				int ret = VMA.VmaCreateImageNative(allocator, pImageCreateInfo, pAllocationCreateInfo, pImage, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
				return ret;
			}
		}

		/// <summary>		/// Function similar to vmaCreateBuffer().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateImage(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] ref VkImageCreateInfo pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] VkImage* pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkImageCreateInfo* ppImageCreateInfo = &pImageCreateInfo)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					int ret = VMA.VmaCreateImageNative(allocator, (VkImageCreateInfo*)ppImageCreateInfo, pAllocationCreateInfo, pImage, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>		/// Function similar to vmaCreateBuffer().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateImage(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] VkImage* pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					int ret = VMA.VmaCreateImageNative(allocator, pImageCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, pImage, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>		/// Function similar to vmaCreateBuffer().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateImage(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] ref VkImageCreateInfo pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] VkImage* pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkImageCreateInfo* ppImageCreateInfo = &pImageCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						int ret = VMA.VmaCreateImageNative(allocator, (VkImageCreateInfo*)ppImageCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, pImage, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Function similar to vmaCreateBuffer().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateImage(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] ref VkImage pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkImage* ppImage = &pImage)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					int ret = VMA.VmaCreateImageNative(allocator, pImageCreateInfo, pAllocationCreateInfo, (VkImage*)ppImage, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>		/// Function similar to vmaCreateBuffer().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateImage(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] ref VkImageCreateInfo pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] ref VkImage pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkImageCreateInfo* ppImageCreateInfo = &pImageCreateInfo)
			{
				fixed (VkImage* ppImage = &pImage)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						int ret = VMA.VmaCreateImageNative(allocator, (VkImageCreateInfo*)ppImageCreateInfo, pAllocationCreateInfo, (VkImage*)ppImage, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Function similar to vmaCreateBuffer().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateImage(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] ref VkImage pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (VkImage* ppImage = &pImage)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						int ret = VMA.VmaCreateImageNative(allocator, pImageCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, (VkImage*)ppImage, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Function similar to vmaCreateBuffer().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateImage(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] ref VkImageCreateInfo pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] ref VkImage pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkImageCreateInfo* ppImageCreateInfo = &pImageCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					fixed (VkImage* ppImage = &pImage)
					{
						fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
						{
							int ret = VMA.VmaCreateImageNative(allocator, (VkImageCreateInfo*)ppImageCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, (VkImage*)ppImage, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Function similar to vmaCreateBuffer().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateImage(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] VkImage* pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocation* ppAllocation = &pAllocation)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					int ret = VMA.VmaCreateImageNative(allocator, pImageCreateInfo, pAllocationCreateInfo, pImage, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>		/// Function similar to vmaCreateBuffer().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateImage(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] ref VkImageCreateInfo pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] VkImage* pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkImageCreateInfo* ppImageCreateInfo = &pImageCreateInfo)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						int ret = VMA.VmaCreateImageNative(allocator, (VkImageCreateInfo*)ppImageCreateInfo, pAllocationCreateInfo, pImage, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Function similar to vmaCreateBuffer().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateImage(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] VkImage* pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						int ret = VMA.VmaCreateImageNative(allocator, pImageCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, pImage, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Function similar to vmaCreateBuffer().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateImage(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] ref VkImageCreateInfo pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] VkImage* pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkImageCreateInfo* ppImageCreateInfo = &pImageCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					fixed (VmaAllocation* ppAllocation = &pAllocation)
					{
						fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
						{
							int ret = VMA.VmaCreateImageNative(allocator, (VkImageCreateInfo*)ppImageCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, pImage, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Function similar to vmaCreateBuffer().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateImage(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] ref VkImage pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkImage* ppImage = &pImage)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						int ret = VMA.VmaCreateImageNative(allocator, pImageCreateInfo, pAllocationCreateInfo, (VkImage*)ppImage, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Function similar to vmaCreateBuffer().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateImage(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] ref VkImageCreateInfo pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] ref VkImage pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkImageCreateInfo* ppImageCreateInfo = &pImageCreateInfo)
			{
				fixed (VkImage* ppImage = &pImage)
				{
					fixed (VmaAllocation* ppAllocation = &pAllocation)
					{
						fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
						{
							int ret = VMA.VmaCreateImageNative(allocator, (VkImageCreateInfo*)ppImageCreateInfo, pAllocationCreateInfo, (VkImage*)ppImage, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Function similar to vmaCreateBuffer().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateImage(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] ref VkImage pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (VkImage* ppImage = &pImage)
				{
					fixed (VmaAllocation* ppAllocation = &pAllocation)
					{
						fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
						{
							int ret = VMA.VmaCreateImageNative(allocator, pImageCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, (VkImage*)ppImage, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Function similar to vmaCreateBuffer().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateImage(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] ref VkImageCreateInfo pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] ref VkImage pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkImageCreateInfo* ppImageCreateInfo = &pImageCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					fixed (VkImage* ppImage = &pImage)
					{
						fixed (VmaAllocation* ppAllocation = &pAllocation)
						{
							fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
							{
								int ret = VMA.VmaCreateImageNative(allocator, (VkImageCreateInfo*)ppImageCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, (VkImage*)ppImage, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>		/// Function similar to vmaCreateAliasingBuffer() but for images.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateAliasingImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateAliasingImage(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] VkImage* pImage)
		{
			int ret = VMA.VmaCreateAliasingImageNative(allocator, allocation, pImageCreateInfo, pImage);
			return ret;
		}

		/// <summary>		/// Function similar to vmaCreateAliasingBuffer() but for images.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateAliasingImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateAliasingImage(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] ref VkImageCreateInfo pImageCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] VkImage* pImage)
		{
			fixed (VkImageCreateInfo* ppImageCreateInfo = &pImageCreateInfo)
			{
				int ret = VMA.VmaCreateAliasingImageNative(allocator, allocation, (VkImageCreateInfo*)ppImageCreateInfo, pImage);
				return ret;
			}
		}

		/// <summary>		/// Function similar to vmaCreateAliasingBuffer() but for images.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateAliasingImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateAliasingImage(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] ref VkImage pImage)
		{
			fixed (VkImage* ppImage = &pImage)
			{
				int ret = VMA.VmaCreateAliasingImageNative(allocator, allocation, pImageCreateInfo, (VkImage*)ppImage);
				return ret;
			}
		}

		/// <summary>		/// Function similar to vmaCreateAliasingBuffer() but for images.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateAliasingImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateAliasingImage(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] ref VkImageCreateInfo pImageCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] ref VkImage pImage)
		{
			fixed (VkImageCreateInfo* ppImageCreateInfo = &pImageCreateInfo)
			{
				fixed (VkImage* ppImage = &pImage)
				{
					int ret = VMA.VmaCreateAliasingImageNative(allocator, allocation, (VkImageCreateInfo*)ppImageCreateInfo, (VkImage*)ppImage);
					return ret;
				}
			}
		}

		/// <summary>		/// Function similar to vmaCreateAliasingBuffer2() but for images.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateAliasingImage2")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateAliasingImage2(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "allocationLocalOffset")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong allocationLocalOffset, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] VkImage* pImage)
		{
			int ret = VMA.VmaCreateAliasingImage2Native(allocator, allocation, allocationLocalOffset, pImageCreateInfo, pImage);
			return ret;
		}

		/// <summary>		/// Function similar to vmaCreateAliasingBuffer2() but for images.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateAliasingImage2")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateAliasingImage2(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "allocationLocalOffset")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong allocationLocalOffset, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] ref VkImageCreateInfo pImageCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] VkImage* pImage)
		{
			fixed (VkImageCreateInfo* ppImageCreateInfo = &pImageCreateInfo)
			{
				int ret = VMA.VmaCreateAliasingImage2Native(allocator, allocation, allocationLocalOffset, (VkImageCreateInfo*)ppImageCreateInfo, pImage);
				return ret;
			}
		}

		/// <summary>		/// Function similar to vmaCreateAliasingBuffer2() but for images.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateAliasingImage2")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateAliasingImage2(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "allocationLocalOffset")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong allocationLocalOffset, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] ref VkImage pImage)
		{
			fixed (VkImage* ppImage = &pImage)
			{
				int ret = VMA.VmaCreateAliasingImage2Native(allocator, allocation, allocationLocalOffset, pImageCreateInfo, (VkImage*)ppImage);
				return ret;
			}
		}

		/// <summary>		/// Function similar to vmaCreateAliasingBuffer2() but for images.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateAliasingImage2")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int CreateAliasingImage2(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "allocationLocalOffset")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong allocationLocalOffset, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] ref VkImageCreateInfo pImageCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] ref VkImage pImage)
		{
			fixed (VkImageCreateInfo* ppImageCreateInfo = &pImageCreateInfo)
			{
				fixed (VkImage* ppImage = &pImage)
				{
					int ret = VMA.VmaCreateAliasingImage2Native(allocator, allocation, allocationLocalOffset, (VkImageCreateInfo*)ppImageCreateInfo, (VkImage*)ppImage);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// This is just a convenience function equivalent to:<br/>		/// It is safe to pass null as image and/or allocation.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaDestroyImage")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroyImage(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "image")] [NativeName(NativeNameType.Type, "VkImage")] VkImage image, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation)
		{
			VMA.VmaDestroyImageNative(allocator, image, allocation);
		}

		/// <summary>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaBuildStatsString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BuildStatsString(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "ppStatsString")] [NativeName(NativeNameType.Type, "char**")] byte** ppStatsString, [NativeName(NativeNameType.Param, "detailedMap")] [NativeName(NativeNameType.Type, "VkBool32")] VkBool32 detailedMap)
		{
			VMA.VmaBuildStatsStringNative(allocator, ppStatsString, detailedMap);
		}

		/// <summary>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaBuildStatsString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BuildStatsString(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "ppStatsString")] [NativeName(NativeNameType.Type, "char**")] ref byte* ppStatsString, [NativeName(NativeNameType.Param, "detailedMap")] [NativeName(NativeNameType.Type, "VkBool32")] VkBool32 detailedMap)
		{
			fixed (byte** pppStatsString = &ppStatsString)
			{
				VMA.VmaBuildStatsStringNative(allocator, (byte**)pppStatsString, detailedMap);
			}
		}

		[NativeName(NativeNameType.Func, "vmaFreeStatsString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void FreeStatsString(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pStatsString")] [NativeName(NativeNameType.Type, "char*")] byte* pStatsString)
		{
			VMA.VmaFreeStatsStringNative(allocator, pStatsString);
		}

		[NativeName(NativeNameType.Func, "vmaFreeStatsString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void FreeStatsString(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pStatsString")] [NativeName(NativeNameType.Type, "char*")] ref byte pStatsString)
		{
			fixed (byte* ppStatsString = &pStatsString)
			{
				VMA.VmaFreeStatsStringNative(allocator, (byte*)ppStatsString);
			}
		}

		[NativeName(NativeNameType.Func, "vmaFreeStatsString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void FreeStatsString(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pStatsString")] [NativeName(NativeNameType.Type, "char*")] ref string pStatsString)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pStatsString != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pStatsString);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pStatsString, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			VMA.VmaFreeStatsStringNative(allocator, pStr0);
			pStatsString = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[NativeName(NativeNameType.Func, "VmaMalloc")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* Malloc(this VmaAllocator hAllocator, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] ulong size, [NativeName(NativeNameType.Param, "alignment")] [NativeName(NativeNameType.Type, "size_t")] ulong alignment)
		{
			void* ret = VMA.VmaMallocNative(hAllocator, size, alignment);
			return ret;
		}

		[NativeName(NativeNameType.Func, "VmaMalloc")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* Malloc(this VmaAllocator hAllocator, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "alignment")] [NativeName(NativeNameType.Type, "size_t")] ulong alignment)
		{
			void* ret = VMA.VmaMallocNative(hAllocator, size, alignment);
			return ret;
		}

		[NativeName(NativeNameType.Func, "VmaMalloc")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* Malloc(this VmaAllocator hAllocator, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] ulong size, [NativeName(NativeNameType.Param, "alignment")] [NativeName(NativeNameType.Type, "size_t")] nuint alignment)
		{
			void* ret = VMA.VmaMallocNative(hAllocator, size, alignment);
			return ret;
		}

		[NativeName(NativeNameType.Func, "VmaMalloc")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* Malloc(this VmaAllocator hAllocator, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "alignment")] [NativeName(NativeNameType.Type, "size_t")] nuint alignment)
		{
			void* ret = VMA.VmaMallocNative(hAllocator, size, alignment);
			return ret;
		}

		[NativeName(NativeNameType.Func, "VmaFree")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Free(this VmaAllocator hAllocator, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void*")] void* ptr)
		{
			VMA.VmaFreeNative(hAllocator, ptr);
		}

		/// <summary>		/// <br/>		/// Please note that you should consciously handle virtual allocations that could remain unfreed in the block.<br/>		/// You should either free them individually using vmaVirtualFree() or call vmaClearVirtualBlock()<br/>		/// if you are sure this is what you want. If you do neither, an assert is called.<br/>		/// If you keep pointers to some additional metadata associated with your virtual allocations in their `pUserData`,<br/>		/// don't forget to free them.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaDestroyVirtualBlock")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroyVirtualBlock(this VmaVirtualBlock virtualBlock)
		{
			VMA.VmaDestroyVirtualBlockNative(virtualBlock);
		}

		/// <summary>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaIsVirtualBlockEmpty")]
		[return: NativeName(NativeNameType.Type, "VkBool32")]
		public static VkBool32 IsVirtualBlockEmpty(this VmaVirtualBlock virtualBlock)
		{
			VkBool32 ret = VMA.VmaIsVirtualBlockEmptyNative(virtualBlock);
			return ret;
		}

		/// <summary>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaGetVirtualAllocationInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetVirtualAllocationInfo(this VmaVirtualBlock virtualBlock, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaVirtualAllocation")] VmaVirtualAllocation allocation, [NativeName(NativeNameType.Param, "pVirtualAllocInfo")] [NativeName(NativeNameType.Type, "VmaVirtualAllocationInfo*")] VmaVirtualAllocationInfo* pVirtualAllocInfo)
		{
			VMA.VmaGetVirtualAllocationInfoNative(virtualBlock, allocation, pVirtualAllocInfo);
		}

		/// <summary>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaGetVirtualAllocationInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetVirtualAllocationInfo(this VmaVirtualBlock virtualBlock, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaVirtualAllocation")] VmaVirtualAllocation allocation, [NativeName(NativeNameType.Param, "pVirtualAllocInfo")] [NativeName(NativeNameType.Type, "VmaVirtualAllocationInfo*")] ref VmaVirtualAllocationInfo pVirtualAllocInfo)
		{
			fixed (VmaVirtualAllocationInfo* ppVirtualAllocInfo = &pVirtualAllocInfo)
			{
				VMA.VmaGetVirtualAllocationInfoNative(virtualBlock, allocation, (VmaVirtualAllocationInfo*)ppVirtualAllocInfo);
			}
		}

		/// <summary>		/// <br/>		/// If the allocation fails due to not enough free space available, `VK_ERROR_OUT_OF_DEVICE_MEMORY` is returned<br/>		/// (despite the function doesn't ever allocate actual GPU memory).<br/>		/// `pAllocation` is then set to `VK_NULL_HANDLE` and `pOffset`, if not null, it set to `UINT64_MAX`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaVirtualAllocate")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int Allocate(this VmaVirtualBlock virtualBlock, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaVirtualAllocationCreateInfo*")] VmaVirtualAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaVirtualAllocation*")] VmaVirtualAllocation* pAllocation, [NativeName(NativeNameType.Param, "pOffset")] [NativeName(NativeNameType.Type, "VkDeviceSize*")] ulong* pOffset)
		{
			int ret = VMA.VmaVirtualAllocateNative(virtualBlock, pCreateInfo, pAllocation, pOffset);
			return ret;
		}

		/// <summary>		/// <br/>		/// If the allocation fails due to not enough free space available, `VK_ERROR_OUT_OF_DEVICE_MEMORY` is returned<br/>		/// (despite the function doesn't ever allocate actual GPU memory).<br/>		/// `pAllocation` is then set to `VK_NULL_HANDLE` and `pOffset`, if not null, it set to `UINT64_MAX`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaVirtualAllocate")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int Allocate(this VmaVirtualBlock virtualBlock, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaVirtualAllocationCreateInfo*")] ref VmaVirtualAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaVirtualAllocation*")] VmaVirtualAllocation* pAllocation, [NativeName(NativeNameType.Param, "pOffset")] [NativeName(NativeNameType.Type, "VkDeviceSize*")] ulong* pOffset)
		{
			fixed (VmaVirtualAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				int ret = VMA.VmaVirtualAllocateNative(virtualBlock, (VmaVirtualAllocationCreateInfo*)ppCreateInfo, pAllocation, pOffset);
				return ret;
			}
		}

		/// <summary>		/// <br/>		/// If the allocation fails due to not enough free space available, `VK_ERROR_OUT_OF_DEVICE_MEMORY` is returned<br/>		/// (despite the function doesn't ever allocate actual GPU memory).<br/>		/// `pAllocation` is then set to `VK_NULL_HANDLE` and `pOffset`, if not null, it set to `UINT64_MAX`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaVirtualAllocate")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int Allocate(this VmaVirtualBlock virtualBlock, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaVirtualAllocationCreateInfo*")] VmaVirtualAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaVirtualAllocation*")] ref VmaVirtualAllocation pAllocation, [NativeName(NativeNameType.Param, "pOffset")] [NativeName(NativeNameType.Type, "VkDeviceSize*")] ulong* pOffset)
		{
			fixed (VmaVirtualAllocation* ppAllocation = &pAllocation)
			{
				int ret = VMA.VmaVirtualAllocateNative(virtualBlock, pCreateInfo, (VmaVirtualAllocation*)ppAllocation, pOffset);
				return ret;
			}
		}

		/// <summary>		/// <br/>		/// If the allocation fails due to not enough free space available, `VK_ERROR_OUT_OF_DEVICE_MEMORY` is returned<br/>		/// (despite the function doesn't ever allocate actual GPU memory).<br/>		/// `pAllocation` is then set to `VK_NULL_HANDLE` and `pOffset`, if not null, it set to `UINT64_MAX`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaVirtualAllocate")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int Allocate(this VmaVirtualBlock virtualBlock, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaVirtualAllocationCreateInfo*")] ref VmaVirtualAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaVirtualAllocation*")] ref VmaVirtualAllocation pAllocation, [NativeName(NativeNameType.Param, "pOffset")] [NativeName(NativeNameType.Type, "VkDeviceSize*")] ulong* pOffset)
		{
			fixed (VmaVirtualAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VmaVirtualAllocation* ppAllocation = &pAllocation)
				{
					int ret = VMA.VmaVirtualAllocateNative(virtualBlock, (VmaVirtualAllocationCreateInfo*)ppCreateInfo, (VmaVirtualAllocation*)ppAllocation, pOffset);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// If the allocation fails due to not enough free space available, `VK_ERROR_OUT_OF_DEVICE_MEMORY` is returned<br/>		/// (despite the function doesn't ever allocate actual GPU memory).<br/>		/// `pAllocation` is then set to `VK_NULL_HANDLE` and `pOffset`, if not null, it set to `UINT64_MAX`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaVirtualAllocate")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int Allocate(this VmaVirtualBlock virtualBlock, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaVirtualAllocationCreateInfo*")] VmaVirtualAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaVirtualAllocation*")] VmaVirtualAllocation* pAllocation, [NativeName(NativeNameType.Param, "pOffset")] [NativeName(NativeNameType.Type, "VkDeviceSize*")] ref ulong pOffset)
		{
			fixed (ulong* ppOffset = &pOffset)
			{
				int ret = VMA.VmaVirtualAllocateNative(virtualBlock, pCreateInfo, pAllocation, (ulong*)ppOffset);
				return ret;
			}
		}

		/// <summary>		/// <br/>		/// If the allocation fails due to not enough free space available, `VK_ERROR_OUT_OF_DEVICE_MEMORY` is returned<br/>		/// (despite the function doesn't ever allocate actual GPU memory).<br/>		/// `pAllocation` is then set to `VK_NULL_HANDLE` and `pOffset`, if not null, it set to `UINT64_MAX`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaVirtualAllocate")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int Allocate(this VmaVirtualBlock virtualBlock, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaVirtualAllocationCreateInfo*")] ref VmaVirtualAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaVirtualAllocation*")] VmaVirtualAllocation* pAllocation, [NativeName(NativeNameType.Param, "pOffset")] [NativeName(NativeNameType.Type, "VkDeviceSize*")] ref ulong pOffset)
		{
			fixed (VmaVirtualAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (ulong* ppOffset = &pOffset)
				{
					int ret = VMA.VmaVirtualAllocateNative(virtualBlock, (VmaVirtualAllocationCreateInfo*)ppCreateInfo, pAllocation, (ulong*)ppOffset);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// If the allocation fails due to not enough free space available, `VK_ERROR_OUT_OF_DEVICE_MEMORY` is returned<br/>		/// (despite the function doesn't ever allocate actual GPU memory).<br/>		/// `pAllocation` is then set to `VK_NULL_HANDLE` and `pOffset`, if not null, it set to `UINT64_MAX`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaVirtualAllocate")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int Allocate(this VmaVirtualBlock virtualBlock, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaVirtualAllocationCreateInfo*")] VmaVirtualAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaVirtualAllocation*")] ref VmaVirtualAllocation pAllocation, [NativeName(NativeNameType.Param, "pOffset")] [NativeName(NativeNameType.Type, "VkDeviceSize*")] ref ulong pOffset)
		{
			fixed (VmaVirtualAllocation* ppAllocation = &pAllocation)
			{
				fixed (ulong* ppOffset = &pOffset)
				{
					int ret = VMA.VmaVirtualAllocateNative(virtualBlock, pCreateInfo, (VmaVirtualAllocation*)ppAllocation, (ulong*)ppOffset);
					return ret;
				}
			}
		}

		/// <summary>		/// <br/>		/// If the allocation fails due to not enough free space available, `VK_ERROR_OUT_OF_DEVICE_MEMORY` is returned<br/>		/// (despite the function doesn't ever allocate actual GPU memory).<br/>		/// `pAllocation` is then set to `VK_NULL_HANDLE` and `pOffset`, if not null, it set to `UINT64_MAX`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaVirtualAllocate")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static int Allocate(this VmaVirtualBlock virtualBlock, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaVirtualAllocationCreateInfo*")] ref VmaVirtualAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaVirtualAllocation*")] ref VmaVirtualAllocation pAllocation, [NativeName(NativeNameType.Param, "pOffset")] [NativeName(NativeNameType.Type, "VkDeviceSize*")] ref ulong pOffset)
		{
			fixed (VmaVirtualAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VmaVirtualAllocation* ppAllocation = &pAllocation)
				{
					fixed (ulong* ppOffset = &pOffset)
					{
						int ret = VMA.VmaVirtualAllocateNative(virtualBlock, (VmaVirtualAllocationCreateInfo*)ppCreateInfo, (VmaVirtualAllocation*)ppAllocation, (ulong*)ppOffset);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// <br/>		/// It is correct to call this function with `allocation == VK_NULL_HANDLE` - it does nothing.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaVirtualFree")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Free(this VmaVirtualBlock virtualBlock, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaVirtualAllocation")] VmaVirtualAllocation allocation)
		{
			VMA.VmaVirtualFreeNative(virtualBlock, allocation);
		}

		/// <summary>		/// <br/>		/// You must either call this function or free each virtual allocation individually with vmaVirtualFree()<br/>		/// before destroying a virtual block. Otherwise, an assert is called.<br/>		/// If you keep pointer to some additional metadata associated with your virtual allocation in its `pUserData`,<br/>		/// don't forget to free it as well.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaClearVirtualBlock")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ClearVirtualBlock(this VmaVirtualBlock virtualBlock)
		{
			VMA.VmaClearVirtualBlockNative(virtualBlock);
		}

		/// <summary>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaSetVirtualAllocationUserData")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetVirtualAllocationUserData(this VmaVirtualBlock virtualBlock, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaVirtualAllocation")] VmaVirtualAllocation allocation, [NativeName(NativeNameType.Param, "pUserData")] [NativeName(NativeNameType.Type, "void*")] void* pUserData)
		{
			VMA.VmaSetVirtualAllocationUserDataNative(virtualBlock, allocation, pUserData);
		}

		/// <summary>		/// <br/>		/// This function is fast to call. For more detailed statistics, see vmaCalculateVirtualBlockStatistics().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaGetVirtualBlockStatistics")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetVirtualBlockStatistics(this VmaVirtualBlock virtualBlock, [NativeName(NativeNameType.Param, "pStats")] [NativeName(NativeNameType.Type, "VmaStatistics*")] VmaStatistics* pStats)
		{
			VMA.VmaGetVirtualBlockStatisticsNative(virtualBlock, pStats);
		}

		/// <summary>		/// <br/>		/// This function is fast to call. For more detailed statistics, see vmaCalculateVirtualBlockStatistics().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaGetVirtualBlockStatistics")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetVirtualBlockStatistics(this VmaVirtualBlock virtualBlock, [NativeName(NativeNameType.Param, "pStats")] [NativeName(NativeNameType.Type, "VmaStatistics*")] ref VmaStatistics pStats)
		{
			fixed (VmaStatistics* ppStats = &pStats)
			{
				VMA.VmaGetVirtualBlockStatisticsNative(virtualBlock, (VmaStatistics*)ppStats);
			}
		}

		/// <summary>		/// <br/>		/// This function is slow to call. Use for debugging purposes.<br/>		/// For less detailed statistics, see vmaGetVirtualBlockStatistics().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCalculateVirtualBlockStatistics")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalculateVirtualBlockStatistics(this VmaVirtualBlock virtualBlock, [NativeName(NativeNameType.Param, "pStats")] [NativeName(NativeNameType.Type, "VmaDetailedStatistics*")] VmaDetailedStatistics* pStats)
		{
			VMA.VmaCalculateVirtualBlockStatisticsNative(virtualBlock, pStats);
		}

		/// <summary>		/// <br/>		/// This function is slow to call. Use for debugging purposes.<br/>		/// For less detailed statistics, see vmaGetVirtualBlockStatistics().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaCalculateVirtualBlockStatistics")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalculateVirtualBlockStatistics(this VmaVirtualBlock virtualBlock, [NativeName(NativeNameType.Param, "pStats")] [NativeName(NativeNameType.Type, "VmaDetailedStatistics*")] ref VmaDetailedStatistics pStats)
		{
			fixed (VmaDetailedStatistics* ppStats = &pStats)
			{
				VMA.VmaCalculateVirtualBlockStatisticsNative(virtualBlock, (VmaDetailedStatistics*)ppStats);
			}
		}

		/// <summary>		/// <br/>		/// Returned string must be freed using vmaFreeVirtualBlockStatsString().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaBuildVirtualBlockStatsString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BuildVirtualBlockStatsString(this VmaVirtualBlock virtualBlock, [NativeName(NativeNameType.Param, "ppStatsString")] [NativeName(NativeNameType.Type, "char**")] byte** ppStatsString, [NativeName(NativeNameType.Param, "detailedMap")] [NativeName(NativeNameType.Type, "VkBool32")] VkBool32 detailedMap)
		{
			VMA.VmaBuildVirtualBlockStatsStringNative(virtualBlock, ppStatsString, detailedMap);
		}

		/// <summary>		/// <br/>		/// Returned string must be freed using vmaFreeVirtualBlockStatsString().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaBuildVirtualBlockStatsString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BuildVirtualBlockStatsString(this VmaVirtualBlock virtualBlock, [NativeName(NativeNameType.Param, "ppStatsString")] [NativeName(NativeNameType.Type, "char**")] ref byte* ppStatsString, [NativeName(NativeNameType.Param, "detailedMap")] [NativeName(NativeNameType.Type, "VkBool32")] VkBool32 detailedMap)
		{
			fixed (byte** pppStatsString = &ppStatsString)
			{
				VMA.VmaBuildVirtualBlockStatsStringNative(virtualBlock, (byte**)pppStatsString, detailedMap);
			}
		}

		/// <summary>		/// Frees a string returned by vmaBuildVirtualBlockStatsString().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaFreeVirtualBlockStatsString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void FreeVirtualBlockStatsString(this VmaVirtualBlock virtualBlock, [NativeName(NativeNameType.Param, "pStatsString")] [NativeName(NativeNameType.Type, "char*")] byte* pStatsString)
		{
			VMA.VmaFreeVirtualBlockStatsStringNative(virtualBlock, pStatsString);
		}

		/// <summary>		/// Frees a string returned by vmaBuildVirtualBlockStatsString().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaFreeVirtualBlockStatsString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void FreeVirtualBlockStatsString(this VmaVirtualBlock virtualBlock, [NativeName(NativeNameType.Param, "pStatsString")] [NativeName(NativeNameType.Type, "char*")] ref byte pStatsString)
		{
			fixed (byte* ppStatsString = &pStatsString)
			{
				VMA.VmaFreeVirtualBlockStatsStringNative(virtualBlock, (byte*)ppStatsString);
			}
		}

		/// <summary>		/// Frees a string returned by vmaBuildVirtualBlockStatsString().<br/>		/// </summary>		[NativeName(NativeNameType.Func, "vmaFreeVirtualBlockStatsString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void FreeVirtualBlockStatsString(this VmaVirtualBlock virtualBlock, [NativeName(NativeNameType.Param, "pStatsString")] [NativeName(NativeNameType.Type, "char*")] ref string pStatsString)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pStatsString != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pStatsString);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pStatsString, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			VMA.VmaFreeVirtualBlockStatsStringNative(virtualBlock, pStr0);
			pStatsString = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

	}
}
