namespace HexaGen
{
    using HexaGen.Core;
    using System.Text;

    public sealed class CsCodeWriter : ICodeWriter, IDisposable
    {
        private readonly string[] _indentStrings;
        private readonly string @namespace;
        private readonly IEnumerable<string> usings;

        private StreamWriter _writer;

        private int linesWritten;
        private int blocks = 0;
        private int indentLevel;


        private string _indentString = "";
        private bool _shouldIndent = true;

        public int IndentLevel { get => indentLevel; }

        public string NewLine { get => _writer.NewLine; }

        public string FileName { get; }


        public CsCodeWriter(string fileName, string @namespace, IEnumerable<string> usings, HeaderInjectionDelegate? headerInjector)
        {
            fileName = FileNameHelper.SanitizeFileName(fileName);
            FileName = fileName;
            this.@namespace = @namespace;
            this.usings = usings;
            _indentStrings = new string[10];
            for (int i = 0; i < _indentStrings.Length; i++)
            {
                _indentStrings[i] = new string('\t', i);
            }

            StringBuilder sb = new();
            _writer = File.CreateText(fileName);
            _writer.NewLine = Environment.NewLine;
            sb.AppendLine("// ------------------------------------------------------------------------------");
            sb.AppendLine("// <auto-generated>");
            sb.AppendLine("//     This code was generated by a tool.");
            sb.AppendLine("//");
            sb.AppendLine("//     Changes to this file may cause incorrect behavior and will be lost if");
            sb.AppendLine("//     the code is regenerated.");
            sb.AppendLine("// </auto-generated>");
            sb.AppendLine("// ------------------------------------------------------------------------------");
            sb.AppendLine();

            foreach (string ns in usings)
            {
                sb.AppendLine($"using {ns};");
            }

            headerInjector?.Invoke(this, sb);

            if (usings.Any())
            {
                sb.AppendLine();
            }

            _writer.Write(sb.ToString());

            BeginBlock($"namespace {@namespace}");
        }


        public long Length => _writer.BaseStream.Length;

        public int Lines => linesWritten;

        public void Dispose()
        {
            EndBlock();
            _writer.Dispose();
        }

        public void Write(char chr)
        {
            WriteIndented(chr);
        }

        public void Write(string @string)
        {
            WriteIndented(@string);
        }

        public void WriteLine()
        {
            _writer.WriteLine();
            _shouldIndent = true;
        }

        public void WriteLine(string @string)
        {
            WriteIndented(@string);
            _writer.WriteLine();
            _shouldIndent = true;
            linesWritten++;
        }

        private static readonly char[] newLineCharacters = ['\n', '\r'];

        public void WriteLines(string? text)
        {
            if (text == null)
                return;

            ReadOnlySpan<char> span = text.AsSpan();
            while (span.Length > 0)
            {
                int index = span.IndexOfAny(newLineCharacters);
                if (index == -1)
                {
                    index = span.Length;
                }

                var part = span[..index];
                WriteIndented(part);
                _writer.WriteLine();
                _shouldIndent = true;

                linesWritten++;

                if (index + 1 < span.Length && (span[index + 1] == '\n' || span[index + 1] == '\r'))
                {
                    index++;
                }

                if (index + 1 >= span.Length)
                {
                    break;
                }

                span = span[(index + 1)..];
            }

            _shouldIndent = true;
        }

        public void WriteLines(IEnumerable<string> lines)
        {
            foreach (var line in lines)
            {
                WriteLine(line);
            }
        }

        public void BeginBlock(string content)
        {
            WriteLine(content);
            WriteLine("{");
            Indent(1);
            blocks++;
        }

        public void EndBlock()
        {
            if (blocks <= 0)
                return;
            blocks--;
            Unindent(1);
            WriteLine("}");
        }

        public IDisposable PushBlock(string marker = "{") => new CodeBlock(this, marker);

        public void Indent(int count = 1)
        {
            indentLevel += count;

            if (IndentLevel < _indentStrings.Length)
            {
                _indentString = _indentStrings[IndentLevel];
            }
            else
            {
                _indentString = new string('\t', IndentLevel);
            }
        }

        public void Unindent(int count = 1)
        {
            if (count > indentLevel)
                throw new ArgumentException("count out of range.", nameof(count));

            indentLevel -= count;
            if (indentLevel < _indentStrings.Length)
            {
                _indentString = _indentStrings[indentLevel];
            }
            else
            {
                _indentString = new string('\t', indentLevel);
            }
        }

        private void WriteIndented(char chr)
        {
            if (_shouldIndent)
            {
                _writer.Write(_indentString);
                _shouldIndent = false;
            }

            _writer.Write(chr);
        }

        private void WriteIndented(string @string)
        {
            if (_shouldIndent)
            {
                _writer.Write(_indentString);
                _shouldIndent = false;
            }

            _writer.Write(@string);
        }

        private void WriteIndented(ReadOnlySpan<char> @string)
        {
            if (_shouldIndent)
            {
                _writer.Write(_indentString);
                _shouldIndent = false;
            }

            _writer.Write(@string);
        }

        public readonly struct CodeBlock : IDisposable
        {
            private readonly CsCodeWriter _writer;

            public CodeBlock(CsCodeWriter writer, string content)
            {
                _writer = writer;
                _writer.BeginBlock(content);
            }

            public void Dispose()
            {
                _writer.EndBlock();
            }
        }

    }
}
